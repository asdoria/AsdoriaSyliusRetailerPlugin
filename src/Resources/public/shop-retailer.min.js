/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@vue-leaflet/vue-leaflet/dist/vue-leaflet.esm.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@vue-leaflet/vue-leaflet/dist/vue-leaflet.esm.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LCircle": function() { return /* binding */ script; },
/* harmony export */   "LCircleMarker": function() { return /* binding */ script$1; },
/* harmony export */   "LControl": function() { return /* binding */ script$2; },
/* harmony export */   "LControlAttribution": function() { return /* binding */ script$3; },
/* harmony export */   "LControlLayers": function() { return /* binding */ script$4; },
/* harmony export */   "LControlScale": function() { return /* binding */ script$5; },
/* harmony export */   "LControlZoom": function() { return /* binding */ script$6; },
/* harmony export */   "LFeatureGroup": function() { return /* binding */ script$7; },
/* harmony export */   "LGeoJson": function() { return /* binding */ script$8; },
/* harmony export */   "LGridLayer": function() { return /* binding */ script$9; },
/* harmony export */   "LIcon": function() { return /* binding */ script$a; },
/* harmony export */   "LImageOverlay": function() { return /* binding */ script$b; },
/* harmony export */   "LLayerGroup": function() { return /* binding */ script$c; },
/* harmony export */   "LMap": function() { return /* binding */ script$d; },
/* harmony export */   "LMarker": function() { return /* binding */ script$e; },
/* harmony export */   "LPolygon": function() { return /* binding */ script$f; },
/* harmony export */   "LPolyline": function() { return /* binding */ script$g; },
/* harmony export */   "LPopup": function() { return /* binding */ script$h; },
/* harmony export */   "LRectangle": function() { return /* binding */ script$i; },
/* harmony export */   "LTileLayer": function() { return /* binding */ script$j; },
/* harmony export */   "LTooltip": function() { return /* binding */ script$k; },
/* harmony export */   "LWmsTileLayer": function() { return /* binding */ script$l; }
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm-bundler.js");


const debounce = (fn, time) => {
  let timeout;

  return function (...args) {
    const context = this;
    if (timeout) {
      clearTimeout(timeout);
    }
    timeout = setTimeout(() => {
      fn.apply(context, args);
      timeout = null;
    }, time);
  };
};

const capitalizeFirstLetter = (string) => {
  if (!string || typeof string.charAt !== "function") {
    return string;
  }
  return string.charAt(0).toUpperCase() + string.slice(1);
};

const propsBinder = (methods, leafletElement, props) => {
  for (const key in props) {
    const setMethodName = "set" + capitalizeFirstLetter(key);
    if (methods[setMethodName]) {
      (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(
        () => props[key],
        (newVal, oldVal) => {
          methods[setMethodName](newVal, oldVal);
        }
      );
    } else if (leafletElement[setMethodName]) {
      (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(
        () => props[key],
        (newVal) => {
          leafletElement[setMethodName](newVal);
        }
      );
    }
  }
};

const remapEvents = (contextAttrs) => {
  const result = {};
  for (const attrName in contextAttrs) {
    if (
      attrName.startsWith("on") &&
      !attrName.startsWith("onUpdate") &&
      attrName !== "onReady"
    ) {
      const eventName = attrName.slice(2).toLocaleLowerCase();
      result[eventName] = contextAttrs[attrName];
    }
  }
  return result;
};

const resetWebpackIcon = async (Icon) => {
  const modules = await Promise.all([
    __webpack_require__.e(/*! import() */ "node_modules_leaflet_dist_images_marker-icon-2x_png").then(__webpack_require__.t.bind(__webpack_require__, /*! leaflet/dist/images/marker-icon-2x.png */ "./node_modules/leaflet/dist/images/marker-icon-2x.png", 17)),
    __webpack_require__.e(/*! import() */ "node_modules_leaflet_dist_images_marker-icon_png").then(__webpack_require__.t.bind(__webpack_require__, /*! leaflet/dist/images/marker-icon.png */ "./node_modules/leaflet/dist/images/marker-icon.png", 17)),
    __webpack_require__.e(/*! import() */ "node_modules_leaflet_dist_images_marker-shadow_png").then(__webpack_require__.t.bind(__webpack_require__, /*! leaflet/dist/images/marker-shadow.png */ "./node_modules/leaflet/dist/images/marker-shadow.png", 17)),
  ]);

  delete Icon.Default.prototype._getIconUrl;

  Icon.Default.mergeOptions({
    iconRetinaUrl: modules[0].default,
    iconUrl: modules[1].default,
    shadowUrl: modules[2].default,
  });
};

/**
 * Wraps a placeholder function and provides it with the given name.
 * The wrapper can later be updated with {@link updateLeafletWrapper}
 * to provide a different function.
 *
 * @param {String} methodName Key used to provide the wrapper function
 */
const provideLeafletWrapper = (methodName) => {
  const wrapped = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(() =>
    console.warn(`Method ${methodName} has been invoked without being replaced`)
  );
  const wrapper = (...args) => wrapped.value(...args);
  // eslint-disable-next-line vue/no-ref-as-operand
  wrapper.wrapped = wrapped;
  (0,vue__WEBPACK_IMPORTED_MODULE_0__.provide)(methodName, wrapper);

  return wrapper;
};

/**
 * Change the function that will be executed when an injected Leaflet wrapper
 * is invoked.
 *
 * @param {*} wrapper Provided wrapper whose wrapped function is to be updated
 * @param {function} leafletMethod New method to be wrapped by the wrapper
 */
const updateLeafletWrapper = (wrapper, leafletMethod) =>
  (wrapper.wrapped.value = leafletMethod);

const WINDOW_OR_GLOBAL =
  (typeof self === "object" && self.self === self && self) ||
  (typeof __webpack_require__.g === "object" && __webpack_require__.g.global === __webpack_require__.g && __webpack_require__.g) ||
  undefined;

const GLOBAL_LEAFLET_OPT = "useGlobalLeaflet";

const props = {
  options: {
    type: Object,
    default: () => ({}),
  },
};

const setup = (props) => {
  return { options: props.options, methods: {} };
};

const props$1 = {
  ...props,
  pane: {
    type: String,
    default: "overlayPane",
  },
  attribution: {
    type: String,
    default: null,
  },
  name: {
    type: String,
    custom: true,
    default: undefined,
  },
  layerType: {
    type: String,
    custom: true,
    default: undefined,
  },
  visible: {
    type: Boolean,
    custom: true,
    default: true,
  },
};

const setup$1 = (props, leafletRef, context) => {
  const addLayer = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)("addLayer");
  const removeLayer = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)("removeLayer");
  const {
    options: componentOptions,
    methods: componentMethods,
  } = setup(props);

  const options = {
    ...componentOptions,
    attribution: props.attribution,
    pane: props.pane,
  };

  const addThisLayer = () => addLayer({ leafletObject: leafletRef.value });
  const removeThisLayer = () =>
    removeLayer({ leafletObject: leafletRef.value });

  const methods = {
    ...componentMethods,
    setAttribution(val, old) {
      const attributionControl = this.$parent.leafletObject.attributionControl;
      attributionControl.removeAttribution(old).addAttribution(val);
    },
    setName() {
      removeThisLayer();
      if (props.visible) {
        addThisLayer();
      }
    },
    setLayerType() {
      removeThisLayer();
      if (props.visible) {
        addThisLayer();
      }
    },
    setVisible(isVisible) {
      if (leafletRef.value) {
        if (isVisible) {
          addThisLayer();
        } else {
          removeThisLayer();
        }
      }
    },
    bindPopup({ leafletObject }) {
      leafletRef.value.bindPopup(leafletObject);
    },
    bindTooltip({ leafletObject }) {
      leafletRef.value.bindTooltip(leafletObject);
    },
    unbindTooltip() {
      const tooltip = leafletRef.value ? leafletRef.value.getTooltip() : null;
      if (tooltip) {
        tooltip.unbindTooltip();
      }
    },
    unbindPopup() {
      const popup = leafletRef.value ? leafletRef.value.getPopup() : null;
      if (popup) {
        popup.unbindPopup();
      }
    },
    updateVisibleProp(value) {
      /**
       * Triggers when the visible prop needs to be updated
       * @type {boolean}
       * @property {boolean} value - value of the visible property
       */
      context.emit("update:visible", value);
    },
  };

  (0,vue__WEBPACK_IMPORTED_MODULE_0__.provide)("bindPopup", methods.bindPopup);
  (0,vue__WEBPACK_IMPORTED_MODULE_0__.provide)("bindTooltip", methods.bindTooltip);
  (0,vue__WEBPACK_IMPORTED_MODULE_0__.provide)("unbindTooltip", methods.unbindTooltip);
  (0,vue__WEBPACK_IMPORTED_MODULE_0__.provide)("unbindPopup", methods.unbindPopup);

  (0,vue__WEBPACK_IMPORTED_MODULE_0__.onUnmounted)(() => {
    methods.unbindPopup();
    methods.unbindTooltip();
    removeThisLayer();
  });

  return { options, methods };
};

const render = (ready, slots) => {
  if (ready && slots.default) {
    return (0,vue__WEBPACK_IMPORTED_MODULE_0__.h)("div", { style: { display: "none" } }, slots.default());
  }
};

const props$2 = {
  ...props,
  interactive: {
    type: Boolean,
    default: true,
  },
  bubblingMouseEvents: {
    type: Boolean,
    default: true,
  },
};

const setup$2 = (props) => {
  const { options: componentOptions, methods } = setup(props);
  const options = {
    ...componentOptions,
    interactive: props.interactive,
    bubblingMouseEvents: props.bubblingMouseEvents,
  };

  return { options, methods };
};

const props$3 = {
  ...props$1,
  ...props$2,
  stroke: {
    type: Boolean,
    custom: true,
    default: true,
  },
  color: {
    type: String,
    custom: true,
    default: "#3388ff",
  },
  weight: {
    type: Number,
    custom: true,
    default: 3,
  },
  opacity: {
    type: Number,
    custom: true,
    default: 1.0,
  },
  lineCap: {
    type: String,
    custom: true,
    default: "round",
  },
  lineJoin: {
    type: String,
    custom: true,
    default: "round",
  },
  dashArray: {
    type: String,
    custom: true,
    default: null,
  },
  dashOffset: {
    type: String,
    custom: true,
    default: null,
  },
  fill: {
    type: Boolean,
    custom: true,
    default: false,
  },
  fillColor: {
    type: String,
    custom: true,
    default: "#3388ff",
  },
  fillOpacity: {
    type: Number,
    custom: true,
    default: 0.2,
  },
  fillRule: {
    type: String,
    custom: true,
    default: "evenodd",
  },
  className: {
    type: String,
    custom: true,
    default: null,
  },
};

const setup$3 = (props, leafletRef, context) => {
  const { options: layerOptions, methods: layerMethods } = setup$1(
    props,
    leafletRef,
    context
  );
  const {
    options: interactiveLayerOptions,
    methods: interactiveLayerMethods,
  } = setup$2(props);

  const removeLayer = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)("removeLayer");

  const options = {
    ...layerOptions,
    ...interactiveLayerOptions,
    stroke: props.stroke,
    color: props.color,
    weight: props.weight,
    opacity: props.opacity,
    lineCap: props.lineCap,
    lineJoin: props.lineJoin,
    dashArray: props.dashArray,
    dashOffset: props.dashOffset,
    fill: props.fill,
    fillColor: props.fillColor,
    fillOpacity: props.fillOpacity,
    fillRule: props.fillRule,
    className: props.className,
  };
  const methods = {
    ...layerMethods,
    ...interactiveLayerMethods,
    setStroke(stroke) {
      leafletRef.value.setStyle({ stroke });
    },
    setColor(color) {
      leafletRef.value.setStyle({ color });
    },
    setWeight(weight) {
      leafletRef.value.setStyle({ weight });
    },
    setOpacity(opacity) {
      leafletRef.value.setStyle({ opacity });
    },
    setLineCap(lineCap) {
      leafletRef.value.setStyle({ lineCap });
    },
    setLineJoin(lineJoin) {
      leafletRef.value.setStyle({ lineJoin });
    },
    setDashArray(dashArray) {
      leafletRef.value.setStyle({ dashArray });
    },
    setDashOffset(dashOffset) {
      leafletRef.value.setStyle({ dashOffset });
    },
    setFill(fill) {
      leafletRef.value.setStyle({ fill });
    },
    setFillColor(fillColor) {
      leafletRef.value.setStyle({ fillColor });
    },
    setFillOpacity(fillOpacity) {
      leafletRef.value.setStyle({ fillOpacity });
    },
    setFillRule(fillRule) {
      leafletRef.value.setStyle({ fillRule });
    },
    setClassName(className) {
      leafletRef.value.setStyle({ className });
    },
  };

  (0,vue__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount)(() => {
    removeLayer({ leafletObject: leafletRef.value });
  });

  return { options, methods };
};

const props$4 = {
  ...props$3,
  latLng: {
    type: [Object, Array],
    custom: true,
    default: null,
  },
  /**
   * Radius of the marker in pixels.
   */
  radius: {
    type: Number,
    default: null,
  },
};

const setup$4 = (props, leafletRef, context) => {
  const { options: pathOptions, methods: pathMethods } = setup$3(
    props,
    leafletRef,
    context
  );
  const options = {
    ...pathOptions,
    ...props,
  };
  const methods = {
    ...pathMethods,
    setRadius(radius) {
      leafletRef.value.setRadius(radius);
    },
    setLatLng(latLng) {
      leafletRef.value.setLatLng(latLng);
    },
  };

  return { options, methods };
};

const props$5 = {
  ...props$4,
  /**
   * Radius of the circle in meters.
   */
  radius: {
    type: Number,
    default: null,
  },
};

const setup$5 = (props, leafletRef, context) => {
  const {
    options: circleMarkerOptions,
    methods: circleMarkerMethods,
  } = setup$4(props, leafletRef, context);

  const options = {
    ...circleMarkerOptions,
    ...props,
  };

  const methods = {
    ...circleMarkerMethods,
  };

  return { options, methods };
};

/**
 * Circle component, lets you add and personalize circles on the map
 */
var script = {
  name: "LCircle",
  props: props$5,
  setup(props, context) {
    const leafletRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)({});
    const ready = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(false);

    const useGlobalLeaflet = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(GLOBAL_LEAFLET_OPT);
    const addLayer = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)("addLayer");

    const { options, methods } = setup$5(props, leafletRef, context);

    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(async () => {
      const { circle, DomEvent } = useGlobalLeaflet
        ? WINDOW_OR_GLOBAL.L
        : await __webpack_require__.e(/*! import() */ "vendors-node_modules_leaflet_dist_leaflet-src_esm_js").then(__webpack_require__.bind(__webpack_require__, /*! leaflet/dist/leaflet-src.esm */ "./node_modules/leaflet/dist/leaflet-src.esm.js"));

      leafletRef.value = circle(props.latLng, options);

      const listeners = remapEvents(context.attrs);
      DomEvent.on(leafletRef.value, listeners);

      propsBinder(methods, leafletRef.value, props);

      addLayer({
        ...props,
        ...methods,
        leafletObject: leafletRef.value,
      });
      ready.value = true;
      (0,vue__WEBPACK_IMPORTED_MODULE_0__.nextTick)(() => context.emit("ready", leafletRef.value));
    });
    return { ready, leafletObject: leafletRef };
  },
  render() {
    return render(this.ready, this.$slots);
  },
};

script.__file = "src/components/LCircle.vue";

/**
 * Circle Marker component, lets you add and personalize circle markers on the map
 */
var script$1 = {
  name: "LCircleMarker",
  props: props$4,
  setup(props, context) {
    const leafletRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)({});
    const ready = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(false);

    const useGlobalLeaflet = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(GLOBAL_LEAFLET_OPT);
    const addLayer = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)("addLayer");

    const { options, methods } = setup$4(props, leafletRef, context);

    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(async () => {
      const { circleMarker, DomEvent } = useGlobalLeaflet
        ? WINDOW_OR_GLOBAL.L
        : await __webpack_require__.e(/*! import() */ "vendors-node_modules_leaflet_dist_leaflet-src_esm_js").then(__webpack_require__.bind(__webpack_require__, /*! leaflet/dist/leaflet-src.esm */ "./node_modules/leaflet/dist/leaflet-src.esm.js"));

      leafletRef.value = circleMarker(props.latLng, options);

      const listeners = remapEvents(context.attrs);
      DomEvent.on(leafletRef.value, listeners);

      propsBinder(methods, leafletRef.value, props);

      addLayer({
        ...props,
        ...methods,
        leafletObject: leafletRef.value,
      });
      ready.value = true;
      (0,vue__WEBPACK_IMPORTED_MODULE_0__.nextTick)(() => context.emit("ready", leafletRef.value));
    });
    return { ready, leafletObject: leafletRef };
  },
  render() {
    return render(this.ready, this.$slots);
  },
};

script$1.__file = "src/components/LCircleMarker.vue";

const props$6 = {
  ...props,
  position: {
    type: String,
    default: "topright",
  },
};

const setup$6 = (props, leafletRef) => {
  const {
    options: componentOptions,
    methods: componentMethods,
  } = setup(props);
  const options = {
    ...componentOptions,
    position: props.position,
  };

  const methods = {
    ...componentMethods,
    setPosition(position) {
      if (leafletRef.value) {
        leafletRef.value.setPosition(position);
      }
    },
  };

  (0,vue__WEBPACK_IMPORTED_MODULE_0__.onUnmounted)(() => {
    if (leafletRef.value) {
      leafletRef.value.remove();
    }
  });

  return { options, methods };
};

const render$1 = (slots) => {
  if (slots.default) {
    return (0,vue__WEBPACK_IMPORTED_MODULE_0__.h)("div", { ref: "root" }, slots.default());
  }
  return null;
};

var script$2 = {
  name: "LControl",
  props: {
    ...props$6,
    disableClickPropagation: {
      type: Boolean,
      custom: true,
      default: true,
    },
    disableScrollPropagation: {
      type: Boolean,
      custom: true,
      default: false,
    },
  },
  setup(props, context) {
    const leafletRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)({});
    const root = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null);

    const useGlobalLeaflet = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(GLOBAL_LEAFLET_OPT);
    const registerControl = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)("registerControl");

    const { options, methods } = setup$6(props, leafletRef);

    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(async () => {
      const { Control, DomEvent } = useGlobalLeaflet
        ? WINDOW_OR_GLOBAL.L
        : await __webpack_require__.e(/*! import() */ "vendors-node_modules_leaflet_dist_leaflet-src_esm_js").then(__webpack_require__.bind(__webpack_require__, /*! leaflet/dist/leaflet-src.esm */ "./node_modules/leaflet/dist/leaflet-src.esm.js"));

      const LControl = Control.extend({
        onAdd() {
          return root.value;
        },
      });

      leafletRef.value = new LControl(options);
      propsBinder(methods, leafletRef.value, props);
      registerControl({ leafletObject: leafletRef.value });

      if (props.disableClickPropagation) {
        DomEvent.disableClickPropagation(root.value);
      }
      if (props.disableScrollPropagation) {
        DomEvent.disableScrollPropagation(root.value);
      }
      (0,vue__WEBPACK_IMPORTED_MODULE_0__.nextTick)(() => context.emit("ready", leafletRef.value));
    });
    return { root, leafletObject: leafletRef };
  },
  render() {
    return render$1(this.$slots);
  },
};

script$2.__file = "src/components/LControl.vue";

const props$7 = {
  ...props$6,
  prefix: {
    type: String,
    default: "Vue-Leaflet",
    custom: true,
  },
};

const setup$7 = (props, leafletRef) => {
  const { options: controlOptions, methods: controlMethods } = setup$6(
    props,
    leafletRef
  );
  const options = {
    ...controlOptions,
    prefix: props.prefix,
  };

  const methods = {
    ...controlMethods,
    setPrefix(prefix) {
      leafletRef.value.setPrefix(prefix);
    },
  };

  return { options, methods };
};

var script$3 = {
  name: "LControlAttribution",
  props: props$7,
  setup(props, context) {
    const leafletRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)({});

    const useGlobalLeaflet = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(GLOBAL_LEAFLET_OPT);
    const registerControl = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)("registerControl");

    const { options, methods } = setup$7(props, leafletRef);

    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(async () => {
      const { control } = useGlobalLeaflet
        ? WINDOW_OR_GLOBAL.L
        : await __webpack_require__.e(/*! import() */ "vendors-node_modules_leaflet_dist_leaflet-src_esm_js").then(__webpack_require__.bind(__webpack_require__, /*! leaflet/dist/leaflet-src.esm */ "./node_modules/leaflet/dist/leaflet-src.esm.js"));

      leafletRef.value = control.attribution(options);
      propsBinder(methods, leafletRef.value, props);
      registerControl({ leafletObject: leafletRef.value });
      (0,vue__WEBPACK_IMPORTED_MODULE_0__.nextTick)(() => context.emit("ready", leafletRef.value));
    });
    return { leafletObject: leafletRef.value };
  },
  render() {
    return null;
  },
};

script$3.__file = "src/components/LControlAttribution.vue";

const props$8 = {
  ...props$6,
  collapsed: {
    type: Boolean,
    default: true,
  },
  autoZIndex: {
    type: Boolean,
    default: true,
  },
  hideSingleBase: {
    type: Boolean,
    default: false,
  },
  sortLayers: {
    type: Boolean,
    default: false,
  },
  sortFunction: {
    type: Function,
    default: undefined,
  },
};

const setup$8 = (props, leafletRef) => {
  const { options: controlOptions } = setup$6(props, leafletRef);
  const options = {
    ...controlOptions,
    collapsed: props.collapsed,
    autoZIndex: props.autoZIndex,
    hideSingleBase: props.hideSingleBase,
    sortLayers: props.sortLayers,
    sortFunction: props.sortFunction,
  };

  const methods = {
    addLayer(layer) {
      if (layer.layerType === "base") {
        leafletRef.value.addBaseLayer(layer.leafletObject, layer.name);
      } else if (layer.layerType === "overlay") {
        leafletRef.value.addOverlay(layer.leafletObject, layer.name);
      }
    },
    removeLayer(layer) {
      leafletRef.value.removeLayer(layer.leafletObject);
    },
  };
  return { options, methods };
};

var script$4 = {
  name: "LControlLayers",
  props: props$8,
  setup(props, context) {
    const leafletRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)({});

    const useGlobalLeaflet = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(GLOBAL_LEAFLET_OPT);
    const registerLayerControl = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)("registerLayerControl");

    const { options, methods } = setup$8(props, leafletRef);

    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(async () => {
      const { control } = useGlobalLeaflet
        ? WINDOW_OR_GLOBAL.L
        : await __webpack_require__.e(/*! import() */ "vendors-node_modules_leaflet_dist_leaflet-src_esm_js").then(__webpack_require__.bind(__webpack_require__, /*! leaflet/dist/leaflet-src.esm */ "./node_modules/leaflet/dist/leaflet-src.esm.js"));

      leafletRef.value = control.layers(null, null, options);

      propsBinder(methods, leafletRef.value, props);

      registerLayerControl({
        ...props,
        ...methods,
        leafletObject: leafletRef.value,
      });
      (0,vue__WEBPACK_IMPORTED_MODULE_0__.nextTick)(() => context.emit("ready", leafletRef.value));
    });
    return { leafletObject: leafletRef.value };
  },
  render() {
    return null;
  },
};

script$4.__file = "src/components/LControlLayers.vue";

const props$9 = {
  ...props$6,
  maxWidth: {
    type: Number,
    default: 100,
  },
  metric: {
    type: Boolean,
    default: true,
  },
  imperial: {
    type: Boolean,
    default: true,
  },
  updateWhenIdle: {
    type: Boolean,
    default: false,
  },
};

const setup$9 = (props, leafletRef) => {
  const { options: controlOptions, methods: controlMethods } = setup$6(
    props,
    leafletRef
  );
  const options = {
    ...controlOptions,
    maxWidth: props.maxWidth,
    metric: props.metric,
    imperial: props.imperial,
    updateWhenIdle: props.updateWhenIdle,
  };

  return { options, methods: controlMethods };
};

var script$5 = {
  name: "LControlScale",
  props: props$9,
  setup(props, context) {
    const leafletRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)({});

    const useGlobalLeaflet = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(GLOBAL_LEAFLET_OPT);
    const registerControl = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)("registerControl");

    const { options, methods } = setup$9(props, leafletRef);

    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(async () => {
      const { control } = useGlobalLeaflet
        ? WINDOW_OR_GLOBAL.L
        : await __webpack_require__.e(/*! import() */ "vendors-node_modules_leaflet_dist_leaflet-src_esm_js").then(__webpack_require__.bind(__webpack_require__, /*! leaflet/dist/leaflet-src.esm */ "./node_modules/leaflet/dist/leaflet-src.esm.js"));

      leafletRef.value = control.scale(options);
      propsBinder(methods, leafletRef.value, props);
      registerControl({ leafletObject: leafletRef.value });
      (0,vue__WEBPACK_IMPORTED_MODULE_0__.nextTick)(() => context.emit("ready", leafletRef.value));
    });
    return { leafletObject: leafletRef.value };
  },
  render() {
    return null;
  },
};

script$5.__file = "src/components/LControlScale.vue";

const props$a = {
  ...props$6,
  zoomInText: {
    type: String,
    default: "+",
  },
  zoomInTitle: {
    type: String,
    default: "Zoom in",
  },
  zoomOutText: {
    type: String,
    default: "-",
  },
  zoomOutTitle: {
    type: String,
    default: "Zoom out",
  },
};

const setup$a = (props, leafletRef) => {
  const { options: controlOptions, methods: controlMethods } = setup$6(
    props,
    leafletRef
  );
  const options = {
    ...controlOptions,
    zoomInText: props.zoomInText,
    zoomInTitle: props.zoomInTitle,
    zoomOutText: props.zoomOutText,
    zoomOutTitle: props.zoomOutTitle,
  };

  return { options, methods: controlMethods };
};

var script$6 = {
  name: "LControlZoom",
  props: props$a,
  setup(props, context) {
    const leafletRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)({});

    const useGlobalLeaflet = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(GLOBAL_LEAFLET_OPT);
    const registerControl = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)("registerControl");

    const { options, methods } = setup$a(props, leafletRef);

    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(async () => {
      const { control } = useGlobalLeaflet
        ? WINDOW_OR_GLOBAL.L
        : await __webpack_require__.e(/*! import() */ "vendors-node_modules_leaflet_dist_leaflet-src_esm_js").then(__webpack_require__.bind(__webpack_require__, /*! leaflet/dist/leaflet-src.esm */ "./node_modules/leaflet/dist/leaflet-src.esm.js"));

      leafletRef.value = control.zoom(options);
      propsBinder(methods, leafletRef.value, props);
      registerControl({ leafletObject: leafletRef.value });
      (0,vue__WEBPACK_IMPORTED_MODULE_0__.nextTick)(() => context.emit("ready", leafletRef.value));
    });
    return { leafletObject: leafletRef.value };
  },
  render() {
    return null;
  },
};

script$6.__file = "src/components/LControlZoom.vue";

const props$b = {
  ...props$1,
};

const setup$b = (props, leafletRef, context) => {
  const { options: layerOptions, methods: layerMethods } = setup$1(
    props,
    leafletRef,
    context
  );

  const options = {
    ...layerOptions,
  };

  const methods = {
    ...layerMethods,
    addLayer(layer) {
      leafletRef.value.addLayer(layer.leafletObject);
    },
    removeLayer(layer) {
      leafletRef.value.removeLayer(layer.leafletObject);
    },
  };

  (0,vue__WEBPACK_IMPORTED_MODULE_0__.provide)("addLayer", methods.addLayer);
  (0,vue__WEBPACK_IMPORTED_MODULE_0__.provide)("removeLayer", methods.removeLayer);

  return { options, methods };
};

const props$c = {
  ...props$b,
};

const setup$c = (props, leafletRef) => {
  const { options: layerOptions, methods: layerGroupMethods } = setup$b(
    props,
    leafletRef
  );

  const options = {
    ...layerOptions,
    ...props,
  };

  const methods = {
    ...layerGroupMethods,
  };

  return { options, methods };
};

var script$7 = {
  props: props$c,
  setup(props, context) {
    const leafletRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)({});
    const ready = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(false);

    const useGlobalLeaflet = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(GLOBAL_LEAFLET_OPT);
    const addLayer = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)("addLayer");

    const { methods, options } = setup$c(props, leafletRef);

    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(async () => {
      const { featureGroup, DomEvent } = useGlobalLeaflet
        ? WINDOW_OR_GLOBAL.L
        : await __webpack_require__.e(/*! import() */ "vendors-node_modules_leaflet_dist_leaflet-src_esm_js").then(__webpack_require__.bind(__webpack_require__, /*! leaflet/dist/leaflet-src.esm */ "./node_modules/leaflet/dist/leaflet-src.esm.js"));

      leafletRef.value = featureGroup(options);

      const listeners = remapEvents(context.attrs);
      DomEvent.on(leafletRef.value, listeners);

      propsBinder(methods, leafletRef.value, props);
      addLayer({
        ...props,
        ...methods,
        leafletObject: leafletRef.value,
      });
      ready.value = true;
      (0,vue__WEBPACK_IMPORTED_MODULE_0__.nextTick)(() => context.emit("ready", leafletRef.value));
    });
    return { ready, leafletObject: leafletRef };
  },
  render() {
    return render(this.ready, this.$slots);
  },
};

script$7.__file = "src/components/LFeatureGroup.vue";

const props$d = {
  ...props$b,
  geojson: {
    type: [Object, Array],
    default: () => ({}),
  },
};

const setup$d = (props, leafletRef) => {
  const { options: layerOptions, methods: layerGroupMethods } = setup$b(
    props,
    leafletRef
  );

  const options = {
    ...layerOptions,
    ...props,
  };

  const methods = {
    ...layerGroupMethods,
    setGeojson(newVal) {
      leafletRef.value.clearLayers();
      leafletRef.value.addData(newVal);
    },
    getGeoJSONData() {
      return leafletRef.value.toGeoJSON();
    },
    getBounds() {
      return leafletRef.value.getBounds();
    },
  };

  return { options, methods };
};

var script$8 = {
  props: props$d,
  setup(props, context) {
    const leafletRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)({});
    const ready = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(false);

    const useGlobalLeaflet = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(GLOBAL_LEAFLET_OPT);
    const addLayer = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)("addLayer");

    const { methods, options } = setup$d(props, leafletRef);

    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(async () => {
      const { geoJSON, DomEvent } = useGlobalLeaflet
        ? WINDOW_OR_GLOBAL.L
        : await __webpack_require__.e(/*! import() */ "vendors-node_modules_leaflet_dist_leaflet-src_esm_js").then(__webpack_require__.bind(__webpack_require__, /*! leaflet/dist/leaflet-src.esm */ "./node_modules/leaflet/dist/leaflet-src.esm.js"));

      leafletRef.value = geoJSON(props.geojson, options);

      const listeners = remapEvents(context.attrs);
      DomEvent.on(leafletRef.value, listeners);

      propsBinder(methods, leafletRef.value, props);
      addLayer({
        ...props,
        ...methods,
        leafletObject: leafletRef.value,
      });
      ready.value = true;
      (0,vue__WEBPACK_IMPORTED_MODULE_0__.nextTick)(() => context.emit("ready", leafletRef.value));
    });
    return { ready, leafletObject: leafletRef };
  },
  render() {
    return render(this.ready, this.$slots);
  },
};

script$8.__file = "src/components/LGeoJson.vue";

const props$e = {
  ...props$1,
  pane: {
    type: String,
    default: "tilePane",
  },
  opacity: {
    type: Number,
    custom: false,
    default: 1.0,
  },
  zIndex: {
    type: Number,
    default: 1,
  },
  tileSize: {
    type: Number,
    default: 256,
  },
  noWrap: {
    type: Boolean,
    default: false,
  },
  minZoom: {
    type: Number,
    default: 0,
  },
  maxZoom: {
    type: Number,
    default: undefined,
  },
};

const setup$e = (props, leafletRef, context) => {
  const { options: layerOptions, methods: layerMethods } = setup$1(
    props,
    leafletRef,
    context
  );
  const options = {
    ...layerOptions,
    pane: props.pane,
    opacity: props.opacity,
    zIndex: props.zIndex,
    tileSize: props.tileSize,
    noWrap: props.noWrap,
    minZoom: props.minZoom,
    maxZoom: props.maxZoom,
  };
  return { options, methods: { ...layerMethods } };
};

var script$9 = {
  props: {
    ...props$e,
    childRender: {
      type: Function,
      required: true,
    },
  },
  setup(props, context) {
    const leafletRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)({});
    const tileComponents = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)({});
    const root = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null);
    const ready = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(false);

    const useGlobalLeaflet = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(GLOBAL_LEAFLET_OPT);
    const addLayer = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)("addLayer");

    const { options, methods } = setup$e(props, leafletRef, context);

    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(async () => {
      const { GridLayer, DomEvent, DomUtil } = useGlobalLeaflet
        ? WINDOW_OR_GLOBAL.L
        : await __webpack_require__.e(/*! import() */ "vendors-node_modules_leaflet_dist_leaflet-src_esm_js").then(__webpack_require__.bind(__webpack_require__, /*! leaflet/dist/leaflet-src.esm */ "./node_modules/leaflet/dist/leaflet-src.esm.js"));

      methods.onUnload = (e) => {
        const key = leafletRef.value._tileCoordsToKey(e.coords);
        if (tileComponents[key]) {
          tileComponents[key].innerHTML = "";
          tileComponents[key] = undefined;
        }
      };

      methods.setTileComponent = () => {
        leafletRef.value.redraw();
      };

      const GLayer = GridLayer.extend({
        createTile(coords) {
          const key = leafletRef.value._tileCoordsToKey(coords);
          tileComponents[key] = DomUtil.create("div");

          let vNode = (0,vue__WEBPACK_IMPORTED_MODULE_0__.h)(
            { setup: props.childRender, props: ["coords"] },
            { coords }
          );
          (0,vue__WEBPACK_IMPORTED_MODULE_0__.render)(vNode, tileComponents[key]);

          return tileComponents[key];
        },
      });

      leafletRef.value = new GLayer(options);

      const listeners = remapEvents(context.attrs);
      DomEvent.on(leafletRef.value, listeners);

      leafletRef.value.on("tileunload", methods.onUnload);

      propsBinder(methods, leafletRef.value, props);
      addLayer({
        ...props,
        ...methods,
        leafletObject: leafletRef.value,
      });
      ready.value = true;
      (0,vue__WEBPACK_IMPORTED_MODULE_0__.nextTick)(() => context.emit("ready", leafletRef.value));
    });

    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onUnmounted)(() => {
      leafletRef.value.off("tileunload", methods.unLoad);
    });

    return { root, ready, leafletObject: leafletRef };
  },
  render() {
    if (this.ready) {
      return (0,vue__WEBPACK_IMPORTED_MODULE_0__.h)("div", { style: { display: "none" }, ref: "root" });
    }
    return null;
  },
};

script$9.__file = "src/components/LGridLayer.vue";

const props$f = {
  iconUrl: {
    type: String,
    custom: true,
    default: null,
  },
  iconRetinaUrl: {
    type: String,
    custom: true,
    default: null,
  },
  iconSize: {
    type: [Object, Array],
    custom: true,
    default: null,
  },
  iconAnchor: {
    type: [Object, Array],
    custom: true,
    default: null,
  },
  popupAnchor: {
    type: [Object, Array],
    custom: true,
    default: () => [0, 0],
  },
  tooltipAnchor: {
    type: [Object, Array],
    custom: true,
    default: () => [0, 0],
  },
  shadowUrl: {
    type: String,
    custom: true,
    default: null,
  },
  shadowRetinaUrl: {
    type: String,
    custom: true,
    default: null,
  },
  shadowSize: {
    type: [Object, Array],
    custom: true,
    default: null,
  },
  shadowAnchor: {
    type: [Object, Array],
    custom: true,
    default: null,
  },
  bgPos: {
    type: [Object, Array],
    custom: true,
    default: () => [0, 0],
  },
  className: {
    type: String,
    custom: true,
    default: "",
  },
  options: {
    type: Object,
    custom: true,
    default: () => ({}),
  },
};

/**
 * Icon component, lets you add and custom icons to the map
 */
var script$a = {
  name: "LIcon",
  props: {
    ...props$f,
    ...props,
  },
  setup(props, context) {
    const root = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null);

    const useGlobalLeaflet = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(GLOBAL_LEAFLET_OPT);
    const canSetParentHtml = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)("canSetParentHtml");
    const setParentHtml = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)("setParentHtml");
    const setIcon = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)("setIcon");

    let onDomEvent;
    let offDomEvent;
    let divIcon;
    let icon;
    let iconObject = undefined;

    const createIcon = (el, recreationNeeded, htmlSwapNeeded) => {
      const elHtml = el && el.innerHTML;
      if (!recreationNeeded) {
        if (htmlSwapNeeded && iconObject && canSetParentHtml()) {
          setParentHtml(elHtml);
        }
        return;
      }

      const listeners = remapEvents(context.attrs);
      if (iconObject) {
        offDomEvent(iconObject, listeners);
      }

      const { options: componentOptions } = setup(props);
      const options = {
        ...componentOptions,
        iconUrl: props.iconUrl,
        iconRetinaUrl: props.iconRetinaUrl,
        iconSize: props.iconSize,
        iconAnchor: props.iconAnchor,
        popupAnchor: props.popupAnchor,
        tooltipAnchor: props.tooltipAnchor,
        shadowUrl: props.shadowUrl,
        shadowRetinaUrl: props.shadowRetinaUrl,
        shadowSize: props.shadowSize,
        shadowAnchor: props.shadowAnchor,
        bgPos: props.bgPos,
        className: props.className,
        html: elHtml || props.html,
      };

      iconObject = options.html ? divIcon(options) : icon(options);
      onDomEvent(iconObject, listeners);
      setIcon(iconObject);
    };

    const scheduleCreateIcon = () => {
      (0,vue__WEBPACK_IMPORTED_MODULE_0__.nextTick)(() => createIcon(root.value, true, false));
    };

    const scheduleHtmlSwap = () => {
      (0,vue__WEBPACK_IMPORTED_MODULE_0__.nextTick)(() => createIcon(root.value, false, true));
    };

    const methods = {
      setIconUrl: scheduleCreateIcon,
      setIconRetinaUrl: scheduleCreateIcon,
      setIconSize: scheduleCreateIcon,
      setIconAnchor: scheduleCreateIcon,
      setPopupAnchor: scheduleCreateIcon,
      setTooltipAnchor: scheduleCreateIcon,
      setShadowUrl: scheduleCreateIcon,
      setShadowRetinaUrl: scheduleCreateIcon,
      setShadowAnchor: scheduleCreateIcon,
      setBgPos: scheduleCreateIcon,
      setClassName: scheduleCreateIcon,
      setHtml: scheduleCreateIcon,
    };

    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(async () => {
      const { DomEvent, divIcon: lDivIcon, icon: lIcon } = useGlobalLeaflet
        ? WINDOW_OR_GLOBAL.L
        : await __webpack_require__.e(/*! import() */ "vendors-node_modules_leaflet_dist_leaflet-src_esm_js").then(__webpack_require__.bind(__webpack_require__, /*! leaflet/dist/leaflet-src.esm */ "./node_modules/leaflet/dist/leaflet-src.esm.js"));

      onDomEvent = DomEvent.on;
      offDomEvent = DomEvent.off;
      divIcon = lDivIcon;
      icon = lIcon;

      propsBinder(methods, {}, props);

      const observer = new MutationObserver(scheduleHtmlSwap);
      observer.observe(root.value, {
        attributes: true,
        childList: true,
        characterData: true,
        subtree: true,
      });
      scheduleCreateIcon();
    });

    return { root };
  },
  render() {
    const content = this.$slots.default ? this.$slots.default() : undefined;
    return (0,vue__WEBPACK_IMPORTED_MODULE_0__.h)("div", { ref: "root" }, content);
  },
};

script$a.__file = "src/components/LIcon.vue";

/**
 * @typedef {import('leaflet/dist/leaflet-src.esm.js').LatLngBounds} LatLngBounds
 */

const props$g = {
  ...props$1,
  url: {
    type: String,
    required: true,
  },
  bounds: {
    type: [Array, Object],
    required: true,
  },
  opacity: {
    type: Number,
    custom: true,
    default: 1.0,
  },
  alt: {
    type: String,
    default: "",
  },
  interactive: {
    type: Boolean,
    default: false,
  },
  crossOrigin: {
    type: Boolean,
    default: false,
  },
  errorOverlayUrl: {
    type: String,
    custom: true,
    default: "",
  },
  zIndex: {
    type: Number,
    custom: true,
    default: 1,
  },
  className: {
    type: String,
    default: "",
  },
};

const setup$f = (setupProps, LeafletRef, context) => {
  const { options: layerOptions, methods: layerMethods } = setup$1(
    setupProps,
    LeafletRef,
    context
  );
  const options = {
    ...layerOptions,
    ...setupProps,
  };

  const methods = {
    ...layerMethods,
    /**
     * Sets the opacity of the overlay.
     * @param {number} opacity
     */
    setOpacity(opacity) {
      return LeafletRef.value.setOpacity(opacity);
    },
    /**
     * Changes the URL of the image.
     * @param {string} url
     */
    setUrl(url) {
      return LeafletRef.value.setUrl(url);
    },
    /**
     * Update the bounds that this ImageOverlay covers
     * @param {LatLngBounds | Array<Array<number>>} bounds
     */
    setBounds(bounds) {
      return LeafletRef.value.setBounds(bounds);
    },
    /**
     * Get the bounds that this ImageOverlay covers
     * @returns {LatLngBounds}
     */
    getBounds() {
      return LeafletRef.value.getBounds();
    },
    /**
     * Returns the instance of HTMLImageElement used by this overlay.
     * @returns {HTMLElement}
     */
    getElement() {
      return LeafletRef.value.getElement();
    },
    /**
     * Brings the layer to the top of all overlays.
     */
    bringToFront() {
      return LeafletRef.value.bringToFront();
    },
    /**
     * Brings the layer to the bottom of all overlays.
     */
    bringToBack() {
      return LeafletRef.value.bringToBack();
    },
    /**
     * Changes the zIndex of the image overlay.
     * @param {number} zIndex
     */
    setZIndex(zIndex) {
      return LeafletRef.value.setZIndex(zIndex);
    },
  };

  return { options, methods };
};

/**
 * ImageOverlay component, render a plain image instead of a geospatial map.
 */
var script$b = {
  name: "LImageOverlay",
  props: props$g,
  setup(props, context) {
    const leafletRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)({});
    const ready = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(false);

    const useGlobalLeaflet = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(GLOBAL_LEAFLET_OPT);
    const addLayer = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)("addLayer");

    const { options, methods } = setup$f(props, leafletRef, context);

    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(async () => {
      const { imageOverlay, DomEvent } = useGlobalLeaflet
        ? WINDOW_OR_GLOBAL.L
        : await __webpack_require__.e(/*! import() */ "vendors-node_modules_leaflet_dist_leaflet-src_esm_js").then(__webpack_require__.bind(__webpack_require__, /*! leaflet/dist/leaflet-src.esm */ "./node_modules/leaflet/dist/leaflet-src.esm.js"));
      leafletRef.value = imageOverlay(props.url, props.bounds, options);

      const listeners = remapEvents(context.attrs);
      DomEvent.on(leafletRef.value, listeners);
      propsBinder(methods, leafletRef.value, props);
      addLayer({
        ...props,
        ...methods,
        leafletObject: leafletRef.value,
      });
      ready.value = true;
      (0,vue__WEBPACK_IMPORTED_MODULE_0__.nextTick)(() => context.emit("ready", leafletRef.value));
    });

    return { ready, leafletObject: leafletRef };
  },
  render() {
    return render(this.ready, this.$slots);
  },
};

script$b.__file = "src/components/LImageOverlay.vue";

var script$c = {
  props: props$b,
  setup(props, context) {
    const leafletRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)({});
    const ready = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(false);

    const useGlobalLeaflet = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(GLOBAL_LEAFLET_OPT);
    const addLayer = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)("addLayer");

    const { methods } = setup$b(props, leafletRef, context);

    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(async () => {
      const { layerGroup, DomEvent } = useGlobalLeaflet
        ? WINDOW_OR_GLOBAL.L
        : await __webpack_require__.e(/*! import() */ "vendors-node_modules_leaflet_dist_leaflet-src_esm_js").then(__webpack_require__.bind(__webpack_require__, /*! leaflet/dist/leaflet-src.esm */ "./node_modules/leaflet/dist/leaflet-src.esm.js"));
      leafletRef.value = layerGroup(props.options);

      const listeners = remapEvents(context.attrs);
      DomEvent.on(leafletRef.value, listeners);

      propsBinder(methods, leafletRef.value, props);
      addLayer({
        ...props,
        ...methods,
        leafletObject: leafletRef.value,
      });
      ready.value = true;
      (0,vue__WEBPACK_IMPORTED_MODULE_0__.nextTick)(() => context.emit("ready", leafletRef.value));
    });
    return { ready, leafletObject: leafletRef };
  },
  render() {
    return render(this.ready, this.$slots);
  },
};

script$c.__file = "src/components/LLayerGroup.vue";

var script$d = {
  emits: ["ready", "update:zoom", "update:center", "update:bounds"],
  props: {
    ...props,
    /**
     * The center of the map, supports .sync modifier
     */
    center: {
      type: [Object, Array],
      default: () => [0, 0],
    },
    /**
     * The bounds of the map, supports .sync modifier
     */
    bounds: {
      type: [Array, Object],
      default: undefined,
    },
    /**
     * The max bounds of the map
     */
    maxBounds: {
      type: [Array, Object],
      default: undefined,
    },
    /**
     * The zoom of the map, supports .sync modifier
     */
    zoom: {
      type: Number,
      default: 0,
    },
    /**
     * The minZoom of the map
     */
    minZoom: {
      type: Number,
      default: undefined,
    },
    /**
     * The maxZoom of the map
     */
    maxZoom: {
      type: Number,
      default: undefined,
    },
    /**
     * The paddingBottomRight of the map
     */
    paddingBottomRight: {
      type: Array,
      default: undefined,
    },
    /**
     * The paddingTopLeft of the map
     */
    paddingTopLeft: {
      type: Array,
      default: undefined,
    },
    /**
     * The padding of the map
     */
    padding: {
      type: Array,
      default: undefined,
    },
    /**
     * The worldCopyJump option for the map
     */
    worldCopyJump: {
      type: Boolean,
      default: false,
    },
    /**
     * The CRS to use for the map. Can be an object that defines a coordinate reference
     * system for projecting geographical points into screen coordinates and back
     * (see https://leafletjs.com/reference-1.7.1.html#crs-l-crs-base), or a string
     * name identifying one of Leaflet's defined CRSs, such as "EPSG4326".
     */
    crs: {
      type: [String, Object],
      default: "EPSG3857",
    },
    maxBoundsViscosity: {
      type: Number,
      default: undefined,
    },
    inertia: {
      type: Boolean,
      default: undefined,
    },
    inertiaDeceleration: {
      type: Number,
      default: undefined,
    },
    inertiaMaxSpeed: {
      type: Number,
      default: undefined,
    },
    easeLinearity: {
      type: Number,
      default: undefined,
    },
    zoomAnimation: {
      type: Boolean,
      default: undefined,
    },
    zoomAnimationThreshold: {
      type: Number,
      default: undefined,
    },
    fadeAnimation: {
      type: Boolean,
      default: undefined,
    },
    markerZoomAnimation: {
      type: Boolean,
      default: undefined,
    },
    noBlockingAnimations: {
      type: Boolean,
      default: false,
    },
    useGlobalLeaflet: {
      type: Boolean,
      default: false,
    },
  },
  setup(props, context) {
    const root = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null);
    const blueprint = (0,vue__WEBPACK_IMPORTED_MODULE_0__.reactive)({
      ready: false,
      leafletRef: {},
      layersToAdd: [],
      layersInControl: [],
    });
    const { options: componentOptions } = setup(props);
    const options = {
      ...componentOptions,
      minZoom: props.minZoom,
      maxZoom: props.maxZoom,
      maxBounds: props.maxBounds,
      maxBoundsViscosity: props.maxBoundsViscosity,
      worldCopyJump: props.worldCopyJump,
      crs: props.crs,
      center: props.center,
      zoom: props.zoom,
      inertia: props.inertia,
      inertiaDeceleration: props.inertiaDeceleration,
      inertiaMaxSpeed: props.inertiaMaxSpeed,
      easeLinearity: props.easeLinearity,
      zoomAnimation: props.zoomAnimation,
      zoomAnimationThreshold: props.zoomAnimationThreshold,
      fadeAnimation: props.fadeAnimation,
      markerZoomAnimation: props.markerZoomAnimation,
    };

    const addLayer = provideLeafletWrapper("addLayer");
    const removeLayer = provideLeafletWrapper("removeLayer");
    const registerControl = provideLeafletWrapper("registerControl");
    const registerLayerControl = provideLeafletWrapper("registerLayerControl");
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.provide)(GLOBAL_LEAFLET_OPT, props.useGlobalLeaflet);

    const eventHandlers = {
      moveEndHandler() {
        /**
         * Triggers when zoom is updated
         * @type {number,string}
         */
        context.emit("update:zoom", blueprint.leafletRef.getZoom());
        /**
         * Triggers when center is updated
         * @type {object,array}
         */
        context.emit("update:center", blueprint.leafletRef.getCenter());

        /**
         * Triggers when bounds are updated
         * @type {object}
         */
        context.emit("update:bounds", blueprint.leafletRef.getBounds());
      },
      overlayAddHandler(e) {
        const layer = blueprint.layersInControl.find((l) => l.name === e.name);
        if (layer) {
          layer.updateVisibleProp(true);
        }
      },
      overlayRemoveHandler(e) {
        const layer = blueprint.layersInControl.find((l) => l.name === e.name);
        if (layer) {
          layer.updateVisibleProp(false);
        }
      },
    };

    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(async () => {
      if (props.useGlobalLeaflet) {
        WINDOW_OR_GLOBAL.L = WINDOW_OR_GLOBAL.L || (await __webpack_require__.e(/*! import() */ "vendors-node_modules_leaflet_dist_leaflet-src_js").then(__webpack_require__.t.bind(__webpack_require__, /*! leaflet */ "./node_modules/leaflet/dist/leaflet-src.js", 23)));
      }
      const {
        map,
        CRS,
        Icon,
        latLngBounds,
        latLng,
        DomEvent,
      } = props.useGlobalLeaflet
        ? WINDOW_OR_GLOBAL.L
        : await __webpack_require__.e(/*! import() */ "vendors-node_modules_leaflet_dist_leaflet-src_esm_js").then(__webpack_require__.bind(__webpack_require__, /*! leaflet/dist/leaflet-src.esm */ "./node_modules/leaflet/dist/leaflet-src.esm.js"));

      try {
        options.beforeMapMount && (await options.beforeMapMount());
      } catch (error) {
        console.error(
          `The following error occurred running the provided beforeMapMount hook ${error.message}`
        );
      }

      await resetWebpackIcon(Icon);

      const optionsCrs =
        typeof options.crs == "string" ? CRS[options.crs] : options.crs;
      options.crs = optionsCrs || CRS.EPSG3857;

      const methods = {
        addLayer(layer) {
          if (layer.layerType !== undefined) {
            if (blueprint.layerControl === undefined) {
              blueprint.layersToAdd.push(layer);
            } else {
              const exist = blueprint.layersInControl.find(
                (l) =>
                  l.leafletObject._leaflet_id ===
                  layer.leafletObject._leaflet_id
              );
              if (!exist) {
                blueprint.layerControl.addLayer(layer);
                blueprint.layersInControl.push(layer);
              }
            }
          }
          if (layer.visible !== false) {
            blueprint.leafletRef.addLayer(layer.leafletObject);
          }
        },
        removeLayer(layer) {
          if (layer.layerType !== undefined) {
            if (blueprint.layerControl === undefined) {
              blueprint.layersToAdd = blueprint.layersToAdd.filter(
                (l) => l.name !== layer.name
              );
            } else {
              blueprint.layerControl.removeLayer(layer.leafletObject);
              blueprint.layersInControl = blueprint.layersInControl.filter(
                (l) =>
                  l.leafletObject._leaflet_id !==
                  layer.leafletObject._leaflet_id
              );
            }
          }
          blueprint.leafletRef.removeLayer(layer.leafletObject);
        },

        registerLayerControl(lControlLayer) {
          blueprint.layerControl = lControlLayer;
          blueprint.layersToAdd.forEach((layer) => {
            blueprint.layerControl.addLayer(layer);
          });
          blueprint.layersToAdd = [];

          registerControl(lControlLayer);
        },

        registerControl(lControl) {
          blueprint.leafletRef.addControl(lControl.leafletObject);
        },

        setZoom(newVal) {
          const zoom = blueprint.leafletRef.getZoom();
          if (newVal !== zoom) {
            blueprint.leafletRef.setZoom(newVal, {
              animate: props.noBlockingAnimations ? false : null,
            });
          }
        },

        setPaddingBottomRight(newVal) {
          blueprint.paddingBottomRight = newVal;
        },
        setPaddingTopLeft(newVal) {
          blueprint.paddingTopLeft = newVal;
        },
        setPadding(newVal) {
          blueprint.padding = newVal;
        },
        setCrs(newVal) {
          const prevBounds = blueprint.leafletRef.getBounds();
          blueprint.leafletRef.options.crs = newVal;
          blueprint.leafletRef.fitBounds(prevBounds, {
            animate: false,
            padding: [0, 0],
          });
        },
        fitBounds(bounds) {
          blueprint.leafletRef.fitBounds(bounds, {
            animate: this.noBlockingAnimations ? false : null,
          });
        },
        setBounds(newVal) {
          if (!newVal) {
            return;
          }
          const newBounds = latLngBounds(newVal);
          if (!newBounds.isValid()) {
            return;
          }
          const oldBounds =
            blueprint.lastSetBounds || blueprint.leafletRef.getBounds();
          const boundsChanged = !oldBounds.equals(newBounds, 0); // set maxMargin to 0 - check exact equals
          if (boundsChanged) {
            blueprint.lastSetBounds = newBounds;
            blueprint.leafletRef.fitBounds(newBounds, this.fitBoundsOptions);
          }
        },

        setCenter(newVal) {
          if (newVal == null) {
            return;
          }
          const newCenter = latLng(newVal);
          const oldCenter =
            blueprint.lastSetCenter || blueprint.leafletRef.getCenter();
          if (
            oldCenter.lat !== newCenter.lat ||
            oldCenter.lng !== newCenter.lng
          ) {
            blueprint.lastSetCenter = newCenter;
            blueprint.leafletRef.panTo(newCenter, {
              animate: this.noBlockingAnimations ? false : null,
            });
          }
        },
      };

      updateLeafletWrapper(addLayer, methods.addLayer);
      updateLeafletWrapper(removeLayer, methods.removeLayer);
      updateLeafletWrapper(registerControl, methods.registerControl);
      updateLeafletWrapper(registerLayerControl, methods.registerLayerControl);

      blueprint.leafletRef = map(root.value, options);

      propsBinder(methods, blueprint.leafletRef, props);
      const listeners = remapEvents(context.attrs);

      blueprint.leafletRef.on(
        "moveend",
        debounce(eventHandlers.moveEndHandler, 100)
      );
      blueprint.leafletRef.on("overlayadd", eventHandlers.overlayAddHandler);
      blueprint.leafletRef.on(
        "overlayremove",
        eventHandlers.overlayRemoveHandler
      );
      DomEvent.on(blueprint.leafletRef, listeners);
      blueprint.ready = true;
      (0,vue__WEBPACK_IMPORTED_MODULE_0__.nextTick)(() => context.emit("ready", blueprint.leafletRef));
    });

    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount)(() => {
      if (blueprint.leafletRef) {
        blueprint.leafletRef.remove();
      }
    });

    const leafletObject = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => blueprint.leafletRef);
    const ready = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => blueprint.ready);
    return { root, ready, leafletObject };
  },
  render() {
    return (0,vue__WEBPACK_IMPORTED_MODULE_0__.h)(
      "div",
      { style: { width: "100%", height: "100%" }, ref: "root" },
      this.ready ? this.$slots.default() : {}
    );
  },
};

script$d.__file = "src/components/LMap.vue";

const props$h = {
  ...props$1,
  pane: {
    type: String,
    default: "markerPane",
  },
  draggable: {
    type: Boolean,
    custom: true,
    default: false,
  },
  latLng: {
    type: [Object, Array],
    custom: true,
    default: null,
  },
  icon: {
    type: [Object],
    default: () => undefined,
    custom: false,
  },
  zIndexOffset: {
    type: Number,
    custom: false,
    default: null,
  },
};

const setup$g = (props, leafletRef, context) => {
  const { options: layerOptions, methods: layerMethods } = setup$1(
    props,
    leafletRef,
    context
  );
  const options = {
    ...layerOptions,
    ...props,
  };

  const methods = {
    ...layerMethods,
    setDraggable(value) {
      if (leafletRef.value.dragging) {
        value
          ? leafletRef.value.dragging.enable()
          : leafletRef.value.dragging.disable();
      }
    },
    latLngSync(event) {
      context.emit("update:latLng", event.latlng);
      context.emit("update:lat-lng", event.latlng);
    },
    setLatLng(newVal) {
      if (newVal == null) {
        return;
      }

      if (leafletRef.value) {
        const oldLatLng = leafletRef.value.getLatLng();
        if (!oldLatLng || !oldLatLng.equals(newVal)) {
          leafletRef.value.setLatLng(newVal);
        }
      }
    },
  };
  return { options, methods };
};

/**
 * Marker component, lets you add and personalize markers on the map
 */
var script$e = {
  name: "LMarker",
  props: props$h,
  setup(props, context) {
    const leafletRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)({});
    const ready = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(false);

    const useGlobalLeaflet = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(GLOBAL_LEAFLET_OPT);
    const addLayer = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)("addLayer");

    (0,vue__WEBPACK_IMPORTED_MODULE_0__.provide)("canSetParentHtml", () => !!leafletRef.value.getElement());
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.provide)(
      "setParentHtml",
      (html) => (leafletRef.value.getElement().innerHTML = html)
    );
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.provide)(
      "setIcon",
      (newIcon) => leafletRef.value.setIcon && leafletRef.value.setIcon(newIcon)
    );
    const { options, methods } = setup$g(props, leafletRef, context);
    if (options.icon === undefined) {
      // If the options objection has a property named 'icon', then Leaflet will overwrite
      // the default icon with it for the marker, _even if it is undefined_.
      // This leads to the issue discussed in https://github.com/vue-leaflet/vue-leaflet/issues/130
      delete options.icon;
    }

    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(async () => {
      const { marker, DomEvent } = useGlobalLeaflet
        ? WINDOW_OR_GLOBAL.L
        : await __webpack_require__.e(/*! import() */ "vendors-node_modules_leaflet_dist_leaflet-src_esm_js").then(__webpack_require__.bind(__webpack_require__, /*! leaflet/dist/leaflet-src.esm */ "./node_modules/leaflet/dist/leaflet-src.esm.js"));
      leafletRef.value = marker(props.latLng, options);

      const listeners = remapEvents(context.attrs);
      DomEvent.on(leafletRef.value, listeners);

      leafletRef.value.on("move", debounce(methods.latLngSync, 100));
      propsBinder(methods, leafletRef.value, props);
      addLayer({
        ...props,
        ...methods,
        leafletObject: leafletRef.value,
      });
      ready.value = true;
      (0,vue__WEBPACK_IMPORTED_MODULE_0__.nextTick)(() => context.emit("ready", leafletRef.value));
    });

    return { ready, leafletObject: leafletRef };
  },
  render() {
    return render(this.ready, this.$slots);
  },
};

script$e.__file = "src/components/LMarker.vue";

const props$i = {
  ...props$3,
  latLngs: {
    type: Array,
    default: () => [],
  },
  smoothFactor: {
    type: Number,
    custom: true,
    default: 1.0,
  },
  noClip: {
    type: Boolean,
    custom: true,
    default: false,
  },
};

const setup$h = (props, leafletRef, context) => {
  const { options: pathOptions, methods: pathMethods } = setup$3(
    props,
    leafletRef,
    context
  );
  const options = {
    ...pathOptions,
    ...props,
  };

  const methods = {
    ...pathMethods,
    setSmoothFactor(smoothFactor) {
      leafletRef.value.setStyle({ smoothFactor });
    },
    setNoClip(noClip) {
      leafletRef.value.setStyle({ noClip });
    },
    addLatLng(latLng) {
      leafletRef.value.addLatLng(latLng);
    },
  };
  return { options, methods };
};

const props$j = {
  ...props$i,
};

const setup$i = (props, leafletRef, context) => {
  const { options: polylineOptions, methods: polylineMethods } = setup$h(
    props,
    leafletRef,
    context
  );
  const options = {
    ...polylineOptions,
    ...props,
  };

  const methods = {
    ...polylineMethods,
    toGeoJSON(precision) {
      return leafletRef.value.toGeoJSON(precision);
    },
  };

  return { options, methods };
};

/**
 * Polygon component, lets you add and customize polygon regions on the map
 */
var script$f = {
  name: "LPolygon",
  props: props$j,
  setup(props, context) {
    const leafletRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)({});
    const ready = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(false);

    const useGlobalLeaflet = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(GLOBAL_LEAFLET_OPT);
    const addLayer = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)("addLayer");

    const { options, methods } = setup$i(props, leafletRef, context);

    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(async () => {
      const { polygon, DomEvent } = useGlobalLeaflet
        ? WINDOW_OR_GLOBAL.L
        : await __webpack_require__.e(/*! import() */ "vendors-node_modules_leaflet_dist_leaflet-src_esm_js").then(__webpack_require__.bind(__webpack_require__, /*! leaflet/dist/leaflet-src.esm */ "./node_modules/leaflet/dist/leaflet-src.esm.js"));

      leafletRef.value = polygon(props.latLngs, options);

      const listeners = remapEvents(context.attrs);
      DomEvent.on(leafletRef.value, listeners);

      propsBinder(methods, leafletRef.value, props);

      addLayer({
        ...props,
        ...methods,
        leafletObject: leafletRef.value,
      });
      ready.value = true;
      (0,vue__WEBPACK_IMPORTED_MODULE_0__.nextTick)(() => context.emit("ready", leafletRef.value));
    });

    return { ready, leafletObject: leafletRef };
  },
  render() {
    return render(this.ready, this.$slots);
  },
};

script$f.__file = "src/components/LPolygon.vue";

/**
 * Polyline component, lets you add and personalize polylines on the map
 */
var script$g = {
  name: "LPolyline",
  props: props$i,
  setup(props, context) {
    const leafletRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)({});
    const ready = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(false);

    const useGlobalLeaflet = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(GLOBAL_LEAFLET_OPT);
    const addLayer = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)("addLayer");

    const { options, methods } = setup$h(props, leafletRef, context);

    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(async () => {
      const { polyline, DomEvent } = useGlobalLeaflet
        ? WINDOW_OR_GLOBAL.L
        : await __webpack_require__.e(/*! import() */ "vendors-node_modules_leaflet_dist_leaflet-src_esm_js").then(__webpack_require__.bind(__webpack_require__, /*! leaflet/dist/leaflet-src.esm */ "./node_modules/leaflet/dist/leaflet-src.esm.js"));

      leafletRef.value = polyline(props.latLngs, options);

      const listeners = remapEvents(context.attrs);
      DomEvent.on(leafletRef.value, listeners);

      propsBinder(methods, leafletRef.value, props);

      addLayer({
        ...props,
        ...methods,
        leafletObject: leafletRef.value,
      });
      ready.value = true;
      (0,vue__WEBPACK_IMPORTED_MODULE_0__.nextTick)(() => context.emit("ready", leafletRef.value));
    });
    return { ready, leafletObject: leafletRef };
  },
  render() {
    return render(this.ready, this.$slots);
  },
};

script$g.__file = "src/components/LPolyline.vue";

const props$k = {
  ...props,
  content: {
    type: String,
    default: null,
  },
};

const setup$j = (props, leafletRef) => {
  const { options, methods: componentMethods } = setup(props);
  const methods = {
    ...componentMethods,
    setContent(newVal) {
      if (leafletRef.value && newVal !== null && newVal !== undefined) {
        leafletRef.value.setContent(newVal);
      }
    },
  };
  return { options, methods };
};

const render$2 = (slots) => {
  if (slots.default) {
    return (0,vue__WEBPACK_IMPORTED_MODULE_0__.h)("div", { ref: "root" }, slots.default());
  }
  return null;
};

const props$l = {
  ...props$k,
  latLng: {
    type: [Object, Array],
    default: () => [],
  },
};

const setup$k = (props, leafletRef) => {
  const { options, methods } = setup$j(props, leafletRef);
  const unbindPopup = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)("unbindPopup");

  (0,vue__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount)(() => {
    unbindPopup();
  });

  return { options, methods };
};

/**
 * Display a popup on the map
 */
var script$h = {
  name: "LPopup",
  props: props$l,
  setup(props, context) {
    const leafletRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)({});
    const root = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null);

    const useGlobalLeaflet = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(GLOBAL_LEAFLET_OPT);
    const bindPopup = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)("bindPopup");

    const { options, methods } = setup$k(props, leafletRef);

    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(async () => {
      const { popup, DomEvent } = useGlobalLeaflet
        ? WINDOW_OR_GLOBAL.L
        : await __webpack_require__.e(/*! import() */ "vendors-node_modules_leaflet_dist_leaflet-src_esm_js").then(__webpack_require__.bind(__webpack_require__, /*! leaflet/dist/leaflet-src.esm */ "./node_modules/leaflet/dist/leaflet-src.esm.js"));

      leafletRef.value = popup(options);

      if (props.latLng !== undefined) {
        leafletRef.value.setLatLng(props.latLng);
      }

      propsBinder(methods, leafletRef.value, props);
      const listeners = remapEvents(context.attrs);
      DomEvent.on(leafletRef.value, listeners);
      leafletRef.value.setContent(props.content || root.value);
      bindPopup({ leafletObject: leafletRef.value });
      (0,vue__WEBPACK_IMPORTED_MODULE_0__.nextTick)(() => context.emit("ready", leafletRef.value));
    });
    return { root, leafletObject: leafletRef };
  },
  render() {
    return render$2(this.$slots);
  },
};

script$h.__file = "src/components/LPopup.vue";

const props$m = {
  ...props$j,
  bounds: {
    type: Array,
    default: undefined,
  },
};

const setup$l = (props, leafletRef, context) => {
  const { options: polygonOptions, methods: polygonMethods } = setup$i(
    props,
    leafletRef,
    context
  );
  const options = {
    ...polygonOptions,
    ...props,
  };

  const methods = {
    ...polygonMethods,
    setBounds(latLngBounds) {
      leafletRef.value.setBounds(latLngBounds);
    },
    setLatLngs(latLngs) {
      // Calling setLatLngs on a Leaflet rectangle will convert it
      // to a polygon. So instead, we call setBounds here to ensure
      // that the rectangle remains a rectangle, defined by the
      // bounds of the points in the latLngs array.
      leafletRef.value.setBounds(latLngs);
    },
  };

  return { options, methods };
};

/**
 * Rectangle component, lets you add and customize rectangular regions on the map
 */
var script$i = {
  name: "LRectangle",
  props: props$m,
  setup(props, context) {
    const leafletRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)({});
    const ready = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(false);

    const useGlobalLeaflet = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(GLOBAL_LEAFLET_OPT);
    const addLayer = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)("addLayer");

    const { options, methods } = setup$l(props, leafletRef, context);

    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(async () => {
      const { rectangle, latLngBounds, DomEvent } = useGlobalLeaflet
        ? WINDOW_OR_GLOBAL.L
        : await __webpack_require__.e(/*! import() */ "vendors-node_modules_leaflet_dist_leaflet-src_esm_js").then(__webpack_require__.bind(__webpack_require__, /*! leaflet/dist/leaflet-src.esm */ "./node_modules/leaflet/dist/leaflet-src.esm.js"));

      const bounds =
        props.bounds && props.bounds.length
          ? latLngBounds(props.bounds)
          : latLngBounds(props.latLngs);
      leafletRef.value = rectangle(bounds, options);

      const listeners = remapEvents(context.attrs);
      DomEvent.on(leafletRef.value, listeners);

      propsBinder(methods, leafletRef.value, props);

      addLayer({
        ...props,
        ...methods,
        leafletObject: leafletRef.value,
      });
      ready.value = true;
      (0,vue__WEBPACK_IMPORTED_MODULE_0__.nextTick)(() => context.emit("ready", leafletRef.value));
    });

    return { ready, leafletObject: leafletRef };
  },
  render() {
    return render(this.ready, this.$slots);
  },
};

script$i.__file = "src/components/LRectangle.vue";

const props$n = {
  ...props$e,
  tms: {
    type: Boolean,
    default: false,
  },
  subdomains: {
    type: String,
    default: "abc",
  },
  detectRetina: {
    type: Boolean,
    default: false,
  },
  url: {
    type: String,
    default: null,
  },
};

const setup$m = (props, leafletRef) => {
  const {
    options: gridLayerOptions,
    methods: gridLayerMethods,
  } = setup$e(props, leafletRef);
  const options = {
    ...gridLayerOptions,
    tms: props.tms,
    subdomains: props.subdomains,
    detectRetina: props.detectRetina,
  };
  return {
    options,
    methods: {
      ...gridLayerMethods,
    },
  };
};

var script$j = {
  props: props$n,
  setup(props, context) {
    const leafletRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)({});

    const useGlobalLeaflet = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(GLOBAL_LEAFLET_OPT);
    const addLayer = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)("addLayer");

    const { options, methods } = setup$m(props, leafletRef);

    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(async () => {
      const { tileLayer, DomEvent } = useGlobalLeaflet
        ? WINDOW_OR_GLOBAL.L
        : await __webpack_require__.e(/*! import() */ "vendors-node_modules_leaflet_dist_leaflet-src_esm_js").then(__webpack_require__.bind(__webpack_require__, /*! leaflet/dist/leaflet-src.esm */ "./node_modules/leaflet/dist/leaflet-src.esm.js"));
      leafletRef.value = tileLayer(props.url, options);

      const listeners = remapEvents(context.attrs);
      DomEvent.on(leafletRef.value, listeners);

      propsBinder(methods, leafletRef.value, props);
      addLayer({
        ...props,
        ...methods,
        leafletObject: leafletRef.value,
      });
      (0,vue__WEBPACK_IMPORTED_MODULE_0__.nextTick)(() => context.emit("ready", leafletRef.value));
    });

    return { leafletObject: leafletRef };
  },
  render() {
    return null;
  },
};

script$j.__file = "src/components/LTileLayer.vue";

const props$o = {
  ...props$k,
};

const setup$n = (props, leafletRef) => {
  const { options, methods } = setup$j(props, leafletRef);
  const unbindTooltip = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)("unbindTooltip");

  (0,vue__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount)(() => {
    unbindTooltip();
  });

  return { options, methods };
};

/**
 * Display a tooltip on the map
 */
var script$k = {
  name: "LTooltip",
  props: props$o,
  setup(props, context) {
    const leafletRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)({});
    const root = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null);

    const useGlobalLeaflet = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(GLOBAL_LEAFLET_OPT);
    const bindTooltip = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)("bindTooltip");

    const { options, methods } = setup$n(props, leafletRef);

    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(async () => {
      const { tooltip, DomEvent } = useGlobalLeaflet
        ? WINDOW_OR_GLOBAL.L
        : await __webpack_require__.e(/*! import() */ "vendors-node_modules_leaflet_dist_leaflet-src_esm_js").then(__webpack_require__.bind(__webpack_require__, /*! leaflet/dist/leaflet-src.esm */ "./node_modules/leaflet/dist/leaflet-src.esm.js"));

      leafletRef.value = tooltip(options);

      propsBinder(methods, leafletRef.value, props);
      const listeners = remapEvents(context.attrs);
      DomEvent.on(leafletRef.value, listeners);
      leafletRef.value.setContent(props.content || root.value);
      bindTooltip({ leafletObject: leafletRef.value });
      (0,vue__WEBPACK_IMPORTED_MODULE_0__.nextTick)(() => context.emit("ready", leafletRef.value));
    });
    return { root, leafletObject: leafletRef };
  },
  render() {
    return render$2(this.$slots);
  },
};

script$k.__file = "src/components/LTooltip.vue";

const props$p = {
  ...props$n,
  baseUrl: {
    type: String,
    default: null,
    required: true,
  },
  layers: {
    type: String,
    default: "",
  },
  styles: {
    type: String,
    default: "",
  },
  format: {
    type: String,
    default: "image/jpeg",
  },
  transparent: {
    type: Boolean,
    custom: false,
  },
  version: {
    type: String,
    default: "1.1.1",
  },
  crs: {
    default: null,
  },
  upperCase: {
    type: Boolean,
    default: false,
  },
};

const setup$o = (props, leafletRef) => {
  const {
    options: tileLayerOptions,
    methods: tileLayerMethods,
  } = setup$m(props, leafletRef);
  const options = {
    ...tileLayerOptions,
    layers: props.layers,
    styles: props.styles,
    format: props.format,
    transparent: props.transparent,
    version: props.version,
    crs: props.crs,
    upperCase: props.upperCase,
  };
  return {
    options,
    methods: {
      ...tileLayerMethods,
    },
  };
};

var script$l = {
  props: props$p,
  setup(props, context) {
    const leafletRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)({});

    const useGlobalLeaflet = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(GLOBAL_LEAFLET_OPT);
    const addLayer = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)("addLayer");

    const { options, methods } = setup$o(props, leafletRef);

    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(async () => {
      const { tileLayer, DomEvent } = useGlobalLeaflet
        ? WINDOW_OR_GLOBAL.L
        : await __webpack_require__.e(/*! import() */ "vendors-node_modules_leaflet_dist_leaflet-src_esm_js").then(__webpack_require__.bind(__webpack_require__, /*! leaflet/dist/leaflet-src.esm */ "./node_modules/leaflet/dist/leaflet-src.esm.js"));

      leafletRef.value = tileLayer.wms(props.baseUrl, options);

      const listeners = remapEvents(context.attrs);
      DomEvent.on(leafletRef.value, listeners);

      propsBinder(methods, leafletRef.value, props);
      addLayer({
        ...props,
        ...methods,
        leafletObject: leafletRef.value,
      });
      (0,vue__WEBPACK_IMPORTED_MODULE_0__.nextTick)(() => context.emit("ready", leafletRef.value));
    });
    return { leafletObject: leafletRef.value };
  },
  render() {
    return null;
  },
};

script$l.__file = "src/components/LWmsTileLayer.vue";


//# sourceMappingURL=vue-leaflet.esm.js.map


/***/ }),

/***/ "./node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BASE_TRANSITION": function() { return /* binding */ BASE_TRANSITION; },
/* harmony export */   "CAMELIZE": function() { return /* binding */ CAMELIZE; },
/* harmony export */   "CAPITALIZE": function() { return /* binding */ CAPITALIZE; },
/* harmony export */   "CREATE_BLOCK": function() { return /* binding */ CREATE_BLOCK; },
/* harmony export */   "CREATE_COMMENT": function() { return /* binding */ CREATE_COMMENT; },
/* harmony export */   "CREATE_ELEMENT_BLOCK": function() { return /* binding */ CREATE_ELEMENT_BLOCK; },
/* harmony export */   "CREATE_ELEMENT_VNODE": function() { return /* binding */ CREATE_ELEMENT_VNODE; },
/* harmony export */   "CREATE_SLOTS": function() { return /* binding */ CREATE_SLOTS; },
/* harmony export */   "CREATE_STATIC": function() { return /* binding */ CREATE_STATIC; },
/* harmony export */   "CREATE_TEXT": function() { return /* binding */ CREATE_TEXT; },
/* harmony export */   "CREATE_VNODE": function() { return /* binding */ CREATE_VNODE; },
/* harmony export */   "FRAGMENT": function() { return /* binding */ FRAGMENT; },
/* harmony export */   "GUARD_REACTIVE_PROPS": function() { return /* binding */ GUARD_REACTIVE_PROPS; },
/* harmony export */   "IS_MEMO_SAME": function() { return /* binding */ IS_MEMO_SAME; },
/* harmony export */   "IS_REF": function() { return /* binding */ IS_REF; },
/* harmony export */   "KEEP_ALIVE": function() { return /* binding */ KEEP_ALIVE; },
/* harmony export */   "MERGE_PROPS": function() { return /* binding */ MERGE_PROPS; },
/* harmony export */   "NORMALIZE_CLASS": function() { return /* binding */ NORMALIZE_CLASS; },
/* harmony export */   "NORMALIZE_PROPS": function() { return /* binding */ NORMALIZE_PROPS; },
/* harmony export */   "NORMALIZE_STYLE": function() { return /* binding */ NORMALIZE_STYLE; },
/* harmony export */   "OPEN_BLOCK": function() { return /* binding */ OPEN_BLOCK; },
/* harmony export */   "POP_SCOPE_ID": function() { return /* binding */ POP_SCOPE_ID; },
/* harmony export */   "PUSH_SCOPE_ID": function() { return /* binding */ PUSH_SCOPE_ID; },
/* harmony export */   "RENDER_LIST": function() { return /* binding */ RENDER_LIST; },
/* harmony export */   "RENDER_SLOT": function() { return /* binding */ RENDER_SLOT; },
/* harmony export */   "RESOLVE_COMPONENT": function() { return /* binding */ RESOLVE_COMPONENT; },
/* harmony export */   "RESOLVE_DIRECTIVE": function() { return /* binding */ RESOLVE_DIRECTIVE; },
/* harmony export */   "RESOLVE_DYNAMIC_COMPONENT": function() { return /* binding */ RESOLVE_DYNAMIC_COMPONENT; },
/* harmony export */   "RESOLVE_FILTER": function() { return /* binding */ RESOLVE_FILTER; },
/* harmony export */   "SET_BLOCK_TRACKING": function() { return /* binding */ SET_BLOCK_TRACKING; },
/* harmony export */   "SUSPENSE": function() { return /* binding */ SUSPENSE; },
/* harmony export */   "TELEPORT": function() { return /* binding */ TELEPORT; },
/* harmony export */   "TO_DISPLAY_STRING": function() { return /* binding */ TO_DISPLAY_STRING; },
/* harmony export */   "TO_HANDLERS": function() { return /* binding */ TO_HANDLERS; },
/* harmony export */   "TO_HANDLER_KEY": function() { return /* binding */ TO_HANDLER_KEY; },
/* harmony export */   "UNREF": function() { return /* binding */ UNREF; },
/* harmony export */   "WITH_CTX": function() { return /* binding */ WITH_CTX; },
/* harmony export */   "WITH_DIRECTIVES": function() { return /* binding */ WITH_DIRECTIVES; },
/* harmony export */   "WITH_MEMO": function() { return /* binding */ WITH_MEMO; },
/* harmony export */   "advancePositionWithClone": function() { return /* binding */ advancePositionWithClone; },
/* harmony export */   "advancePositionWithMutation": function() { return /* binding */ advancePositionWithMutation; },
/* harmony export */   "assert": function() { return /* binding */ assert; },
/* harmony export */   "baseCompile": function() { return /* binding */ baseCompile; },
/* harmony export */   "baseParse": function() { return /* binding */ baseParse; },
/* harmony export */   "buildDirectiveArgs": function() { return /* binding */ buildDirectiveArgs; },
/* harmony export */   "buildProps": function() { return /* binding */ buildProps; },
/* harmony export */   "buildSlots": function() { return /* binding */ buildSlots; },
/* harmony export */   "checkCompatEnabled": function() { return /* binding */ checkCompatEnabled; },
/* harmony export */   "createArrayExpression": function() { return /* binding */ createArrayExpression; },
/* harmony export */   "createAssignmentExpression": function() { return /* binding */ createAssignmentExpression; },
/* harmony export */   "createBlockStatement": function() { return /* binding */ createBlockStatement; },
/* harmony export */   "createCacheExpression": function() { return /* binding */ createCacheExpression; },
/* harmony export */   "createCallExpression": function() { return /* binding */ createCallExpression; },
/* harmony export */   "createCompilerError": function() { return /* binding */ createCompilerError; },
/* harmony export */   "createCompoundExpression": function() { return /* binding */ createCompoundExpression; },
/* harmony export */   "createConditionalExpression": function() { return /* binding */ createConditionalExpression; },
/* harmony export */   "createForLoopParams": function() { return /* binding */ createForLoopParams; },
/* harmony export */   "createFunctionExpression": function() { return /* binding */ createFunctionExpression; },
/* harmony export */   "createIfStatement": function() { return /* binding */ createIfStatement; },
/* harmony export */   "createInterpolation": function() { return /* binding */ createInterpolation; },
/* harmony export */   "createObjectExpression": function() { return /* binding */ createObjectExpression; },
/* harmony export */   "createObjectProperty": function() { return /* binding */ createObjectProperty; },
/* harmony export */   "createReturnStatement": function() { return /* binding */ createReturnStatement; },
/* harmony export */   "createRoot": function() { return /* binding */ createRoot; },
/* harmony export */   "createSequenceExpression": function() { return /* binding */ createSequenceExpression; },
/* harmony export */   "createSimpleExpression": function() { return /* binding */ createSimpleExpression; },
/* harmony export */   "createStructuralDirectiveTransform": function() { return /* binding */ createStructuralDirectiveTransform; },
/* harmony export */   "createTemplateLiteral": function() { return /* binding */ createTemplateLiteral; },
/* harmony export */   "createTransformContext": function() { return /* binding */ createTransformContext; },
/* harmony export */   "createVNodeCall": function() { return /* binding */ createVNodeCall; },
/* harmony export */   "extractIdentifiers": function() { return /* binding */ extractIdentifiers; },
/* harmony export */   "findDir": function() { return /* binding */ findDir; },
/* harmony export */   "findProp": function() { return /* binding */ findProp; },
/* harmony export */   "generate": function() { return /* binding */ generate; },
/* harmony export */   "generateCodeFrame": function() { return /* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_0__.generateCodeFrame; },
/* harmony export */   "getBaseTransformPreset": function() { return /* binding */ getBaseTransformPreset; },
/* harmony export */   "getConstantType": function() { return /* binding */ getConstantType; },
/* harmony export */   "getInnerRange": function() { return /* binding */ getInnerRange; },
/* harmony export */   "getMemoedVNodeCall": function() { return /* binding */ getMemoedVNodeCall; },
/* harmony export */   "getVNodeBlockHelper": function() { return /* binding */ getVNodeBlockHelper; },
/* harmony export */   "getVNodeHelper": function() { return /* binding */ getVNodeHelper; },
/* harmony export */   "hasDynamicKeyVBind": function() { return /* binding */ hasDynamicKeyVBind; },
/* harmony export */   "hasScopeRef": function() { return /* binding */ hasScopeRef; },
/* harmony export */   "helperNameMap": function() { return /* binding */ helperNameMap; },
/* harmony export */   "injectProp": function() { return /* binding */ injectProp; },
/* harmony export */   "isBuiltInType": function() { return /* binding */ isBuiltInType; },
/* harmony export */   "isCoreComponent": function() { return /* binding */ isCoreComponent; },
/* harmony export */   "isFunctionType": function() { return /* binding */ isFunctionType; },
/* harmony export */   "isInDestructureAssignment": function() { return /* binding */ isInDestructureAssignment; },
/* harmony export */   "isMemberExpression": function() { return /* binding */ isMemberExpression; },
/* harmony export */   "isMemberExpressionBrowser": function() { return /* binding */ isMemberExpressionBrowser; },
/* harmony export */   "isMemberExpressionNode": function() { return /* binding */ isMemberExpressionNode; },
/* harmony export */   "isReferencedIdentifier": function() { return /* binding */ isReferencedIdentifier; },
/* harmony export */   "isSimpleIdentifier": function() { return /* binding */ isSimpleIdentifier; },
/* harmony export */   "isSlotOutlet": function() { return /* binding */ isSlotOutlet; },
/* harmony export */   "isStaticArgOf": function() { return /* binding */ isStaticArgOf; },
/* harmony export */   "isStaticExp": function() { return /* binding */ isStaticExp; },
/* harmony export */   "isStaticProperty": function() { return /* binding */ isStaticProperty; },
/* harmony export */   "isStaticPropertyKey": function() { return /* binding */ isStaticPropertyKey; },
/* harmony export */   "isTemplateNode": function() { return /* binding */ isTemplateNode; },
/* harmony export */   "isText": function() { return /* binding */ isText; },
/* harmony export */   "isVSlot": function() { return /* binding */ isVSlot; },
/* harmony export */   "locStub": function() { return /* binding */ locStub; },
/* harmony export */   "makeBlock": function() { return /* binding */ makeBlock; },
/* harmony export */   "noopDirectiveTransform": function() { return /* binding */ noopDirectiveTransform; },
/* harmony export */   "processExpression": function() { return /* binding */ processExpression; },
/* harmony export */   "processFor": function() { return /* binding */ processFor; },
/* harmony export */   "processIf": function() { return /* binding */ processIf; },
/* harmony export */   "processSlotOutlet": function() { return /* binding */ processSlotOutlet; },
/* harmony export */   "registerRuntimeHelpers": function() { return /* binding */ registerRuntimeHelpers; },
/* harmony export */   "resolveComponentType": function() { return /* binding */ resolveComponentType; },
/* harmony export */   "toValidAssetId": function() { return /* binding */ toValidAssetId; },
/* harmony export */   "trackSlotScopes": function() { return /* binding */ trackSlotScopes; },
/* harmony export */   "trackVForSlotScopes": function() { return /* binding */ trackVForSlotScopes; },
/* harmony export */   "transform": function() { return /* binding */ transform; },
/* harmony export */   "transformBind": function() { return /* binding */ transformBind; },
/* harmony export */   "transformElement": function() { return /* binding */ transformElement; },
/* harmony export */   "transformExpression": function() { return /* binding */ transformExpression; },
/* harmony export */   "transformModel": function() { return /* binding */ transformModel; },
/* harmony export */   "transformOn": function() { return /* binding */ transformOn; },
/* harmony export */   "traverseNode": function() { return /* binding */ traverseNode; },
/* harmony export */   "walkBlockDeclarations": function() { return /* binding */ walkBlockDeclarations; },
/* harmony export */   "walkFunctionParams": function() { return /* binding */ walkFunctionParams; },
/* harmony export */   "walkIdentifiers": function() { return /* binding */ walkIdentifiers; },
/* harmony export */   "warnDeprecation": function() { return /* binding */ warnDeprecation; }
/* harmony export */ });
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");



function defaultOnError(error) {
    throw error;
}
function defaultOnWarn(msg) {
    ( true) && console.warn(`[Vue warn] ${msg.message}`);
}
function createCompilerError(code, loc, messages, additionalMessage) {
    const msg =  true
        ? (messages || errorMessages)[code] + (additionalMessage || ``)
        : 0;
    const error = new SyntaxError(String(msg));
    error.code = code;
    error.loc = loc;
    return error;
}
const errorMessages = {
    // parse errors
    [0 /* ABRUPT_CLOSING_OF_EMPTY_COMMENT */]: 'Illegal comment.',
    [1 /* CDATA_IN_HTML_CONTENT */]: 'CDATA section is allowed only in XML context.',
    [2 /* DUPLICATE_ATTRIBUTE */]: 'Duplicate attribute.',
    [3 /* END_TAG_WITH_ATTRIBUTES */]: 'End tag cannot have attributes.',
    [4 /* END_TAG_WITH_TRAILING_SOLIDUS */]: "Illegal '/' in tags.",
    [5 /* EOF_BEFORE_TAG_NAME */]: 'Unexpected EOF in tag.',
    [6 /* EOF_IN_CDATA */]: 'Unexpected EOF in CDATA section.',
    [7 /* EOF_IN_COMMENT */]: 'Unexpected EOF in comment.',
    [8 /* EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */]: 'Unexpected EOF in script.',
    [9 /* EOF_IN_TAG */]: 'Unexpected EOF in tag.',
    [10 /* INCORRECTLY_CLOSED_COMMENT */]: 'Incorrectly closed comment.',
    [11 /* INCORRECTLY_OPENED_COMMENT */]: 'Incorrectly opened comment.',
    [12 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */]: "Illegal tag name. Use '&lt;' to print '<'.",
    [13 /* MISSING_ATTRIBUTE_VALUE */]: 'Attribute value was expected.',
    [14 /* MISSING_END_TAG_NAME */]: 'End tag name was expected.',
    [15 /* MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */]: 'Whitespace was expected.',
    [16 /* NESTED_COMMENT */]: "Unexpected '<!--' in comment.",
    [17 /* UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */]: 'Attribute name cannot contain U+0022 ("), U+0027 (\'), and U+003C (<).',
    [18 /* UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */]: 'Unquoted attribute value cannot contain U+0022 ("), U+0027 (\'), U+003C (<), U+003D (=), and U+0060 (`).',
    [19 /* UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */]: "Attribute name cannot start with '='.",
    [21 /* UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */]: "'<?' is allowed only in XML context.",
    [20 /* UNEXPECTED_NULL_CHARACTER */]: `Unexpected null character.`,
    [22 /* UNEXPECTED_SOLIDUS_IN_TAG */]: "Illegal '/' in tags.",
    // Vue-specific parse errors
    [23 /* X_INVALID_END_TAG */]: 'Invalid end tag.',
    [24 /* X_MISSING_END_TAG */]: 'Element is missing end tag.',
    [25 /* X_MISSING_INTERPOLATION_END */]: 'Interpolation end sign was not found.',
    [27 /* X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */]: 'End bracket for dynamic directive argument was not found. ' +
        'Note that dynamic directive argument cannot contain spaces.',
    [26 /* X_MISSING_DIRECTIVE_NAME */]: 'Legal directive name was expected.',
    // transform errors
    [28 /* X_V_IF_NO_EXPRESSION */]: `v-if/v-else-if is missing expression.`,
    [29 /* X_V_IF_SAME_KEY */]: `v-if/else branches must use unique keys.`,
    [30 /* X_V_ELSE_NO_ADJACENT_IF */]: `v-else/v-else-if has no adjacent v-if or v-else-if.`,
    [31 /* X_V_FOR_NO_EXPRESSION */]: `v-for is missing expression.`,
    [32 /* X_V_FOR_MALFORMED_EXPRESSION */]: `v-for has invalid expression.`,
    [33 /* X_V_FOR_TEMPLATE_KEY_PLACEMENT */]: `<template v-for> key should be placed on the <template> tag.`,
    [34 /* X_V_BIND_NO_EXPRESSION */]: `v-bind is missing expression.`,
    [35 /* X_V_ON_NO_EXPRESSION */]: `v-on is missing expression.`,
    [36 /* X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */]: `Unexpected custom directive on <slot> outlet.`,
    [37 /* X_V_SLOT_MIXED_SLOT_USAGE */]: `Mixed v-slot usage on both the component and nested <template>.` +
        `When there are multiple named slots, all slots should use <template> ` +
        `syntax to avoid scope ambiguity.`,
    [38 /* X_V_SLOT_DUPLICATE_SLOT_NAMES */]: `Duplicate slot names found. `,
    [39 /* X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */]: `Extraneous children found when component already has explicitly named ` +
        `default slot. These children will be ignored.`,
    [40 /* X_V_SLOT_MISPLACED */]: `v-slot can only be used on components or <template> tags.`,
    [41 /* X_V_MODEL_NO_EXPRESSION */]: `v-model is missing expression.`,
    [42 /* X_V_MODEL_MALFORMED_EXPRESSION */]: `v-model value must be a valid JavaScript member expression.`,
    [43 /* X_V_MODEL_ON_SCOPE_VARIABLE */]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,
    [44 /* X_INVALID_EXPRESSION */]: `Error parsing JavaScript expression: `,
    [45 /* X_KEEP_ALIVE_INVALID_CHILDREN */]: `<KeepAlive> expects exactly one child component.`,
    // generic errors
    [46 /* X_PREFIX_ID_NOT_SUPPORTED */]: `"prefixIdentifiers" option is not supported in this build of compiler.`,
    [47 /* X_MODULE_MODE_NOT_SUPPORTED */]: `ES module mode is not supported in this build of compiler.`,
    [48 /* X_CACHE_HANDLER_NOT_SUPPORTED */]: `"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.`,
    [49 /* X_SCOPE_ID_NOT_SUPPORTED */]: `"scopeId" option is only supported in module mode.`,
    // just to fulfill types
    [50 /* __EXTEND_POINT__ */]: ``
};

const FRAGMENT = Symbol(( true) ? `Fragment` : 0);
const TELEPORT = Symbol(( true) ? `Teleport` : 0);
const SUSPENSE = Symbol(( true) ? `Suspense` : 0);
const KEEP_ALIVE = Symbol(( true) ? `KeepAlive` : 0);
const BASE_TRANSITION = Symbol(( true) ? `BaseTransition` : 0);
const OPEN_BLOCK = Symbol(( true) ? `openBlock` : 0);
const CREATE_BLOCK = Symbol(( true) ? `createBlock` : 0);
const CREATE_ELEMENT_BLOCK = Symbol(( true) ? `createElementBlock` : 0);
const CREATE_VNODE = Symbol(( true) ? `createVNode` : 0);
const CREATE_ELEMENT_VNODE = Symbol(( true) ? `createElementVNode` : 0);
const CREATE_COMMENT = Symbol(( true) ? `createCommentVNode` : 0);
const CREATE_TEXT = Symbol(( true) ? `createTextVNode` : 0);
const CREATE_STATIC = Symbol(( true) ? `createStaticVNode` : 0);
const RESOLVE_COMPONENT = Symbol(( true) ? `resolveComponent` : 0);
const RESOLVE_DYNAMIC_COMPONENT = Symbol(( true) ? `resolveDynamicComponent` : 0);
const RESOLVE_DIRECTIVE = Symbol(( true) ? `resolveDirective` : 0);
const RESOLVE_FILTER = Symbol(( true) ? `resolveFilter` : 0);
const WITH_DIRECTIVES = Symbol(( true) ? `withDirectives` : 0);
const RENDER_LIST = Symbol(( true) ? `renderList` : 0);
const RENDER_SLOT = Symbol(( true) ? `renderSlot` : 0);
const CREATE_SLOTS = Symbol(( true) ? `createSlots` : 0);
const TO_DISPLAY_STRING = Symbol(( true) ? `toDisplayString` : 0);
const MERGE_PROPS = Symbol(( true) ? `mergeProps` : 0);
const NORMALIZE_CLASS = Symbol(( true) ? `normalizeClass` : 0);
const NORMALIZE_STYLE = Symbol(( true) ? `normalizeStyle` : 0);
const NORMALIZE_PROPS = Symbol(( true) ? `normalizeProps` : 0);
const GUARD_REACTIVE_PROPS = Symbol(( true) ? `guardReactiveProps` : 0);
const TO_HANDLERS = Symbol(( true) ? `toHandlers` : 0);
const CAMELIZE = Symbol(( true) ? `camelize` : 0);
const CAPITALIZE = Symbol(( true) ? `capitalize` : 0);
const TO_HANDLER_KEY = Symbol(( true) ? `toHandlerKey` : 0);
const SET_BLOCK_TRACKING = Symbol(( true) ? `setBlockTracking` : 0);
const PUSH_SCOPE_ID = Symbol(( true) ? `pushScopeId` : 0);
const POP_SCOPE_ID = Symbol(( true) ? `popScopeId` : 0);
const WITH_CTX = Symbol(( true) ? `withCtx` : 0);
const UNREF = Symbol(( true) ? `unref` : 0);
const IS_REF = Symbol(( true) ? `isRef` : 0);
const WITH_MEMO = Symbol(( true) ? `withMemo` : 0);
const IS_MEMO_SAME = Symbol(( true) ? `isMemoSame` : 0);
// Name mapping for runtime helpers that need to be imported from 'vue' in
// generated code. Make sure these are correctly exported in the runtime!
// Using `any` here because TS doesn't allow symbols as index type.
const helperNameMap = {
    [FRAGMENT]: `Fragment`,
    [TELEPORT]: `Teleport`,
    [SUSPENSE]: `Suspense`,
    [KEEP_ALIVE]: `KeepAlive`,
    [BASE_TRANSITION]: `BaseTransition`,
    [OPEN_BLOCK]: `openBlock`,
    [CREATE_BLOCK]: `createBlock`,
    [CREATE_ELEMENT_BLOCK]: `createElementBlock`,
    [CREATE_VNODE]: `createVNode`,
    [CREATE_ELEMENT_VNODE]: `createElementVNode`,
    [CREATE_COMMENT]: `createCommentVNode`,
    [CREATE_TEXT]: `createTextVNode`,
    [CREATE_STATIC]: `createStaticVNode`,
    [RESOLVE_COMPONENT]: `resolveComponent`,
    [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,
    [RESOLVE_DIRECTIVE]: `resolveDirective`,
    [RESOLVE_FILTER]: `resolveFilter`,
    [WITH_DIRECTIVES]: `withDirectives`,
    [RENDER_LIST]: `renderList`,
    [RENDER_SLOT]: `renderSlot`,
    [CREATE_SLOTS]: `createSlots`,
    [TO_DISPLAY_STRING]: `toDisplayString`,
    [MERGE_PROPS]: `mergeProps`,
    [NORMALIZE_CLASS]: `normalizeClass`,
    [NORMALIZE_STYLE]: `normalizeStyle`,
    [NORMALIZE_PROPS]: `normalizeProps`,
    [GUARD_REACTIVE_PROPS]: `guardReactiveProps`,
    [TO_HANDLERS]: `toHandlers`,
    [CAMELIZE]: `camelize`,
    [CAPITALIZE]: `capitalize`,
    [TO_HANDLER_KEY]: `toHandlerKey`,
    [SET_BLOCK_TRACKING]: `setBlockTracking`,
    [PUSH_SCOPE_ID]: `pushScopeId`,
    [POP_SCOPE_ID]: `popScopeId`,
    [WITH_CTX]: `withCtx`,
    [UNREF]: `unref`,
    [IS_REF]: `isRef`,
    [WITH_MEMO]: `withMemo`,
    [IS_MEMO_SAME]: `isMemoSame`
};
function registerRuntimeHelpers(helpers) {
    Object.getOwnPropertySymbols(helpers).forEach(s => {
        helperNameMap[s] = helpers[s];
    });
}

// AST Utilities ---------------------------------------------------------------
// Some expressions, e.g. sequence and conditional expressions, are never
// associated with template nodes, so their source locations are just a stub.
// Container types like CompoundExpression also don't need a real location.
const locStub = {
    source: '',
    start: { line: 1, column: 1, offset: 0 },
    end: { line: 1, column: 1, offset: 0 }
};
function createRoot(children, loc = locStub) {
    return {
        type: 0 /* ROOT */,
        children,
        helpers: [],
        components: [],
        directives: [],
        hoists: [],
        imports: [],
        cached: 0,
        temps: 0,
        codegenNode: undefined,
        loc
    };
}
function createVNodeCall(context, tag, props, children, patchFlag, dynamicProps, directives, isBlock = false, disableTracking = false, isComponent = false, loc = locStub) {
    if (context) {
        if (isBlock) {
            context.helper(OPEN_BLOCK);
            context.helper(getVNodeBlockHelper(context.inSSR, isComponent));
        }
        else {
            context.helper(getVNodeHelper(context.inSSR, isComponent));
        }
        if (directives) {
            context.helper(WITH_DIRECTIVES);
        }
    }
    return {
        type: 13 /* VNODE_CALL */,
        tag,
        props,
        children,
        patchFlag,
        dynamicProps,
        directives,
        isBlock,
        disableTracking,
        isComponent,
        loc
    };
}
function createArrayExpression(elements, loc = locStub) {
    return {
        type: 17 /* JS_ARRAY_EXPRESSION */,
        loc,
        elements
    };
}
function createObjectExpression(properties, loc = locStub) {
    return {
        type: 15 /* JS_OBJECT_EXPRESSION */,
        loc,
        properties
    };
}
function createObjectProperty(key, value) {
    return {
        type: 16 /* JS_PROPERTY */,
        loc: locStub,
        key: (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(key) ? createSimpleExpression(key, true) : key,
        value
    };
}
function createSimpleExpression(content, isStatic = false, loc = locStub, constType = 0 /* NOT_CONSTANT */) {
    return {
        type: 4 /* SIMPLE_EXPRESSION */,
        loc,
        content,
        isStatic,
        constType: isStatic ? 3 /* CAN_STRINGIFY */ : constType
    };
}
function createInterpolation(content, loc) {
    return {
        type: 5 /* INTERPOLATION */,
        loc,
        content: (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(content)
            ? createSimpleExpression(content, false, loc)
            : content
    };
}
function createCompoundExpression(children, loc = locStub) {
    return {
        type: 8 /* COMPOUND_EXPRESSION */,
        loc,
        children
    };
}
function createCallExpression(callee, args = [], loc = locStub) {
    return {
        type: 14 /* JS_CALL_EXPRESSION */,
        loc,
        callee,
        arguments: args
    };
}
function createFunctionExpression(params, returns = undefined, newline = false, isSlot = false, loc = locStub) {
    return {
        type: 18 /* JS_FUNCTION_EXPRESSION */,
        params,
        returns,
        newline,
        isSlot,
        loc
    };
}
function createConditionalExpression(test, consequent, alternate, newline = true) {
    return {
        type: 19 /* JS_CONDITIONAL_EXPRESSION */,
        test,
        consequent,
        alternate,
        newline,
        loc: locStub
    };
}
function createCacheExpression(index, value, isVNode = false) {
    return {
        type: 20 /* JS_CACHE_EXPRESSION */,
        index,
        value,
        isVNode,
        loc: locStub
    };
}
function createBlockStatement(body) {
    return {
        type: 21 /* JS_BLOCK_STATEMENT */,
        body,
        loc: locStub
    };
}
function createTemplateLiteral(elements) {
    return {
        type: 22 /* JS_TEMPLATE_LITERAL */,
        elements,
        loc: locStub
    };
}
function createIfStatement(test, consequent, alternate) {
    return {
        type: 23 /* JS_IF_STATEMENT */,
        test,
        consequent,
        alternate,
        loc: locStub
    };
}
function createAssignmentExpression(left, right) {
    return {
        type: 24 /* JS_ASSIGNMENT_EXPRESSION */,
        left,
        right,
        loc: locStub
    };
}
function createSequenceExpression(expressions) {
    return {
        type: 25 /* JS_SEQUENCE_EXPRESSION */,
        expressions,
        loc: locStub
    };
}
function createReturnStatement(returns) {
    return {
        type: 26 /* JS_RETURN_STATEMENT */,
        returns,
        loc: locStub
    };
}

const isStaticExp = (p) => p.type === 4 /* SIMPLE_EXPRESSION */ && p.isStatic;
const isBuiltInType = (tag, expected) => tag === expected || tag === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hyphenate)(expected);
function isCoreComponent(tag) {
    if (isBuiltInType(tag, 'Teleport')) {
        return TELEPORT;
    }
    else if (isBuiltInType(tag, 'Suspense')) {
        return SUSPENSE;
    }
    else if (isBuiltInType(tag, 'KeepAlive')) {
        return KEEP_ALIVE;
    }
    else if (isBuiltInType(tag, 'BaseTransition')) {
        return BASE_TRANSITION;
    }
}
const nonIdentifierRE = /^\d|[^\$\w]/;
const isSimpleIdentifier = (name) => !nonIdentifierRE.test(name);
const validFirstIdentCharRE = /[A-Za-z_$\xA0-\uFFFF]/;
const validIdentCharRE = /[\.\?\w$\xA0-\uFFFF]/;
const whitespaceRE = /\s+[.[]\s*|\s*[.[]\s+/g;
/**
 * Simple lexer to check if an expression is a member expression. This is
 * lax and only checks validity at the root level (i.e. does not validate exps
 * inside square brackets), but it's ok since these are only used on template
 * expressions and false positives are invalid expressions in the first place.
 */
const isMemberExpressionBrowser = (path) => {
    // remove whitespaces around . or [ first
    path = path.trim().replace(whitespaceRE, s => s.trim());
    let state = 0 /* inMemberExp */;
    let stateStack = [];
    let currentOpenBracketCount = 0;
    let currentOpenParensCount = 0;
    let currentStringType = null;
    for (let i = 0; i < path.length; i++) {
        const char = path.charAt(i);
        switch (state) {
            case 0 /* inMemberExp */:
                if (char === '[') {
                    stateStack.push(state);
                    state = 1 /* inBrackets */;
                    currentOpenBracketCount++;
                }
                else if (char === '(') {
                    stateStack.push(state);
                    state = 2 /* inParens */;
                    currentOpenParensCount++;
                }
                else if (!(i === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)) {
                    return false;
                }
                break;
            case 1 /* inBrackets */:
                if (char === `'` || char === `"` || char === '`') {
                    stateStack.push(state);
                    state = 3 /* inString */;
                    currentStringType = char;
                }
                else if (char === `[`) {
                    currentOpenBracketCount++;
                }
                else if (char === `]`) {
                    if (!--currentOpenBracketCount) {
                        state = stateStack.pop();
                    }
                }
                break;
            case 2 /* inParens */:
                if (char === `'` || char === `"` || char === '`') {
                    stateStack.push(state);
                    state = 3 /* inString */;
                    currentStringType = char;
                }
                else if (char === `(`) {
                    currentOpenParensCount++;
                }
                else if (char === `)`) {
                    // if the exp ends as a call then it should not be considered valid
                    if (i === path.length - 1) {
                        return false;
                    }
                    if (!--currentOpenParensCount) {
                        state = stateStack.pop();
                    }
                }
                break;
            case 3 /* inString */:
                if (char === currentStringType) {
                    state = stateStack.pop();
                    currentStringType = null;
                }
                break;
        }
    }
    return !currentOpenBracketCount && !currentOpenParensCount;
};
const isMemberExpressionNode = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NOOP
    ;
const isMemberExpression = isMemberExpressionBrowser
    ;
function getInnerRange(loc, offset, length) {
    const source = loc.source.slice(offset, offset + length);
    const newLoc = {
        source,
        start: advancePositionWithClone(loc.start, loc.source, offset),
        end: loc.end
    };
    if (length != null) {
        newLoc.end = advancePositionWithClone(loc.start, loc.source, offset + length);
    }
    return newLoc;
}
function advancePositionWithClone(pos, source, numberOfCharacters = source.length) {
    return advancePositionWithMutation((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, pos), source, numberOfCharacters);
}
// advance by mutation without cloning (for performance reasons), since this
// gets called a lot in the parser
function advancePositionWithMutation(pos, source, numberOfCharacters = source.length) {
    let linesCount = 0;
    let lastNewLinePos = -1;
    for (let i = 0; i < numberOfCharacters; i++) {
        if (source.charCodeAt(i) === 10 /* newline char code */) {
            linesCount++;
            lastNewLinePos = i;
        }
    }
    pos.offset += numberOfCharacters;
    pos.line += linesCount;
    pos.column =
        lastNewLinePos === -1
            ? pos.column + numberOfCharacters
            : numberOfCharacters - lastNewLinePos;
    return pos;
}
function assert(condition, msg) {
    /* istanbul ignore if */
    if (!condition) {
        throw new Error(msg || `unexpected compiler condition`);
    }
}
function findDir(node, name, allowEmpty = false) {
    for (let i = 0; i < node.props.length; i++) {
        const p = node.props[i];
        if (p.type === 7 /* DIRECTIVE */ &&
            (allowEmpty || p.exp) &&
            ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(name) ? p.name === name : name.test(p.name))) {
            return p;
        }
    }
}
function findProp(node, name, dynamicOnly = false, allowEmpty = false) {
    for (let i = 0; i < node.props.length; i++) {
        const p = node.props[i];
        if (p.type === 6 /* ATTRIBUTE */) {
            if (dynamicOnly)
                continue;
            if (p.name === name && (p.value || allowEmpty)) {
                return p;
            }
        }
        else if (p.name === 'bind' &&
            (p.exp || allowEmpty) &&
            isStaticArgOf(p.arg, name)) {
            return p;
        }
    }
}
function isStaticArgOf(arg, name) {
    return !!(arg && isStaticExp(arg) && arg.content === name);
}
function hasDynamicKeyVBind(node) {
    return node.props.some(p => p.type === 7 /* DIRECTIVE */ &&
        p.name === 'bind' &&
        (!p.arg || // v-bind="obj"
            p.arg.type !== 4 /* SIMPLE_EXPRESSION */ || // v-bind:[_ctx.foo]
            !p.arg.isStatic) // v-bind:[foo]
    );
}
function isText(node) {
    return node.type === 5 /* INTERPOLATION */ || node.type === 2 /* TEXT */;
}
function isVSlot(p) {
    return p.type === 7 /* DIRECTIVE */ && p.name === 'slot';
}
function isTemplateNode(node) {
    return (node.type === 1 /* ELEMENT */ && node.tagType === 3 /* TEMPLATE */);
}
function isSlotOutlet(node) {
    return node.type === 1 /* ELEMENT */ && node.tagType === 2 /* SLOT */;
}
function getVNodeHelper(ssr, isComponent) {
    return ssr || isComponent ? CREATE_VNODE : CREATE_ELEMENT_VNODE;
}
function getVNodeBlockHelper(ssr, isComponent) {
    return ssr || isComponent ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK;
}
const propsHelperSet = new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS]);
function getUnnormalizedProps(props, callPath = []) {
    if (props &&
        !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(props) &&
        props.type === 14 /* JS_CALL_EXPRESSION */) {
        const callee = props.callee;
        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(callee) && propsHelperSet.has(callee)) {
            return getUnnormalizedProps(props.arguments[0], callPath.concat(props));
        }
    }
    return [props, callPath];
}
function injectProp(node, prop, context) {
    let propsWithInjection;
    /**
     * 1. mergeProps(...)
     * 2. toHandlers(...)
     * 3. normalizeProps(...)
     * 4. normalizeProps(guardReactiveProps(...))
     *
     * we need to get the real props before normalization
     */
    let props = node.type === 13 /* VNODE_CALL */ ? node.props : node.arguments[2];
    let callPath = [];
    let parentCall;
    if (props &&
        !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(props) &&
        props.type === 14 /* JS_CALL_EXPRESSION */) {
        const ret = getUnnormalizedProps(props);
        props = ret[0];
        callPath = ret[1];
        parentCall = callPath[callPath.length - 1];
    }
    if (props == null || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(props)) {
        propsWithInjection = createObjectExpression([prop]);
    }
    else if (props.type === 14 /* JS_CALL_EXPRESSION */) {
        // merged props... add ours
        // only inject key to object literal if it's the first argument so that
        // if doesn't override user provided keys
        const first = props.arguments[0];
        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(first) && first.type === 15 /* JS_OBJECT_EXPRESSION */) {
            first.properties.unshift(prop);
        }
        else {
            if (props.callee === TO_HANDLERS) {
                // #2366
                propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
                    createObjectExpression([prop]),
                    props
                ]);
            }
            else {
                props.arguments.unshift(createObjectExpression([prop]));
            }
        }
        !propsWithInjection && (propsWithInjection = props);
    }
    else if (props.type === 15 /* JS_OBJECT_EXPRESSION */) {
        let alreadyExists = false;
        // check existing key to avoid overriding user provided keys
        if (prop.key.type === 4 /* SIMPLE_EXPRESSION */) {
            const propKeyName = prop.key.content;
            alreadyExists = props.properties.some(p => p.key.type === 4 /* SIMPLE_EXPRESSION */ &&
                p.key.content === propKeyName);
        }
        if (!alreadyExists) {
            props.properties.unshift(prop);
        }
        propsWithInjection = props;
    }
    else {
        // single v-bind with expression, return a merged replacement
        propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
            createObjectExpression([prop]),
            props
        ]);
        // in the case of nested helper call, e.g. `normalizeProps(guardReactiveProps(props))`,
        // it will be rewritten as `normalizeProps(mergeProps({ key: 0 }, props))`,
        // the `guardReactiveProps` will no longer be needed
        if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {
            parentCall = callPath[callPath.length - 2];
        }
    }
    if (node.type === 13 /* VNODE_CALL */) {
        if (parentCall) {
            parentCall.arguments[0] = propsWithInjection;
        }
        else {
            node.props = propsWithInjection;
        }
    }
    else {
        if (parentCall) {
            parentCall.arguments[0] = propsWithInjection;
        }
        else {
            node.arguments[2] = propsWithInjection;
        }
    }
}
function toValidAssetId(name, type) {
    // see issue#4422, we need adding identifier on validAssetId if variable `name` has specific character
    return `_${type}_${name.replace(/[^\w]/g, (searchValue, replaceValue) => {
        return searchValue === '-' ? '_' : name.charCodeAt(replaceValue).toString();
    })}`;
}
// Check if a node contains expressions that reference current context scope ids
function hasScopeRef(node, ids) {
    if (!node || Object.keys(ids).length === 0) {
        return false;
    }
    switch (node.type) {
        case 1 /* ELEMENT */:
            for (let i = 0; i < node.props.length; i++) {
                const p = node.props[i];
                if (p.type === 7 /* DIRECTIVE */ &&
                    (hasScopeRef(p.arg, ids) || hasScopeRef(p.exp, ids))) {
                    return true;
                }
            }
            return node.children.some(c => hasScopeRef(c, ids));
        case 11 /* FOR */:
            if (hasScopeRef(node.source, ids)) {
                return true;
            }
            return node.children.some(c => hasScopeRef(c, ids));
        case 9 /* IF */:
            return node.branches.some(b => hasScopeRef(b, ids));
        case 10 /* IF_BRANCH */:
            if (hasScopeRef(node.condition, ids)) {
                return true;
            }
            return node.children.some(c => hasScopeRef(c, ids));
        case 4 /* SIMPLE_EXPRESSION */:
            return (!node.isStatic &&
                isSimpleIdentifier(node.content) &&
                !!ids[node.content]);
        case 8 /* COMPOUND_EXPRESSION */:
            return node.children.some(c => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(c) && hasScopeRef(c, ids));
        case 5 /* INTERPOLATION */:
        case 12 /* TEXT_CALL */:
            return hasScopeRef(node.content, ids);
        case 2 /* TEXT */:
        case 3 /* COMMENT */:
            return false;
        default:
            if ((true)) ;
            return false;
    }
}
function getMemoedVNodeCall(node) {
    if (node.type === 14 /* JS_CALL_EXPRESSION */ && node.callee === WITH_MEMO) {
        return node.arguments[1].returns;
    }
    else {
        return node;
    }
}
function makeBlock(node, { helper, removeHelper, inSSR }) {
    if (!node.isBlock) {
        node.isBlock = true;
        removeHelper(getVNodeHelper(inSSR, node.isComponent));
        helper(OPEN_BLOCK);
        helper(getVNodeBlockHelper(inSSR, node.isComponent));
    }
}

const deprecationData = {
    ["COMPILER_IS_ON_ELEMENT" /* COMPILER_IS_ON_ELEMENT */]: {
        message: `Platform-native elements with "is" prop will no longer be ` +
            `treated as components in Vue 3 unless the "is" value is explicitly ` +
            `prefixed with "vue:".`,
        link: `https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html`
    },
    ["COMPILER_V_BIND_SYNC" /* COMPILER_V_BIND_SYNC */]: {
        message: key => `.sync modifier for v-bind has been removed. Use v-model with ` +
            `argument instead. \`v-bind:${key}.sync\` should be changed to ` +
            `\`v-model:${key}\`.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-model.html`
    },
    ["COMPILER_V_BIND_PROP" /* COMPILER_V_BIND_PROP */]: {
        message: `.prop modifier for v-bind has been removed and no longer necessary. ` +
            `Vue 3 will automatically set a binding as DOM property when appropriate.`
    },
    ["COMPILER_V_BIND_OBJECT_ORDER" /* COMPILER_V_BIND_OBJECT_ORDER */]: {
        message: `v-bind="obj" usage is now order sensitive and behaves like JavaScript ` +
            `object spread: it will now overwrite an existing non-mergeable attribute ` +
            `that appears before v-bind in the case of conflict. ` +
            `To retain 2.x behavior, move v-bind to make it the first attribute. ` +
            `You can also suppress this warning if the usage is intended.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-bind.html`
    },
    ["COMPILER_V_ON_NATIVE" /* COMPILER_V_ON_NATIVE */]: {
        message: `.native modifier for v-on has been removed as is no longer necessary.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html`
    },
    ["COMPILER_V_IF_V_FOR_PRECEDENCE" /* COMPILER_V_IF_V_FOR_PRECEDENCE */]: {
        message: `v-if / v-for precedence when used on the same element has changed ` +
            `in Vue 3: v-if now takes higher precedence and will no longer have ` +
            `access to v-for scope variables. It is best to avoid the ambiguity ` +
            `with <template> tags or use a computed property that filters v-for ` +
            `data source.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html`
    },
    ["COMPILER_NATIVE_TEMPLATE" /* COMPILER_NATIVE_TEMPLATE */]: {
        message: `<template> with no special directives will render as a native template ` +
            `element instead of its inner content in Vue 3.`
    },
    ["COMPILER_INLINE_TEMPLATE" /* COMPILER_INLINE_TEMPLATE */]: {
        message: `"inline-template" has been removed in Vue 3.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html`
    },
    ["COMPILER_FILTER" /* COMPILER_FILTERS */]: {
        message: `filters have been removed in Vue 3. ` +
            `The "|" symbol will be treated as native JavaScript bitwise OR operator. ` +
            `Use method calls or computed properties instead.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/filters.html`
    }
};
function getCompatValue(key, context) {
    const config = context.options
        ? context.options.compatConfig
        : context.compatConfig;
    const value = config && config[key];
    if (key === 'MODE') {
        return value || 3; // compiler defaults to v3 behavior
    }
    else {
        return value;
    }
}
function isCompatEnabled(key, context) {
    const mode = getCompatValue('MODE', context);
    const value = getCompatValue(key, context);
    // in v3 mode, only enable if explicitly set to true
    // otherwise enable for any non-false value
    return mode === 3 ? value === true : value !== false;
}
function checkCompatEnabled(key, context, loc, ...args) {
    const enabled = isCompatEnabled(key, context);
    if (( true) && enabled) {
        warnDeprecation(key, context, loc, ...args);
    }
    return enabled;
}
function warnDeprecation(key, context, loc, ...args) {
    const val = getCompatValue(key, context);
    if (val === 'suppress-warning') {
        return;
    }
    const { message, link } = deprecationData[key];
    const msg = `(deprecation ${key}) ${typeof message === 'function' ? message(...args) : message}${link ? `\n  Details: ${link}` : ``}`;
    const err = new SyntaxError(msg);
    err.code = key;
    if (loc)
        err.loc = loc;
    context.onWarn(err);
}

// The default decoder only provides escapes for characters reserved as part of
// the template syntax, and is only used if the custom renderer did not provide
// a platform-specific decoder.
const decodeRE = /&(gt|lt|amp|apos|quot);/g;
const decodeMap = {
    gt: '>',
    lt: '<',
    amp: '&',
    apos: "'",
    quot: '"'
};
const defaultParserOptions = {
    delimiters: [`{{`, `}}`],
    getNamespace: () => 0 /* HTML */,
    getTextMode: () => 0 /* DATA */,
    isVoidTag: _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NO,
    isPreTag: _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NO,
    isCustomElement: _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NO,
    decodeEntities: (rawText) => rawText.replace(decodeRE, (_, p1) => decodeMap[p1]),
    onError: defaultOnError,
    onWarn: defaultOnWarn,
    comments: ("development" !== 'production')
};
function baseParse(content, options = {}) {
    const context = createParserContext(content, options);
    const start = getCursor(context);
    return createRoot(parseChildren(context, 0 /* DATA */, []), getSelection(context, start));
}
function createParserContext(content, rawOptions) {
    const options = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, defaultParserOptions);
    let key;
    for (key in rawOptions) {
        // @ts-ignore
        options[key] =
            rawOptions[key] === undefined
                ? defaultParserOptions[key]
                : rawOptions[key];
    }
    return {
        options,
        column: 1,
        line: 1,
        offset: 0,
        originalSource: content,
        source: content,
        inPre: false,
        inVPre: false,
        onWarn: options.onWarn
    };
}
function parseChildren(context, mode, ancestors) {
    const parent = last(ancestors);
    const ns = parent ? parent.ns : 0 /* HTML */;
    const nodes = [];
    while (!isEnd(context, mode, ancestors)) {
        const s = context.source;
        let node = undefined;
        if (mode === 0 /* DATA */ || mode === 1 /* RCDATA */) {
            if (!context.inVPre && startsWith(s, context.options.delimiters[0])) {
                // '{{'
                node = parseInterpolation(context, mode);
            }
            else if (mode === 0 /* DATA */ && s[0] === '<') {
                // https://html.spec.whatwg.org/multipage/parsing.html#tag-open-state
                if (s.length === 1) {
                    emitError(context, 5 /* EOF_BEFORE_TAG_NAME */, 1);
                }
                else if (s[1] === '!') {
                    // https://html.spec.whatwg.org/multipage/parsing.html#markup-declaration-open-state
                    if (startsWith(s, '<!--')) {
                        node = parseComment(context);
                    }
                    else if (startsWith(s, '<!DOCTYPE')) {
                        // Ignore DOCTYPE by a limitation.
                        node = parseBogusComment(context);
                    }
                    else if (startsWith(s, '<![CDATA[')) {
                        if (ns !== 0 /* HTML */) {
                            node = parseCDATA(context, ancestors);
                        }
                        else {
                            emitError(context, 1 /* CDATA_IN_HTML_CONTENT */);
                            node = parseBogusComment(context);
                        }
                    }
                    else {
                        emitError(context, 11 /* INCORRECTLY_OPENED_COMMENT */);
                        node = parseBogusComment(context);
                    }
                }
                else if (s[1] === '/') {
                    // https://html.spec.whatwg.org/multipage/parsing.html#end-tag-open-state
                    if (s.length === 2) {
                        emitError(context, 5 /* EOF_BEFORE_TAG_NAME */, 2);
                    }
                    else if (s[2] === '>') {
                        emitError(context, 14 /* MISSING_END_TAG_NAME */, 2);
                        advanceBy(context, 3);
                        continue;
                    }
                    else if (/[a-z]/i.test(s[2])) {
                        emitError(context, 23 /* X_INVALID_END_TAG */);
                        parseTag(context, 1 /* End */, parent);
                        continue;
                    }
                    else {
                        emitError(context, 12 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */, 2);
                        node = parseBogusComment(context);
                    }
                }
                else if (/[a-z]/i.test(s[1])) {
                    node = parseElement(context, ancestors);
                    // 2.x <template> with no directive compat
                    if (isCompatEnabled("COMPILER_NATIVE_TEMPLATE" /* COMPILER_NATIVE_TEMPLATE */, context) &&
                        node &&
                        node.tag === 'template' &&
                        !node.props.some(p => p.type === 7 /* DIRECTIVE */ &&
                            isSpecialTemplateDirective(p.name))) {
                        ( true) &&
                            warnDeprecation("COMPILER_NATIVE_TEMPLATE" /* COMPILER_NATIVE_TEMPLATE */, context, node.loc);
                        node = node.children;
                    }
                }
                else if (s[1] === '?') {
                    emitError(context, 21 /* UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */, 1);
                    node = parseBogusComment(context);
                }
                else {
                    emitError(context, 12 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */, 1);
                }
            }
        }
        if (!node) {
            node = parseText(context, mode);
        }
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(node)) {
            for (let i = 0; i < node.length; i++) {
                pushNode(nodes, node[i]);
            }
        }
        else {
            pushNode(nodes, node);
        }
    }
    // Whitespace handling strategy like v2
    let removedWhitespace = false;
    if (mode !== 2 /* RAWTEXT */ && mode !== 1 /* RCDATA */) {
        const shouldCondense = context.options.whitespace !== 'preserve';
        for (let i = 0; i < nodes.length; i++) {
            const node = nodes[i];
            if (!context.inPre && node.type === 2 /* TEXT */) {
                if (!/[^\t\r\n\f ]/.test(node.content)) {
                    const prev = nodes[i - 1];
                    const next = nodes[i + 1];
                    // Remove if:
                    // - the whitespace is the first or last node, or:
                    // - (condense mode) the whitespace is adjacent to a comment, or:
                    // - (condense mode) the whitespace is between two elements AND contains newline
                    if (!prev ||
                        !next ||
                        (shouldCondense &&
                            (prev.type === 3 /* COMMENT */ ||
                                next.type === 3 /* COMMENT */ ||
                                (prev.type === 1 /* ELEMENT */ &&
                                    next.type === 1 /* ELEMENT */ &&
                                    /[\r\n]/.test(node.content))))) {
                        removedWhitespace = true;
                        nodes[i] = null;
                    }
                    else {
                        // Otherwise, the whitespace is condensed into a single space
                        node.content = ' ';
                    }
                }
                else if (shouldCondense) {
                    // in condense mode, consecutive whitespaces in text are condensed
                    // down to a single space.
                    node.content = node.content.replace(/[\t\r\n\f ]+/g, ' ');
                }
            }
            // Remove comment nodes if desired by configuration.
            else if (node.type === 3 /* COMMENT */ && !context.options.comments) {
                removedWhitespace = true;
                nodes[i] = null;
            }
        }
        if (context.inPre && parent && context.options.isPreTag(parent.tag)) {
            // remove leading newline per html spec
            // https://html.spec.whatwg.org/multipage/grouping-content.html#the-pre-element
            const first = nodes[0];
            if (first && first.type === 2 /* TEXT */) {
                first.content = first.content.replace(/^\r?\n/, '');
            }
        }
    }
    return removedWhitespace ? nodes.filter(Boolean) : nodes;
}
function pushNode(nodes, node) {
    if (node.type === 2 /* TEXT */) {
        const prev = last(nodes);
        // Merge if both this and the previous node are text and those are
        // consecutive. This happens for cases like "a < b".
        if (prev &&
            prev.type === 2 /* TEXT */ &&
            prev.loc.end.offset === node.loc.start.offset) {
            prev.content += node.content;
            prev.loc.end = node.loc.end;
            prev.loc.source += node.loc.source;
            return;
        }
    }
    nodes.push(node);
}
function parseCDATA(context, ancestors) {
    advanceBy(context, 9);
    const nodes = parseChildren(context, 3 /* CDATA */, ancestors);
    if (context.source.length === 0) {
        emitError(context, 6 /* EOF_IN_CDATA */);
    }
    else {
        advanceBy(context, 3);
    }
    return nodes;
}
function parseComment(context) {
    const start = getCursor(context);
    let content;
    // Regular comment.
    const match = /--(\!)?>/.exec(context.source);
    if (!match) {
        content = context.source.slice(4);
        advanceBy(context, context.source.length);
        emitError(context, 7 /* EOF_IN_COMMENT */);
    }
    else {
        if (match.index <= 3) {
            emitError(context, 0 /* ABRUPT_CLOSING_OF_EMPTY_COMMENT */);
        }
        if (match[1]) {
            emitError(context, 10 /* INCORRECTLY_CLOSED_COMMENT */);
        }
        content = context.source.slice(4, match.index);
        // Advancing with reporting nested comments.
        const s = context.source.slice(0, match.index);
        let prevIndex = 1, nestedIndex = 0;
        while ((nestedIndex = s.indexOf('<!--', prevIndex)) !== -1) {
            advanceBy(context, nestedIndex - prevIndex + 1);
            if (nestedIndex + 4 < s.length) {
                emitError(context, 16 /* NESTED_COMMENT */);
            }
            prevIndex = nestedIndex + 1;
        }
        advanceBy(context, match.index + match[0].length - prevIndex + 1);
    }
    return {
        type: 3 /* COMMENT */,
        content,
        loc: getSelection(context, start)
    };
}
function parseBogusComment(context) {
    const start = getCursor(context);
    const contentStart = context.source[1] === '?' ? 1 : 2;
    let content;
    const closeIndex = context.source.indexOf('>');
    if (closeIndex === -1) {
        content = context.source.slice(contentStart);
        advanceBy(context, context.source.length);
    }
    else {
        content = context.source.slice(contentStart, closeIndex);
        advanceBy(context, closeIndex + 1);
    }
    return {
        type: 3 /* COMMENT */,
        content,
        loc: getSelection(context, start)
    };
}
function parseElement(context, ancestors) {
    // Start tag.
    const wasInPre = context.inPre;
    const wasInVPre = context.inVPre;
    const parent = last(ancestors);
    const element = parseTag(context, 0 /* Start */, parent);
    const isPreBoundary = context.inPre && !wasInPre;
    const isVPreBoundary = context.inVPre && !wasInVPre;
    if (element.isSelfClosing || context.options.isVoidTag(element.tag)) {
        // #4030 self-closing <pre> tag
        if (isPreBoundary) {
            context.inPre = false;
        }
        if (isVPreBoundary) {
            context.inVPre = false;
        }
        return element;
    }
    // Children.
    ancestors.push(element);
    const mode = context.options.getTextMode(element, parent);
    const children = parseChildren(context, mode, ancestors);
    ancestors.pop();
    // 2.x inline-template compat
    {
        const inlineTemplateProp = element.props.find(p => p.type === 6 /* ATTRIBUTE */ && p.name === 'inline-template');
        if (inlineTemplateProp &&
            checkCompatEnabled("COMPILER_INLINE_TEMPLATE" /* COMPILER_INLINE_TEMPLATE */, context, inlineTemplateProp.loc)) {
            const loc = getSelection(context, element.loc.end);
            inlineTemplateProp.value = {
                type: 2 /* TEXT */,
                content: loc.source,
                loc
            };
        }
    }
    element.children = children;
    // End tag.
    if (startsWithEndTagOpen(context.source, element.tag)) {
        parseTag(context, 1 /* End */, parent);
    }
    else {
        emitError(context, 24 /* X_MISSING_END_TAG */, 0, element.loc.start);
        if (context.source.length === 0 && element.tag.toLowerCase() === 'script') {
            const first = children[0];
            if (first && startsWith(first.loc.source, '<!--')) {
                emitError(context, 8 /* EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */);
            }
        }
    }
    element.loc = getSelection(context, element.loc.start);
    if (isPreBoundary) {
        context.inPre = false;
    }
    if (isVPreBoundary) {
        context.inVPre = false;
    }
    return element;
}
const isSpecialTemplateDirective = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.makeMap)(`if,else,else-if,for,slot`);
function parseTag(context, type, parent) {
    // Tag open.
    const start = getCursor(context);
    const match = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(context.source);
    const tag = match[1];
    const ns = context.options.getNamespace(tag, parent);
    advanceBy(context, match[0].length);
    advanceSpaces(context);
    // save current state in case we need to re-parse attributes with v-pre
    const cursor = getCursor(context);
    const currentSource = context.source;
    // check <pre> tag
    if (context.options.isPreTag(tag)) {
        context.inPre = true;
    }
    // Attributes.
    let props = parseAttributes(context, type);
    // check v-pre
    if (type === 0 /* Start */ &&
        !context.inVPre &&
        props.some(p => p.type === 7 /* DIRECTIVE */ && p.name === 'pre')) {
        context.inVPre = true;
        // reset context
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)(context, cursor);
        context.source = currentSource;
        // re-parse attrs and filter out v-pre itself
        props = parseAttributes(context, type).filter(p => p.name !== 'v-pre');
    }
    // Tag close.
    let isSelfClosing = false;
    if (context.source.length === 0) {
        emitError(context, 9 /* EOF_IN_TAG */);
    }
    else {
        isSelfClosing = startsWith(context.source, '/>');
        if (type === 1 /* End */ && isSelfClosing) {
            emitError(context, 4 /* END_TAG_WITH_TRAILING_SOLIDUS */);
        }
        advanceBy(context, isSelfClosing ? 2 : 1);
    }
    if (type === 1 /* End */) {
        return;
    }
    // 2.x deprecation checks
    if (( true) &&
        isCompatEnabled("COMPILER_V_IF_V_FOR_PRECEDENCE" /* COMPILER_V_IF_V_FOR_PRECEDENCE */, context)) {
        let hasIf = false;
        let hasFor = false;
        for (let i = 0; i < props.length; i++) {
            const p = props[i];
            if (p.type === 7 /* DIRECTIVE */) {
                if (p.name === 'if') {
                    hasIf = true;
                }
                else if (p.name === 'for') {
                    hasFor = true;
                }
            }
            if (hasIf && hasFor) {
                warnDeprecation("COMPILER_V_IF_V_FOR_PRECEDENCE" /* COMPILER_V_IF_V_FOR_PRECEDENCE */, context, getSelection(context, start));
                break;
            }
        }
    }
    let tagType = 0 /* ELEMENT */;
    if (!context.inVPre) {
        if (tag === 'slot') {
            tagType = 2 /* SLOT */;
        }
        else if (tag === 'template') {
            if (props.some(p => p.type === 7 /* DIRECTIVE */ && isSpecialTemplateDirective(p.name))) {
                tagType = 3 /* TEMPLATE */;
            }
        }
        else if (isComponent(tag, props, context)) {
            tagType = 1 /* COMPONENT */;
        }
    }
    return {
        type: 1 /* ELEMENT */,
        ns,
        tag,
        tagType,
        props,
        isSelfClosing,
        children: [],
        loc: getSelection(context, start),
        codegenNode: undefined // to be created during transform phase
    };
}
function isComponent(tag, props, context) {
    const options = context.options;
    if (options.isCustomElement(tag)) {
        return false;
    }
    if (tag === 'component' ||
        /^[A-Z]/.test(tag) ||
        isCoreComponent(tag) ||
        (options.isBuiltInComponent && options.isBuiltInComponent(tag)) ||
        (options.isNativeTag && !options.isNativeTag(tag))) {
        return true;
    }
    // at this point the tag should be a native tag, but check for potential "is"
    // casting
    for (let i = 0; i < props.length; i++) {
        const p = props[i];
        if (p.type === 6 /* ATTRIBUTE */) {
            if (p.name === 'is' && p.value) {
                if (p.value.content.startsWith('vue:')) {
                    return true;
                }
                else if (checkCompatEnabled("COMPILER_IS_ON_ELEMENT" /* COMPILER_IS_ON_ELEMENT */, context, p.loc)) {
                    return true;
                }
            }
        }
        else {
            // directive
            // v-is (TODO Deprecate)
            if (p.name === 'is') {
                return true;
            }
            else if (
            // :is on plain element - only treat as component in compat mode
            p.name === 'bind' &&
                isStaticArgOf(p.arg, 'is') &&
                true &&
                checkCompatEnabled("COMPILER_IS_ON_ELEMENT" /* COMPILER_IS_ON_ELEMENT */, context, p.loc)) {
                return true;
            }
        }
    }
}
function parseAttributes(context, type) {
    const props = [];
    const attributeNames = new Set();
    while (context.source.length > 0 &&
        !startsWith(context.source, '>') &&
        !startsWith(context.source, '/>')) {
        if (startsWith(context.source, '/')) {
            emitError(context, 22 /* UNEXPECTED_SOLIDUS_IN_TAG */);
            advanceBy(context, 1);
            advanceSpaces(context);
            continue;
        }
        if (type === 1 /* End */) {
            emitError(context, 3 /* END_TAG_WITH_ATTRIBUTES */);
        }
        const attr = parseAttribute(context, attributeNames);
        // Trim whitespace between class
        // https://github.com/vuejs/core/issues/4251
        if (attr.type === 6 /* ATTRIBUTE */ &&
            attr.value &&
            attr.name === 'class') {
            attr.value.content = attr.value.content.replace(/\s+/g, ' ').trim();
        }
        if (type === 0 /* Start */) {
            props.push(attr);
        }
        if (/^[^\t\r\n\f />]/.test(context.source)) {
            emitError(context, 15 /* MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */);
        }
        advanceSpaces(context);
    }
    return props;
}
function parseAttribute(context, nameSet) {
    // Name.
    const start = getCursor(context);
    const match = /^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(context.source);
    const name = match[0];
    if (nameSet.has(name)) {
        emitError(context, 2 /* DUPLICATE_ATTRIBUTE */);
    }
    nameSet.add(name);
    if (name[0] === '=') {
        emitError(context, 19 /* UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */);
    }
    {
        const pattern = /["'<]/g;
        let m;
        while ((m = pattern.exec(name))) {
            emitError(context, 17 /* UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */, m.index);
        }
    }
    advanceBy(context, name.length);
    // Value
    let value = undefined;
    if (/^[\t\r\n\f ]*=/.test(context.source)) {
        advanceSpaces(context);
        advanceBy(context, 1);
        advanceSpaces(context);
        value = parseAttributeValue(context);
        if (!value) {
            emitError(context, 13 /* MISSING_ATTRIBUTE_VALUE */);
        }
    }
    const loc = getSelection(context, start);
    if (!context.inVPre && /^(v-[A-Za-z0-9-]|:|\.|@|#)/.test(name)) {
        const match = /(?:^v-([a-z0-9-]+))?(?:(?::|^\.|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i.exec(name);
        let isPropShorthand = startsWith(name, '.');
        let dirName = match[1] ||
            (isPropShorthand || startsWith(name, ':')
                ? 'bind'
                : startsWith(name, '@')
                    ? 'on'
                    : 'slot');
        let arg;
        if (match[2]) {
            const isSlot = dirName === 'slot';
            const startOffset = name.lastIndexOf(match[2]);
            const loc = getSelection(context, getNewPosition(context, start, startOffset), getNewPosition(context, start, startOffset + match[2].length + ((isSlot && match[3]) || '').length));
            let content = match[2];
            let isStatic = true;
            if (content.startsWith('[')) {
                isStatic = false;
                if (!content.endsWith(']')) {
                    emitError(context, 27 /* X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */);
                    content = content.slice(1);
                }
                else {
                    content = content.slice(1, content.length - 1);
                }
            }
            else if (isSlot) {
                // #1241 special case for v-slot: vuetify relies extensively on slot
                // names containing dots. v-slot doesn't have any modifiers and Vue 2.x
                // supports such usage so we are keeping it consistent with 2.x.
                content += match[3] || '';
            }
            arg = {
                type: 4 /* SIMPLE_EXPRESSION */,
                content,
                isStatic,
                constType: isStatic
                    ? 3 /* CAN_STRINGIFY */
                    : 0 /* NOT_CONSTANT */,
                loc
            };
        }
        if (value && value.isQuoted) {
            const valueLoc = value.loc;
            valueLoc.start.offset++;
            valueLoc.start.column++;
            valueLoc.end = advancePositionWithClone(valueLoc.start, value.content);
            valueLoc.source = valueLoc.source.slice(1, -1);
        }
        const modifiers = match[3] ? match[3].slice(1).split('.') : [];
        if (isPropShorthand)
            modifiers.push('prop');
        // 2.x compat v-bind:foo.sync -> v-model:foo
        if (dirName === 'bind' && arg) {
            if (modifiers.includes('sync') &&
                checkCompatEnabled("COMPILER_V_BIND_SYNC" /* COMPILER_V_BIND_SYNC */, context, loc, arg.loc.source)) {
                dirName = 'model';
                modifiers.splice(modifiers.indexOf('sync'), 1);
            }
            if (( true) && modifiers.includes('prop')) {
                checkCompatEnabled("COMPILER_V_BIND_PROP" /* COMPILER_V_BIND_PROP */, context, loc);
            }
        }
        return {
            type: 7 /* DIRECTIVE */,
            name: dirName,
            exp: value && {
                type: 4 /* SIMPLE_EXPRESSION */,
                content: value.content,
                isStatic: false,
                // Treat as non-constant by default. This can be potentially set to
                // other values by `transformExpression` to make it eligible for hoisting.
                constType: 0 /* NOT_CONSTANT */,
                loc: value.loc
            },
            arg,
            modifiers,
            loc
        };
    }
    // missing directive name or illegal directive name
    if (!context.inVPre && startsWith(name, 'v-')) {
        emitError(context, 26 /* X_MISSING_DIRECTIVE_NAME */);
    }
    return {
        type: 6 /* ATTRIBUTE */,
        name,
        value: value && {
            type: 2 /* TEXT */,
            content: value.content,
            loc: value.loc
        },
        loc
    };
}
function parseAttributeValue(context) {
    const start = getCursor(context);
    let content;
    const quote = context.source[0];
    const isQuoted = quote === `"` || quote === `'`;
    if (isQuoted) {
        // Quoted value.
        advanceBy(context, 1);
        const endIndex = context.source.indexOf(quote);
        if (endIndex === -1) {
            content = parseTextData(context, context.source.length, 4 /* ATTRIBUTE_VALUE */);
        }
        else {
            content = parseTextData(context, endIndex, 4 /* ATTRIBUTE_VALUE */);
            advanceBy(context, 1);
        }
    }
    else {
        // Unquoted
        const match = /^[^\t\r\n\f >]+/.exec(context.source);
        if (!match) {
            return undefined;
        }
        const unexpectedChars = /["'<=`]/g;
        let m;
        while ((m = unexpectedChars.exec(match[0]))) {
            emitError(context, 18 /* UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */, m.index);
        }
        content = parseTextData(context, match[0].length, 4 /* ATTRIBUTE_VALUE */);
    }
    return { content, isQuoted, loc: getSelection(context, start) };
}
function parseInterpolation(context, mode) {
    const [open, close] = context.options.delimiters;
    const closeIndex = context.source.indexOf(close, open.length);
    if (closeIndex === -1) {
        emitError(context, 25 /* X_MISSING_INTERPOLATION_END */);
        return undefined;
    }
    const start = getCursor(context);
    advanceBy(context, open.length);
    const innerStart = getCursor(context);
    const innerEnd = getCursor(context);
    const rawContentLength = closeIndex - open.length;
    const rawContent = context.source.slice(0, rawContentLength);
    const preTrimContent = parseTextData(context, rawContentLength, mode);
    const content = preTrimContent.trim();
    const startOffset = preTrimContent.indexOf(content);
    if (startOffset > 0) {
        advancePositionWithMutation(innerStart, rawContent, startOffset);
    }
    const endOffset = rawContentLength - (preTrimContent.length - content.length - startOffset);
    advancePositionWithMutation(innerEnd, rawContent, endOffset);
    advanceBy(context, close.length);
    return {
        type: 5 /* INTERPOLATION */,
        content: {
            type: 4 /* SIMPLE_EXPRESSION */,
            isStatic: false,
            // Set `isConstant` to false by default and will decide in transformExpression
            constType: 0 /* NOT_CONSTANT */,
            content,
            loc: getSelection(context, innerStart, innerEnd)
        },
        loc: getSelection(context, start)
    };
}
function parseText(context, mode) {
    const endTokens = mode === 3 /* CDATA */ ? [']]>'] : ['<', context.options.delimiters[0]];
    let endIndex = context.source.length;
    for (let i = 0; i < endTokens.length; i++) {
        const index = context.source.indexOf(endTokens[i], 1);
        if (index !== -1 && endIndex > index) {
            endIndex = index;
        }
    }
    const start = getCursor(context);
    const content = parseTextData(context, endIndex, mode);
    return {
        type: 2 /* TEXT */,
        content,
        loc: getSelection(context, start)
    };
}
/**
 * Get text data with a given length from the current location.
 * This translates HTML entities in the text data.
 */
function parseTextData(context, length, mode) {
    const rawText = context.source.slice(0, length);
    advanceBy(context, length);
    if (mode === 2 /* RAWTEXT */ ||
        mode === 3 /* CDATA */ ||
        !rawText.includes('&')) {
        return rawText;
    }
    else {
        // DATA or RCDATA containing "&"". Entity decoding required.
        return context.options.decodeEntities(rawText, mode === 4 /* ATTRIBUTE_VALUE */);
    }
}
function getCursor(context) {
    const { column, line, offset } = context;
    return { column, line, offset };
}
function getSelection(context, start, end) {
    end = end || getCursor(context);
    return {
        start,
        end,
        source: context.originalSource.slice(start.offset, end.offset)
    };
}
function last(xs) {
    return xs[xs.length - 1];
}
function startsWith(source, searchString) {
    return source.startsWith(searchString);
}
function advanceBy(context, numberOfCharacters) {
    const { source } = context;
    advancePositionWithMutation(context, source, numberOfCharacters);
    context.source = source.slice(numberOfCharacters);
}
function advanceSpaces(context) {
    const match = /^[\t\r\n\f ]+/.exec(context.source);
    if (match) {
        advanceBy(context, match[0].length);
    }
}
function getNewPosition(context, start, numberOfCharacters) {
    return advancePositionWithClone(start, context.originalSource.slice(start.offset, numberOfCharacters), numberOfCharacters);
}
function emitError(context, code, offset, loc = getCursor(context)) {
    if (offset) {
        loc.offset += offset;
        loc.column += offset;
    }
    context.options.onError(createCompilerError(code, {
        start: loc,
        end: loc,
        source: ''
    }));
}
function isEnd(context, mode, ancestors) {
    const s = context.source;
    switch (mode) {
        case 0 /* DATA */:
            if (startsWith(s, '</')) {
                // TODO: probably bad performance
                for (let i = ancestors.length - 1; i >= 0; --i) {
                    if (startsWithEndTagOpen(s, ancestors[i].tag)) {
                        return true;
                    }
                }
            }
            break;
        case 1 /* RCDATA */:
        case 2 /* RAWTEXT */: {
            const parent = last(ancestors);
            if (parent && startsWithEndTagOpen(s, parent.tag)) {
                return true;
            }
            break;
        }
        case 3 /* CDATA */:
            if (startsWith(s, ']]>')) {
                return true;
            }
            break;
    }
    return !s;
}
function startsWithEndTagOpen(source, tag) {
    return (startsWith(source, '</') &&
        source.slice(2, 2 + tag.length).toLowerCase() === tag.toLowerCase() &&
        /[\t\r\n\f />]/.test(source[2 + tag.length] || '>'));
}

function hoistStatic(root, context) {
    walk(root, context, 
    // Root node is unfortunately non-hoistable due to potential parent
    // fallthrough attributes.
    isSingleElementRoot(root, root.children[0]));
}
function isSingleElementRoot(root, child) {
    const { children } = root;
    return (children.length === 1 &&
        child.type === 1 /* ELEMENT */ &&
        !isSlotOutlet(child));
}
function walk(node, context, doNotHoistNode = false) {
    const { children } = node;
    const originalCount = children.length;
    let hoistedCount = 0;
    for (let i = 0; i < children.length; i++) {
        const child = children[i];
        // only plain elements & text calls are eligible for hoisting.
        if (child.type === 1 /* ELEMENT */ &&
            child.tagType === 0 /* ELEMENT */) {
            const constantType = doNotHoistNode
                ? 0 /* NOT_CONSTANT */
                : getConstantType(child, context);
            if (constantType > 0 /* NOT_CONSTANT */) {
                if (constantType >= 2 /* CAN_HOIST */) {
                    child.codegenNode.patchFlag =
                        -1 /* HOISTED */ + (( true) ? ` /* HOISTED */` : 0);
                    child.codegenNode = context.hoist(child.codegenNode);
                    hoistedCount++;
                    continue;
                }
            }
            else {
                // node may contain dynamic children, but its props may be eligible for
                // hoisting.
                const codegenNode = child.codegenNode;
                if (codegenNode.type === 13 /* VNODE_CALL */) {
                    const flag = getPatchFlag(codegenNode);
                    if ((!flag ||
                        flag === 512 /* NEED_PATCH */ ||
                        flag === 1 /* TEXT */) &&
                        getGeneratedPropsConstantType(child, context) >=
                            2 /* CAN_HOIST */) {
                        const props = getNodeProps(child);
                        if (props) {
                            codegenNode.props = context.hoist(props);
                        }
                    }
                    if (codegenNode.dynamicProps) {
                        codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps);
                    }
                }
            }
        }
        else if (child.type === 12 /* TEXT_CALL */ &&
            getConstantType(child.content, context) >= 2 /* CAN_HOIST */) {
            child.codegenNode = context.hoist(child.codegenNode);
            hoistedCount++;
        }
        // walk further
        if (child.type === 1 /* ELEMENT */) {
            const isComponent = child.tagType === 1 /* COMPONENT */;
            if (isComponent) {
                context.scopes.vSlot++;
            }
            walk(child, context);
            if (isComponent) {
                context.scopes.vSlot--;
            }
        }
        else if (child.type === 11 /* FOR */) {
            // Do not hoist v-for single child because it has to be a block
            walk(child, context, child.children.length === 1);
        }
        else if (child.type === 9 /* IF */) {
            for (let i = 0; i < child.branches.length; i++) {
                // Do not hoist v-if single child because it has to be a block
                walk(child.branches[i], context, child.branches[i].children.length === 1);
            }
        }
    }
    if (hoistedCount && context.transformHoist) {
        context.transformHoist(children, context, node);
    }
    // all children were hoisted - the entire children array is hoistable.
    if (hoistedCount &&
        hoistedCount === originalCount &&
        node.type === 1 /* ELEMENT */ &&
        node.tagType === 0 /* ELEMENT */ &&
        node.codegenNode &&
        node.codegenNode.type === 13 /* VNODE_CALL */ &&
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(node.codegenNode.children)) {
        node.codegenNode.children = context.hoist(createArrayExpression(node.codegenNode.children));
    }
}
function getConstantType(node, context) {
    const { constantCache } = context;
    switch (node.type) {
        case 1 /* ELEMENT */:
            if (node.tagType !== 0 /* ELEMENT */) {
                return 0 /* NOT_CONSTANT */;
            }
            const cached = constantCache.get(node);
            if (cached !== undefined) {
                return cached;
            }
            const codegenNode = node.codegenNode;
            if (codegenNode.type !== 13 /* VNODE_CALL */) {
                return 0 /* NOT_CONSTANT */;
            }
            if (codegenNode.isBlock &&
                node.tag !== 'svg' &&
                node.tag !== 'foreignObject') {
                return 0 /* NOT_CONSTANT */;
            }
            const flag = getPatchFlag(codegenNode);
            if (!flag) {
                let returnType = 3 /* CAN_STRINGIFY */;
                // Element itself has no patch flag. However we still need to check:
                // 1. Even for a node with no patch flag, it is possible for it to contain
                // non-hoistable expressions that refers to scope variables, e.g. compiler
                // injected keys or cached event handlers. Therefore we need to always
                // check the codegenNode's props to be sure.
                const generatedPropsType = getGeneratedPropsConstantType(node, context);
                if (generatedPropsType === 0 /* NOT_CONSTANT */) {
                    constantCache.set(node, 0 /* NOT_CONSTANT */);
                    return 0 /* NOT_CONSTANT */;
                }
                if (generatedPropsType < returnType) {
                    returnType = generatedPropsType;
                }
                // 2. its children.
                for (let i = 0; i < node.children.length; i++) {
                    const childType = getConstantType(node.children[i], context);
                    if (childType === 0 /* NOT_CONSTANT */) {
                        constantCache.set(node, 0 /* NOT_CONSTANT */);
                        return 0 /* NOT_CONSTANT */;
                    }
                    if (childType < returnType) {
                        returnType = childType;
                    }
                }
                // 3. if the type is not already CAN_SKIP_PATCH which is the lowest non-0
                // type, check if any of the props can cause the type to be lowered
                // we can skip can_patch because it's guaranteed by the absence of a
                // patchFlag.
                if (returnType > 1 /* CAN_SKIP_PATCH */) {
                    for (let i = 0; i < node.props.length; i++) {
                        const p = node.props[i];
                        if (p.type === 7 /* DIRECTIVE */ && p.name === 'bind' && p.exp) {
                            const expType = getConstantType(p.exp, context);
                            if (expType === 0 /* NOT_CONSTANT */) {
                                constantCache.set(node, 0 /* NOT_CONSTANT */);
                                return 0 /* NOT_CONSTANT */;
                            }
                            if (expType < returnType) {
                                returnType = expType;
                            }
                        }
                    }
                }
                // only svg/foreignObject could be block here, however if they are
                // static then they don't need to be blocks since there will be no
                // nested updates.
                if (codegenNode.isBlock) {
                    // except set custom directives.
                    for (let i = 0; i < node.props.length; i++) {
                        const p = node.props[i];
                        if (p.type === 7 /* DIRECTIVE */) {
                            constantCache.set(node, 0 /* NOT_CONSTANT */);
                            return 0 /* NOT_CONSTANT */;
                        }
                    }
                    context.removeHelper(OPEN_BLOCK);
                    context.removeHelper(getVNodeBlockHelper(context.inSSR, codegenNode.isComponent));
                    codegenNode.isBlock = false;
                    context.helper(getVNodeHelper(context.inSSR, codegenNode.isComponent));
                }
                constantCache.set(node, returnType);
                return returnType;
            }
            else {
                constantCache.set(node, 0 /* NOT_CONSTANT */);
                return 0 /* NOT_CONSTANT */;
            }
        case 2 /* TEXT */:
        case 3 /* COMMENT */:
            return 3 /* CAN_STRINGIFY */;
        case 9 /* IF */:
        case 11 /* FOR */:
        case 10 /* IF_BRANCH */:
            return 0 /* NOT_CONSTANT */;
        case 5 /* INTERPOLATION */:
        case 12 /* TEXT_CALL */:
            return getConstantType(node.content, context);
        case 4 /* SIMPLE_EXPRESSION */:
            return node.constType;
        case 8 /* COMPOUND_EXPRESSION */:
            let returnType = 3 /* CAN_STRINGIFY */;
            for (let i = 0; i < node.children.length; i++) {
                const child = node.children[i];
                if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(child) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(child)) {
                    continue;
                }
                const childType = getConstantType(child, context);
                if (childType === 0 /* NOT_CONSTANT */) {
                    return 0 /* NOT_CONSTANT */;
                }
                else if (childType < returnType) {
                    returnType = childType;
                }
            }
            return returnType;
        default:
            if ((true)) ;
            return 0 /* NOT_CONSTANT */;
    }
}
const allowHoistedHelperSet = new Set([
    NORMALIZE_CLASS,
    NORMALIZE_STYLE,
    NORMALIZE_PROPS,
    GUARD_REACTIVE_PROPS
]);
function getConstantTypeOfHelperCall(value, context) {
    if (value.type === 14 /* JS_CALL_EXPRESSION */ &&
        !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(value.callee) &&
        allowHoistedHelperSet.has(value.callee)) {
        const arg = value.arguments[0];
        if (arg.type === 4 /* SIMPLE_EXPRESSION */) {
            return getConstantType(arg, context);
        }
        else if (arg.type === 14 /* JS_CALL_EXPRESSION */) {
            // in the case of nested helper call, e.g. `normalizeProps(guardReactiveProps(exp))`
            return getConstantTypeOfHelperCall(arg, context);
        }
    }
    return 0 /* NOT_CONSTANT */;
}
function getGeneratedPropsConstantType(node, context) {
    let returnType = 3 /* CAN_STRINGIFY */;
    const props = getNodeProps(node);
    if (props && props.type === 15 /* JS_OBJECT_EXPRESSION */) {
        const { properties } = props;
        for (let i = 0; i < properties.length; i++) {
            const { key, value } = properties[i];
            const keyType = getConstantType(key, context);
            if (keyType === 0 /* NOT_CONSTANT */) {
                return keyType;
            }
            if (keyType < returnType) {
                returnType = keyType;
            }
            let valueType;
            if (value.type === 4 /* SIMPLE_EXPRESSION */) {
                valueType = getConstantType(value, context);
            }
            else if (value.type === 14 /* JS_CALL_EXPRESSION */) {
                // some helper calls can be hoisted,
                // such as the `normalizeProps` generated by the compiler for pre-normalize class,
                // in this case we need to respect the ConstantType of the helper's arguments
                valueType = getConstantTypeOfHelperCall(value, context);
            }
            else {
                valueType = 0 /* NOT_CONSTANT */;
            }
            if (valueType === 0 /* NOT_CONSTANT */) {
                return valueType;
            }
            if (valueType < returnType) {
                returnType = valueType;
            }
        }
    }
    return returnType;
}
function getNodeProps(node) {
    const codegenNode = node.codegenNode;
    if (codegenNode.type === 13 /* VNODE_CALL */) {
        return codegenNode.props;
    }
}
function getPatchFlag(node) {
    const flag = node.patchFlag;
    return flag ? parseInt(flag, 10) : undefined;
}

function createTransformContext(root, { filename = '', prefixIdentifiers = false, hoistStatic = false, cacheHandlers = false, nodeTransforms = [], directiveTransforms = {}, transformHoist = null, isBuiltInComponent = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NOOP, isCustomElement = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NOOP, expressionPlugins = [], scopeId = null, slotted = true, ssr = false, inSSR = false, ssrCssVars = ``, bindingMetadata = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.EMPTY_OBJ, inline = false, isTS = false, onError = defaultOnError, onWarn = defaultOnWarn, compatConfig }) {
    const nameMatch = filename.replace(/\?.*$/, '').match(/([^/\\]+)\.\w+$/);
    const context = {
        // options
        selfName: nameMatch && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.capitalize)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.camelize)(nameMatch[1])),
        prefixIdentifiers,
        hoistStatic,
        cacheHandlers,
        nodeTransforms,
        directiveTransforms,
        transformHoist,
        isBuiltInComponent,
        isCustomElement,
        expressionPlugins,
        scopeId,
        slotted,
        ssr,
        inSSR,
        ssrCssVars,
        bindingMetadata,
        inline,
        isTS,
        onError,
        onWarn,
        compatConfig,
        // state
        root,
        helpers: new Map(),
        components: new Set(),
        directives: new Set(),
        hoists: [],
        imports: [],
        constantCache: new Map(),
        temps: 0,
        cached: 0,
        identifiers: Object.create(null),
        scopes: {
            vFor: 0,
            vSlot: 0,
            vPre: 0,
            vOnce: 0
        },
        parent: null,
        currentNode: root,
        childIndex: 0,
        inVOnce: false,
        // methods
        helper(name) {
            const count = context.helpers.get(name) || 0;
            context.helpers.set(name, count + 1);
            return name;
        },
        removeHelper(name) {
            const count = context.helpers.get(name);
            if (count) {
                const currentCount = count - 1;
                if (!currentCount) {
                    context.helpers.delete(name);
                }
                else {
                    context.helpers.set(name, currentCount);
                }
            }
        },
        helperString(name) {
            return `_${helperNameMap[context.helper(name)]}`;
        },
        replaceNode(node) {
            /* istanbul ignore if */
            if ((true)) {
                if (!context.currentNode) {
                    throw new Error(`Node being replaced is already removed.`);
                }
                if (!context.parent) {
                    throw new Error(`Cannot replace root node.`);
                }
            }
            context.parent.children[context.childIndex] = context.currentNode = node;
        },
        removeNode(node) {
            if (( true) && !context.parent) {
                throw new Error(`Cannot remove root node.`);
            }
            const list = context.parent.children;
            const removalIndex = node
                ? list.indexOf(node)
                : context.currentNode
                    ? context.childIndex
                    : -1;
            /* istanbul ignore if */
            if (( true) && removalIndex < 0) {
                throw new Error(`node being removed is not a child of current parent`);
            }
            if (!node || node === context.currentNode) {
                // current node removed
                context.currentNode = null;
                context.onNodeRemoved();
            }
            else {
                // sibling node removed
                if (context.childIndex > removalIndex) {
                    context.childIndex--;
                    context.onNodeRemoved();
                }
            }
            context.parent.children.splice(removalIndex, 1);
        },
        onNodeRemoved: () => { },
        addIdentifiers(exp) {
        },
        removeIdentifiers(exp) {
        },
        hoist(exp) {
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(exp))
                exp = createSimpleExpression(exp);
            context.hoists.push(exp);
            const identifier = createSimpleExpression(`_hoisted_${context.hoists.length}`, false, exp.loc, 2 /* CAN_HOIST */);
            identifier.hoisted = exp;
            return identifier;
        },
        cache(exp, isVNode = false) {
            return createCacheExpression(context.cached++, exp, isVNode);
        }
    };
    {
        context.filters = new Set();
    }
    return context;
}
function transform(root, options) {
    const context = createTransformContext(root, options);
    traverseNode(root, context);
    if (options.hoistStatic) {
        hoistStatic(root, context);
    }
    if (!options.ssr) {
        createRootCodegen(root, context);
    }
    // finalize meta information
    root.helpers = [...context.helpers.keys()];
    root.components = [...context.components];
    root.directives = [...context.directives];
    root.imports = context.imports;
    root.hoists = context.hoists;
    root.temps = context.temps;
    root.cached = context.cached;
    {
        root.filters = [...context.filters];
    }
}
function createRootCodegen(root, context) {
    const { helper } = context;
    const { children } = root;
    if (children.length === 1) {
        const child = children[0];
        // if the single child is an element, turn it into a block.
        if (isSingleElementRoot(root, child) && child.codegenNode) {
            // single element root is never hoisted so codegenNode will never be
            // SimpleExpressionNode
            const codegenNode = child.codegenNode;
            if (codegenNode.type === 13 /* VNODE_CALL */) {
                makeBlock(codegenNode, context);
            }
            root.codegenNode = codegenNode;
        }
        else {
            // - single <slot/>, IfNode, ForNode: already blocks.
            // - single text node: always patched.
            // root codegen falls through via genNode()
            root.codegenNode = child;
        }
    }
    else if (children.length > 1) {
        // root has multiple nodes - return a fragment block.
        let patchFlag = 64 /* STABLE_FRAGMENT */;
        let patchFlagText = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[64];
        // check if the fragment actually contains a single valid child with
        // the rest being comments
        if (( true) &&
            children.filter(c => c.type !== 3 /* COMMENT */).length === 1) {
            patchFlag |= 2048 /* DEV_ROOT_FRAGMENT */;
            patchFlagText += `, ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[2048]}`;
        }
        root.codegenNode = createVNodeCall(context, helper(FRAGMENT), undefined, root.children, patchFlag + (( true) ? ` /* ${patchFlagText} */` : 0), undefined, undefined, true, undefined, false /* isComponent */);
    }
    else ;
}
function traverseChildren(parent, context) {
    let i = 0;
    const nodeRemoved = () => {
        i--;
    };
    for (; i < parent.children.length; i++) {
        const child = parent.children[i];
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(child))
            continue;
        context.parent = parent;
        context.childIndex = i;
        context.onNodeRemoved = nodeRemoved;
        traverseNode(child, context);
    }
}
function traverseNode(node, context) {
    context.currentNode = node;
    // apply transform plugins
    const { nodeTransforms } = context;
    const exitFns = [];
    for (let i = 0; i < nodeTransforms.length; i++) {
        const onExit = nodeTransforms[i](node, context);
        if (onExit) {
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(onExit)) {
                exitFns.push(...onExit);
            }
            else {
                exitFns.push(onExit);
            }
        }
        if (!context.currentNode) {
            // node was removed
            return;
        }
        else {
            // node may have been replaced
            node = context.currentNode;
        }
    }
    switch (node.type) {
        case 3 /* COMMENT */:
            if (!context.ssr) {
                // inject import for the Comment symbol, which is needed for creating
                // comment nodes with `createVNode`
                context.helper(CREATE_COMMENT);
            }
            break;
        case 5 /* INTERPOLATION */:
            // no need to traverse, but we need to inject toString helper
            if (!context.ssr) {
                context.helper(TO_DISPLAY_STRING);
            }
            break;
        // for container types, further traverse downwards
        case 9 /* IF */:
            for (let i = 0; i < node.branches.length; i++) {
                traverseNode(node.branches[i], context);
            }
            break;
        case 10 /* IF_BRANCH */:
        case 11 /* FOR */:
        case 1 /* ELEMENT */:
        case 0 /* ROOT */:
            traverseChildren(node, context);
            break;
    }
    // exit transforms
    context.currentNode = node;
    let i = exitFns.length;
    while (i--) {
        exitFns[i]();
    }
}
function createStructuralDirectiveTransform(name, fn) {
    const matches = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(name)
        ? (n) => n === name
        : (n) => name.test(n);
    return (node, context) => {
        if (node.type === 1 /* ELEMENT */) {
            const { props } = node;
            // structural directive transforms are not concerned with slots
            // as they are handled separately in vSlot.ts
            if (node.tagType === 3 /* TEMPLATE */ && props.some(isVSlot)) {
                return;
            }
            const exitFns = [];
            for (let i = 0; i < props.length; i++) {
                const prop = props[i];
                if (prop.type === 7 /* DIRECTIVE */ && matches(prop.name)) {
                    // structural directives are removed to avoid infinite recursion
                    // also we remove them *before* applying so that it can further
                    // traverse itself in case it moves the node around
                    props.splice(i, 1);
                    i--;
                    const onExit = fn(node, prop, context);
                    if (onExit)
                        exitFns.push(onExit);
                }
            }
            return exitFns;
        }
    };
}

const PURE_ANNOTATION = `/*#__PURE__*/`;
const aliasHelper = (s) => `${helperNameMap[s]}: _${helperNameMap[s]}`;
function createCodegenContext(ast, { mode = 'function', prefixIdentifiers = mode === 'module', sourceMap = false, filename = `template.vue.html`, scopeId = null, optimizeImports = false, runtimeGlobalName = `Vue`, runtimeModuleName = `vue`, ssrRuntimeModuleName = 'vue/server-renderer', ssr = false, isTS = false, inSSR = false }) {
    const context = {
        mode,
        prefixIdentifiers,
        sourceMap,
        filename,
        scopeId,
        optimizeImports,
        runtimeGlobalName,
        runtimeModuleName,
        ssrRuntimeModuleName,
        ssr,
        isTS,
        inSSR,
        source: ast.loc.source,
        code: ``,
        column: 1,
        line: 1,
        offset: 0,
        indentLevel: 0,
        pure: false,
        map: undefined,
        helper(key) {
            return `_${helperNameMap[key]}`;
        },
        push(code, node) {
            context.code += code;
        },
        indent() {
            newline(++context.indentLevel);
        },
        deindent(withoutNewLine = false) {
            if (withoutNewLine) {
                --context.indentLevel;
            }
            else {
                newline(--context.indentLevel);
            }
        },
        newline() {
            newline(context.indentLevel);
        }
    };
    function newline(n) {
        context.push('\n' + `  `.repeat(n));
    }
    return context;
}
function generate(ast, options = {}) {
    const context = createCodegenContext(ast, options);
    if (options.onContextCreated)
        options.onContextCreated(context);
    const { mode, push, prefixIdentifiers, indent, deindent, newline, scopeId, ssr } = context;
    const hasHelpers = ast.helpers.length > 0;
    const useWithBlock = !prefixIdentifiers && mode !== 'module';
    // preambles
    // in setup() inline mode, the preamble is generated in a sub context
    // and returned separately.
    const preambleContext = context;
    {
        genFunctionPreamble(ast, preambleContext);
    }
    // enter render function
    const functionName = ssr ? `ssrRender` : `render`;
    const args = ssr ? ['_ctx', '_push', '_parent', '_attrs'] : ['_ctx', '_cache'];
    const signature = args.join(', ');
    {
        push(`function ${functionName}(${signature}) {`);
    }
    indent();
    if (useWithBlock) {
        push(`with (_ctx) {`);
        indent();
        // function mode const declarations should be inside with block
        // also they should be renamed to avoid collision with user properties
        if (hasHelpers) {
            push(`const { ${ast.helpers.map(aliasHelper).join(', ')} } = _Vue`);
            push(`\n`);
            newline();
        }
    }
    // generate asset resolution statements
    if (ast.components.length) {
        genAssets(ast.components, 'component', context);
        if (ast.directives.length || ast.temps > 0) {
            newline();
        }
    }
    if (ast.directives.length) {
        genAssets(ast.directives, 'directive', context);
        if (ast.temps > 0) {
            newline();
        }
    }
    if (ast.filters && ast.filters.length) {
        newline();
        genAssets(ast.filters, 'filter', context);
        newline();
    }
    if (ast.temps > 0) {
        push(`let `);
        for (let i = 0; i < ast.temps; i++) {
            push(`${i > 0 ? `, ` : ``}_temp${i}`);
        }
    }
    if (ast.components.length || ast.directives.length || ast.temps) {
        push(`\n`);
        newline();
    }
    // generate the VNode tree expression
    if (!ssr) {
        push(`return `);
    }
    if (ast.codegenNode) {
        genNode(ast.codegenNode, context);
    }
    else {
        push(`null`);
    }
    if (useWithBlock) {
        deindent();
        push(`}`);
    }
    deindent();
    push(`}`);
    return {
        ast,
        code: context.code,
        preamble: ``,
        // SourceMapGenerator does have toJSON() method but it's not in the types
        map: context.map ? context.map.toJSON() : undefined
    };
}
function genFunctionPreamble(ast, context) {
    const { ssr, prefixIdentifiers, push, newline, runtimeModuleName, runtimeGlobalName, ssrRuntimeModuleName } = context;
    const VueBinding = runtimeGlobalName;
    // Generate const declaration for helpers
    // In prefix mode, we place the const declaration at top so it's done
    // only once; But if we not prefixing, we place the declaration inside the
    // with block so it doesn't incur the `in` check cost for every helper access.
    if (ast.helpers.length > 0) {
        {
            // "with" mode.
            // save Vue in a separate variable to avoid collision
            push(`const _Vue = ${VueBinding}\n`);
            // in "with" mode, helpers are declared inside the with block to avoid
            // has check cost, but hoists are lifted out of the function - we need
            // to provide the helper here.
            if (ast.hoists.length) {
                const staticHelpers = [
                    CREATE_VNODE,
                    CREATE_ELEMENT_VNODE,
                    CREATE_COMMENT,
                    CREATE_TEXT,
                    CREATE_STATIC
                ]
                    .filter(helper => ast.helpers.includes(helper))
                    .map(aliasHelper)
                    .join(', ');
                push(`const { ${staticHelpers} } = _Vue\n`);
            }
        }
    }
    genHoists(ast.hoists, context);
    newline();
    push(`return `);
}
function genAssets(assets, type, { helper, push, newline, isTS }) {
    const resolver = helper(type === 'filter'
        ? RESOLVE_FILTER
        : type === 'component'
            ? RESOLVE_COMPONENT
            : RESOLVE_DIRECTIVE);
    for (let i = 0; i < assets.length; i++) {
        let id = assets[i];
        // potential component implicit self-reference inferred from SFC filename
        const maybeSelfReference = id.endsWith('__self');
        if (maybeSelfReference) {
            id = id.slice(0, -6);
        }
        push(`const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)}${maybeSelfReference ? `, true` : ``})${isTS ? `!` : ``}`);
        if (i < assets.length - 1) {
            newline();
        }
    }
}
function genHoists(hoists, context) {
    if (!hoists.length) {
        return;
    }
    context.pure = true;
    const { push, newline, helper, scopeId, mode } = context;
    newline();
    for (let i = 0; i < hoists.length; i++) {
        const exp = hoists[i];
        if (exp) {
            push(`const _hoisted_${i + 1} = ${``}`);
            genNode(exp, context);
            newline();
        }
    }
    context.pure = false;
}
function isText$1(n) {
    return ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(n) ||
        n.type === 4 /* SIMPLE_EXPRESSION */ ||
        n.type === 2 /* TEXT */ ||
        n.type === 5 /* INTERPOLATION */ ||
        n.type === 8 /* COMPOUND_EXPRESSION */);
}
function genNodeListAsArray(nodes, context) {
    const multilines = nodes.length > 3 ||
        ((( true)) && nodes.some(n => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(n) || !isText$1(n)));
    context.push(`[`);
    multilines && context.indent();
    genNodeList(nodes, context, multilines);
    multilines && context.deindent();
    context.push(`]`);
}
function genNodeList(nodes, context, multilines = false, comma = true) {
    const { push, newline } = context;
    for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(node)) {
            push(node);
        }
        else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(node)) {
            genNodeListAsArray(node, context);
        }
        else {
            genNode(node, context);
        }
        if (i < nodes.length - 1) {
            if (multilines) {
                comma && push(',');
                newline();
            }
            else {
                comma && push(', ');
            }
        }
    }
}
function genNode(node, context) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(node)) {
        context.push(node);
        return;
    }
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(node)) {
        context.push(context.helper(node));
        return;
    }
    switch (node.type) {
        case 1 /* ELEMENT */:
        case 9 /* IF */:
        case 11 /* FOR */:
            ( true) &&
                assert(node.codegenNode != null, `Codegen node is missing for element/if/for node. ` +
                    `Apply appropriate transforms first.`);
            genNode(node.codegenNode, context);
            break;
        case 2 /* TEXT */:
            genText(node, context);
            break;
        case 4 /* SIMPLE_EXPRESSION */:
            genExpression(node, context);
            break;
        case 5 /* INTERPOLATION */:
            genInterpolation(node, context);
            break;
        case 12 /* TEXT_CALL */:
            genNode(node.codegenNode, context);
            break;
        case 8 /* COMPOUND_EXPRESSION */:
            genCompoundExpression(node, context);
            break;
        case 3 /* COMMENT */:
            genComment(node, context);
            break;
        case 13 /* VNODE_CALL */:
            genVNodeCall(node, context);
            break;
        case 14 /* JS_CALL_EXPRESSION */:
            genCallExpression(node, context);
            break;
        case 15 /* JS_OBJECT_EXPRESSION */:
            genObjectExpression(node, context);
            break;
        case 17 /* JS_ARRAY_EXPRESSION */:
            genArrayExpression(node, context);
            break;
        case 18 /* JS_FUNCTION_EXPRESSION */:
            genFunctionExpression(node, context);
            break;
        case 19 /* JS_CONDITIONAL_EXPRESSION */:
            genConditionalExpression(node, context);
            break;
        case 20 /* JS_CACHE_EXPRESSION */:
            genCacheExpression(node, context);
            break;
        case 21 /* JS_BLOCK_STATEMENT */:
            genNodeList(node.body, context, true, false);
            break;
        // SSR only types
        case 22 /* JS_TEMPLATE_LITERAL */:
            break;
        case 23 /* JS_IF_STATEMENT */:
            break;
        case 24 /* JS_ASSIGNMENT_EXPRESSION */:
            break;
        case 25 /* JS_SEQUENCE_EXPRESSION */:
            break;
        case 26 /* JS_RETURN_STATEMENT */:
            break;
        /* istanbul ignore next */
        case 10 /* IF_BRANCH */:
            // noop
            break;
        default:
            if ((true)) {
                assert(false, `unhandled codegen node type: ${node.type}`);
                // make sure we exhaust all possible types
                const exhaustiveCheck = node;
                return exhaustiveCheck;
            }
    }
}
function genText(node, context) {
    context.push(JSON.stringify(node.content), node);
}
function genExpression(node, context) {
    const { content, isStatic } = node;
    context.push(isStatic ? JSON.stringify(content) : content, node);
}
function genInterpolation(node, context) {
    const { push, helper, pure } = context;
    if (pure)
        push(PURE_ANNOTATION);
    push(`${helper(TO_DISPLAY_STRING)}(`);
    genNode(node.content, context);
    push(`)`);
}
function genCompoundExpression(node, context) {
    for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(child)) {
            context.push(child);
        }
        else {
            genNode(child, context);
        }
    }
}
function genExpressionAsPropertyKey(node, context) {
    const { push } = context;
    if (node.type === 8 /* COMPOUND_EXPRESSION */) {
        push(`[`);
        genCompoundExpression(node, context);
        push(`]`);
    }
    else if (node.isStatic) {
        // only quote keys if necessary
        const text = isSimpleIdentifier(node.content)
            ? node.content
            : JSON.stringify(node.content);
        push(text, node);
    }
    else {
        push(`[${node.content}]`, node);
    }
}
function genComment(node, context) {
    const { push, helper, pure } = context;
    if (pure) {
        push(PURE_ANNOTATION);
    }
    push(`${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`, node);
}
function genVNodeCall(node, context) {
    const { push, helper, pure } = context;
    const { tag, props, children, patchFlag, dynamicProps, directives, isBlock, disableTracking, isComponent } = node;
    if (directives) {
        push(helper(WITH_DIRECTIVES) + `(`);
    }
    if (isBlock) {
        push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);
    }
    if (pure) {
        push(PURE_ANNOTATION);
    }
    const callHelper = isBlock
        ? getVNodeBlockHelper(context.inSSR, isComponent)
        : getVNodeHelper(context.inSSR, isComponent);
    push(helper(callHelper) + `(`, node);
    genNodeList(genNullableArgs([tag, props, children, patchFlag, dynamicProps]), context);
    push(`)`);
    if (isBlock) {
        push(`)`);
    }
    if (directives) {
        push(`, `);
        genNode(directives, context);
        push(`)`);
    }
}
function genNullableArgs(args) {
    let i = args.length;
    while (i--) {
        if (args[i] != null)
            break;
    }
    return args.slice(0, i + 1).map(arg => arg || `null`);
}
// JavaScript
function genCallExpression(node, context) {
    const { push, helper, pure } = context;
    const callee = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(node.callee) ? node.callee : helper(node.callee);
    if (pure) {
        push(PURE_ANNOTATION);
    }
    push(callee + `(`, node);
    genNodeList(node.arguments, context);
    push(`)`);
}
function genObjectExpression(node, context) {
    const { push, indent, deindent, newline } = context;
    const { properties } = node;
    if (!properties.length) {
        push(`{}`, node);
        return;
    }
    const multilines = properties.length > 1 ||
        ((( true)) &&
            properties.some(p => p.value.type !== 4 /* SIMPLE_EXPRESSION */));
    push(multilines ? `{` : `{ `);
    multilines && indent();
    for (let i = 0; i < properties.length; i++) {
        const { key, value } = properties[i];
        // key
        genExpressionAsPropertyKey(key, context);
        push(`: `);
        // value
        genNode(value, context);
        if (i < properties.length - 1) {
            // will only reach this if it's multilines
            push(`,`);
            newline();
        }
    }
    multilines && deindent();
    push(multilines ? `}` : ` }`);
}
function genArrayExpression(node, context) {
    genNodeListAsArray(node.elements, context);
}
function genFunctionExpression(node, context) {
    const { push, indent, deindent } = context;
    const { params, returns, body, newline, isSlot } = node;
    if (isSlot) {
        // wrap slot functions with owner context
        push(`_${helperNameMap[WITH_CTX]}(`);
    }
    push(`(`, node);
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(params)) {
        genNodeList(params, context);
    }
    else if (params) {
        genNode(params, context);
    }
    push(`) => `);
    if (newline || body) {
        push(`{`);
        indent();
    }
    if (returns) {
        if (newline) {
            push(`return `);
        }
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(returns)) {
            genNodeListAsArray(returns, context);
        }
        else {
            genNode(returns, context);
        }
    }
    else if (body) {
        genNode(body, context);
    }
    if (newline || body) {
        deindent();
        push(`}`);
    }
    if (isSlot) {
        if (node.isNonScopedSlot) {
            push(`, undefined, true`);
        }
        push(`)`);
    }
}
function genConditionalExpression(node, context) {
    const { test, consequent, alternate, newline: needNewline } = node;
    const { push, indent, deindent, newline } = context;
    if (test.type === 4 /* SIMPLE_EXPRESSION */) {
        const needsParens = !isSimpleIdentifier(test.content);
        needsParens && push(`(`);
        genExpression(test, context);
        needsParens && push(`)`);
    }
    else {
        push(`(`);
        genNode(test, context);
        push(`)`);
    }
    needNewline && indent();
    context.indentLevel++;
    needNewline || push(` `);
    push(`? `);
    genNode(consequent, context);
    context.indentLevel--;
    needNewline && newline();
    needNewline || push(` `);
    push(`: `);
    const isNested = alternate.type === 19 /* JS_CONDITIONAL_EXPRESSION */;
    if (!isNested) {
        context.indentLevel++;
    }
    genNode(alternate, context);
    if (!isNested) {
        context.indentLevel--;
    }
    needNewline && deindent(true /* without newline */);
}
function genCacheExpression(node, context) {
    const { push, helper, indent, deindent, newline } = context;
    push(`_cache[${node.index}] || (`);
    if (node.isVNode) {
        indent();
        push(`${helper(SET_BLOCK_TRACKING)}(-1),`);
        newline();
    }
    push(`_cache[${node.index}] = `);
    genNode(node.value, context);
    if (node.isVNode) {
        push(`,`);
        newline();
        push(`${helper(SET_BLOCK_TRACKING)}(1),`);
        newline();
        push(`_cache[${node.index}]`);
        deindent();
    }
    push(`)`);
}

function walkIdentifiers(root, onIdentifier, includeAll = false, parentStack = [], knownIds = Object.create(null)) {
    {
        return;
    }
}
function isReferencedIdentifier(id, parent, parentStack) {
    {
        return false;
    }
}
function isInDestructureAssignment(parent, parentStack) {
    if (parent &&
        (parent.type === 'ObjectProperty' || parent.type === 'ArrayPattern')) {
        let i = parentStack.length;
        while (i--) {
            const p = parentStack[i];
            if (p.type === 'AssignmentExpression') {
                return true;
            }
            else if (p.type !== 'ObjectProperty' && !p.type.endsWith('Pattern')) {
                break;
            }
        }
    }
    return false;
}
function walkFunctionParams(node, onIdent) {
    for (const p of node.params) {
        for (const id of extractIdentifiers(p)) {
            onIdent(id);
        }
    }
}
function walkBlockDeclarations(block, onIdent) {
    for (const stmt of block.body) {
        if (stmt.type === 'VariableDeclaration') {
            if (stmt.declare)
                continue;
            for (const decl of stmt.declarations) {
                for (const id of extractIdentifiers(decl.id)) {
                    onIdent(id);
                }
            }
        }
        else if (stmt.type === 'FunctionDeclaration' ||
            stmt.type === 'ClassDeclaration') {
            if (stmt.declare || !stmt.id)
                continue;
            onIdent(stmt.id);
        }
    }
}
function extractIdentifiers(param, nodes = []) {
    switch (param.type) {
        case 'Identifier':
            nodes.push(param);
            break;
        case 'MemberExpression':
            let object = param;
            while (object.type === 'MemberExpression') {
                object = object.object;
            }
            nodes.push(object);
            break;
        case 'ObjectPattern':
            for (const prop of param.properties) {
                if (prop.type === 'RestElement') {
                    extractIdentifiers(prop.argument, nodes);
                }
                else {
                    extractIdentifiers(prop.value, nodes);
                }
            }
            break;
        case 'ArrayPattern':
            param.elements.forEach(element => {
                if (element)
                    extractIdentifiers(element, nodes);
            });
            break;
        case 'RestElement':
            extractIdentifiers(param.argument, nodes);
            break;
        case 'AssignmentPattern':
            extractIdentifiers(param.left, nodes);
            break;
    }
    return nodes;
}
const isFunctionType = (node) => {
    return /Function(?:Expression|Declaration)$|Method$/.test(node.type);
};
const isStaticProperty = (node) => node &&
    (node.type === 'ObjectProperty' || node.type === 'ObjectMethod') &&
    !node.computed;
const isStaticPropertyKey = (node, parent) => isStaticProperty(parent) && parent.key === node;

// these keywords should not appear inside expressions, but operators like
// typeof, instanceof and in are allowed
const prohibitedKeywordRE = new RegExp('\\b' +
    ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +
        'super,throw,while,yield,delete,export,import,return,switch,default,' +
        'extends,finally,continue,debugger,function,arguments,typeof,void')
        .split(',')
        .join('\\b|\\b') +
    '\\b');
// strip strings in expressions
const stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;
/**
 * Validate a non-prefixed expression.
 * This is only called when using the in-browser runtime compiler since it
 * doesn't prefix expressions.
 */
function validateBrowserExpression(node, context, asParams = false, asRawStatements = false) {
    const exp = node.content;
    // empty expressions are validated per-directive since some directives
    // do allow empty expressions.
    if (!exp.trim()) {
        return;
    }
    try {
        new Function(asRawStatements
            ? ` ${exp} `
            : `return ${asParams ? `(${exp}) => {}` : `(${exp})`}`);
    }
    catch (e) {
        let message = e.message;
        const keywordMatch = exp
            .replace(stripStringRE, '')
            .match(prohibitedKeywordRE);
        if (keywordMatch) {
            message = `avoid using JavaScript keyword as property name: "${keywordMatch[0]}"`;
        }
        context.onError(createCompilerError(44 /* X_INVALID_EXPRESSION */, node.loc, undefined, message));
    }
}

const transformExpression = (node, context) => {
    if (node.type === 5 /* INTERPOLATION */) {
        node.content = processExpression(node.content, context);
    }
    else if (node.type === 1 /* ELEMENT */) {
        // handle directives on element
        for (let i = 0; i < node.props.length; i++) {
            const dir = node.props[i];
            // do not process for v-on & v-for since they are special handled
            if (dir.type === 7 /* DIRECTIVE */ && dir.name !== 'for') {
                const exp = dir.exp;
                const arg = dir.arg;
                // do not process exp if this is v-on:arg - we need special handling
                // for wrapping inline statements.
                if (exp &&
                    exp.type === 4 /* SIMPLE_EXPRESSION */ &&
                    !(dir.name === 'on' && arg)) {
                    dir.exp = processExpression(exp, context, 
                    // slot args must be processed as function params
                    dir.name === 'slot');
                }
                if (arg && arg.type === 4 /* SIMPLE_EXPRESSION */ && !arg.isStatic) {
                    dir.arg = processExpression(arg, context);
                }
            }
        }
    }
};
// Important: since this function uses Node.js only dependencies, it should
// always be used with a leading !true check so that it can be
// tree-shaken from the browser build.
function processExpression(node, context, 
// some expressions like v-slot props & v-for aliases should be parsed as
// function params
asParams = false, 
// v-on handler values may contain multiple statements
asRawStatements = false, localVars = Object.create(context.identifiers)) {
    {
        if ((true)) {
            // simple in-browser validation (same logic in 2.x)
            validateBrowserExpression(node, context, asParams, asRawStatements);
        }
        return node;
    }
}

const transformIf = createStructuralDirectiveTransform(/^(if|else|else-if)$/, (node, dir, context) => {
    return processIf(node, dir, context, (ifNode, branch, isRoot) => {
        // #1587: We need to dynamically increment the key based on the current
        // node's sibling nodes, since chained v-if/else branches are
        // rendered at the same depth
        const siblings = context.parent.children;
        let i = siblings.indexOf(ifNode);
        let key = 0;
        while (i-- >= 0) {
            const sibling = siblings[i];
            if (sibling && sibling.type === 9 /* IF */) {
                key += sibling.branches.length;
            }
        }
        // Exit callback. Complete the codegenNode when all children have been
        // transformed.
        return () => {
            if (isRoot) {
                ifNode.codegenNode = createCodegenNodeForBranch(branch, key, context);
            }
            else {
                // attach this branch's codegen node to the v-if root.
                const parentCondition = getParentCondition(ifNode.codegenNode);
                parentCondition.alternate = createCodegenNodeForBranch(branch, key + ifNode.branches.length - 1, context);
            }
        };
    });
});
// target-agnostic transform used for both Client and SSR
function processIf(node, dir, context, processCodegen) {
    if (dir.name !== 'else' &&
        (!dir.exp || !dir.exp.content.trim())) {
        const loc = dir.exp ? dir.exp.loc : node.loc;
        context.onError(createCompilerError(28 /* X_V_IF_NO_EXPRESSION */, dir.loc));
        dir.exp = createSimpleExpression(`true`, false, loc);
    }
    if ( true && dir.exp) {
        validateBrowserExpression(dir.exp, context);
    }
    if (dir.name === 'if') {
        const branch = createIfBranch(node, dir);
        const ifNode = {
            type: 9 /* IF */,
            loc: node.loc,
            branches: [branch]
        };
        context.replaceNode(ifNode);
        if (processCodegen) {
            return processCodegen(ifNode, branch, true);
        }
    }
    else {
        // locate the adjacent v-if
        const siblings = context.parent.children;
        const comments = [];
        let i = siblings.indexOf(node);
        while (i-- >= -1) {
            const sibling = siblings[i];
            if (( true) && sibling && sibling.type === 3 /* COMMENT */) {
                context.removeNode(sibling);
                comments.unshift(sibling);
                continue;
            }
            if (sibling &&
                sibling.type === 2 /* TEXT */ &&
                !sibling.content.trim().length) {
                context.removeNode(sibling);
                continue;
            }
            if (sibling && sibling.type === 9 /* IF */) {
                // Check if v-else was followed by v-else-if
                if (dir.name === 'else-if' &&
                    sibling.branches[sibling.branches.length - 1].condition === undefined) {
                    context.onError(createCompilerError(30 /* X_V_ELSE_NO_ADJACENT_IF */, node.loc));
                }
                // move the node to the if node's branches
                context.removeNode();
                const branch = createIfBranch(node, dir);
                if (( true) &&
                    comments.length &&
                    // #3619 ignore comments if the v-if is direct child of <transition>
                    !(context.parent &&
                        context.parent.type === 1 /* ELEMENT */ &&
                        isBuiltInType(context.parent.tag, 'transition'))) {
                    branch.children = [...comments, ...branch.children];
                }
                // check if user is forcing same key on different branches
                if (true) {
                    const key = branch.userKey;
                    if (key) {
                        sibling.branches.forEach(({ userKey }) => {
                            if (isSameKey(userKey, key)) {
                                context.onError(createCompilerError(29 /* X_V_IF_SAME_KEY */, branch.userKey.loc));
                            }
                        });
                    }
                }
                sibling.branches.push(branch);
                const onExit = processCodegen && processCodegen(sibling, branch, false);
                // since the branch was removed, it will not be traversed.
                // make sure to traverse here.
                traverseNode(branch, context);
                // call on exit
                if (onExit)
                    onExit();
                // make sure to reset currentNode after traversal to indicate this
                // node has been removed.
                context.currentNode = null;
            }
            else {
                context.onError(createCompilerError(30 /* X_V_ELSE_NO_ADJACENT_IF */, node.loc));
            }
            break;
        }
    }
}
function createIfBranch(node, dir) {
    const isTemplateIf = node.tagType === 3 /* TEMPLATE */;
    return {
        type: 10 /* IF_BRANCH */,
        loc: node.loc,
        condition: dir.name === 'else' ? undefined : dir.exp,
        children: isTemplateIf && !findDir(node, 'for') ? node.children : [node],
        userKey: findProp(node, `key`),
        isTemplateIf
    };
}
function createCodegenNodeForBranch(branch, keyIndex, context) {
    if (branch.condition) {
        return createConditionalExpression(branch.condition, createChildrenCodegenNode(branch, keyIndex, context), 
        // make sure to pass in asBlock: true so that the comment node call
        // closes the current block.
        createCallExpression(context.helper(CREATE_COMMENT), [
            ( true) ? '"v-if"' : 0,
            'true'
        ]));
    }
    else {
        return createChildrenCodegenNode(branch, keyIndex, context);
    }
}
function createChildrenCodegenNode(branch, keyIndex, context) {
    const { helper } = context;
    const keyProperty = createObjectProperty(`key`, createSimpleExpression(`${keyIndex}`, false, locStub, 2 /* CAN_HOIST */));
    const { children } = branch;
    const firstChild = children[0];
    const needFragmentWrapper = children.length !== 1 || firstChild.type !== 1 /* ELEMENT */;
    if (needFragmentWrapper) {
        if (children.length === 1 && firstChild.type === 11 /* FOR */) {
            // optimize away nested fragments when child is a ForNode
            const vnodeCall = firstChild.codegenNode;
            injectProp(vnodeCall, keyProperty, context);
            return vnodeCall;
        }
        else {
            let patchFlag = 64 /* STABLE_FRAGMENT */;
            let patchFlagText = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[64];
            // check if the fragment actually contains a single valid child with
            // the rest being comments
            if (( true) &&
                !branch.isTemplateIf &&
                children.filter(c => c.type !== 3 /* COMMENT */).length === 1) {
                patchFlag |= 2048 /* DEV_ROOT_FRAGMENT */;
                patchFlagText += `, ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[2048]}`;
            }
            return createVNodeCall(context, helper(FRAGMENT), createObjectExpression([keyProperty]), children, patchFlag + (( true) ? ` /* ${patchFlagText} */` : 0), undefined, undefined, true, false, false /* isComponent */, branch.loc);
        }
    }
    else {
        const ret = firstChild.codegenNode;
        const vnodeCall = getMemoedVNodeCall(ret);
        // Change createVNode to createBlock.
        if (vnodeCall.type === 13 /* VNODE_CALL */) {
            makeBlock(vnodeCall, context);
        }
        // inject branch key
        injectProp(vnodeCall, keyProperty, context);
        return ret;
    }
}
function isSameKey(a, b) {
    if (!a || a.type !== b.type) {
        return false;
    }
    if (a.type === 6 /* ATTRIBUTE */) {
        if (a.value.content !== b.value.content) {
            return false;
        }
    }
    else {
        // directive
        const exp = a.exp;
        const branchExp = b.exp;
        if (exp.type !== branchExp.type) {
            return false;
        }
        if (exp.type !== 4 /* SIMPLE_EXPRESSION */ ||
            exp.isStatic !== branchExp.isStatic ||
            exp.content !== branchExp.content) {
            return false;
        }
    }
    return true;
}
function getParentCondition(node) {
    while (true) {
        if (node.type === 19 /* JS_CONDITIONAL_EXPRESSION */) {
            if (node.alternate.type === 19 /* JS_CONDITIONAL_EXPRESSION */) {
                node = node.alternate;
            }
            else {
                return node;
            }
        }
        else if (node.type === 20 /* JS_CACHE_EXPRESSION */) {
            node = node.value;
        }
    }
}

const transformFor = createStructuralDirectiveTransform('for', (node, dir, context) => {
    const { helper, removeHelper } = context;
    return processFor(node, dir, context, forNode => {
        // create the loop render function expression now, and add the
        // iterator on exit after all children have been traversed
        const renderExp = createCallExpression(helper(RENDER_LIST), [
            forNode.source
        ]);
        const isTemplate = isTemplateNode(node);
        const memo = findDir(node, 'memo');
        const keyProp = findProp(node, `key`);
        const keyExp = keyProp &&
            (keyProp.type === 6 /* ATTRIBUTE */
                ? createSimpleExpression(keyProp.value.content, true)
                : keyProp.exp);
        const keyProperty = keyProp ? createObjectProperty(`key`, keyExp) : null;
        const isStableFragment = forNode.source.type === 4 /* SIMPLE_EXPRESSION */ &&
            forNode.source.constType > 0 /* NOT_CONSTANT */;
        const fragmentFlag = isStableFragment
            ? 64 /* STABLE_FRAGMENT */
            : keyProp
                ? 128 /* KEYED_FRAGMENT */
                : 256 /* UNKEYED_FRAGMENT */;
        forNode.codegenNode = createVNodeCall(context, helper(FRAGMENT), undefined, renderExp, fragmentFlag +
            (( true) ? ` /* ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[fragmentFlag]} */` : 0), undefined, undefined, true /* isBlock */, !isStableFragment /* disableTracking */, false /* isComponent */, node.loc);
        return () => {
            // finish the codegen now that all children have been traversed
            let childBlock;
            const { children } = forNode;
            // check <template v-for> key placement
            if (( true) && isTemplate) {
                node.children.some(c => {
                    if (c.type === 1 /* ELEMENT */) {
                        const key = findProp(c, 'key');
                        if (key) {
                            context.onError(createCompilerError(33 /* X_V_FOR_TEMPLATE_KEY_PLACEMENT */, key.loc));
                            return true;
                        }
                    }
                });
            }
            const needFragmentWrapper = children.length !== 1 || children[0].type !== 1 /* ELEMENT */;
            const slotOutlet = isSlotOutlet(node)
                ? node
                : isTemplate &&
                    node.children.length === 1 &&
                    isSlotOutlet(node.children[0])
                    ? node.children[0] // api-extractor somehow fails to infer this
                    : null;
            if (slotOutlet) {
                // <slot v-for="..."> or <template v-for="..."><slot/></template>
                childBlock = slotOutlet.codegenNode;
                if (isTemplate && keyProperty) {
                    // <template v-for="..." :key="..."><slot/></template>
                    // we need to inject the key to the renderSlot() call.
                    // the props for renderSlot is passed as the 3rd argument.
                    injectProp(childBlock, keyProperty, context);
                }
            }
            else if (needFragmentWrapper) {
                // <template v-for="..."> with text or multi-elements
                // should generate a fragment block for each loop
                childBlock = createVNodeCall(context, helper(FRAGMENT), keyProperty ? createObjectExpression([keyProperty]) : undefined, node.children, 64 /* STABLE_FRAGMENT */ +
                    (( true)
                        ? ` /* ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[64]} */`
                        : 0), undefined, undefined, true, undefined, false /* isComponent */);
            }
            else {
                // Normal element v-for. Directly use the child's codegenNode
                // but mark it as a block.
                childBlock = children[0]
                    .codegenNode;
                if (isTemplate && keyProperty) {
                    injectProp(childBlock, keyProperty, context);
                }
                if (childBlock.isBlock !== !isStableFragment) {
                    if (childBlock.isBlock) {
                        // switch from block to vnode
                        removeHelper(OPEN_BLOCK);
                        removeHelper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
                    }
                    else {
                        // switch from vnode to block
                        removeHelper(getVNodeHelper(context.inSSR, childBlock.isComponent));
                    }
                }
                childBlock.isBlock = !isStableFragment;
                if (childBlock.isBlock) {
                    helper(OPEN_BLOCK);
                    helper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
                }
                else {
                    helper(getVNodeHelper(context.inSSR, childBlock.isComponent));
                }
            }
            if (memo) {
                const loop = createFunctionExpression(createForLoopParams(forNode.parseResult, [
                    createSimpleExpression(`_cached`)
                ]));
                loop.body = createBlockStatement([
                    createCompoundExpression([`const _memo = (`, memo.exp, `)`]),
                    createCompoundExpression([
                        `if (_cached`,
                        ...(keyExp ? [` && _cached.key === `, keyExp] : []),
                        ` && ${context.helperString(IS_MEMO_SAME)}(_cached, _memo)) return _cached`
                    ]),
                    createCompoundExpression([`const _item = `, childBlock]),
                    createSimpleExpression(`_item.memo = _memo`),
                    createSimpleExpression(`return _item`)
                ]);
                renderExp.arguments.push(loop, createSimpleExpression(`_cache`), createSimpleExpression(String(context.cached++)));
            }
            else {
                renderExp.arguments.push(createFunctionExpression(createForLoopParams(forNode.parseResult), childBlock, true /* force newline */));
            }
        };
    });
});
// target-agnostic transform used for both Client and SSR
function processFor(node, dir, context, processCodegen) {
    if (!dir.exp) {
        context.onError(createCompilerError(31 /* X_V_FOR_NO_EXPRESSION */, dir.loc));
        return;
    }
    const parseResult = parseForExpression(
    // can only be simple expression because vFor transform is applied
    // before expression transform.
    dir.exp, context);
    if (!parseResult) {
        context.onError(createCompilerError(32 /* X_V_FOR_MALFORMED_EXPRESSION */, dir.loc));
        return;
    }
    const { addIdentifiers, removeIdentifiers, scopes } = context;
    const { source, value, key, index } = parseResult;
    const forNode = {
        type: 11 /* FOR */,
        loc: dir.loc,
        source,
        valueAlias: value,
        keyAlias: key,
        objectIndexAlias: index,
        parseResult,
        children: isTemplateNode(node) ? node.children : [node]
    };
    context.replaceNode(forNode);
    // bookkeeping
    scopes.vFor++;
    const onExit = processCodegen && processCodegen(forNode);
    return () => {
        scopes.vFor--;
        if (onExit)
            onExit();
    };
}
const forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
// This regex doesn't cover the case if key or index aliases have destructuring,
// but those do not make sense in the first place, so this works in practice.
const forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
const stripParensRE = /^\(|\)$/g;
function parseForExpression(input, context) {
    const loc = input.loc;
    const exp = input.content;
    const inMatch = exp.match(forAliasRE);
    if (!inMatch)
        return;
    const [, LHS, RHS] = inMatch;
    const result = {
        source: createAliasExpression(loc, RHS.trim(), exp.indexOf(RHS, LHS.length)),
        value: undefined,
        key: undefined,
        index: undefined
    };
    if (true) {
        validateBrowserExpression(result.source, context);
    }
    let valueContent = LHS.trim().replace(stripParensRE, '').trim();
    const trimmedOffset = LHS.indexOf(valueContent);
    const iteratorMatch = valueContent.match(forIteratorRE);
    if (iteratorMatch) {
        valueContent = valueContent.replace(forIteratorRE, '').trim();
        const keyContent = iteratorMatch[1].trim();
        let keyOffset;
        if (keyContent) {
            keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);
            result.key = createAliasExpression(loc, keyContent, keyOffset);
            if (true) {
                validateBrowserExpression(result.key, context, true);
            }
        }
        if (iteratorMatch[2]) {
            const indexContent = iteratorMatch[2].trim();
            if (indexContent) {
                result.index = createAliasExpression(loc, indexContent, exp.indexOf(indexContent, result.key
                    ? keyOffset + keyContent.length
                    : trimmedOffset + valueContent.length));
                if (true) {
                    validateBrowserExpression(result.index, context, true);
                }
            }
        }
    }
    if (valueContent) {
        result.value = createAliasExpression(loc, valueContent, trimmedOffset);
        if (true) {
            validateBrowserExpression(result.value, context, true);
        }
    }
    return result;
}
function createAliasExpression(range, content, offset) {
    return createSimpleExpression(content, false, getInnerRange(range, offset, content.length));
}
function createForLoopParams({ value, key, index }, memoArgs = []) {
    return createParamsList([value, key, index, ...memoArgs]);
}
function createParamsList(args) {
    let i = args.length;
    while (i--) {
        if (args[i])
            break;
    }
    return args
        .slice(0, i + 1)
        .map((arg, i) => arg || createSimpleExpression(`_`.repeat(i + 1), false));
}

const defaultFallback = createSimpleExpression(`undefined`, false);
// A NodeTransform that:
// 1. Tracks scope identifiers for scoped slots so that they don't get prefixed
//    by transformExpression. This is only applied in non-browser builds with
//    { prefixIdentifiers: true }.
// 2. Track v-slot depths so that we know a slot is inside another slot.
//    Note the exit callback is executed before buildSlots() on the same node,
//    so only nested slots see positive numbers.
const trackSlotScopes = (node, context) => {
    if (node.type === 1 /* ELEMENT */ &&
        (node.tagType === 1 /* COMPONENT */ ||
            node.tagType === 3 /* TEMPLATE */)) {
        // We are only checking non-empty v-slot here
        // since we only care about slots that introduce scope variables.
        const vSlot = findDir(node, 'slot');
        if (vSlot) {
            vSlot.exp;
            context.scopes.vSlot++;
            return () => {
                context.scopes.vSlot--;
            };
        }
    }
};
// A NodeTransform that tracks scope identifiers for scoped slots with v-for.
// This transform is only applied in non-browser builds with { prefixIdentifiers: true }
const trackVForSlotScopes = (node, context) => {
    let vFor;
    if (isTemplateNode(node) &&
        node.props.some(isVSlot) &&
        (vFor = findDir(node, 'for'))) {
        const result = (vFor.parseResult = parseForExpression(vFor.exp, context));
        if (result) {
            const { value, key, index } = result;
            const { addIdentifiers, removeIdentifiers } = context;
            value && addIdentifiers(value);
            key && addIdentifiers(key);
            index && addIdentifiers(index);
            return () => {
                value && removeIdentifiers(value);
                key && removeIdentifiers(key);
                index && removeIdentifiers(index);
            };
        }
    }
};
const buildClientSlotFn = (props, children, loc) => createFunctionExpression(props, children, false /* newline */, true /* isSlot */, children.length ? children[0].loc : loc);
// Instead of being a DirectiveTransform, v-slot processing is called during
// transformElement to build the slots object for a component.
function buildSlots(node, context, buildSlotFn = buildClientSlotFn) {
    context.helper(WITH_CTX);
    const { children, loc } = node;
    const slotsProperties = [];
    const dynamicSlots = [];
    // If the slot is inside a v-for or another v-slot, force it to be dynamic
    // since it likely uses a scope variable.
    let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;
    // 1. Check for slot with slotProps on component itself.
    //    <Comp v-slot="{ prop }"/>
    const onComponentSlot = findDir(node, 'slot', true);
    if (onComponentSlot) {
        const { arg, exp } = onComponentSlot;
        if (arg && !isStaticExp(arg)) {
            hasDynamicSlots = true;
        }
        slotsProperties.push(createObjectProperty(arg || createSimpleExpression('default', true), buildSlotFn(exp, children, loc)));
    }
    // 2. Iterate through children and check for template slots
    //    <template v-slot:foo="{ prop }">
    let hasTemplateSlots = false;
    let hasNamedDefaultSlot = false;
    const implicitDefaultChildren = [];
    const seenSlotNames = new Set();
    for (let i = 0; i < children.length; i++) {
        const slotElement = children[i];
        let slotDir;
        if (!isTemplateNode(slotElement) ||
            !(slotDir = findDir(slotElement, 'slot', true))) {
            // not a <template v-slot>, skip.
            if (slotElement.type !== 3 /* COMMENT */) {
                implicitDefaultChildren.push(slotElement);
            }
            continue;
        }
        if (onComponentSlot) {
            // already has on-component slot - this is incorrect usage.
            context.onError(createCompilerError(37 /* X_V_SLOT_MIXED_SLOT_USAGE */, slotDir.loc));
            break;
        }
        hasTemplateSlots = true;
        const { children: slotChildren, loc: slotLoc } = slotElement;
        const { arg: slotName = createSimpleExpression(`default`, true), exp: slotProps, loc: dirLoc } = slotDir;
        // check if name is dynamic.
        let staticSlotName;
        if (isStaticExp(slotName)) {
            staticSlotName = slotName ? slotName.content : `default`;
        }
        else {
            hasDynamicSlots = true;
        }
        const slotFunction = buildSlotFn(slotProps, slotChildren, slotLoc);
        // check if this slot is conditional (v-if/v-for)
        let vIf;
        let vElse;
        let vFor;
        if ((vIf = findDir(slotElement, 'if'))) {
            hasDynamicSlots = true;
            dynamicSlots.push(createConditionalExpression(vIf.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback));
        }
        else if ((vElse = findDir(slotElement, /^else(-if)?$/, true /* allowEmpty */))) {
            // find adjacent v-if
            let j = i;
            let prev;
            while (j--) {
                prev = children[j];
                if (prev.type !== 3 /* COMMENT */) {
                    break;
                }
            }
            if (prev && isTemplateNode(prev) && findDir(prev, 'if')) {
                // remove node
                children.splice(i, 1);
                i--;
                // attach this slot to previous conditional
                let conditional = dynamicSlots[dynamicSlots.length - 1];
                while (conditional.alternate.type === 19 /* JS_CONDITIONAL_EXPRESSION */) {
                    conditional = conditional.alternate;
                }
                conditional.alternate = vElse.exp
                    ? createConditionalExpression(vElse.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback)
                    : buildDynamicSlot(slotName, slotFunction);
            }
            else {
                context.onError(createCompilerError(30 /* X_V_ELSE_NO_ADJACENT_IF */, vElse.loc));
            }
        }
        else if ((vFor = findDir(slotElement, 'for'))) {
            hasDynamicSlots = true;
            const parseResult = vFor.parseResult ||
                parseForExpression(vFor.exp, context);
            if (parseResult) {
                // Render the dynamic slots as an array and add it to the createSlot()
                // args. The runtime knows how to handle it appropriately.
                dynamicSlots.push(createCallExpression(context.helper(RENDER_LIST), [
                    parseResult.source,
                    createFunctionExpression(createForLoopParams(parseResult), buildDynamicSlot(slotName, slotFunction), true /* force newline */)
                ]));
            }
            else {
                context.onError(createCompilerError(32 /* X_V_FOR_MALFORMED_EXPRESSION */, vFor.loc));
            }
        }
        else {
            // check duplicate static names
            if (staticSlotName) {
                if (seenSlotNames.has(staticSlotName)) {
                    context.onError(createCompilerError(38 /* X_V_SLOT_DUPLICATE_SLOT_NAMES */, dirLoc));
                    continue;
                }
                seenSlotNames.add(staticSlotName);
                if (staticSlotName === 'default') {
                    hasNamedDefaultSlot = true;
                }
            }
            slotsProperties.push(createObjectProperty(slotName, slotFunction));
        }
    }
    if (!onComponentSlot) {
        const buildDefaultSlotProperty = (props, children) => {
            const fn = buildSlotFn(props, children, loc);
            if (context.compatConfig) {
                fn.isNonScopedSlot = true;
            }
            return createObjectProperty(`default`, fn);
        };
        if (!hasTemplateSlots) {
            // implicit default slot (on component)
            slotsProperties.push(buildDefaultSlotProperty(undefined, children));
        }
        else if (implicitDefaultChildren.length &&
            // #3766
            // with whitespace: 'preserve', whitespaces between slots will end up in
            // implicitDefaultChildren. Ignore if all implicit children are whitespaces.
            implicitDefaultChildren.some(node => isNonWhitespaceContent(node))) {
            // implicit default slot (mixed with named slots)
            if (hasNamedDefaultSlot) {
                context.onError(createCompilerError(39 /* X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */, implicitDefaultChildren[0].loc));
            }
            else {
                slotsProperties.push(buildDefaultSlotProperty(undefined, implicitDefaultChildren));
            }
        }
    }
    const slotFlag = hasDynamicSlots
        ? 2 /* DYNAMIC */
        : hasForwardedSlots(node.children)
            ? 3 /* FORWARDED */
            : 1 /* STABLE */;
    let slots = createObjectExpression(slotsProperties.concat(createObjectProperty(`_`, 
    // 2 = compiled but dynamic = can skip normalization, but must run diff
    // 1 = compiled and static = can skip normalization AND diff as optimized
    createSimpleExpression(slotFlag + (( true) ? ` /* ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__.slotFlagsText[slotFlag]} */` : 0), false))), loc);
    if (dynamicSlots.length) {
        slots = createCallExpression(context.helper(CREATE_SLOTS), [
            slots,
            createArrayExpression(dynamicSlots)
        ]);
    }
    return {
        slots,
        hasDynamicSlots
    };
}
function buildDynamicSlot(name, fn) {
    return createObjectExpression([
        createObjectProperty(`name`, name),
        createObjectProperty(`fn`, fn)
    ]);
}
function hasForwardedSlots(children) {
    for (let i = 0; i < children.length; i++) {
        const child = children[i];
        switch (child.type) {
            case 1 /* ELEMENT */:
                if (child.tagType === 2 /* SLOT */ ||
                    hasForwardedSlots(child.children)) {
                    return true;
                }
                break;
            case 9 /* IF */:
                if (hasForwardedSlots(child.branches))
                    return true;
                break;
            case 10 /* IF_BRANCH */:
            case 11 /* FOR */:
                if (hasForwardedSlots(child.children))
                    return true;
                break;
        }
    }
    return false;
}
function isNonWhitespaceContent(node) {
    if (node.type !== 2 /* TEXT */ && node.type !== 12 /* TEXT_CALL */)
        return true;
    return node.type === 2 /* TEXT */
        ? !!node.content.trim()
        : isNonWhitespaceContent(node.content);
}

// some directive transforms (e.g. v-model) may return a symbol for runtime
// import, which should be used instead of a resolveDirective call.
const directiveImportMap = new WeakMap();
// generate a JavaScript AST for this element's codegen
const transformElement = (node, context) => {
    // perform the work on exit, after all child expressions have been
    // processed and merged.
    return function postTransformElement() {
        node = context.currentNode;
        if (!(node.type === 1 /* ELEMENT */ &&
            (node.tagType === 0 /* ELEMENT */ ||
                node.tagType === 1 /* COMPONENT */))) {
            return;
        }
        const { tag, props } = node;
        const isComponent = node.tagType === 1 /* COMPONENT */;
        // The goal of the transform is to create a codegenNode implementing the
        // VNodeCall interface.
        let vnodeTag = isComponent
            ? resolveComponentType(node, context)
            : `"${tag}"`;
        const isDynamicComponent = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;
        let vnodeProps;
        let vnodeChildren;
        let vnodePatchFlag;
        let patchFlag = 0;
        let vnodeDynamicProps;
        let dynamicPropNames;
        let vnodeDirectives;
        let shouldUseBlock = 
        // dynamic component may resolve to plain elements
        isDynamicComponent ||
            vnodeTag === TELEPORT ||
            vnodeTag === SUSPENSE ||
            (!isComponent &&
                // <svg> and <foreignObject> must be forced into blocks so that block
                // updates inside get proper isSVG flag at runtime. (#639, #643)
                // This is technically web-specific, but splitting the logic out of core
                // leads to too much unnecessary complexity.
                (tag === 'svg' || tag === 'foreignObject'));
        // props
        if (props.length > 0) {
            const propsBuildResult = buildProps(node, context, undefined, isComponent, isDynamicComponent);
            vnodeProps = propsBuildResult.props;
            patchFlag = propsBuildResult.patchFlag;
            dynamicPropNames = propsBuildResult.dynamicPropNames;
            const directives = propsBuildResult.directives;
            vnodeDirectives =
                directives && directives.length
                    ? createArrayExpression(directives.map(dir => buildDirectiveArgs(dir, context)))
                    : undefined;
            if (propsBuildResult.shouldUseBlock) {
                shouldUseBlock = true;
            }
        }
        // children
        if (node.children.length > 0) {
            if (vnodeTag === KEEP_ALIVE) {
                // Although a built-in component, we compile KeepAlive with raw children
                // instead of slot functions so that it can be used inside Transition
                // or other Transition-wrapping HOCs.
                // To ensure correct updates with block optimizations, we need to:
                // 1. Force keep-alive into a block. This avoids its children being
                //    collected by a parent block.
                shouldUseBlock = true;
                // 2. Force keep-alive to always be updated, since it uses raw children.
                patchFlag |= 1024 /* DYNAMIC_SLOTS */;
                if (( true) && node.children.length > 1) {
                    context.onError(createCompilerError(45 /* X_KEEP_ALIVE_INVALID_CHILDREN */, {
                        start: node.children[0].loc.start,
                        end: node.children[node.children.length - 1].loc.end,
                        source: ''
                    }));
                }
            }
            const shouldBuildAsSlots = isComponent &&
                // Teleport is not a real component and has dedicated runtime handling
                vnodeTag !== TELEPORT &&
                // explained above.
                vnodeTag !== KEEP_ALIVE;
            if (shouldBuildAsSlots) {
                const { slots, hasDynamicSlots } = buildSlots(node, context);
                vnodeChildren = slots;
                if (hasDynamicSlots) {
                    patchFlag |= 1024 /* DYNAMIC_SLOTS */;
                }
            }
            else if (node.children.length === 1 && vnodeTag !== TELEPORT) {
                const child = node.children[0];
                const type = child.type;
                // check for dynamic text children
                const hasDynamicTextChild = type === 5 /* INTERPOLATION */ ||
                    type === 8 /* COMPOUND_EXPRESSION */;
                if (hasDynamicTextChild &&
                    getConstantType(child, context) === 0 /* NOT_CONSTANT */) {
                    patchFlag |= 1 /* TEXT */;
                }
                // pass directly if the only child is a text node
                // (plain / interpolation / expression)
                if (hasDynamicTextChild || type === 2 /* TEXT */) {
                    vnodeChildren = child;
                }
                else {
                    vnodeChildren = node.children;
                }
            }
            else {
                vnodeChildren = node.children;
            }
        }
        // patchFlag & dynamicPropNames
        if (patchFlag !== 0) {
            if ((true)) {
                if (patchFlag < 0) {
                    // special flags (negative and mutually exclusive)
                    vnodePatchFlag = patchFlag + ` /* ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[patchFlag]} */`;
                }
                else {
                    // bitwise flags
                    const flagNames = Object.keys(_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames)
                        .map(Number)
                        .filter(n => n > 0 && patchFlag & n)
                        .map(n => _vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[n])
                        .join(`, `);
                    vnodePatchFlag = patchFlag + ` /* ${flagNames} */`;
                }
            }
            else {}
            if (dynamicPropNames && dynamicPropNames.length) {
                vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);
            }
        }
        node.codegenNode = createVNodeCall(context, vnodeTag, vnodeProps, vnodeChildren, vnodePatchFlag, vnodeDynamicProps, vnodeDirectives, !!shouldUseBlock, false /* disableTracking */, isComponent, node.loc);
    };
};
function resolveComponentType(node, context, ssr = false) {
    let { tag } = node;
    // 1. dynamic component
    const isExplicitDynamic = isComponentTag(tag);
    const isProp = findProp(node, 'is');
    if (isProp) {
        if (isExplicitDynamic ||
            (isCompatEnabled("COMPILER_IS_ON_ELEMENT" /* COMPILER_IS_ON_ELEMENT */, context))) {
            const exp = isProp.type === 6 /* ATTRIBUTE */
                ? isProp.value && createSimpleExpression(isProp.value.content, true)
                : isProp.exp;
            if (exp) {
                return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
                    exp
                ]);
            }
        }
        else if (isProp.type === 6 /* ATTRIBUTE */ &&
            isProp.value.content.startsWith('vue:')) {
            // <button is="vue:xxx">
            // if not <component>, only is value that starts with "vue:" will be
            // treated as component by the parse phase and reach here, unless it's
            // compat mode where all is values are considered components
            tag = isProp.value.content.slice(4);
        }
    }
    // 1.5 v-is (TODO: Deprecate)
    const isDir = !isExplicitDynamic && findDir(node, 'is');
    if (isDir && isDir.exp) {
        return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
            isDir.exp
        ]);
    }
    // 2. built-in components (Teleport, Transition, KeepAlive, Suspense...)
    const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag);
    if (builtIn) {
        // built-ins are simply fallthroughs / have special handling during ssr
        // so we don't need to import their runtime equivalents
        if (!ssr)
            context.helper(builtIn);
        return builtIn;
    }
    // 5. user component (resolve)
    context.helper(RESOLVE_COMPONENT);
    context.components.add(tag);
    return toValidAssetId(tag, `component`);
}
function buildProps(node, context, props = node.props, isComponent, isDynamicComponent, ssr = false) {
    const { tag, loc: elementLoc, children } = node;
    let properties = [];
    const mergeArgs = [];
    const runtimeDirectives = [];
    const hasChildren = children.length > 0;
    let shouldUseBlock = false;
    // patchFlag analysis
    let patchFlag = 0;
    let hasRef = false;
    let hasClassBinding = false;
    let hasStyleBinding = false;
    let hasHydrationEventBinding = false;
    let hasDynamicKeys = false;
    let hasVnodeHook = false;
    const dynamicPropNames = [];
    const analyzePatchFlag = ({ key, value }) => {
        if (isStaticExp(key)) {
            const name = key.content;
            const isEventHandler = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isOn)(name);
            if (isEventHandler &&
                (!isComponent || isDynamicComponent) &&
                // omit the flag for click handlers because hydration gives click
                // dedicated fast path.
                name.toLowerCase() !== 'onclick' &&
                // omit v-model handlers
                name !== 'onUpdate:modelValue' &&
                // omit onVnodeXXX hooks
                !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isReservedProp)(name)) {
                hasHydrationEventBinding = true;
            }
            if (isEventHandler && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isReservedProp)(name)) {
                hasVnodeHook = true;
            }
            if (value.type === 20 /* JS_CACHE_EXPRESSION */ ||
                ((value.type === 4 /* SIMPLE_EXPRESSION */ ||
                    value.type === 8 /* COMPOUND_EXPRESSION */) &&
                    getConstantType(value, context) > 0)) {
                // skip if the prop is a cached handler or has constant value
                return;
            }
            if (name === 'ref') {
                hasRef = true;
            }
            else if (name === 'class') {
                hasClassBinding = true;
            }
            else if (name === 'style') {
                hasStyleBinding = true;
            }
            else if (name !== 'key' && !dynamicPropNames.includes(name)) {
                dynamicPropNames.push(name);
            }
            // treat the dynamic class and style binding of the component as dynamic props
            if (isComponent &&
                (name === 'class' || name === 'style') &&
                !dynamicPropNames.includes(name)) {
                dynamicPropNames.push(name);
            }
        }
        else {
            hasDynamicKeys = true;
        }
    };
    for (let i = 0; i < props.length; i++) {
        // static attribute
        const prop = props[i];
        if (prop.type === 6 /* ATTRIBUTE */) {
            const { loc, name, value } = prop;
            let isStatic = true;
            if (name === 'ref') {
                hasRef = true;
                if (context.scopes.vFor > 0) {
                    properties.push(createObjectProperty(createSimpleExpression('ref_for', true), createSimpleExpression('true')));
                }
            }
            // skip is on <component>, or is="vue:xxx"
            if (name === 'is' &&
                (isComponentTag(tag) ||
                    (value && value.content.startsWith('vue:')) ||
                    (isCompatEnabled("COMPILER_IS_ON_ELEMENT" /* COMPILER_IS_ON_ELEMENT */, context)))) {
                continue;
            }
            properties.push(createObjectProperty(createSimpleExpression(name, true, getInnerRange(loc, 0, name.length)), createSimpleExpression(value ? value.content : '', isStatic, value ? value.loc : loc)));
        }
        else {
            // directives
            const { name, arg, exp, loc } = prop;
            const isVBind = name === 'bind';
            const isVOn = name === 'on';
            // skip v-slot - it is handled by its dedicated transform.
            if (name === 'slot') {
                if (!isComponent) {
                    context.onError(createCompilerError(40 /* X_V_SLOT_MISPLACED */, loc));
                }
                continue;
            }
            // skip v-once/v-memo - they are handled by dedicated transforms.
            if (name === 'once' || name === 'memo') {
                continue;
            }
            // skip v-is and :is on <component>
            if (name === 'is' ||
                (isVBind &&
                    isStaticArgOf(arg, 'is') &&
                    (isComponentTag(tag) ||
                        (isCompatEnabled("COMPILER_IS_ON_ELEMENT" /* COMPILER_IS_ON_ELEMENT */, context))))) {
                continue;
            }
            // skip v-on in SSR compilation
            if (isVOn && ssr) {
                continue;
            }
            if (
            // #938: elements with dynamic keys should be forced into blocks
            (isVBind && isStaticArgOf(arg, 'key')) ||
                // inline before-update hooks need to force block so that it is invoked
                // before children
                (isVOn && hasChildren && isStaticArgOf(arg, 'vue:before-update'))) {
                shouldUseBlock = true;
            }
            if (isVBind && isStaticArgOf(arg, 'ref') && context.scopes.vFor > 0) {
                properties.push(createObjectProperty(createSimpleExpression('ref_for', true), createSimpleExpression('true')));
            }
            // special case for v-bind and v-on with no argument
            if (!arg && (isVBind || isVOn)) {
                hasDynamicKeys = true;
                if (exp) {
                    if (properties.length) {
                        mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
                        properties = [];
                    }
                    if (isVBind) {
                        {
                            // 2.x v-bind object order compat
                            if ((true)) {
                                const hasOverridableKeys = mergeArgs.some(arg => {
                                    if (arg.type === 15 /* JS_OBJECT_EXPRESSION */) {
                                        return arg.properties.some(({ key }) => {
                                            if (key.type !== 4 /* SIMPLE_EXPRESSION */ ||
                                                !key.isStatic) {
                                                return true;
                                            }
                                            return (key.content !== 'class' &&
                                                key.content !== 'style' &&
                                                !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isOn)(key.content));
                                        });
                                    }
                                    else {
                                        // dynamic expression
                                        return true;
                                    }
                                });
                                if (hasOverridableKeys) {
                                    checkCompatEnabled("COMPILER_V_BIND_OBJECT_ORDER" /* COMPILER_V_BIND_OBJECT_ORDER */, context, loc);
                                }
                            }
                            if (isCompatEnabled("COMPILER_V_BIND_OBJECT_ORDER" /* COMPILER_V_BIND_OBJECT_ORDER */, context)) {
                                mergeArgs.unshift(exp);
                                continue;
                            }
                        }
                        mergeArgs.push(exp);
                    }
                    else {
                        // v-on="obj" -> toHandlers(obj)
                        mergeArgs.push({
                            type: 14 /* JS_CALL_EXPRESSION */,
                            loc,
                            callee: context.helper(TO_HANDLERS),
                            arguments: [exp]
                        });
                    }
                }
                else {
                    context.onError(createCompilerError(isVBind
                        ? 34 /* X_V_BIND_NO_EXPRESSION */
                        : 35 /* X_V_ON_NO_EXPRESSION */, loc));
                }
                continue;
            }
            const directiveTransform = context.directiveTransforms[name];
            if (directiveTransform) {
                // has built-in directive transform.
                const { props, needRuntime } = directiveTransform(prop, node, context);
                !ssr && props.forEach(analyzePatchFlag);
                properties.push(...props);
                if (needRuntime) {
                    runtimeDirectives.push(prop);
                    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(needRuntime)) {
                        directiveImportMap.set(prop, needRuntime);
                    }
                }
            }
            else if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isBuiltInDirective)(name)) {
                // no built-in transform, this is a user custom directive.
                runtimeDirectives.push(prop);
                // custom dirs may use beforeUpdate so they need to force blocks
                // to ensure before-update gets called before children update
                if (hasChildren) {
                    shouldUseBlock = true;
                }
            }
        }
    }
    let propsExpression = undefined;
    // has v-bind="object" or v-on="object", wrap with mergeProps
    if (mergeArgs.length) {
        if (properties.length) {
            mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
        }
        if (mergeArgs.length > 1) {
            propsExpression = createCallExpression(context.helper(MERGE_PROPS), mergeArgs, elementLoc);
        }
        else {
            // single v-bind with nothing else - no need for a mergeProps call
            propsExpression = mergeArgs[0];
        }
    }
    else if (properties.length) {
        propsExpression = createObjectExpression(dedupeProperties(properties), elementLoc);
    }
    // patchFlag analysis
    if (hasDynamicKeys) {
        patchFlag |= 16 /* FULL_PROPS */;
    }
    else {
        if (hasClassBinding && !isComponent) {
            patchFlag |= 2 /* CLASS */;
        }
        if (hasStyleBinding && !isComponent) {
            patchFlag |= 4 /* STYLE */;
        }
        if (dynamicPropNames.length) {
            patchFlag |= 8 /* PROPS */;
        }
        if (hasHydrationEventBinding) {
            patchFlag |= 32 /* HYDRATE_EVENTS */;
        }
    }
    if (!shouldUseBlock &&
        (patchFlag === 0 || patchFlag === 32 /* HYDRATE_EVENTS */) &&
        (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {
        patchFlag |= 512 /* NEED_PATCH */;
    }
    // pre-normalize props, SSR is skipped for now
    if (!context.inSSR && propsExpression) {
        switch (propsExpression.type) {
            case 15 /* JS_OBJECT_EXPRESSION */:
                // means that there is no v-bind,
                // but still need to deal with dynamic key binding
                let classKeyIndex = -1;
                let styleKeyIndex = -1;
                let hasDynamicKey = false;
                for (let i = 0; i < propsExpression.properties.length; i++) {
                    const key = propsExpression.properties[i].key;
                    if (isStaticExp(key)) {
                        if (key.content === 'class') {
                            classKeyIndex = i;
                        }
                        else if (key.content === 'style') {
                            styleKeyIndex = i;
                        }
                    }
                    else if (!key.isHandlerKey) {
                        hasDynamicKey = true;
                    }
                }
                const classProp = propsExpression.properties[classKeyIndex];
                const styleProp = propsExpression.properties[styleKeyIndex];
                // no dynamic key
                if (!hasDynamicKey) {
                    if (classProp && !isStaticExp(classProp.value)) {
                        classProp.value = createCallExpression(context.helper(NORMALIZE_CLASS), [classProp.value]);
                    }
                    if (styleProp &&
                        // the static style is compiled into an object,
                        // so use `hasStyleBinding` to ensure that it is a dynamic style binding
                        (hasStyleBinding ||
                            (styleProp.value.type === 4 /* SIMPLE_EXPRESSION */ &&
                                styleProp.value.content.trim()[0] === `[`) ||
                            // v-bind:style and style both exist,
                            // v-bind:style with static literal object
                            styleProp.value.type === 17 /* JS_ARRAY_EXPRESSION */)) {
                        styleProp.value = createCallExpression(context.helper(NORMALIZE_STYLE), [styleProp.value]);
                    }
                }
                else {
                    // dynamic key binding, wrap with `normalizeProps`
                    propsExpression = createCallExpression(context.helper(NORMALIZE_PROPS), [propsExpression]);
                }
                break;
            case 14 /* JS_CALL_EXPRESSION */:
                // mergeProps call, do nothing
                break;
            default:
                // single v-bind
                propsExpression = createCallExpression(context.helper(NORMALIZE_PROPS), [
                    createCallExpression(context.helper(GUARD_REACTIVE_PROPS), [
                        propsExpression
                    ])
                ]);
                break;
        }
    }
    return {
        props: propsExpression,
        directives: runtimeDirectives,
        patchFlag,
        dynamicPropNames,
        shouldUseBlock
    };
}
// Dedupe props in an object literal.
// Literal duplicated attributes would have been warned during the parse phase,
// however, it's possible to encounter duplicated `onXXX` handlers with different
// modifiers. We also need to merge static and dynamic class / style attributes.
// - onXXX handlers / style: merge into array
// - class: merge into single expression with concatenation
function dedupeProperties(properties) {
    const knownProps = new Map();
    const deduped = [];
    for (let i = 0; i < properties.length; i++) {
        const prop = properties[i];
        // dynamic keys are always allowed
        if (prop.key.type === 8 /* COMPOUND_EXPRESSION */ || !prop.key.isStatic) {
            deduped.push(prop);
            continue;
        }
        const name = prop.key.content;
        const existing = knownProps.get(name);
        if (existing) {
            if (name === 'style' || name === 'class' || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isOn)(name)) {
                mergeAsArray(existing, prop);
            }
            // unexpected duplicate, should have emitted error during parse
        }
        else {
            knownProps.set(name, prop);
            deduped.push(prop);
        }
    }
    return deduped;
}
function mergeAsArray(existing, incoming) {
    if (existing.value.type === 17 /* JS_ARRAY_EXPRESSION */) {
        existing.value.elements.push(incoming.value);
    }
    else {
        existing.value = createArrayExpression([existing.value, incoming.value], existing.loc);
    }
}
function buildDirectiveArgs(dir, context) {
    const dirArgs = [];
    const runtime = directiveImportMap.get(dir);
    if (runtime) {
        // built-in directive with runtime
        dirArgs.push(context.helperString(runtime));
    }
    else {
        {
            // inject statement for resolving directive
            context.helper(RESOLVE_DIRECTIVE);
            context.directives.add(dir.name);
            dirArgs.push(toValidAssetId(dir.name, `directive`));
        }
    }
    const { loc } = dir;
    if (dir.exp)
        dirArgs.push(dir.exp);
    if (dir.arg) {
        if (!dir.exp) {
            dirArgs.push(`void 0`);
        }
        dirArgs.push(dir.arg);
    }
    if (Object.keys(dir.modifiers).length) {
        if (!dir.arg) {
            if (!dir.exp) {
                dirArgs.push(`void 0`);
            }
            dirArgs.push(`void 0`);
        }
        const trueExpression = createSimpleExpression(`true`, false, loc);
        dirArgs.push(createObjectExpression(dir.modifiers.map(modifier => createObjectProperty(modifier, trueExpression)), loc));
    }
    return createArrayExpression(dirArgs, dir.loc);
}
function stringifyDynamicPropNames(props) {
    let propsNamesString = `[`;
    for (let i = 0, l = props.length; i < l; i++) {
        propsNamesString += JSON.stringify(props[i]);
        if (i < l - 1)
            propsNamesString += ', ';
    }
    return propsNamesString + `]`;
}
function isComponentTag(tag) {
    return tag === 'component' || tag === 'Component';
}

( true)
    ? Object.freeze({})
    : 0;
( true) ? Object.freeze([]) : 0;
const cacheStringFunction = (fn) => {
    const cache = Object.create(null);
    return ((str) => {
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
    });
};
const camelizeRE = /-(\w)/g;
/**
 * @private
 */
const camelize = cacheStringFunction((str) => {
    return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));
});

const transformSlotOutlet = (node, context) => {
    if (isSlotOutlet(node)) {
        const { children, loc } = node;
        const { slotName, slotProps } = processSlotOutlet(node, context);
        const slotArgs = [
            context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,
            slotName,
            '{}',
            'undefined',
            'true'
        ];
        let expectedLen = 2;
        if (slotProps) {
            slotArgs[2] = slotProps;
            expectedLen = 3;
        }
        if (children.length) {
            slotArgs[3] = createFunctionExpression([], children, false, false, loc);
            expectedLen = 4;
        }
        if (context.scopeId && !context.slotted) {
            expectedLen = 5;
        }
        slotArgs.splice(expectedLen); // remove unused arguments
        node.codegenNode = createCallExpression(context.helper(RENDER_SLOT), slotArgs, loc);
    }
};
function processSlotOutlet(node, context) {
    let slotName = `"default"`;
    let slotProps = undefined;
    const nonNameProps = [];
    for (let i = 0; i < node.props.length; i++) {
        const p = node.props[i];
        if (p.type === 6 /* ATTRIBUTE */) {
            if (p.value) {
                if (p.name === 'name') {
                    slotName = JSON.stringify(p.value.content);
                }
                else {
                    p.name = camelize(p.name);
                    nonNameProps.push(p);
                }
            }
        }
        else {
            if (p.name === 'bind' && isStaticArgOf(p.arg, 'name')) {
                if (p.exp)
                    slotName = p.exp;
            }
            else {
                if (p.name === 'bind' && p.arg && isStaticExp(p.arg)) {
                    p.arg.content = camelize(p.arg.content);
                }
                nonNameProps.push(p);
            }
        }
    }
    if (nonNameProps.length > 0) {
        const { props, directives } = buildProps(node, context, nonNameProps, false, false);
        slotProps = props;
        if (directives.length) {
            context.onError(createCompilerError(36 /* X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */, directives[0].loc));
        }
    }
    return {
        slotName,
        slotProps
    };
}

const fnExpRE = /^\s*([\w$_]+|(async\s*)?\([^)]*?\))\s*=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/;
const transformOn = (dir, node, context, augmentor) => {
    const { loc, modifiers, arg } = dir;
    if (!dir.exp && !modifiers.length) {
        context.onError(createCompilerError(35 /* X_V_ON_NO_EXPRESSION */, loc));
    }
    let eventName;
    if (arg.type === 4 /* SIMPLE_EXPRESSION */) {
        if (arg.isStatic) {
            let rawName = arg.content;
            // TODO deprecate @vnodeXXX usage
            if (rawName.startsWith('vue:')) {
                rawName = `vnode-${rawName.slice(4)}`;
            }
            // for all event listeners, auto convert it to camelCase. See issue #2249
            eventName = createSimpleExpression((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.toHandlerKey)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.camelize)(rawName)), true, arg.loc);
        }
        else {
            // #2388
            eventName = createCompoundExpression([
                `${context.helperString(TO_HANDLER_KEY)}(`,
                arg,
                `)`
            ]);
        }
    }
    else {
        // already a compound expression.
        eventName = arg;
        eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`);
        eventName.children.push(`)`);
    }
    // handler processing
    let exp = dir.exp;
    if (exp && !exp.content.trim()) {
        exp = undefined;
    }
    let shouldCache = context.cacheHandlers && !exp && !context.inVOnce;
    if (exp) {
        const isMemberExp = isMemberExpression(exp.content);
        const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content));
        const hasMultipleStatements = exp.content.includes(`;`);
        if (true) {
            validateBrowserExpression(exp, context, false, hasMultipleStatements);
        }
        if (isInlineStatement || (shouldCache && isMemberExp)) {
            // wrap inline statement in a function expression
            exp = createCompoundExpression([
                `${isInlineStatement
                    ? `$event`
                    : `${``}(...args)`} => ${hasMultipleStatements ? `{` : `(`}`,
                exp,
                hasMultipleStatements ? `}` : `)`
            ]);
        }
    }
    let ret = {
        props: [
            createObjectProperty(eventName, exp || createSimpleExpression(`() => {}`, false, loc))
        ]
    };
    // apply extended compiler augmentor
    if (augmentor) {
        ret = augmentor(ret);
    }
    if (shouldCache) {
        // cache handlers so that it's always the same handler being passed down.
        // this avoids unnecessary re-renders when users use inline handlers on
        // components.
        ret.props[0].value = context.cache(ret.props[0].value);
    }
    // mark the key as handler for props normalization check
    ret.props.forEach(p => (p.key.isHandlerKey = true));
    return ret;
};

// v-bind without arg is handled directly in ./transformElements.ts due to it affecting
// codegen for the entire props object. This transform here is only for v-bind
// *with* args.
const transformBind = (dir, _node, context) => {
    const { exp, modifiers, loc } = dir;
    const arg = dir.arg;
    if (arg.type !== 4 /* SIMPLE_EXPRESSION */) {
        arg.children.unshift(`(`);
        arg.children.push(`) || ""`);
    }
    else if (!arg.isStatic) {
        arg.content = `${arg.content} || ""`;
    }
    // .sync is replaced by v-model:arg
    if (modifiers.includes('camel')) {
        if (arg.type === 4 /* SIMPLE_EXPRESSION */) {
            if (arg.isStatic) {
                arg.content = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.camelize)(arg.content);
            }
            else {
                arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`;
            }
        }
        else {
            arg.children.unshift(`${context.helperString(CAMELIZE)}(`);
            arg.children.push(`)`);
        }
    }
    if (!context.inSSR) {
        if (modifiers.includes('prop')) {
            injectPrefix(arg, '.');
        }
        if (modifiers.includes('attr')) {
            injectPrefix(arg, '^');
        }
    }
    if (!exp ||
        (exp.type === 4 /* SIMPLE_EXPRESSION */ && !exp.content.trim())) {
        context.onError(createCompilerError(34 /* X_V_BIND_NO_EXPRESSION */, loc));
        return {
            props: [createObjectProperty(arg, createSimpleExpression('', true, loc))]
        };
    }
    return {
        props: [createObjectProperty(arg, exp)]
    };
};
const injectPrefix = (arg, prefix) => {
    if (arg.type === 4 /* SIMPLE_EXPRESSION */) {
        if (arg.isStatic) {
            arg.content = prefix + arg.content;
        }
        else {
            arg.content = `\`${prefix}\${${arg.content}}\``;
        }
    }
    else {
        arg.children.unshift(`'${prefix}' + (`);
        arg.children.push(`)`);
    }
};

// Merge adjacent text nodes and expressions into a single expression
// e.g. <div>abc {{ d }} {{ e }}</div> should have a single expression node as child.
const transformText = (node, context) => {
    if (node.type === 0 /* ROOT */ ||
        node.type === 1 /* ELEMENT */ ||
        node.type === 11 /* FOR */ ||
        node.type === 10 /* IF_BRANCH */) {
        // perform the transform on node exit so that all expressions have already
        // been processed.
        return () => {
            const children = node.children;
            let currentContainer = undefined;
            let hasText = false;
            for (let i = 0; i < children.length; i++) {
                const child = children[i];
                if (isText(child)) {
                    hasText = true;
                    for (let j = i + 1; j < children.length; j++) {
                        const next = children[j];
                        if (isText(next)) {
                            if (!currentContainer) {
                                currentContainer = children[i] = createCompoundExpression([child], child.loc);
                            }
                            // merge adjacent text node into current
                            currentContainer.children.push(` + `, next);
                            children.splice(j, 1);
                            j--;
                        }
                        else {
                            currentContainer = undefined;
                            break;
                        }
                    }
                }
            }
            if (!hasText ||
                // if this is a plain element with a single text child, leave it
                // as-is since the runtime has dedicated fast path for this by directly
                // setting textContent of the element.
                // for component root it's always normalized anyway.
                (children.length === 1 &&
                    (node.type === 0 /* ROOT */ ||
                        (node.type === 1 /* ELEMENT */ &&
                            node.tagType === 0 /* ELEMENT */ &&
                            // #3756
                            // custom directives can potentially add DOM elements arbitrarily,
                            // we need to avoid setting textContent of the element at runtime
                            // to avoid accidentally overwriting the DOM elements added
                            // by the user through custom directives.
                            !node.props.find(p => p.type === 7 /* DIRECTIVE */ &&
                                !context.directiveTransforms[p.name]) &&
                            // in compat mode, <template> tags with no special directives
                            // will be rendered as a fragment so its children must be
                            // converted into vnodes.
                            !(node.tag === 'template'))))) {
                return;
            }
            // pre-convert text nodes into createTextVNode(text) calls to avoid
            // runtime normalization.
            for (let i = 0; i < children.length; i++) {
                const child = children[i];
                if (isText(child) || child.type === 8 /* COMPOUND_EXPRESSION */) {
                    const callArgs = [];
                    // createTextVNode defaults to single whitespace, so if it is a
                    // single space the code could be an empty call to save bytes.
                    if (child.type !== 2 /* TEXT */ || child.content !== ' ') {
                        callArgs.push(child);
                    }
                    // mark dynamic text with flag so it gets patched inside a block
                    if (!context.ssr &&
                        getConstantType(child, context) === 0 /* NOT_CONSTANT */) {
                        callArgs.push(1 /* TEXT */ +
                            (( true) ? ` /* ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[1]} */` : 0));
                    }
                    children[i] = {
                        type: 12 /* TEXT_CALL */,
                        content: child,
                        loc: child.loc,
                        codegenNode: createCallExpression(context.helper(CREATE_TEXT), callArgs)
                    };
                }
            }
        };
    }
};

const seen = new WeakSet();
const transformOnce = (node, context) => {
    if (node.type === 1 /* ELEMENT */ && findDir(node, 'once', true)) {
        if (seen.has(node) || context.inVOnce) {
            return;
        }
        seen.add(node);
        context.inVOnce = true;
        context.helper(SET_BLOCK_TRACKING);
        return () => {
            context.inVOnce = false;
            const cur = context.currentNode;
            if (cur.codegenNode) {
                cur.codegenNode = context.cache(cur.codegenNode, true /* isVNode */);
            }
        };
    }
};

const transformModel = (dir, node, context) => {
    const { exp, arg } = dir;
    if (!exp) {
        context.onError(createCompilerError(41 /* X_V_MODEL_NO_EXPRESSION */, dir.loc));
        return createTransformProps();
    }
    const rawExp = exp.loc.source;
    const expString = exp.type === 4 /* SIMPLE_EXPRESSION */ ? exp.content : rawExp;
    // im SFC <script setup> inline mode, the exp may have been transformed into
    // _unref(exp)
    context.bindingMetadata[rawExp];
    const maybeRef = !true    /* SETUP_CONST */;
    if (!expString.trim() ||
        (!isMemberExpression(expString) && !maybeRef)) {
        context.onError(createCompilerError(42 /* X_V_MODEL_MALFORMED_EXPRESSION */, exp.loc));
        return createTransformProps();
    }
    const propName = arg ? arg : createSimpleExpression('modelValue', true);
    const eventName = arg
        ? isStaticExp(arg)
            ? `onUpdate:${arg.content}`
            : createCompoundExpression(['"onUpdate:" + ', arg])
        : `onUpdate:modelValue`;
    let assignmentExp;
    const eventArg = context.isTS ? `($event: any)` : `$event`;
    {
        assignmentExp = createCompoundExpression([
            `${eventArg} => ((`,
            exp,
            `) = $event)`
        ]);
    }
    const props = [
        // modelValue: foo
        createObjectProperty(propName, dir.exp),
        // "onUpdate:modelValue": $event => (foo = $event)
        createObjectProperty(eventName, assignmentExp)
    ];
    // modelModifiers: { foo: true, "bar-baz": true }
    if (dir.modifiers.length && node.tagType === 1 /* COMPONENT */) {
        const modifiers = dir.modifiers
            .map(m => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`)
            .join(`, `);
        const modifiersKey = arg
            ? isStaticExp(arg)
                ? `${arg.content}Modifiers`
                : createCompoundExpression([arg, ' + "Modifiers"'])
            : `modelModifiers`;
        props.push(createObjectProperty(modifiersKey, createSimpleExpression(`{ ${modifiers} }`, false, dir.loc, 2 /* CAN_HOIST */)));
    }
    return createTransformProps(props);
};
function createTransformProps(props = []) {
    return { props };
}

const validDivisionCharRE = /[\w).+\-_$\]]/;
const transformFilter = (node, context) => {
    if (!isCompatEnabled("COMPILER_FILTER" /* COMPILER_FILTERS */, context)) {
        return;
    }
    if (node.type === 5 /* INTERPOLATION */) {
        // filter rewrite is applied before expression transform so only
        // simple expressions are possible at this stage
        rewriteFilter(node.content, context);
    }
    if (node.type === 1 /* ELEMENT */) {
        node.props.forEach((prop) => {
            if (prop.type === 7 /* DIRECTIVE */ &&
                prop.name !== 'for' &&
                prop.exp) {
                rewriteFilter(prop.exp, context);
            }
        });
    }
};
function rewriteFilter(node, context) {
    if (node.type === 4 /* SIMPLE_EXPRESSION */) {
        parseFilter(node, context);
    }
    else {
        for (let i = 0; i < node.children.length; i++) {
            const child = node.children[i];
            if (typeof child !== 'object')
                continue;
            if (child.type === 4 /* SIMPLE_EXPRESSION */) {
                parseFilter(child, context);
            }
            else if (child.type === 8 /* COMPOUND_EXPRESSION */) {
                rewriteFilter(node, context);
            }
            else if (child.type === 5 /* INTERPOLATION */) {
                rewriteFilter(child.content, context);
            }
        }
    }
}
function parseFilter(node, context) {
    const exp = node.content;
    let inSingle = false;
    let inDouble = false;
    let inTemplateString = false;
    let inRegex = false;
    let curly = 0;
    let square = 0;
    let paren = 0;
    let lastFilterIndex = 0;
    let c, prev, i, expression, filters = [];
    for (i = 0; i < exp.length; i++) {
        prev = c;
        c = exp.charCodeAt(i);
        if (inSingle) {
            if (c === 0x27 && prev !== 0x5c)
                inSingle = false;
        }
        else if (inDouble) {
            if (c === 0x22 && prev !== 0x5c)
                inDouble = false;
        }
        else if (inTemplateString) {
            if (c === 0x60 && prev !== 0x5c)
                inTemplateString = false;
        }
        else if (inRegex) {
            if (c === 0x2f && prev !== 0x5c)
                inRegex = false;
        }
        else if (c === 0x7c && // pipe
            exp.charCodeAt(i + 1) !== 0x7c &&
            exp.charCodeAt(i - 1) !== 0x7c &&
            !curly &&
            !square &&
            !paren) {
            if (expression === undefined) {
                // first filter, end of expression
                lastFilterIndex = i + 1;
                expression = exp.slice(0, i).trim();
            }
            else {
                pushFilter();
            }
        }
        else {
            switch (c) {
                case 0x22:
                    inDouble = true;
                    break; // "
                case 0x27:
                    inSingle = true;
                    break; // '
                case 0x60:
                    inTemplateString = true;
                    break; // `
                case 0x28:
                    paren++;
                    break; // (
                case 0x29:
                    paren--;
                    break; // )
                case 0x5b:
                    square++;
                    break; // [
                case 0x5d:
                    square--;
                    break; // ]
                case 0x7b:
                    curly++;
                    break; // {
                case 0x7d:
                    curly--;
                    break; // }
            }
            if (c === 0x2f) {
                // /
                let j = i - 1;
                let p;
                // find first non-whitespace prev char
                for (; j >= 0; j--) {
                    p = exp.charAt(j);
                    if (p !== ' ')
                        break;
                }
                if (!p || !validDivisionCharRE.test(p)) {
                    inRegex = true;
                }
            }
        }
    }
    if (expression === undefined) {
        expression = exp.slice(0, i).trim();
    }
    else if (lastFilterIndex !== 0) {
        pushFilter();
    }
    function pushFilter() {
        filters.push(exp.slice(lastFilterIndex, i).trim());
        lastFilterIndex = i + 1;
    }
    if (filters.length) {
        ( true) &&
            warnDeprecation("COMPILER_FILTER" /* COMPILER_FILTERS */, context, node.loc);
        for (i = 0; i < filters.length; i++) {
            expression = wrapFilter(expression, filters[i], context);
        }
        node.content = expression;
    }
}
function wrapFilter(exp, filter, context) {
    context.helper(RESOLVE_FILTER);
    const i = filter.indexOf('(');
    if (i < 0) {
        context.filters.add(filter);
        return `${toValidAssetId(filter, 'filter')}(${exp})`;
    }
    else {
        const name = filter.slice(0, i);
        const args = filter.slice(i + 1);
        context.filters.add(name);
        return `${toValidAssetId(name, 'filter')}(${exp}${args !== ')' ? ',' + args : args}`;
    }
}

const seen$1 = new WeakSet();
const transformMemo = (node, context) => {
    if (node.type === 1 /* ELEMENT */) {
        const dir = findDir(node, 'memo');
        if (!dir || seen$1.has(node)) {
            return;
        }
        seen$1.add(node);
        return () => {
            const codegenNode = node.codegenNode ||
                context.currentNode.codegenNode;
            if (codegenNode && codegenNode.type === 13 /* VNODE_CALL */) {
                // non-component sub tree should be turned into a block
                if (node.tagType !== 1 /* COMPONENT */) {
                    makeBlock(codegenNode, context);
                }
                node.codegenNode = createCallExpression(context.helper(WITH_MEMO), [
                    dir.exp,
                    createFunctionExpression(undefined, codegenNode),
                    `_cache`,
                    String(context.cached++)
                ]);
            }
        };
    }
};

function getBaseTransformPreset(prefixIdentifiers) {
    return [
        [
            transformOnce,
            transformIf,
            transformMemo,
            transformFor,
            ...([transformFilter] ),
            ...(( true)
                    ? [transformExpression]
                    : 0),
            transformSlotOutlet,
            transformElement,
            trackSlotScopes,
            transformText
        ],
        {
            on: transformOn,
            bind: transformBind,
            model: transformModel
        }
    ];
}
// we name it `baseCompile` so that higher order compilers like
// @vue/compiler-dom can export `compile` while re-exporting everything else.
function baseCompile(template, options = {}) {
    const onError = options.onError || defaultOnError;
    const isModuleMode = options.mode === 'module';
    /* istanbul ignore if */
    {
        if (options.prefixIdentifiers === true) {
            onError(createCompilerError(46 /* X_PREFIX_ID_NOT_SUPPORTED */));
        }
        else if (isModuleMode) {
            onError(createCompilerError(47 /* X_MODULE_MODE_NOT_SUPPORTED */));
        }
    }
    const prefixIdentifiers = !true ;
    if (options.cacheHandlers) {
        onError(createCompilerError(48 /* X_CACHE_HANDLER_NOT_SUPPORTED */));
    }
    if (options.scopeId && !isModuleMode) {
        onError(createCompilerError(49 /* X_SCOPE_ID_NOT_SUPPORTED */));
    }
    const ast = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(template) ? baseParse(template, options) : template;
    const [nodeTransforms, directiveTransforms] = getBaseTransformPreset();
    transform(ast, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, options, {
        prefixIdentifiers,
        nodeTransforms: [
            ...nodeTransforms,
            ...(options.nodeTransforms || []) // user transforms
        ],
        directiveTransforms: (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, directiveTransforms, options.directiveTransforms || {} // user transforms
        )
    }));
    return generate(ast, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, options, {
        prefixIdentifiers
    }));
}

const noopDirectiveTransform = () => ({ props: [] });




/***/ }),

/***/ "./node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BASE_TRANSITION": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.BASE_TRANSITION; },
/* harmony export */   "CAMELIZE": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CAMELIZE; },
/* harmony export */   "CAPITALIZE": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CAPITALIZE; },
/* harmony export */   "CREATE_BLOCK": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_BLOCK; },
/* harmony export */   "CREATE_COMMENT": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_COMMENT; },
/* harmony export */   "CREATE_ELEMENT_BLOCK": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_ELEMENT_BLOCK; },
/* harmony export */   "CREATE_ELEMENT_VNODE": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_ELEMENT_VNODE; },
/* harmony export */   "CREATE_SLOTS": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_SLOTS; },
/* harmony export */   "CREATE_STATIC": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_STATIC; },
/* harmony export */   "CREATE_TEXT": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_TEXT; },
/* harmony export */   "CREATE_VNODE": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_VNODE; },
/* harmony export */   "DOMDirectiveTransforms": function() { return /* binding */ DOMDirectiveTransforms; },
/* harmony export */   "DOMNodeTransforms": function() { return /* binding */ DOMNodeTransforms; },
/* harmony export */   "FRAGMENT": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.FRAGMENT; },
/* harmony export */   "GUARD_REACTIVE_PROPS": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.GUARD_REACTIVE_PROPS; },
/* harmony export */   "IS_MEMO_SAME": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.IS_MEMO_SAME; },
/* harmony export */   "IS_REF": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.IS_REF; },
/* harmony export */   "KEEP_ALIVE": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.KEEP_ALIVE; },
/* harmony export */   "MERGE_PROPS": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.MERGE_PROPS; },
/* harmony export */   "NORMALIZE_CLASS": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.NORMALIZE_CLASS; },
/* harmony export */   "NORMALIZE_PROPS": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.NORMALIZE_PROPS; },
/* harmony export */   "NORMALIZE_STYLE": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.NORMALIZE_STYLE; },
/* harmony export */   "OPEN_BLOCK": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.OPEN_BLOCK; },
/* harmony export */   "POP_SCOPE_ID": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.POP_SCOPE_ID; },
/* harmony export */   "PUSH_SCOPE_ID": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.PUSH_SCOPE_ID; },
/* harmony export */   "RENDER_LIST": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RENDER_LIST; },
/* harmony export */   "RENDER_SLOT": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RENDER_SLOT; },
/* harmony export */   "RESOLVE_COMPONENT": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RESOLVE_COMPONENT; },
/* harmony export */   "RESOLVE_DIRECTIVE": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RESOLVE_DIRECTIVE; },
/* harmony export */   "RESOLVE_DYNAMIC_COMPONENT": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RESOLVE_DYNAMIC_COMPONENT; },
/* harmony export */   "RESOLVE_FILTER": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RESOLVE_FILTER; },
/* harmony export */   "SET_BLOCK_TRACKING": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.SET_BLOCK_TRACKING; },
/* harmony export */   "SUSPENSE": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.SUSPENSE; },
/* harmony export */   "TELEPORT": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TELEPORT; },
/* harmony export */   "TO_DISPLAY_STRING": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TO_DISPLAY_STRING; },
/* harmony export */   "TO_HANDLERS": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TO_HANDLERS; },
/* harmony export */   "TO_HANDLER_KEY": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TO_HANDLER_KEY; },
/* harmony export */   "TRANSITION": function() { return /* binding */ TRANSITION; },
/* harmony export */   "TRANSITION_GROUP": function() { return /* binding */ TRANSITION_GROUP; },
/* harmony export */   "UNREF": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.UNREF; },
/* harmony export */   "V_MODEL_CHECKBOX": function() { return /* binding */ V_MODEL_CHECKBOX; },
/* harmony export */   "V_MODEL_DYNAMIC": function() { return /* binding */ V_MODEL_DYNAMIC; },
/* harmony export */   "V_MODEL_RADIO": function() { return /* binding */ V_MODEL_RADIO; },
/* harmony export */   "V_MODEL_SELECT": function() { return /* binding */ V_MODEL_SELECT; },
/* harmony export */   "V_MODEL_TEXT": function() { return /* binding */ V_MODEL_TEXT; },
/* harmony export */   "V_ON_WITH_KEYS": function() { return /* binding */ V_ON_WITH_KEYS; },
/* harmony export */   "V_ON_WITH_MODIFIERS": function() { return /* binding */ V_ON_WITH_MODIFIERS; },
/* harmony export */   "V_SHOW": function() { return /* binding */ V_SHOW; },
/* harmony export */   "WITH_CTX": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.WITH_CTX; },
/* harmony export */   "WITH_DIRECTIVES": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.WITH_DIRECTIVES; },
/* harmony export */   "WITH_MEMO": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.WITH_MEMO; },
/* harmony export */   "advancePositionWithClone": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.advancePositionWithClone; },
/* harmony export */   "advancePositionWithMutation": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.advancePositionWithMutation; },
/* harmony export */   "assert": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.assert; },
/* harmony export */   "baseCompile": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.baseCompile; },
/* harmony export */   "baseParse": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.baseParse; },
/* harmony export */   "buildDirectiveArgs": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.buildDirectiveArgs; },
/* harmony export */   "buildProps": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.buildProps; },
/* harmony export */   "buildSlots": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.buildSlots; },
/* harmony export */   "checkCompatEnabled": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.checkCompatEnabled; },
/* harmony export */   "compile": function() { return /* binding */ compile; },
/* harmony export */   "createArrayExpression": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createArrayExpression; },
/* harmony export */   "createAssignmentExpression": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createAssignmentExpression; },
/* harmony export */   "createBlockStatement": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createBlockStatement; },
/* harmony export */   "createCacheExpression": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCacheExpression; },
/* harmony export */   "createCallExpression": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCallExpression; },
/* harmony export */   "createCompilerError": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCompilerError; },
/* harmony export */   "createCompoundExpression": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCompoundExpression; },
/* harmony export */   "createConditionalExpression": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createConditionalExpression; },
/* harmony export */   "createDOMCompilerError": function() { return /* binding */ createDOMCompilerError; },
/* harmony export */   "createForLoopParams": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createForLoopParams; },
/* harmony export */   "createFunctionExpression": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createFunctionExpression; },
/* harmony export */   "createIfStatement": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createIfStatement; },
/* harmony export */   "createInterpolation": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createInterpolation; },
/* harmony export */   "createObjectExpression": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createObjectExpression; },
/* harmony export */   "createObjectProperty": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createObjectProperty; },
/* harmony export */   "createReturnStatement": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createReturnStatement; },
/* harmony export */   "createRoot": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createRoot; },
/* harmony export */   "createSequenceExpression": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSequenceExpression; },
/* harmony export */   "createSimpleExpression": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression; },
/* harmony export */   "createStructuralDirectiveTransform": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createStructuralDirectiveTransform; },
/* harmony export */   "createTemplateLiteral": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createTemplateLiteral; },
/* harmony export */   "createTransformContext": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createTransformContext; },
/* harmony export */   "createVNodeCall": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createVNodeCall; },
/* harmony export */   "extractIdentifiers": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.extractIdentifiers; },
/* harmony export */   "findDir": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.findDir; },
/* harmony export */   "findProp": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.findProp; },
/* harmony export */   "generate": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.generate; },
/* harmony export */   "generateCodeFrame": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.generateCodeFrame; },
/* harmony export */   "getBaseTransformPreset": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.getBaseTransformPreset; },
/* harmony export */   "getConstantType": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.getConstantType; },
/* harmony export */   "getInnerRange": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.getInnerRange; },
/* harmony export */   "getMemoedVNodeCall": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.getMemoedVNodeCall; },
/* harmony export */   "getVNodeBlockHelper": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.getVNodeBlockHelper; },
/* harmony export */   "getVNodeHelper": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.getVNodeHelper; },
/* harmony export */   "hasDynamicKeyVBind": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.hasDynamicKeyVBind; },
/* harmony export */   "hasScopeRef": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.hasScopeRef; },
/* harmony export */   "helperNameMap": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.helperNameMap; },
/* harmony export */   "injectProp": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.injectProp; },
/* harmony export */   "isBuiltInType": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isBuiltInType; },
/* harmony export */   "isCoreComponent": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isCoreComponent; },
/* harmony export */   "isFunctionType": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isFunctionType; },
/* harmony export */   "isInDestructureAssignment": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isInDestructureAssignment; },
/* harmony export */   "isMemberExpression": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isMemberExpression; },
/* harmony export */   "isMemberExpressionBrowser": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isMemberExpressionBrowser; },
/* harmony export */   "isMemberExpressionNode": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isMemberExpressionNode; },
/* harmony export */   "isReferencedIdentifier": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isReferencedIdentifier; },
/* harmony export */   "isSimpleIdentifier": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isSimpleIdentifier; },
/* harmony export */   "isSlotOutlet": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isSlotOutlet; },
/* harmony export */   "isStaticArgOf": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticArgOf; },
/* harmony export */   "isStaticExp": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticExp; },
/* harmony export */   "isStaticProperty": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticProperty; },
/* harmony export */   "isStaticPropertyKey": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticPropertyKey; },
/* harmony export */   "isTemplateNode": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isTemplateNode; },
/* harmony export */   "isText": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isText; },
/* harmony export */   "isVSlot": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isVSlot; },
/* harmony export */   "locStub": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.locStub; },
/* harmony export */   "makeBlock": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.makeBlock; },
/* harmony export */   "noopDirectiveTransform": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.noopDirectiveTransform; },
/* harmony export */   "parse": function() { return /* binding */ parse; },
/* harmony export */   "parserOptions": function() { return /* binding */ parserOptions; },
/* harmony export */   "processExpression": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.processExpression; },
/* harmony export */   "processFor": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.processFor; },
/* harmony export */   "processIf": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.processIf; },
/* harmony export */   "processSlotOutlet": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.processSlotOutlet; },
/* harmony export */   "registerRuntimeHelpers": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.registerRuntimeHelpers; },
/* harmony export */   "resolveComponentType": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.resolveComponentType; },
/* harmony export */   "toValidAssetId": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.toValidAssetId; },
/* harmony export */   "trackSlotScopes": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.trackSlotScopes; },
/* harmony export */   "trackVForSlotScopes": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.trackVForSlotScopes; },
/* harmony export */   "transform": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transform; },
/* harmony export */   "transformBind": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformBind; },
/* harmony export */   "transformElement": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformElement; },
/* harmony export */   "transformExpression": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformExpression; },
/* harmony export */   "transformModel": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformModel; },
/* harmony export */   "transformOn": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformOn; },
/* harmony export */   "transformStyle": function() { return /* binding */ transformStyle; },
/* harmony export */   "traverseNode": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.traverseNode; },
/* harmony export */   "walkBlockDeclarations": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.walkBlockDeclarations; },
/* harmony export */   "walkFunctionParams": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.walkFunctionParams; },
/* harmony export */   "walkIdentifiers": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.walkIdentifiers; },
/* harmony export */   "warnDeprecation": function() { return /* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.warnDeprecation; }
/* harmony export */ });
/* harmony import */ var _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/compiler-core */ "./node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js");
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");




const V_MODEL_RADIO = Symbol(( true) ? `vModelRadio` : 0);
const V_MODEL_CHECKBOX = Symbol(( true) ? `vModelCheckbox` : 0);
const V_MODEL_TEXT = Symbol(( true) ? `vModelText` : 0);
const V_MODEL_SELECT = Symbol(( true) ? `vModelSelect` : 0);
const V_MODEL_DYNAMIC = Symbol(( true) ? `vModelDynamic` : 0);
const V_ON_WITH_MODIFIERS = Symbol(( true) ? `vOnModifiersGuard` : 0);
const V_ON_WITH_KEYS = Symbol(( true) ? `vOnKeysGuard` : 0);
const V_SHOW = Symbol(( true) ? `vShow` : 0);
const TRANSITION = Symbol(( true) ? `Transition` : 0);
const TRANSITION_GROUP = Symbol(( true) ? `TransitionGroup` : 0);
(0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.registerRuntimeHelpers)({
    [V_MODEL_RADIO]: `vModelRadio`,
    [V_MODEL_CHECKBOX]: `vModelCheckbox`,
    [V_MODEL_TEXT]: `vModelText`,
    [V_MODEL_SELECT]: `vModelSelect`,
    [V_MODEL_DYNAMIC]: `vModelDynamic`,
    [V_ON_WITH_MODIFIERS]: `withModifiers`,
    [V_ON_WITH_KEYS]: `withKeys`,
    [V_SHOW]: `vShow`,
    [TRANSITION]: `Transition`,
    [TRANSITION_GROUP]: `TransitionGroup`
});

/* eslint-disable no-restricted-globals */
let decoder;
function decodeHtmlBrowser(raw, asAttr = false) {
    if (!decoder) {
        decoder = document.createElement('div');
    }
    if (asAttr) {
        decoder.innerHTML = `<div foo="${raw.replace(/"/g, '&quot;')}">`;
        return decoder.children[0].getAttribute('foo');
    }
    else {
        decoder.innerHTML = raw;
        return decoder.textContent;
    }
}

const isRawTextContainer = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)('style,iframe,script,noscript', true);
const parserOptions = {
    isVoidTag: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isVoidTag,
    isNativeTag: tag => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isHTMLTag)(tag) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSVGTag)(tag),
    isPreTag: tag => tag === 'pre',
    decodeEntities: decodeHtmlBrowser ,
    isBuiltInComponent: (tag) => {
        if ((0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isBuiltInType)(tag, `Transition`)) {
            return TRANSITION;
        }
        else if ((0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isBuiltInType)(tag, `TransitionGroup`)) {
            return TRANSITION_GROUP;
        }
    },
    // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
    getNamespace(tag, parent) {
        let ns = parent ? parent.ns : 0 /* HTML */;
        if (parent && ns === 2 /* MATH_ML */) {
            if (parent.tag === 'annotation-xml') {
                if (tag === 'svg') {
                    return 1 /* SVG */;
                }
                if (parent.props.some(a => a.type === 6 /* ATTRIBUTE */ &&
                    a.name === 'encoding' &&
                    a.value != null &&
                    (a.value.content === 'text/html' ||
                        a.value.content === 'application/xhtml+xml'))) {
                    ns = 0 /* HTML */;
                }
            }
            else if (/^m(?:[ions]|text)$/.test(parent.tag) &&
                tag !== 'mglyph' &&
                tag !== 'malignmark') {
                ns = 0 /* HTML */;
            }
        }
        else if (parent && ns === 1 /* SVG */) {
            if (parent.tag === 'foreignObject' ||
                parent.tag === 'desc' ||
                parent.tag === 'title') {
                ns = 0 /* HTML */;
            }
        }
        if (ns === 0 /* HTML */) {
            if (tag === 'svg') {
                return 1 /* SVG */;
            }
            if (tag === 'math') {
                return 2 /* MATH_ML */;
            }
        }
        return ns;
    },
    // https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments
    getTextMode({ tag, ns }) {
        if (ns === 0 /* HTML */) {
            if (tag === 'textarea' || tag === 'title') {
                return 1 /* RCDATA */;
            }
            if (isRawTextContainer(tag)) {
                return 2 /* RAWTEXT */;
            }
        }
        return 0 /* DATA */;
    }
};

// Parse inline CSS strings for static style attributes into an object.
// This is a NodeTransform since it works on the static `style` attribute and
// converts it into a dynamic equivalent:
// style="color: red" -> :style='{ "color": "red" }'
// It is then processed by `transformElement` and included in the generated
// props.
const transformStyle = node => {
    if (node.type === 1 /* ELEMENT */) {
        node.props.forEach((p, i) => {
            if (p.type === 6 /* ATTRIBUTE */ && p.name === 'style' && p.value) {
                // replace p with an expression node
                node.props[i] = {
                    type: 7 /* DIRECTIVE */,
                    name: `bind`,
                    arg: (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(`style`, true, p.loc),
                    exp: parseInlineCSS(p.value.content, p.loc),
                    modifiers: [],
                    loc: p.loc
                };
            }
        });
    }
};
const parseInlineCSS = (cssText, loc) => {
    const normalized = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.parseStringStyle)(cssText);
    return (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(JSON.stringify(normalized), false, loc, 3 /* CAN_STRINGIFY */);
};

function createDOMCompilerError(code, loc) {
    return (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCompilerError)(code, loc,  true ? DOMErrorMessages : 0);
}
const DOMErrorMessages = {
    [50 /* X_V_HTML_NO_EXPRESSION */]: `v-html is missing expression.`,
    [51 /* X_V_HTML_WITH_CHILDREN */]: `v-html will override element children.`,
    [52 /* X_V_TEXT_NO_EXPRESSION */]: `v-text is missing expression.`,
    [53 /* X_V_TEXT_WITH_CHILDREN */]: `v-text will override element children.`,
    [54 /* X_V_MODEL_ON_INVALID_ELEMENT */]: `v-model can only be used on <input>, <textarea> and <select> elements.`,
    [55 /* X_V_MODEL_ARG_ON_ELEMENT */]: `v-model argument is not supported on plain elements.`,
    [56 /* X_V_MODEL_ON_FILE_INPUT_ELEMENT */]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,
    [57 /* X_V_MODEL_UNNECESSARY_VALUE */]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,
    [58 /* X_V_SHOW_NO_EXPRESSION */]: `v-show is missing expression.`,
    [59 /* X_TRANSITION_INVALID_CHILDREN */]: `<Transition> expects exactly one child element or component.`,
    [60 /* X_IGNORED_SIDE_EFFECT_TAG */]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`
};

const transformVHtml = (dir, node, context) => {
    const { exp, loc } = dir;
    if (!exp) {
        context.onError(createDOMCompilerError(50 /* X_V_HTML_NO_EXPRESSION */, loc));
    }
    if (node.children.length) {
        context.onError(createDOMCompilerError(51 /* X_V_HTML_WITH_CHILDREN */, loc));
        node.children.length = 0;
    }
    return {
        props: [
            (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createObjectProperty)((0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(`innerHTML`, true, loc), exp || (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)('', true))
        ]
    };
};

const transformVText = (dir, node, context) => {
    const { exp, loc } = dir;
    if (!exp) {
        context.onError(createDOMCompilerError(52 /* X_V_TEXT_NO_EXPRESSION */, loc));
    }
    if (node.children.length) {
        context.onError(createDOMCompilerError(53 /* X_V_TEXT_WITH_CHILDREN */, loc));
        node.children.length = 0;
    }
    return {
        props: [
            (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createObjectProperty)((0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(`textContent`, true), exp
                ? (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.getConstantType)(exp, context) > 0
                    ? exp
                    : (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCallExpression)(context.helperString(_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TO_DISPLAY_STRING), [exp], loc)
                : (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)('', true))
        ]
    };
};

const transformModel = (dir, node, context) => {
    const baseResult = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformModel)(dir, node, context);
    // base transform has errors OR component v-model (only need props)
    if (!baseResult.props.length || node.tagType === 1 /* COMPONENT */) {
        return baseResult;
    }
    if (dir.arg) {
        context.onError(createDOMCompilerError(55 /* X_V_MODEL_ARG_ON_ELEMENT */, dir.arg.loc));
    }
    function checkDuplicatedValue() {
        const value = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.findProp)(node, 'value');
        if (value) {
            context.onError(createDOMCompilerError(57 /* X_V_MODEL_UNNECESSARY_VALUE */, value.loc));
        }
    }
    const { tag } = node;
    const isCustomElement = context.isCustomElement(tag);
    if (tag === 'input' ||
        tag === 'textarea' ||
        tag === 'select' ||
        isCustomElement) {
        let directiveToUse = V_MODEL_TEXT;
        let isInvalidType = false;
        if (tag === 'input' || isCustomElement) {
            const type = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.findProp)(node, `type`);
            if (type) {
                if (type.type === 7 /* DIRECTIVE */) {
                    // :type="foo"
                    directiveToUse = V_MODEL_DYNAMIC;
                }
                else if (type.value) {
                    switch (type.value.content) {
                        case 'radio':
                            directiveToUse = V_MODEL_RADIO;
                            break;
                        case 'checkbox':
                            directiveToUse = V_MODEL_CHECKBOX;
                            break;
                        case 'file':
                            isInvalidType = true;
                            context.onError(createDOMCompilerError(56 /* X_V_MODEL_ON_FILE_INPUT_ELEMENT */, dir.loc));
                            break;
                        default:
                            // text type
                            ( true) && checkDuplicatedValue();
                            break;
                    }
                }
            }
            else if ((0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.hasDynamicKeyVBind)(node)) {
                // element has bindings with dynamic keys, which can possibly contain
                // "type".
                directiveToUse = V_MODEL_DYNAMIC;
            }
            else {
                // text type
                ( true) && checkDuplicatedValue();
            }
        }
        else if (tag === 'select') {
            directiveToUse = V_MODEL_SELECT;
        }
        else {
            // textarea
            ( true) && checkDuplicatedValue();
        }
        // inject runtime directive
        // by returning the helper symbol via needRuntime
        // the import will replaced a resolveDirective call.
        if (!isInvalidType) {
            baseResult.needRuntime = context.helper(directiveToUse);
        }
    }
    else {
        context.onError(createDOMCompilerError(54 /* X_V_MODEL_ON_INVALID_ELEMENT */, dir.loc));
    }
    // native vmodel doesn't need the `modelValue` props since they are also
    // passed to the runtime as `binding.value`. removing it reduces code size.
    baseResult.props = baseResult.props.filter(p => !(p.key.type === 4 /* SIMPLE_EXPRESSION */ &&
        p.key.content === 'modelValue'));
    return baseResult;
};

const isEventOptionModifier = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)(`passive,once,capture`);
const isNonKeyModifier = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)(
// event propagation management
`stop,prevent,self,` +
    // system modifiers + exact
    `ctrl,shift,alt,meta,exact,` +
    // mouse
    `middle`);
// left & right could be mouse or key modifiers based on event type
const maybeKeyModifier = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)('left,right');
const isKeyboardEvent = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)(`onkeyup,onkeydown,onkeypress`, true);
const resolveModifiers = (key, modifiers, context, loc) => {
    const keyModifiers = [];
    const nonKeyModifiers = [];
    const eventOptionModifiers = [];
    for (let i = 0; i < modifiers.length; i++) {
        const modifier = modifiers[i];
        if (modifier === 'native' &&
            (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.checkCompatEnabled)("COMPILER_V_ON_NATIVE" /* COMPILER_V_ON_NATIVE */, context, loc)) {
            eventOptionModifiers.push(modifier);
        }
        else if (isEventOptionModifier(modifier)) {
            // eventOptionModifiers: modifiers for addEventListener() options,
            // e.g. .passive & .capture
            eventOptionModifiers.push(modifier);
        }
        else {
            // runtimeModifiers: modifiers that needs runtime guards
            if (maybeKeyModifier(modifier)) {
                if ((0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticExp)(key)) {
                    if (isKeyboardEvent(key.content)) {
                        keyModifiers.push(modifier);
                    }
                    else {
                        nonKeyModifiers.push(modifier);
                    }
                }
                else {
                    keyModifiers.push(modifier);
                    nonKeyModifiers.push(modifier);
                }
            }
            else {
                if (isNonKeyModifier(modifier)) {
                    nonKeyModifiers.push(modifier);
                }
                else {
                    keyModifiers.push(modifier);
                }
            }
        }
    }
    return {
        keyModifiers,
        nonKeyModifiers,
        eventOptionModifiers
    };
};
const transformClick = (key, event) => {
    const isStaticClick = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticExp)(key) && key.content.toLowerCase() === 'onclick';
    return isStaticClick
        ? (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(event, true)
        : key.type !== 4 /* SIMPLE_EXPRESSION */
            ? (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCompoundExpression)([
                `(`,
                key,
                `) === "onClick" ? "${event}" : (`,
                key,
                `)`
            ])
            : key;
};
const transformOn = (dir, node, context) => {
    return (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformOn)(dir, node, context, baseResult => {
        const { modifiers } = dir;
        if (!modifiers.length)
            return baseResult;
        let { key, value: handlerExp } = baseResult.props[0];
        const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key, modifiers, context, dir.loc);
        // normalize click.right and click.middle since they don't actually fire
        if (nonKeyModifiers.includes('right')) {
            key = transformClick(key, `onContextmenu`);
        }
        if (nonKeyModifiers.includes('middle')) {
            key = transformClick(key, `onMouseup`);
        }
        if (nonKeyModifiers.length) {
            handlerExp = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCallExpression)(context.helper(V_ON_WITH_MODIFIERS), [
                handlerExp,
                JSON.stringify(nonKeyModifiers)
            ]);
        }
        if (keyModifiers.length &&
            // if event name is dynamic, always wrap with keys guard
            (!(0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticExp)(key) || isKeyboardEvent(key.content))) {
            handlerExp = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCallExpression)(context.helper(V_ON_WITH_KEYS), [
                handlerExp,
                JSON.stringify(keyModifiers)
            ]);
        }
        if (eventOptionModifiers.length) {
            const modifierPostfix = eventOptionModifiers.map(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize).join('');
            key = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticExp)(key)
                ? (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(`${key.content}${modifierPostfix}`, true)
                : (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCompoundExpression)([`(`, key, `) + "${modifierPostfix}"`]);
        }
        return {
            props: [(0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createObjectProperty)(key, handlerExp)]
        };
    });
};

const transformShow = (dir, node, context) => {
    const { exp, loc } = dir;
    if (!exp) {
        context.onError(createDOMCompilerError(58 /* X_V_SHOW_NO_EXPRESSION */, loc));
    }
    return {
        props: [],
        needRuntime: context.helper(V_SHOW)
    };
};

const transformTransition = (node, context) => {
    if (node.type === 1 /* ELEMENT */ &&
        node.tagType === 1 /* COMPONENT */) {
        const component = context.isBuiltInComponent(node.tag);
        if (component === TRANSITION) {
            return () => {
                if (!node.children.length) {
                    return;
                }
                // warn multiple transition children
                if (hasMultipleChildren(node)) {
                    context.onError(createDOMCompilerError(59 /* X_TRANSITION_INVALID_CHILDREN */, {
                        start: node.children[0].loc.start,
                        end: node.children[node.children.length - 1].loc.end,
                        source: ''
                    }));
                }
                // check if it's s single child w/ v-show
                // if yes, inject "persisted: true" to the transition props
                const child = node.children[0];
                if (child.type === 1 /* ELEMENT */) {
                    for (const p of child.props) {
                        if (p.type === 7 /* DIRECTIVE */ && p.name === 'show') {
                            node.props.push({
                                type: 6 /* ATTRIBUTE */,
                                name: 'persisted',
                                value: undefined,
                                loc: node.loc
                            });
                        }
                    }
                }
            };
        }
    }
};
function hasMultipleChildren(node) {
    // #1352 filter out potential comment nodes.
    const children = (node.children = node.children.filter(c => c.type !== 3 /* COMMENT */ &&
        !(c.type === 2 /* TEXT */ && !c.content.trim())));
    const child = children[0];
    return (children.length !== 1 ||
        child.type === 11 /* FOR */ ||
        (child.type === 9 /* IF */ && child.branches.some(hasMultipleChildren)));
}

const ignoreSideEffectTags = (node, context) => {
    if (node.type === 1 /* ELEMENT */ &&
        node.tagType === 0 /* ELEMENT */ &&
        (node.tag === 'script' || node.tag === 'style')) {
        context.onError(createDOMCompilerError(60 /* X_IGNORED_SIDE_EFFECT_TAG */, node.loc));
        context.removeNode();
    }
};

const DOMNodeTransforms = [
    transformStyle,
    ...(( true) ? [transformTransition] : 0)
];
const DOMDirectiveTransforms = {
    cloak: _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.noopDirectiveTransform,
    html: transformVHtml,
    text: transformVText,
    model: transformModel,
    on: transformOn,
    show: transformShow
};
function compile(template, options = {}) {
    return (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.baseCompile)(template, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, parserOptions, options, {
        nodeTransforms: [
            // ignore <script> and <tag>
            // this is not put inside DOMNodeTransforms because that list is used
            // by compiler-ssr to generate vnode fallback branches
            ignoreSideEffectTags,
            ...DOMNodeTransforms,
            ...(options.nodeTransforms || [])
        ],
        directiveTransforms: (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, DOMDirectiveTransforms, options.directiveTransforms || {}),
        transformHoist: null 
    }));
}
function parse(template, options = {}) {
    return (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.baseParse)(template, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, parserOptions, options));
}




/***/ }),

/***/ "./node_modules/@vue/devtools-api/lib/esm/const.js":
/*!*********************************************************!*\
  !*** ./node_modules/@vue/devtools-api/lib/esm/const.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HOOK_PLUGIN_SETTINGS_SET": function() { return /* binding */ HOOK_PLUGIN_SETTINGS_SET; },
/* harmony export */   "HOOK_SETUP": function() { return /* binding */ HOOK_SETUP; }
/* harmony export */ });
const HOOK_SETUP = 'devtools-plugin:setup';
const HOOK_PLUGIN_SETTINGS_SET = 'plugin:settings:set';


/***/ }),

/***/ "./node_modules/@vue/devtools-api/lib/esm/env.js":
/*!*******************************************************!*\
  !*** ./node_modules/@vue/devtools-api/lib/esm/env.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getDevtoolsGlobalHook": function() { return /* binding */ getDevtoolsGlobalHook; },
/* harmony export */   "getTarget": function() { return /* binding */ getTarget; },
/* harmony export */   "isProxyAvailable": function() { return /* binding */ isProxyAvailable; }
/* harmony export */ });
function getDevtoolsGlobalHook() {
    return getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__;
}
function getTarget() {
    // @ts-ignore
    return (typeof navigator !== 'undefined' && typeof window !== 'undefined')
        ? window
        : typeof __webpack_require__.g !== 'undefined'
            ? __webpack_require__.g
            : {};
}
const isProxyAvailable = typeof Proxy === 'function';


/***/ }),

/***/ "./node_modules/@vue/devtools-api/lib/esm/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@vue/devtools-api/lib/esm/index.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isPerformanceSupported": function() { return /* reexport safe */ _time__WEBPACK_IMPORTED_MODULE_0__.isPerformanceSupported; },
/* harmony export */   "now": function() { return /* reexport safe */ _time__WEBPACK_IMPORTED_MODULE_0__.now; },
/* harmony export */   "setupDevtoolsPlugin": function() { return /* binding */ setupDevtoolsPlugin; }
/* harmony export */ });
/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./env */ "./node_modules/@vue/devtools-api/lib/esm/env.js");
/* harmony import */ var _const__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./const */ "./node_modules/@vue/devtools-api/lib/esm/const.js");
/* harmony import */ var _proxy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./proxy */ "./node_modules/@vue/devtools-api/lib/esm/proxy.js");
/* harmony import */ var _time__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./time */ "./node_modules/@vue/devtools-api/lib/esm/time.js");






function setupDevtoolsPlugin(pluginDescriptor, setupFn) {
    const descriptor = pluginDescriptor;
    const target = (0,_env__WEBPACK_IMPORTED_MODULE_1__.getTarget)();
    const hook = (0,_env__WEBPACK_IMPORTED_MODULE_1__.getDevtoolsGlobalHook)();
    const enableProxy = _env__WEBPACK_IMPORTED_MODULE_1__.isProxyAvailable && descriptor.enableEarlyProxy;
    if (hook && (target.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !enableProxy)) {
        hook.emit(_const__WEBPACK_IMPORTED_MODULE_2__.HOOK_SETUP, pluginDescriptor, setupFn);
    }
    else {
        const proxy = enableProxy ? new _proxy__WEBPACK_IMPORTED_MODULE_3__.ApiProxy(descriptor, hook) : null;
        const list = target.__VUE_DEVTOOLS_PLUGINS__ = target.__VUE_DEVTOOLS_PLUGINS__ || [];
        list.push({
            pluginDescriptor: descriptor,
            setupFn,
            proxy,
        });
        if (proxy)
            setupFn(proxy.proxiedTarget);
    }
}


/***/ }),

/***/ "./node_modules/@vue/devtools-api/lib/esm/proxy.js":
/*!*********************************************************!*\
  !*** ./node_modules/@vue/devtools-api/lib/esm/proxy.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ApiProxy": function() { return /* binding */ ApiProxy; }
/* harmony export */ });
/* harmony import */ var _const__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./const */ "./node_modules/@vue/devtools-api/lib/esm/const.js");
/* harmony import */ var _time__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./time */ "./node_modules/@vue/devtools-api/lib/esm/time.js");


class ApiProxy {
    constructor(plugin, hook) {
        this.target = null;
        this.targetQueue = [];
        this.onQueue = [];
        this.plugin = plugin;
        this.hook = hook;
        const defaultSettings = {};
        if (plugin.settings) {
            for (const id in plugin.settings) {
                const item = plugin.settings[id];
                defaultSettings[id] = item.defaultValue;
            }
        }
        const localSettingsSaveId = `__vue-devtools-plugin-settings__${plugin.id}`;
        let currentSettings = Object.assign({}, defaultSettings);
        try {
            const raw = localStorage.getItem(localSettingsSaveId);
            const data = JSON.parse(raw);
            Object.assign(currentSettings, data);
        }
        catch (e) {
            // noop
        }
        this.fallbacks = {
            getSettings() {
                return currentSettings;
            },
            setSettings(value) {
                try {
                    localStorage.setItem(localSettingsSaveId, JSON.stringify(value));
                }
                catch (e) {
                    // noop
                }
                currentSettings = value;
            },
            now() {
                return (0,_time__WEBPACK_IMPORTED_MODULE_0__.now)();
            },
        };
        if (hook) {
            hook.on(_const__WEBPACK_IMPORTED_MODULE_1__.HOOK_PLUGIN_SETTINGS_SET, (pluginId, value) => {
                if (pluginId === this.plugin.id) {
                    this.fallbacks.setSettings(value);
                }
            });
        }
        this.proxiedOn = new Proxy({}, {
            get: (_target, prop) => {
                if (this.target) {
                    return this.target.on[prop];
                }
                else {
                    return (...args) => {
                        this.onQueue.push({
                            method: prop,
                            args,
                        });
                    };
                }
            },
        });
        this.proxiedTarget = new Proxy({}, {
            get: (_target, prop) => {
                if (this.target) {
                    return this.target[prop];
                }
                else if (prop === 'on') {
                    return this.proxiedOn;
                }
                else if (Object.keys(this.fallbacks).includes(prop)) {
                    return (...args) => {
                        this.targetQueue.push({
                            method: prop,
                            args,
                            resolve: () => { },
                        });
                        return this.fallbacks[prop](...args);
                    };
                }
                else {
                    return (...args) => {
                        return new Promise(resolve => {
                            this.targetQueue.push({
                                method: prop,
                                args,
                                resolve,
                            });
                        });
                    };
                }
            },
        });
    }
    async setRealTarget(target) {
        this.target = target;
        for (const item of this.onQueue) {
            this.target.on[item.method](...item.args);
        }
        for (const item of this.targetQueue) {
            item.resolve(await this.target[item.method](...item.args));
        }
    }
}


/***/ }),

/***/ "./node_modules/@vue/devtools-api/lib/esm/time.js":
/*!********************************************************!*\
  !*** ./node_modules/@vue/devtools-api/lib/esm/time.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isPerformanceSupported": function() { return /* binding */ isPerformanceSupported; },
/* harmony export */   "now": function() { return /* binding */ now; }
/* harmony export */ });
let supported;
let perf;
function isPerformanceSupported() {
    var _a;
    if (supported !== undefined) {
        return supported;
    }
    if (typeof window !== 'undefined' && window.performance) {
        supported = true;
        perf = window.performance;
    }
    else if (typeof __webpack_require__.g !== 'undefined' && ((_a = __webpack_require__.g.perf_hooks) === null || _a === void 0 ? void 0 : _a.performance)) {
        supported = true;
        perf = __webpack_require__.g.perf_hooks.performance;
    }
    else {
        supported = false;
    }
    return supported;
}
function now() {
    return isPerformanceSupported() ? perf.now() : Date.now();
}


/***/ }),

/***/ "./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EffectScope": function() { return /* binding */ EffectScope; },
/* harmony export */   "ITERATE_KEY": function() { return /* binding */ ITERATE_KEY; },
/* harmony export */   "ReactiveEffect": function() { return /* binding */ ReactiveEffect; },
/* harmony export */   "computed": function() { return /* binding */ computed; },
/* harmony export */   "customRef": function() { return /* binding */ customRef; },
/* harmony export */   "deferredComputed": function() { return /* binding */ deferredComputed; },
/* harmony export */   "effect": function() { return /* binding */ effect; },
/* harmony export */   "effectScope": function() { return /* binding */ effectScope; },
/* harmony export */   "enableTracking": function() { return /* binding */ enableTracking; },
/* harmony export */   "getCurrentScope": function() { return /* binding */ getCurrentScope; },
/* harmony export */   "isProxy": function() { return /* binding */ isProxy; },
/* harmony export */   "isReactive": function() { return /* binding */ isReactive; },
/* harmony export */   "isReadonly": function() { return /* binding */ isReadonly; },
/* harmony export */   "isRef": function() { return /* binding */ isRef; },
/* harmony export */   "isShallow": function() { return /* binding */ isShallow; },
/* harmony export */   "markRaw": function() { return /* binding */ markRaw; },
/* harmony export */   "onScopeDispose": function() { return /* binding */ onScopeDispose; },
/* harmony export */   "pauseTracking": function() { return /* binding */ pauseTracking; },
/* harmony export */   "proxyRefs": function() { return /* binding */ proxyRefs; },
/* harmony export */   "reactive": function() { return /* binding */ reactive; },
/* harmony export */   "readonly": function() { return /* binding */ readonly; },
/* harmony export */   "ref": function() { return /* binding */ ref; },
/* harmony export */   "resetTracking": function() { return /* binding */ resetTracking; },
/* harmony export */   "shallowReactive": function() { return /* binding */ shallowReactive; },
/* harmony export */   "shallowReadonly": function() { return /* binding */ shallowReadonly; },
/* harmony export */   "shallowRef": function() { return /* binding */ shallowRef; },
/* harmony export */   "stop": function() { return /* binding */ stop; },
/* harmony export */   "toRaw": function() { return /* binding */ toRaw; },
/* harmony export */   "toRef": function() { return /* binding */ toRef; },
/* harmony export */   "toRefs": function() { return /* binding */ toRefs; },
/* harmony export */   "track": function() { return /* binding */ track; },
/* harmony export */   "trigger": function() { return /* binding */ trigger; },
/* harmony export */   "triggerRef": function() { return /* binding */ triggerRef; },
/* harmony export */   "unref": function() { return /* binding */ unref; }
/* harmony export */ });
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");


function warn(msg, ...args) {
    console.warn(`[Vue warn] ${msg}`, ...args);
}

let activeEffectScope;
class EffectScope {
    constructor(detached = false) {
        /**
         * @internal
         */
        this.active = true;
        /**
         * @internal
         */
        this.effects = [];
        /**
         * @internal
         */
        this.cleanups = [];
        if (!detached && activeEffectScope) {
            this.parent = activeEffectScope;
            this.index =
                (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
        }
    }
    run(fn) {
        if (this.active) {
            const currentEffectScope = activeEffectScope;
            try {
                activeEffectScope = this;
                return fn();
            }
            finally {
                activeEffectScope = currentEffectScope;
            }
        }
        else if ((true)) {
            warn(`cannot run an inactive effect scope.`);
        }
    }
    /**
     * This should only be called on non-detached scopes
     * @internal
     */
    on() {
        activeEffectScope = this;
    }
    /**
     * This should only be called on non-detached scopes
     * @internal
     */
    off() {
        activeEffectScope = this.parent;
    }
    stop(fromParent) {
        if (this.active) {
            let i, l;
            for (i = 0, l = this.effects.length; i < l; i++) {
                this.effects[i].stop();
            }
            for (i = 0, l = this.cleanups.length; i < l; i++) {
                this.cleanups[i]();
            }
            if (this.scopes) {
                for (i = 0, l = this.scopes.length; i < l; i++) {
                    this.scopes[i].stop(true);
                }
            }
            // nested scope, dereference from parent to avoid memory leaks
            if (this.parent && !fromParent) {
                // optimized O(1) removal
                const last = this.parent.scopes.pop();
                if (last && last !== this) {
                    this.parent.scopes[this.index] = last;
                    last.index = this.index;
                }
            }
            this.active = false;
        }
    }
}
function effectScope(detached) {
    return new EffectScope(detached);
}
function recordEffectScope(effect, scope = activeEffectScope) {
    if (scope && scope.active) {
        scope.effects.push(effect);
    }
}
function getCurrentScope() {
    return activeEffectScope;
}
function onScopeDispose(fn) {
    if (activeEffectScope) {
        activeEffectScope.cleanups.push(fn);
    }
    else if ((true)) {
        warn(`onScopeDispose() is called when there is no active effect scope` +
            ` to be associated with.`);
    }
}

const createDep = (effects) => {
    const dep = new Set(effects);
    dep.w = 0;
    dep.n = 0;
    return dep;
};
const wasTracked = (dep) => (dep.w & trackOpBit) > 0;
const newTracked = (dep) => (dep.n & trackOpBit) > 0;
const initDepMarkers = ({ deps }) => {
    if (deps.length) {
        for (let i = 0; i < deps.length; i++) {
            deps[i].w |= trackOpBit; // set was tracked
        }
    }
};
const finalizeDepMarkers = (effect) => {
    const { deps } = effect;
    if (deps.length) {
        let ptr = 0;
        for (let i = 0; i < deps.length; i++) {
            const dep = deps[i];
            if (wasTracked(dep) && !newTracked(dep)) {
                dep.delete(effect);
            }
            else {
                deps[ptr++] = dep;
            }
            // clear bits
            dep.w &= ~trackOpBit;
            dep.n &= ~trackOpBit;
        }
        deps.length = ptr;
    }
};

const targetMap = new WeakMap();
// The number of effects currently being tracked recursively.
let effectTrackDepth = 0;
let trackOpBit = 1;
/**
 * The bitwise track markers support at most 30 levels of recursion.
 * This value is chosen to enable modern JS engines to use a SMI on all platforms.
 * When recursion depth is greater, fall back to using a full cleanup.
 */
const maxMarkerBits = 30;
let activeEffect;
const ITERATE_KEY = Symbol(( true) ? 'iterate' : 0);
const MAP_KEY_ITERATE_KEY = Symbol(( true) ? 'Map key iterate' : 0);
class ReactiveEffect {
    constructor(fn, scheduler = null, scope) {
        this.fn = fn;
        this.scheduler = scheduler;
        this.active = true;
        this.deps = [];
        this.parent = undefined;
        recordEffectScope(this, scope);
    }
    run() {
        if (!this.active) {
            return this.fn();
        }
        let parent = activeEffect;
        let lastShouldTrack = shouldTrack;
        while (parent) {
            if (parent === this) {
                return;
            }
            parent = parent.parent;
        }
        try {
            this.parent = activeEffect;
            activeEffect = this;
            shouldTrack = true;
            trackOpBit = 1 << ++effectTrackDepth;
            if (effectTrackDepth <= maxMarkerBits) {
                initDepMarkers(this);
            }
            else {
                cleanupEffect(this);
            }
            return this.fn();
        }
        finally {
            if (effectTrackDepth <= maxMarkerBits) {
                finalizeDepMarkers(this);
            }
            trackOpBit = 1 << --effectTrackDepth;
            activeEffect = this.parent;
            shouldTrack = lastShouldTrack;
            this.parent = undefined;
            if (this.deferStop) {
                this.stop();
            }
        }
    }
    stop() {
        // stopped while running itself - defer the cleanup
        if (activeEffect === this) {
            this.deferStop = true;
        }
        else if (this.active) {
            cleanupEffect(this);
            if (this.onStop) {
                this.onStop();
            }
            this.active = false;
        }
    }
}
function cleanupEffect(effect) {
    const { deps } = effect;
    if (deps.length) {
        for (let i = 0; i < deps.length; i++) {
            deps[i].delete(effect);
        }
        deps.length = 0;
    }
}
function effect(fn, options) {
    if (fn.effect) {
        fn = fn.effect.fn;
    }
    const _effect = new ReactiveEffect(fn);
    if (options) {
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)(_effect, options);
        if (options.scope)
            recordEffectScope(_effect, options.scope);
    }
    if (!options || !options.lazy) {
        _effect.run();
    }
    const runner = _effect.run.bind(_effect);
    runner.effect = _effect;
    return runner;
}
function stop(runner) {
    runner.effect.stop();
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = false;
}
function enableTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = true;
}
function resetTracking() {
    const last = trackStack.pop();
    shouldTrack = last === undefined ? true : last;
}
function track(target, type, key) {
    if (shouldTrack && activeEffect) {
        let depsMap = targetMap.get(target);
        if (!depsMap) {
            targetMap.set(target, (depsMap = new Map()));
        }
        let dep = depsMap.get(key);
        if (!dep) {
            depsMap.set(key, (dep = createDep()));
        }
        const eventInfo = ( true)
            ? { effect: activeEffect, target, type, key }
            : 0;
        trackEffects(dep, eventInfo);
    }
}
function trackEffects(dep, debuggerEventExtraInfo) {
    let shouldTrack = false;
    if (effectTrackDepth <= maxMarkerBits) {
        if (!newTracked(dep)) {
            dep.n |= trackOpBit; // set newly tracked
            shouldTrack = !wasTracked(dep);
        }
    }
    else {
        // Full cleanup mode.
        shouldTrack = !dep.has(activeEffect);
    }
    if (shouldTrack) {
        dep.add(activeEffect);
        activeEffect.deps.push(dep);
        if (( true) && activeEffect.onTrack) {
            activeEffect.onTrack(Object.assign({ effect: activeEffect }, debuggerEventExtraInfo));
        }
    }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
    const depsMap = targetMap.get(target);
    if (!depsMap) {
        // never been tracked
        return;
    }
    let deps = [];
    if (type === "clear" /* CLEAR */) {
        // collection being cleared
        // trigger all effects for target
        deps = [...depsMap.values()];
    }
    else if (key === 'length' && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target)) {
        depsMap.forEach((dep, key) => {
            if (key === 'length' || key >= newValue) {
                deps.push(dep);
            }
        });
    }
    else {
        // schedule runs for SET | ADD | DELETE
        if (key !== void 0) {
            deps.push(depsMap.get(key));
        }
        // also run for iteration key on ADD | DELETE | Map.SET
        switch (type) {
            case "add" /* ADD */:
                if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target)) {
                    deps.push(depsMap.get(ITERATE_KEY));
                    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)) {
                        deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
                    }
                }
                else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isIntegerKey)(key)) {
                    // new index added to array -> length changes
                    deps.push(depsMap.get('length'));
                }
                break;
            case "delete" /* DELETE */:
                if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target)) {
                    deps.push(depsMap.get(ITERATE_KEY));
                    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)) {
                        deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
                    }
                }
                break;
            case "set" /* SET */:
                if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)) {
                    deps.push(depsMap.get(ITERATE_KEY));
                }
                break;
        }
    }
    const eventInfo = ( true)
        ? { target, type, key, newValue, oldValue, oldTarget }
        : 0;
    if (deps.length === 1) {
        if (deps[0]) {
            if ((true)) {
                triggerEffects(deps[0], eventInfo);
            }
            else {}
        }
    }
    else {
        const effects = [];
        for (const dep of deps) {
            if (dep) {
                effects.push(...dep);
            }
        }
        if ((true)) {
            triggerEffects(createDep(effects), eventInfo);
        }
        else {}
    }
}
function triggerEffects(dep, debuggerEventExtraInfo) {
    // spread into array for stabilization
    const effects = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(dep) ? dep : [...dep];
    for (const effect of effects) {
        if (effect.computed) {
            triggerEffect(effect, debuggerEventExtraInfo);
        }
    }
    for (const effect of effects) {
        if (!effect.computed) {
            triggerEffect(effect, debuggerEventExtraInfo);
        }
    }
}
function triggerEffect(effect, debuggerEventExtraInfo) {
    if (effect !== activeEffect || effect.allowRecurse) {
        if (( true) && effect.onTrigger) {
            effect.onTrigger((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({ effect }, debuggerEventExtraInfo));
        }
        if (effect.scheduler) {
            effect.scheduler();
        }
        else {
            effect.run();
        }
    }
}

const isNonTrackableKeys = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.makeMap)(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
/*#__PURE__*/
Object.getOwnPropertyNames(Symbol)
    // ios10.x Object.getOwnPropertyNames(Symbol) can enumerate 'arguments' and 'caller'
    // but accessing them on Symbol leads to TypeError because Symbol is a strict mode
    // function
    .filter(key => key !== 'arguments' && key !== 'caller')
    .map(key => Symbol[key])
    .filter(_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol));
const get = /*#__PURE__*/ createGetter();
const shallowGet = /*#__PURE__*/ createGetter(false, true);
const readonlyGet = /*#__PURE__*/ createGetter(true);
const shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true);
const arrayInstrumentations = /*#__PURE__*/ createArrayInstrumentations();
function createArrayInstrumentations() {
    const instrumentations = {};
    ['includes', 'indexOf', 'lastIndexOf'].forEach(key => {
        instrumentations[key] = function (...args) {
            const arr = toRaw(this);
            for (let i = 0, l = this.length; i < l; i++) {
                track(arr, "get" /* GET */, i + '');
            }
            // we run the method using the original args first (which may be reactive)
            const res = arr[key](...args);
            if (res === -1 || res === false) {
                // if that didn't work, run it again using raw values.
                return arr[key](...args.map(toRaw));
            }
            else {
                return res;
            }
        };
    });
    ['push', 'pop', 'shift', 'unshift', 'splice'].forEach(key => {
        instrumentations[key] = function (...args) {
            pauseTracking();
            const res = toRaw(this)[key].apply(this, args);
            resetTracking();
            return res;
        };
    });
    return instrumentations;
}
function createGetter(isReadonly = false, shallow = false) {
    return function get(target, key, receiver) {
        if (key === "__v_isReactive" /* IS_REACTIVE */) {
            return !isReadonly;
        }
        else if (key === "__v_isReadonly" /* IS_READONLY */) {
            return isReadonly;
        }
        else if (key === "__v_isShallow" /* IS_SHALLOW */) {
            return shallow;
        }
        else if (key === "__v_raw" /* RAW */ &&
            receiver ===
                (isReadonly
                    ? shallow
                        ? shallowReadonlyMap
                        : readonlyMap
                    : shallow
                        ? shallowReactiveMap
                        : reactiveMap).get(target)) {
            return target;
        }
        const targetIsArray = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target);
        if (!isReadonly && targetIsArray && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(arrayInstrumentations, key)) {
            return Reflect.get(arrayInstrumentations, key, receiver);
        }
        const res = Reflect.get(target, key, receiver);
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
            return res;
        }
        if (!isReadonly) {
            track(target, "get" /* GET */, key);
        }
        if (shallow) {
            return res;
        }
        if (isRef(res)) {
            // ref unwrapping - skip unwrap for Array + integer key.
            return targetIsArray && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isIntegerKey)(key) ? res : res.value;
        }
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(res)) {
            // Convert returned value into a proxy as well. we do the isObject check
            // here to avoid invalid value warning. Also need to lazy access readonly
            // and reactive here to avoid circular dependency.
            return isReadonly ? readonly(res) : reactive(res);
        }
        return res;
    };
}
const set = /*#__PURE__*/ createSetter();
const shallowSet = /*#__PURE__*/ createSetter(true);
function createSetter(shallow = false) {
    return function set(target, key, value, receiver) {
        let oldValue = target[key];
        if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
            return false;
        }
        if (!shallow && !isReadonly(value)) {
            if (!isShallow(value)) {
                value = toRaw(value);
                oldValue = toRaw(oldValue);
            }
            if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target) && isRef(oldValue) && !isRef(value)) {
                oldValue.value = value;
                return true;
            }
        }
        const hadKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isIntegerKey)(key)
            ? Number(key) < target.length
            : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(target, key);
        const result = Reflect.set(target, key, value, receiver);
        // don't trigger if target is something up in the prototype chain of original
        if (target === toRaw(receiver)) {
            if (!hadKey) {
                trigger(target, "add" /* ADD */, key, value);
            }
            else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(value, oldValue)) {
                trigger(target, "set" /* SET */, key, value, oldValue);
            }
        }
        return result;
    };
}
function deleteProperty(target, key) {
    const hadKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(target, key);
    const oldValue = target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
        trigger(target, "delete" /* DELETE */, key, undefined, oldValue);
    }
    return result;
}
function has(target, key) {
    const result = Reflect.has(target, key);
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(key) || !builtInSymbols.has(key)) {
        track(target, "has" /* HAS */, key);
    }
    return result;
}
function ownKeys(target) {
    track(target, "iterate" /* ITERATE */, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target) ? 'length' : ITERATE_KEY);
    return Reflect.ownKeys(target);
}
const mutableHandlers = {
    get,
    set,
    deleteProperty,
    has,
    ownKeys
};
const readonlyHandlers = {
    get: readonlyGet,
    set(target, key) {
        if ((true)) {
            warn(`Set operation on key "${String(key)}" failed: target is readonly.`, target);
        }
        return true;
    },
    deleteProperty(target, key) {
        if ((true)) {
            warn(`Delete operation on key "${String(key)}" failed: target is readonly.`, target);
        }
        return true;
    }
};
const shallowReactiveHandlers = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, mutableHandlers, {
    get: shallowGet,
    set: shallowSet
});
// Props handlers are special in the sense that it should not unwrap top-level
// refs (in order to allow refs to be explicitly passed down), but should
// retain the reactivity of the normal readonly object.
const shallowReadonlyHandlers = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, readonlyHandlers, {
    get: shallowReadonlyGet
});

const toShallow = (value) => value;
const getProto = (v) => Reflect.getPrototypeOf(v);
function get$1(target, key, isReadonly = false, isShallow = false) {
    // #1772: readonly(reactive(Map)) should return readonly + reactive version
    // of the value
    target = target["__v_raw" /* RAW */];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (!isReadonly) {
        if (key !== rawKey) {
            track(rawTarget, "get" /* GET */, key);
        }
        track(rawTarget, "get" /* GET */, rawKey);
    }
    const { has } = getProto(rawTarget);
    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
    if (has.call(rawTarget, key)) {
        return wrap(target.get(key));
    }
    else if (has.call(rawTarget, rawKey)) {
        return wrap(target.get(rawKey));
    }
    else if (target !== rawTarget) {
        // #3602 readonly(reactive(Map))
        // ensure that the nested reactive `Map` can do tracking for itself
        target.get(key);
    }
}
function has$1(key, isReadonly = false) {
    const target = this["__v_raw" /* RAW */];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (!isReadonly) {
        if (key !== rawKey) {
            track(rawTarget, "has" /* HAS */, key);
        }
        track(rawTarget, "has" /* HAS */, rawKey);
    }
    return key === rawKey
        ? target.has(key)
        : target.has(key) || target.has(rawKey);
}
function size(target, isReadonly = false) {
    target = target["__v_raw" /* RAW */];
    !isReadonly && track(toRaw(target), "iterate" /* ITERATE */, ITERATE_KEY);
    return Reflect.get(target, 'size', target);
}
function add(value) {
    value = toRaw(value);
    const target = toRaw(this);
    const proto = getProto(target);
    const hadKey = proto.has.call(target, value);
    if (!hadKey) {
        target.add(value);
        trigger(target, "add" /* ADD */, value, value);
    }
    return this;
}
function set$1(key, value) {
    value = toRaw(value);
    const target = toRaw(this);
    const { has, get } = getProto(target);
    let hadKey = has.call(target, key);
    if (!hadKey) {
        key = toRaw(key);
        hadKey = has.call(target, key);
    }
    else if ((true)) {
        checkIdentityKeys(target, has, key);
    }
    const oldValue = get.call(target, key);
    target.set(key, value);
    if (!hadKey) {
        trigger(target, "add" /* ADD */, key, value);
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(value, oldValue)) {
        trigger(target, "set" /* SET */, key, value, oldValue);
    }
    return this;
}
function deleteEntry(key) {
    const target = toRaw(this);
    const { has, get } = getProto(target);
    let hadKey = has.call(target, key);
    if (!hadKey) {
        key = toRaw(key);
        hadKey = has.call(target, key);
    }
    else if ((true)) {
        checkIdentityKeys(target, has, key);
    }
    const oldValue = get ? get.call(target, key) : undefined;
    // forward the operation before queueing reactions
    const result = target.delete(key);
    if (hadKey) {
        trigger(target, "delete" /* DELETE */, key, undefined, oldValue);
    }
    return result;
}
function clear() {
    const target = toRaw(this);
    const hadItems = target.size !== 0;
    const oldTarget = ( true)
        ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)
            ? new Map(target)
            : new Set(target)
        : 0;
    // forward the operation before queueing reactions
    const result = target.clear();
    if (hadItems) {
        trigger(target, "clear" /* CLEAR */, undefined, undefined, oldTarget);
    }
    return result;
}
function createForEach(isReadonly, isShallow) {
    return function forEach(callback, thisArg) {
        const observed = this;
        const target = observed["__v_raw" /* RAW */];
        const rawTarget = toRaw(target);
        const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
        !isReadonly && track(rawTarget, "iterate" /* ITERATE */, ITERATE_KEY);
        return target.forEach((value, key) => {
            // important: make sure the callback is
            // 1. invoked with the reactive map as `this` and 3rd arg
            // 2. the value received should be a corresponding reactive/readonly.
            return callback.call(thisArg, wrap(value), wrap(key), observed);
        });
    };
}
function createIterableMethod(method, isReadonly, isShallow) {
    return function (...args) {
        const target = this["__v_raw" /* RAW */];
        const rawTarget = toRaw(target);
        const targetIsMap = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(rawTarget);
        const isPair = method === 'entries' || (method === Symbol.iterator && targetIsMap);
        const isKeyOnly = method === 'keys' && targetIsMap;
        const innerIterator = target[method](...args);
        const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
        !isReadonly &&
            track(rawTarget, "iterate" /* ITERATE */, isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
        // return a wrapped iterator which returns observed versions of the
        // values emitted from the real iterator
        return {
            // iterator protocol
            next() {
                const { value, done } = innerIterator.next();
                return done
                    ? { value, done }
                    : {
                        value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
                        done
                    };
            },
            // iterable protocol
            [Symbol.iterator]() {
                return this;
            }
        };
    };
}
function createReadonlyMethod(type) {
    return function (...args) {
        if ((true)) {
            const key = args[0] ? `on key "${args[0]}" ` : ``;
            console.warn(`${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.capitalize)(type)} operation ${key}failed: target is readonly.`, toRaw(this));
        }
        return type === "delete" /* DELETE */ ? false : this;
    };
}
function createInstrumentations() {
    const mutableInstrumentations = {
        get(key) {
            return get$1(this, key);
        },
        get size() {
            return size(this);
        },
        has: has$1,
        add,
        set: set$1,
        delete: deleteEntry,
        clear,
        forEach: createForEach(false, false)
    };
    const shallowInstrumentations = {
        get(key) {
            return get$1(this, key, false, true);
        },
        get size() {
            return size(this);
        },
        has: has$1,
        add,
        set: set$1,
        delete: deleteEntry,
        clear,
        forEach: createForEach(false, true)
    };
    const readonlyInstrumentations = {
        get(key) {
            return get$1(this, key, true);
        },
        get size() {
            return size(this, true);
        },
        has(key) {
            return has$1.call(this, key, true);
        },
        add: createReadonlyMethod("add" /* ADD */),
        set: createReadonlyMethod("set" /* SET */),
        delete: createReadonlyMethod("delete" /* DELETE */),
        clear: createReadonlyMethod("clear" /* CLEAR */),
        forEach: createForEach(true, false)
    };
    const shallowReadonlyInstrumentations = {
        get(key) {
            return get$1(this, key, true, true);
        },
        get size() {
            return size(this, true);
        },
        has(key) {
            return has$1.call(this, key, true);
        },
        add: createReadonlyMethod("add" /* ADD */),
        set: createReadonlyMethod("set" /* SET */),
        delete: createReadonlyMethod("delete" /* DELETE */),
        clear: createReadonlyMethod("clear" /* CLEAR */),
        forEach: createForEach(true, true)
    };
    const iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator];
    iteratorMethods.forEach(method => {
        mutableInstrumentations[method] = createIterableMethod(method, false, false);
        readonlyInstrumentations[method] = createIterableMethod(method, true, false);
        shallowInstrumentations[method] = createIterableMethod(method, false, true);
        shallowReadonlyInstrumentations[method] = createIterableMethod(method, true, true);
    });
    return [
        mutableInstrumentations,
        readonlyInstrumentations,
        shallowInstrumentations,
        shallowReadonlyInstrumentations
    ];
}
const [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* #__PURE__*/ createInstrumentations();
function createInstrumentationGetter(isReadonly, shallow) {
    const instrumentations = shallow
        ? isReadonly
            ? shallowReadonlyInstrumentations
            : shallowInstrumentations
        : isReadonly
            ? readonlyInstrumentations
            : mutableInstrumentations;
    return (target, key, receiver) => {
        if (key === "__v_isReactive" /* IS_REACTIVE */) {
            return !isReadonly;
        }
        else if (key === "__v_isReadonly" /* IS_READONLY */) {
            return isReadonly;
        }
        else if (key === "__v_raw" /* RAW */) {
            return target;
        }
        return Reflect.get((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(instrumentations, key) && key in target
            ? instrumentations
            : target, key, receiver);
    };
}
const mutableCollectionHandlers = {
    get: /*#__PURE__*/ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
    get: /*#__PURE__*/ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
    get: /*#__PURE__*/ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
    get: /*#__PURE__*/ createInstrumentationGetter(true, true)
};
function checkIdentityKeys(target, has, key) {
    const rawKey = toRaw(key);
    if (rawKey !== key && has.call(target, rawKey)) {
        const type = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.toRawType)(target);
        console.warn(`Reactive ${type} contains both the raw and reactive ` +
            `versions of the same object${type === `Map` ? ` as keys` : ``}, ` +
            `which can lead to inconsistencies. ` +
            `Avoid differentiating between the raw and reactive versions ` +
            `of an object and only use the reactive version if possible.`);
    }
}

const reactiveMap = new WeakMap();
const shallowReactiveMap = new WeakMap();
const readonlyMap = new WeakMap();
const shallowReadonlyMap = new WeakMap();
function targetTypeMap(rawType) {
    switch (rawType) {
        case 'Object':
        case 'Array':
            return 1 /* COMMON */;
        case 'Map':
        case 'Set':
        case 'WeakMap':
        case 'WeakSet':
            return 2 /* COLLECTION */;
        default:
            return 0 /* INVALID */;
    }
}
function getTargetType(value) {
    return value["__v_skip" /* SKIP */] || !Object.isExtensible(value)
        ? 0 /* INVALID */
        : targetTypeMap((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.toRawType)(value));
}
function reactive(target) {
    // if trying to observe a readonly proxy, return the readonly version.
    if (isReadonly(target)) {
        return target;
    }
    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
}
/**
 * Return a shallowly-reactive copy of the original object, where only the root
 * level properties are reactive. It also does not auto-unwrap refs (even at the
 * root level).
 */
function shallowReactive(target) {
    return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
}
/**
 * Creates a readonly copy of the original object. Note the returned copy is not
 * made reactive, but `readonly` can be called on an already reactive object.
 */
function readonly(target) {
    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
}
/**
 * Returns a reactive-copy of the original object, where only the root level
 * properties are readonly, and does NOT unwrap refs nor recursively convert
 * returned properties.
 * This is used for creating the props proxy object for stateful components.
 */
function shallowReadonly(target) {
    return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);
}
function createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(target)) {
        if ((true)) {
            console.warn(`value cannot be made reactive: ${String(target)}`);
        }
        return target;
    }
    // target is already a Proxy, return it.
    // exception: calling readonly() on a reactive object
    if (target["__v_raw" /* RAW */] &&
        !(isReadonly && target["__v_isReactive" /* IS_REACTIVE */])) {
        return target;
    }
    // target already has corresponding Proxy
    const existingProxy = proxyMap.get(target);
    if (existingProxy) {
        return existingProxy;
    }
    // only specific value types can be observed.
    const targetType = getTargetType(target);
    if (targetType === 0 /* INVALID */) {
        return target;
    }
    const proxy = new Proxy(target, targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers);
    proxyMap.set(target, proxy);
    return proxy;
}
function isReactive(value) {
    if (isReadonly(value)) {
        return isReactive(value["__v_raw" /* RAW */]);
    }
    return !!(value && value["__v_isReactive" /* IS_REACTIVE */]);
}
function isReadonly(value) {
    return !!(value && value["__v_isReadonly" /* IS_READONLY */]);
}
function isShallow(value) {
    return !!(value && value["__v_isShallow" /* IS_SHALLOW */]);
}
function isProxy(value) {
    return isReactive(value) || isReadonly(value);
}
function toRaw(observed) {
    const raw = observed && observed["__v_raw" /* RAW */];
    return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.def)(value, "__v_skip" /* SKIP */, true);
    return value;
}
const toReactive = (value) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) ? reactive(value) : value;
const toReadonly = (value) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) ? readonly(value) : value;

function trackRefValue(ref) {
    if (shouldTrack && activeEffect) {
        ref = toRaw(ref);
        if ((true)) {
            trackEffects(ref.dep || (ref.dep = createDep()), {
                target: ref,
                type: "get" /* GET */,
                key: 'value'
            });
        }
        else {}
    }
}
function triggerRefValue(ref, newVal) {
    ref = toRaw(ref);
    if (ref.dep) {
        if ((true)) {
            triggerEffects(ref.dep, {
                target: ref,
                type: "set" /* SET */,
                key: 'value',
                newValue: newVal
            });
        }
        else {}
    }
}
function isRef(r) {
    return !!(r && r.__v_isRef === true);
}
function ref(value) {
    return createRef(value, false);
}
function shallowRef(value) {
    return createRef(value, true);
}
function createRef(rawValue, shallow) {
    if (isRef(rawValue)) {
        return rawValue;
    }
    return new RefImpl(rawValue, shallow);
}
class RefImpl {
    constructor(value, __v_isShallow) {
        this.__v_isShallow = __v_isShallow;
        this.dep = undefined;
        this.__v_isRef = true;
        this._rawValue = __v_isShallow ? value : toRaw(value);
        this._value = __v_isShallow ? value : toReactive(value);
    }
    get value() {
        trackRefValue(this);
        return this._value;
    }
    set value(newVal) {
        newVal = this.__v_isShallow ? newVal : toRaw(newVal);
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(newVal, this._rawValue)) {
            this._rawValue = newVal;
            this._value = this.__v_isShallow ? newVal : toReactive(newVal);
            triggerRefValue(this, newVal);
        }
    }
}
function triggerRef(ref) {
    triggerRefValue(ref, ( true) ? ref.value : 0);
}
function unref(ref) {
    return isRef(ref) ? ref.value : ref;
}
const shallowUnwrapHandlers = {
    get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
    set: (target, key, value, receiver) => {
        const oldValue = target[key];
        if (isRef(oldValue) && !isRef(value)) {
            oldValue.value = value;
            return true;
        }
        else {
            return Reflect.set(target, key, value, receiver);
        }
    }
};
function proxyRefs(objectWithRefs) {
    return isReactive(objectWithRefs)
        ? objectWithRefs
        : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
class CustomRefImpl {
    constructor(factory) {
        this.dep = undefined;
        this.__v_isRef = true;
        const { get, set } = factory(() => trackRefValue(this), () => triggerRefValue(this));
        this._get = get;
        this._set = set;
    }
    get value() {
        return this._get();
    }
    set value(newVal) {
        this._set(newVal);
    }
}
function customRef(factory) {
    return new CustomRefImpl(factory);
}
function toRefs(object) {
    if (( true) && !isProxy(object)) {
        console.warn(`toRefs() expects a reactive object but received a plain one.`);
    }
    const ret = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(object) ? new Array(object.length) : {};
    for (const key in object) {
        ret[key] = toRef(object, key);
    }
    return ret;
}
class ObjectRefImpl {
    constructor(_object, _key, _defaultValue) {
        this._object = _object;
        this._key = _key;
        this._defaultValue = _defaultValue;
        this.__v_isRef = true;
    }
    get value() {
        const val = this._object[this._key];
        return val === undefined ? this._defaultValue : val;
    }
    set value(newVal) {
        this._object[this._key] = newVal;
    }
}
function toRef(object, key, defaultValue) {
    const val = object[key];
    return isRef(val)
        ? val
        : new ObjectRefImpl(object, key, defaultValue);
}

class ComputedRefImpl {
    constructor(getter, _setter, isReadonly, isSSR) {
        this._setter = _setter;
        this.dep = undefined;
        this.__v_isRef = true;
        this._dirty = true;
        this.effect = new ReactiveEffect(getter, () => {
            if (!this._dirty) {
                this._dirty = true;
                triggerRefValue(this);
            }
        });
        this.effect.computed = this;
        this.effect.active = this._cacheable = !isSSR;
        this["__v_isReadonly" /* IS_READONLY */] = isReadonly;
    }
    get value() {
        // the computed ref may get wrapped by other proxies e.g. readonly() #3376
        const self = toRaw(this);
        trackRefValue(self);
        if (self._dirty || !self._cacheable) {
            self._dirty = false;
            self._value = self.effect.run();
        }
        return self._value;
    }
    set value(newValue) {
        this._setter(newValue);
    }
}
function computed(getterOrOptions, debugOptions, isSSR = false) {
    let getter;
    let setter;
    const onlyGetter = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isFunction)(getterOrOptions);
    if (onlyGetter) {
        getter = getterOrOptions;
        setter = ( true)
            ? () => {
                console.warn('Write operation failed: computed value is readonly');
            }
            : 0;
    }
    else {
        getter = getterOrOptions.get;
        setter = getterOrOptions.set;
    }
    const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
    if (( true) && debugOptions && !isSSR) {
        cRef.effect.onTrack = debugOptions.onTrack;
        cRef.effect.onTrigger = debugOptions.onTrigger;
    }
    return cRef;
}

var _a;
const tick = /*#__PURE__*/ Promise.resolve();
const queue = [];
let queued = false;
const scheduler = (fn) => {
    queue.push(fn);
    if (!queued) {
        queued = true;
        tick.then(flush);
    }
};
const flush = () => {
    for (let i = 0; i < queue.length; i++) {
        queue[i]();
    }
    queue.length = 0;
    queued = false;
};
class DeferredComputedRefImpl {
    constructor(getter) {
        this.dep = undefined;
        this._dirty = true;
        this.__v_isRef = true;
        this[_a] = true;
        let compareTarget;
        let hasCompareTarget = false;
        let scheduled = false;
        this.effect = new ReactiveEffect(getter, (computedTrigger) => {
            if (this.dep) {
                if (computedTrigger) {
                    compareTarget = this._value;
                    hasCompareTarget = true;
                }
                else if (!scheduled) {
                    const valueToCompare = hasCompareTarget ? compareTarget : this._value;
                    scheduled = true;
                    hasCompareTarget = false;
                    scheduler(() => {
                        if (this.effect.active && this._get() !== valueToCompare) {
                            triggerRefValue(this);
                        }
                        scheduled = false;
                    });
                }
                // chained upstream computeds are notified synchronously to ensure
                // value invalidation in case of sync access; normal effects are
                // deferred to be triggered in scheduler.
                for (const e of this.dep) {
                    if (e.computed instanceof DeferredComputedRefImpl) {
                        e.scheduler(true /* computedTrigger */);
                    }
                }
            }
            this._dirty = true;
        });
        this.effect.computed = this;
    }
    _get() {
        if (this._dirty) {
            this._dirty = false;
            return (this._value = this.effect.run());
        }
        return this._value;
    }
    get value() {
        trackRefValue(this);
        // the computed ref may get wrapped by other proxies e.g. readonly() #3376
        return toRaw(this)._get();
    }
}
_a = "__v_isReadonly" /* IS_READONLY */;
function deferredComputed(getter) {
    return new DeferredComputedRefImpl(getter);
}




/***/ }),

/***/ "./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseTransition": function() { return /* binding */ BaseTransition; },
/* harmony export */   "Comment": function() { return /* binding */ Comment; },
/* harmony export */   "EffectScope": function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.EffectScope; },
/* harmony export */   "Fragment": function() { return /* binding */ Fragment; },
/* harmony export */   "KeepAlive": function() { return /* binding */ KeepAlive; },
/* harmony export */   "ReactiveEffect": function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ReactiveEffect; },
/* harmony export */   "Static": function() { return /* binding */ Static; },
/* harmony export */   "Suspense": function() { return /* binding */ Suspense; },
/* harmony export */   "Teleport": function() { return /* binding */ Teleport; },
/* harmony export */   "Text": function() { return /* binding */ Text; },
/* harmony export */   "callWithAsyncErrorHandling": function() { return /* binding */ callWithAsyncErrorHandling; },
/* harmony export */   "callWithErrorHandling": function() { return /* binding */ callWithErrorHandling; },
/* harmony export */   "camelize": function() { return /* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize; },
/* harmony export */   "capitalize": function() { return /* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize; },
/* harmony export */   "cloneVNode": function() { return /* binding */ cloneVNode; },
/* harmony export */   "compatUtils": function() { return /* binding */ compatUtils; },
/* harmony export */   "computed": function() { return /* binding */ computed; },
/* harmony export */   "createBlock": function() { return /* binding */ createBlock; },
/* harmony export */   "createCommentVNode": function() { return /* binding */ createCommentVNode; },
/* harmony export */   "createElementBlock": function() { return /* binding */ createElementBlock; },
/* harmony export */   "createElementVNode": function() { return /* binding */ createBaseVNode; },
/* harmony export */   "createHydrationRenderer": function() { return /* binding */ createHydrationRenderer; },
/* harmony export */   "createPropsRestProxy": function() { return /* binding */ createPropsRestProxy; },
/* harmony export */   "createRenderer": function() { return /* binding */ createRenderer; },
/* harmony export */   "createSlots": function() { return /* binding */ createSlots; },
/* harmony export */   "createStaticVNode": function() { return /* binding */ createStaticVNode; },
/* harmony export */   "createTextVNode": function() { return /* binding */ createTextVNode; },
/* harmony export */   "createVNode": function() { return /* binding */ createVNode; },
/* harmony export */   "customRef": function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.customRef; },
/* harmony export */   "defineAsyncComponent": function() { return /* binding */ defineAsyncComponent; },
/* harmony export */   "defineComponent": function() { return /* binding */ defineComponent; },
/* harmony export */   "defineEmits": function() { return /* binding */ defineEmits; },
/* harmony export */   "defineExpose": function() { return /* binding */ defineExpose; },
/* harmony export */   "defineProps": function() { return /* binding */ defineProps; },
/* harmony export */   "devtools": function() { return /* binding */ devtools; },
/* harmony export */   "effect": function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.effect; },
/* harmony export */   "effectScope": function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.effectScope; },
/* harmony export */   "getCurrentInstance": function() { return /* binding */ getCurrentInstance; },
/* harmony export */   "getCurrentScope": function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.getCurrentScope; },
/* harmony export */   "getTransitionRawChildren": function() { return /* binding */ getTransitionRawChildren; },
/* harmony export */   "guardReactiveProps": function() { return /* binding */ guardReactiveProps; },
/* harmony export */   "h": function() { return /* binding */ h; },
/* harmony export */   "handleError": function() { return /* binding */ handleError; },
/* harmony export */   "initCustomFormatter": function() { return /* binding */ initCustomFormatter; },
/* harmony export */   "inject": function() { return /* binding */ inject; },
/* harmony export */   "isMemoSame": function() { return /* binding */ isMemoSame; },
/* harmony export */   "isProxy": function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy; },
/* harmony export */   "isReactive": function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive; },
/* harmony export */   "isReadonly": function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReadonly; },
/* harmony export */   "isRef": function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef; },
/* harmony export */   "isRuntimeOnly": function() { return /* binding */ isRuntimeOnly; },
/* harmony export */   "isShallow": function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isShallow; },
/* harmony export */   "isVNode": function() { return /* binding */ isVNode; },
/* harmony export */   "markRaw": function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.markRaw; },
/* harmony export */   "mergeDefaults": function() { return /* binding */ mergeDefaults; },
/* harmony export */   "mergeProps": function() { return /* binding */ mergeProps; },
/* harmony export */   "nextTick": function() { return /* binding */ nextTick; },
/* harmony export */   "normalizeClass": function() { return /* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeClass; },
/* harmony export */   "normalizeProps": function() { return /* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeProps; },
/* harmony export */   "normalizeStyle": function() { return /* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeStyle; },
/* harmony export */   "onActivated": function() { return /* binding */ onActivated; },
/* harmony export */   "onBeforeMount": function() { return /* binding */ onBeforeMount; },
/* harmony export */   "onBeforeUnmount": function() { return /* binding */ onBeforeUnmount; },
/* harmony export */   "onBeforeUpdate": function() { return /* binding */ onBeforeUpdate; },
/* harmony export */   "onDeactivated": function() { return /* binding */ onDeactivated; },
/* harmony export */   "onErrorCaptured": function() { return /* binding */ onErrorCaptured; },
/* harmony export */   "onMounted": function() { return /* binding */ onMounted; },
/* harmony export */   "onRenderTracked": function() { return /* binding */ onRenderTracked; },
/* harmony export */   "onRenderTriggered": function() { return /* binding */ onRenderTriggered; },
/* harmony export */   "onScopeDispose": function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.onScopeDispose; },
/* harmony export */   "onServerPrefetch": function() { return /* binding */ onServerPrefetch; },
/* harmony export */   "onUnmounted": function() { return /* binding */ onUnmounted; },
/* harmony export */   "onUpdated": function() { return /* binding */ onUpdated; },
/* harmony export */   "openBlock": function() { return /* binding */ openBlock; },
/* harmony export */   "popScopeId": function() { return /* binding */ popScopeId; },
/* harmony export */   "provide": function() { return /* binding */ provide; },
/* harmony export */   "proxyRefs": function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.proxyRefs; },
/* harmony export */   "pushScopeId": function() { return /* binding */ pushScopeId; },
/* harmony export */   "queuePostFlushCb": function() { return /* binding */ queuePostFlushCb; },
/* harmony export */   "reactive": function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.reactive; },
/* harmony export */   "readonly": function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.readonly; },
/* harmony export */   "ref": function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref; },
/* harmony export */   "registerRuntimeCompiler": function() { return /* binding */ registerRuntimeCompiler; },
/* harmony export */   "renderList": function() { return /* binding */ renderList; },
/* harmony export */   "renderSlot": function() { return /* binding */ renderSlot; },
/* harmony export */   "resolveComponent": function() { return /* binding */ resolveComponent; },
/* harmony export */   "resolveDirective": function() { return /* binding */ resolveDirective; },
/* harmony export */   "resolveDynamicComponent": function() { return /* binding */ resolveDynamicComponent; },
/* harmony export */   "resolveFilter": function() { return /* binding */ resolveFilter; },
/* harmony export */   "resolveTransitionHooks": function() { return /* binding */ resolveTransitionHooks; },
/* harmony export */   "setBlockTracking": function() { return /* binding */ setBlockTracking; },
/* harmony export */   "setDevtoolsHook": function() { return /* binding */ setDevtoolsHook; },
/* harmony export */   "setTransitionHooks": function() { return /* binding */ setTransitionHooks; },
/* harmony export */   "shallowReactive": function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReactive; },
/* harmony export */   "shallowReadonly": function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly; },
/* harmony export */   "shallowRef": function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowRef; },
/* harmony export */   "ssrContextKey": function() { return /* binding */ ssrContextKey; },
/* harmony export */   "ssrUtils": function() { return /* binding */ ssrUtils; },
/* harmony export */   "stop": function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.stop; },
/* harmony export */   "toDisplayString": function() { return /* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.toDisplayString; },
/* harmony export */   "toHandlerKey": function() { return /* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey; },
/* harmony export */   "toHandlers": function() { return /* binding */ toHandlers; },
/* harmony export */   "toRaw": function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw; },
/* harmony export */   "toRef": function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRef; },
/* harmony export */   "toRefs": function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRefs; },
/* harmony export */   "transformVNodeArgs": function() { return /* binding */ transformVNodeArgs; },
/* harmony export */   "triggerRef": function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.triggerRef; },
/* harmony export */   "unref": function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.unref; },
/* harmony export */   "useAttrs": function() { return /* binding */ useAttrs; },
/* harmony export */   "useSSRContext": function() { return /* binding */ useSSRContext; },
/* harmony export */   "useSlots": function() { return /* binding */ useSlots; },
/* harmony export */   "useTransitionState": function() { return /* binding */ useTransitionState; },
/* harmony export */   "version": function() { return /* binding */ version; },
/* harmony export */   "warn": function() { return /* binding */ warn; },
/* harmony export */   "watch": function() { return /* binding */ watch; },
/* harmony export */   "watchEffect": function() { return /* binding */ watchEffect; },
/* harmony export */   "watchPostEffect": function() { return /* binding */ watchPostEffect; },
/* harmony export */   "watchSyncEffect": function() { return /* binding */ watchSyncEffect; },
/* harmony export */   "withAsyncContext": function() { return /* binding */ withAsyncContext; },
/* harmony export */   "withCtx": function() { return /* binding */ withCtx; },
/* harmony export */   "withDefaults": function() { return /* binding */ withDefaults; },
/* harmony export */   "withDirectives": function() { return /* binding */ withDirectives; },
/* harmony export */   "withMemo": function() { return /* binding */ withMemo; },
/* harmony export */   "withScopeId": function() { return /* binding */ withScopeId; }
/* harmony export */ });
/* harmony import */ var _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/reactivity */ "./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js");
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");





const stack = [];
function pushWarningContext(vnode) {
    stack.push(vnode);
}
function popWarningContext() {
    stack.pop();
}
function warn(msg, ...args) {
    // avoid props formatting or warn handler tracking deps that might be mutated
    // during patch, leading to infinite recursion.
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
    const instance = stack.length ? stack[stack.length - 1].component : null;
    const appWarnHandler = instance && instance.appContext.config.warnHandler;
    const trace = getComponentTrace();
    if (appWarnHandler) {
        callWithErrorHandling(appWarnHandler, instance, 11 /* APP_WARN_HANDLER */, [
            msg + args.join(''),
            instance && instance.proxy,
            trace
                .map(({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`)
                .join('\n'),
            trace
        ]);
    }
    else {
        const warnArgs = [`[Vue warn]: ${msg}`, ...args];
        /* istanbul ignore if */
        if (trace.length &&
            // avoid spamming console during tests
            !false) {
            warnArgs.push(`\n`, ...formatTrace(trace));
        }
        console.warn(...warnArgs);
    }
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
}
function getComponentTrace() {
    let currentVNode = stack[stack.length - 1];
    if (!currentVNode) {
        return [];
    }
    // we can't just use the stack because it will be incomplete during updates
    // that did not start from the root. Re-construct the parent chain using
    // instance parent pointers.
    const normalizedStack = [];
    while (currentVNode) {
        const last = normalizedStack[0];
        if (last && last.vnode === currentVNode) {
            last.recurseCount++;
        }
        else {
            normalizedStack.push({
                vnode: currentVNode,
                recurseCount: 0
            });
        }
        const parentInstance = currentVNode.component && currentVNode.component.parent;
        currentVNode = parentInstance && parentInstance.vnode;
    }
    return normalizedStack;
}
/* istanbul ignore next */
function formatTrace(trace) {
    const logs = [];
    trace.forEach((entry, i) => {
        logs.push(...(i === 0 ? [] : [`\n`]), ...formatTraceEntry(entry));
    });
    return logs;
}
function formatTraceEntry({ vnode, recurseCount }) {
    const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
    const isRoot = vnode.component ? vnode.component.parent == null : false;
    const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;
    const close = `>` + postfix;
    return vnode.props
        ? [open, ...formatProps(vnode.props), close]
        : [open + close];
}
/* istanbul ignore next */
function formatProps(props) {
    const res = [];
    const keys = Object.keys(props);
    keys.slice(0, 3).forEach(key => {
        res.push(...formatProp(key, props[key]));
    });
    if (keys.length > 3) {
        res.push(` ...`);
    }
    return res;
}
/* istanbul ignore next */
function formatProp(key, value, raw) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(value)) {
        value = JSON.stringify(value);
        return raw ? value : [`${key}=${value}`];
    }
    else if (typeof value === 'number' ||
        typeof value === 'boolean' ||
        value == null) {
        return raw ? value : [`${key}=${value}`];
    }
    else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(value)) {
        value = formatProp(key, (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(value.value), true);
        return raw ? value : [`${key}=Ref<`, value, `>`];
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {
        return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
    }
    else {
        value = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(value);
        return raw ? value : [`${key}=`, value];
    }
}

const ErrorTypeStrings = {
    ["sp" /* SERVER_PREFETCH */]: 'serverPrefetch hook',
    ["bc" /* BEFORE_CREATE */]: 'beforeCreate hook',
    ["c" /* CREATED */]: 'created hook',
    ["bm" /* BEFORE_MOUNT */]: 'beforeMount hook',
    ["m" /* MOUNTED */]: 'mounted hook',
    ["bu" /* BEFORE_UPDATE */]: 'beforeUpdate hook',
    ["u" /* UPDATED */]: 'updated',
    ["bum" /* BEFORE_UNMOUNT */]: 'beforeUnmount hook',
    ["um" /* UNMOUNTED */]: 'unmounted hook',
    ["a" /* ACTIVATED */]: 'activated hook',
    ["da" /* DEACTIVATED */]: 'deactivated hook',
    ["ec" /* ERROR_CAPTURED */]: 'errorCaptured hook',
    ["rtc" /* RENDER_TRACKED */]: 'renderTracked hook',
    ["rtg" /* RENDER_TRIGGERED */]: 'renderTriggered hook',
    [0 /* SETUP_FUNCTION */]: 'setup function',
    [1 /* RENDER_FUNCTION */]: 'render function',
    [2 /* WATCH_GETTER */]: 'watcher getter',
    [3 /* WATCH_CALLBACK */]: 'watcher callback',
    [4 /* WATCH_CLEANUP */]: 'watcher cleanup function',
    [5 /* NATIVE_EVENT_HANDLER */]: 'native event handler',
    [6 /* COMPONENT_EVENT_HANDLER */]: 'component event handler',
    [7 /* VNODE_HOOK */]: 'vnode hook',
    [8 /* DIRECTIVE_HOOK */]: 'directive hook',
    [9 /* TRANSITION_HOOK */]: 'transition hook',
    [10 /* APP_ERROR_HANDLER */]: 'app errorHandler',
    [11 /* APP_WARN_HANDLER */]: 'app warnHandler',
    [12 /* FUNCTION_REF */]: 'ref function',
    [13 /* ASYNC_COMPONENT_LOADER */]: 'async component loader',
    [14 /* SCHEDULER */]: 'scheduler flush. This is likely a Vue internals bug. ' +
        'Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core'
};
function callWithErrorHandling(fn, instance, type, args) {
    let res;
    try {
        res = args ? fn(...args) : fn();
    }
    catch (err) {
        handleError(err, instance, type);
    }
    return res;
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(fn)) {
        const res = callWithErrorHandling(fn, instance, type, args);
        if (res && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(res)) {
            res.catch(err => {
                handleError(err, instance, type);
            });
        }
        return res;
    }
    const values = [];
    for (let i = 0; i < fn.length; i++) {
        values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
    }
    return values;
}
function handleError(err, instance, type, throwInDev = true) {
    const contextVNode = instance ? instance.vnode : null;
    if (instance) {
        let cur = instance.parent;
        // the exposed instance is the render proxy to keep it consistent with 2.x
        const exposedInstance = instance.proxy;
        // in production the hook receives only the error code
        const errorInfo = ( true) ? ErrorTypeStrings[type] : 0;
        while (cur) {
            const errorCapturedHooks = cur.ec;
            if (errorCapturedHooks) {
                for (let i = 0; i < errorCapturedHooks.length; i++) {
                    if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
                        return;
                    }
                }
            }
            cur = cur.parent;
        }
        // app-level handling
        const appErrorHandler = instance.appContext.config.errorHandler;
        if (appErrorHandler) {
            callWithErrorHandling(appErrorHandler, null, 10 /* APP_ERROR_HANDLER */, [err, exposedInstance, errorInfo]);
            return;
        }
    }
    logError(err, type, contextVNode, throwInDev);
}
function logError(err, type, contextVNode, throwInDev = true) {
    if ((true)) {
        const info = ErrorTypeStrings[type];
        if (contextVNode) {
            pushWarningContext(contextVNode);
        }
        warn(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
        if (contextVNode) {
            popWarningContext();
        }
        // crash in dev by default so it's more noticeable
        if (throwInDev) {
            throw err;
        }
        else {
            console.error(err);
        }
    }
    else {}
}

let isFlushing = false;
let isFlushPending = false;
const queue = [];
let flushIndex = 0;
const pendingPreFlushCbs = [];
let activePreFlushCbs = null;
let preFlushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /*#__PURE__*/ Promise.resolve();
let currentFlushPromise = null;
let currentPreFlushParentJob = null;
const RECURSION_LIMIT = 100;
function nextTick(fn) {
    const p = currentFlushPromise || resolvedPromise;
    return fn ? p.then(this ? fn.bind(this) : fn) : p;
}
// #2768
// Use binary-search to find a suitable position in the queue,
// so that the queue maintains the increasing order of job's id,
// which can prevent the job from being skipped and also can avoid repeated patching.
function findInsertionIndex(id) {
    // the start index should be `flushIndex + 1`
    let start = flushIndex + 1;
    let end = queue.length;
    while (start < end) {
        const middle = (start + end) >>> 1;
        const middleJobId = getId(queue[middle]);
        middleJobId < id ? (start = middle + 1) : (end = middle);
    }
    return start;
}
function queueJob(job) {
    // the dedupe search uses the startIndex argument of Array.includes()
    // by default the search index includes the current job that is being run
    // so it cannot recursively trigger itself again.
    // if the job is a watch() callback, the search will start with a +1 index to
    // allow it recursively trigger itself - it is the user's responsibility to
    // ensure it doesn't end up in an infinite loop.
    if ((!queue.length ||
        !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) &&
        job !== currentPreFlushParentJob) {
        if (job.id == null) {
            queue.push(job);
        }
        else {
            queue.splice(findInsertionIndex(job.id), 0, job);
        }
        queueFlush();
    }
}
function queueFlush() {
    if (!isFlushing && !isFlushPending) {
        isFlushPending = true;
        currentFlushPromise = resolvedPromise.then(flushJobs);
    }
}
function invalidateJob(job) {
    const i = queue.indexOf(job);
    if (i > flushIndex) {
        queue.splice(i, 1);
    }
}
function queueCb(cb, activeQueue, pendingQueue, index) {
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(cb)) {
        if (!activeQueue ||
            !activeQueue.includes(cb, cb.allowRecurse ? index + 1 : index)) {
            pendingQueue.push(cb);
        }
    }
    else {
        // if cb is an array, it is a component lifecycle hook which can only be
        // triggered by a job, which is already deduped in the main queue, so
        // we can skip duplicate check here to improve perf
        pendingQueue.push(...cb);
    }
    queueFlush();
}
function queuePreFlushCb(cb) {
    queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex);
}
function queuePostFlushCb(cb) {
    queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex);
}
function flushPreFlushCbs(seen, parentJob = null) {
    if (pendingPreFlushCbs.length) {
        currentPreFlushParentJob = parentJob;
        activePreFlushCbs = [...new Set(pendingPreFlushCbs)];
        pendingPreFlushCbs.length = 0;
        if ((true)) {
            seen = seen || new Map();
        }
        for (preFlushIndex = 0; preFlushIndex < activePreFlushCbs.length; preFlushIndex++) {
            if (( true) &&
                checkRecursiveUpdates(seen, activePreFlushCbs[preFlushIndex])) {
                continue;
            }
            activePreFlushCbs[preFlushIndex]();
        }
        activePreFlushCbs = null;
        preFlushIndex = 0;
        currentPreFlushParentJob = null;
        // recursively flush until it drains
        flushPreFlushCbs(seen, parentJob);
    }
}
function flushPostFlushCbs(seen) {
    // flush any pre cbs queued during the flush (e.g. pre watchers)
    flushPreFlushCbs();
    if (pendingPostFlushCbs.length) {
        const deduped = [...new Set(pendingPostFlushCbs)];
        pendingPostFlushCbs.length = 0;
        // #1947 already has active queue, nested flushPostFlushCbs call
        if (activePostFlushCbs) {
            activePostFlushCbs.push(...deduped);
            return;
        }
        activePostFlushCbs = deduped;
        if ((true)) {
            seen = seen || new Map();
        }
        activePostFlushCbs.sort((a, b) => getId(a) - getId(b));
        for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
            if (( true) &&
                checkRecursiveUpdates(seen, activePostFlushCbs[postFlushIndex])) {
                continue;
            }
            activePostFlushCbs[postFlushIndex]();
        }
        activePostFlushCbs = null;
        postFlushIndex = 0;
    }
}
const getId = (job) => job.id == null ? Infinity : job.id;
function flushJobs(seen) {
    isFlushPending = false;
    isFlushing = true;
    if ((true)) {
        seen = seen || new Map();
    }
    flushPreFlushCbs(seen);
    // Sort queue before flush.
    // This ensures that:
    // 1. Components are updated from parent to child. (because parent is always
    //    created before the child so its render effect will have smaller
    //    priority number)
    // 2. If a component is unmounted during a parent component's update,
    //    its update can be skipped.
    queue.sort((a, b) => getId(a) - getId(b));
    // conditional usage of checkRecursiveUpdate must be determined out of
    // try ... catch block since Rollup by default de-optimizes treeshaking
    // inside try-catch. This can leave all warning code unshaked. Although
    // they would get eventually shaken by a minifier like terser, some minifiers
    // would fail to do that (e.g. https://github.com/evanw/esbuild/issues/1610)
    const check = ( true)
        ? (job) => checkRecursiveUpdates(seen, job)
        : 0;
    try {
        for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
            const job = queue[flushIndex];
            if (job && job.active !== false) {
                if (( true) && check(job)) {
                    continue;
                }
                // console.log(`running:`, job.id)
                callWithErrorHandling(job, null, 14 /* SCHEDULER */);
            }
        }
    }
    finally {
        flushIndex = 0;
        queue.length = 0;
        flushPostFlushCbs(seen);
        isFlushing = false;
        currentFlushPromise = null;
        // some postFlushCb queued jobs!
        // keep flushing until it drains.
        if (queue.length ||
            pendingPreFlushCbs.length ||
            pendingPostFlushCbs.length) {
            flushJobs(seen);
        }
    }
}
function checkRecursiveUpdates(seen, fn) {
    if (!seen.has(fn)) {
        seen.set(fn, 1);
    }
    else {
        const count = seen.get(fn);
        if (count > RECURSION_LIMIT) {
            const instance = fn.ownerInstance;
            const componentName = instance && getComponentName(instance.type);
            warn(`Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. ` +
                `This means you have a reactive effect that is mutating its own ` +
                `dependencies and thus recursively triggering itself. Possible sources ` +
                `include component template, render function, updated hook or ` +
                `watcher source function.`);
            return true;
        }
        else {
            seen.set(fn, count + 1);
        }
    }
}

/* eslint-disable no-restricted-globals */
let isHmrUpdating = false;
const hmrDirtyComponents = new Set();
// Expose the HMR runtime on the global object
// This makes it entirely tree-shakable without polluting the exports and makes
// it easier to be used in toolings like vue-loader
// Note: for a component to be eligible for HMR it also needs the __hmrId option
// to be set so that its instances can be registered / removed.
if ((true)) {
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)().__VUE_HMR_RUNTIME__ = {
        createRecord: tryWrap(createRecord),
        rerender: tryWrap(rerender),
        reload: tryWrap(reload)
    };
}
const map = new Map();
function registerHMR(instance) {
    const id = instance.type.__hmrId;
    let record = map.get(id);
    if (!record) {
        createRecord(id, instance.type);
        record = map.get(id);
    }
    record.instances.add(instance);
}
function unregisterHMR(instance) {
    map.get(instance.type.__hmrId).instances.delete(instance);
}
function createRecord(id, initialDef) {
    if (map.has(id)) {
        return false;
    }
    map.set(id, {
        initialDef: normalizeClassComponent(initialDef),
        instances: new Set()
    });
    return true;
}
function normalizeClassComponent(component) {
    return isClassComponent(component) ? component.__vccOpts : component;
}
function rerender(id, newRender) {
    const record = map.get(id);
    if (!record) {
        return;
    }
    // update initial record (for not-yet-rendered component)
    record.initialDef.render = newRender;
    [...record.instances].forEach(instance => {
        if (newRender) {
            instance.render = newRender;
            normalizeClassComponent(instance.type).render = newRender;
        }
        instance.renderCache = [];
        // this flag forces child components with slot content to update
        isHmrUpdating = true;
        instance.update();
        isHmrUpdating = false;
    });
}
function reload(id, newComp) {
    const record = map.get(id);
    if (!record)
        return;
    newComp = normalizeClassComponent(newComp);
    // update initial def (for not-yet-rendered components)
    updateComponentDef(record.initialDef, newComp);
    // create a snapshot which avoids the set being mutated during updates
    const instances = [...record.instances];
    for (const instance of instances) {
        const oldComp = normalizeClassComponent(instance.type);
        if (!hmrDirtyComponents.has(oldComp)) {
            // 1. Update existing comp definition to match new one
            if (oldComp !== record.initialDef) {
                updateComponentDef(oldComp, newComp);
            }
            // 2. mark definition dirty. This forces the renderer to replace the
            // component on patch.
            hmrDirtyComponents.add(oldComp);
        }
        // 3. invalidate options resolution cache
        instance.appContext.optionsCache.delete(instance.type);
        // 4. actually update
        if (instance.ceReload) {
            // custom element
            hmrDirtyComponents.add(oldComp);
            instance.ceReload(newComp.styles);
            hmrDirtyComponents.delete(oldComp);
        }
        else if (instance.parent) {
            // 4. Force the parent instance to re-render. This will cause all updated
            // components to be unmounted and re-mounted. Queue the update so that we
            // don't end up forcing the same parent to re-render multiple times.
            queueJob(instance.parent.update);
            // instance is the inner component of an async custom element
            // invoke to reset styles
            if (instance.parent.type.__asyncLoader &&
                instance.parent.ceReload) {
                instance.parent.ceReload(newComp.styles);
            }
        }
        else if (instance.appContext.reload) {
            // root instance mounted via createApp() has a reload method
            instance.appContext.reload();
        }
        else if (typeof window !== 'undefined') {
            // root instance inside tree created via raw render(). Force reload.
            window.location.reload();
        }
        else {
            console.warn('[HMR] Root or manually mounted instance modified. Full reload required.');
        }
    }
    // 5. make sure to cleanup dirty hmr components after update
    queuePostFlushCb(() => {
        for (const instance of instances) {
            hmrDirtyComponents.delete(normalizeClassComponent(instance.type));
        }
    });
}
function updateComponentDef(oldComp, newComp) {
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(oldComp, newComp);
    for (const key in oldComp) {
        if (key !== '__file' && !(key in newComp)) {
            delete oldComp[key];
        }
    }
}
function tryWrap(fn) {
    return (id, arg) => {
        try {
            return fn(id, arg);
        }
        catch (e) {
            console.error(e);
            console.warn(`[HMR] Something went wrong during Vue component hot-reload. ` +
                `Full reload required.`);
        }
    };
}

let devtools;
let buffer = [];
let devtoolsNotInstalled = false;
function emit(event, ...args) {
    if (devtools) {
        devtools.emit(event, ...args);
    }
    else if (!devtoolsNotInstalled) {
        buffer.push({ event, args });
    }
}
function setDevtoolsHook(hook, target) {
    var _a, _b;
    devtools = hook;
    if (devtools) {
        devtools.enabled = true;
        buffer.forEach(({ event, args }) => devtools.emit(event, ...args));
        buffer = [];
    }
    else if (
    // handle late devtools injection - only do this if we are in an actual
    // browser environment to avoid the timer handle stalling test runner exit
    // (#4815)
    typeof window !== 'undefined' &&
        // some envs mock window but not fully
        window.HTMLElement &&
        // also exclude jsdom
        !((_b = (_a = window.navigator) === null || _a === void 0 ? void 0 : _a.userAgent) === null || _b === void 0 ? void 0 : _b.includes('jsdom'))) {
        const replay = (target.__VUE_DEVTOOLS_HOOK_REPLAY__ =
            target.__VUE_DEVTOOLS_HOOK_REPLAY__ || []);
        replay.push((newHook) => {
            setDevtoolsHook(newHook, target);
        });
        // clear buffer after 3s - the user probably doesn't have devtools installed
        // at all, and keeping the buffer will cause memory leaks (#4738)
        setTimeout(() => {
            if (!devtools) {
                target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
                devtoolsNotInstalled = true;
                buffer = [];
            }
        }, 3000);
    }
    else {
        // non-browser env, assume not installed
        devtoolsNotInstalled = true;
        buffer = [];
    }
}
function devtoolsInitApp(app, version) {
    emit("app:init" /* APP_INIT */, app, version, {
        Fragment,
        Text,
        Comment,
        Static
    });
}
function devtoolsUnmountApp(app) {
    emit("app:unmount" /* APP_UNMOUNT */, app);
}
const devtoolsComponentAdded = /*#__PURE__*/ createDevtoolsComponentHook("component:added" /* COMPONENT_ADDED */);
const devtoolsComponentUpdated = 
/*#__PURE__*/ createDevtoolsComponentHook("component:updated" /* COMPONENT_UPDATED */);
const devtoolsComponentRemoved = 
/*#__PURE__*/ createDevtoolsComponentHook("component:removed" /* COMPONENT_REMOVED */);
function createDevtoolsComponentHook(hook) {
    return (component) => {
        emit(hook, component.appContext.app, component.uid, component.parent ? component.parent.uid : undefined, component);
    };
}
const devtoolsPerfStart = /*#__PURE__*/ createDevtoolsPerformanceHook("perf:start" /* PERFORMANCE_START */);
const devtoolsPerfEnd = /*#__PURE__*/ createDevtoolsPerformanceHook("perf:end" /* PERFORMANCE_END */);
function createDevtoolsPerformanceHook(hook) {
    return (component, type, time) => {
        emit(hook, component.appContext.app, component.uid, component, type, time);
    };
}
function devtoolsComponentEmit(component, event, params) {
    emit("component:emit" /* COMPONENT_EMIT */, component.appContext.app, component, event, params);
}

function emit$1(instance, event, ...rawArgs) {
    if (instance.isUnmounted)
        return;
    const props = instance.vnode.props || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
    if ((true)) {
        const { emitsOptions, propsOptions: [propsOptions] } = instance;
        if (emitsOptions) {
            if (!(event in emitsOptions) &&
                !(false )) {
                if (!propsOptions || !((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(event) in propsOptions)) {
                    warn(`Component emitted event "${event}" but it is neither declared in ` +
                        `the emits option nor as an "${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(event)}" prop.`);
                }
            }
            else {
                const validator = emitsOptions[event];
                if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(validator)) {
                    const isValid = validator(...rawArgs);
                    if (!isValid) {
                        warn(`Invalid event arguments: event validation failed for event "${event}".`);
                    }
                }
            }
        }
    }
    let args = rawArgs;
    const isModelListener = event.startsWith('update:');
    // for v-model update:xxx events, apply modifiers on args
    const modelArg = isModelListener && event.slice(7);
    if (modelArg && modelArg in props) {
        const modifiersKey = `${modelArg === 'modelValue' ? 'model' : modelArg}Modifiers`;
        const { number, trim } = props[modifiersKey] || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
        if (trim) {
            args = rawArgs.map(a => a.trim());
        }
        if (number) {
            args = rawArgs.map(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber);
        }
    }
    if (true) {
        devtoolsComponentEmit(instance, event, args);
    }
    if ((true)) {
        const lowerCaseEvent = event.toLowerCase();
        if (lowerCaseEvent !== event && props[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(lowerCaseEvent)]) {
            warn(`Event "${lowerCaseEvent}" is emitted in component ` +
                `${formatComponentName(instance, instance.type)} but the handler is registered for "${event}". ` +
                `Note that HTML attributes are case-insensitive and you cannot use ` +
                `v-on to listen to camelCase events when using in-DOM templates. ` +
                `You should probably use "${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(event)}" instead of "${event}".`);
        }
    }
    let handlerName;
    let handler = props[(handlerName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(event))] ||
        // also try camelCase event handler (#2249)
        props[(handlerName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(event)))];
    // for v-model update:xxx events, also trigger kebab-case equivalent
    // for props passed via kebab-case
    if (!handler && isModelListener) {
        handler = props[(handlerName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(event)))];
    }
    if (handler) {
        callWithAsyncErrorHandling(handler, instance, 6 /* COMPONENT_EVENT_HANDLER */, args);
    }
    const onceHandler = props[handlerName + `Once`];
    if (onceHandler) {
        if (!instance.emitted) {
            instance.emitted = {};
        }
        else if (instance.emitted[handlerName]) {
            return;
        }
        instance.emitted[handlerName] = true;
        callWithAsyncErrorHandling(onceHandler, instance, 6 /* COMPONENT_EVENT_HANDLER */, args);
    }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
    const cache = appContext.emitsCache;
    const cached = cache.get(comp);
    if (cached !== undefined) {
        return cached;
    }
    const raw = comp.emits;
    let normalized = {};
    // apply mixin/extends props
    let hasExtends = false;
    if (__VUE_OPTIONS_API__ && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(comp)) {
        const extendEmits = (raw) => {
            const normalizedFromExtend = normalizeEmitsOptions(raw, appContext, true);
            if (normalizedFromExtend) {
                hasExtends = true;
                (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(normalized, normalizedFromExtend);
            }
        };
        if (!asMixin && appContext.mixins.length) {
            appContext.mixins.forEach(extendEmits);
        }
        if (comp.extends) {
            extendEmits(comp.extends);
        }
        if (comp.mixins) {
            comp.mixins.forEach(extendEmits);
        }
    }
    if (!raw && !hasExtends) {
        cache.set(comp, null);
        return null;
    }
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {
        raw.forEach(key => (normalized[key] = null));
    }
    else {
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(normalized, raw);
    }
    cache.set(comp, normalized);
    return normalized;
}
// Check if an incoming prop key is a declared emit event listener.
// e.g. With `emits: { click: null }`, props named `onClick` and `onclick` are
// both considered matched listeners.
function isEmitListener(options, key) {
    if (!options || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
        return false;
    }
    key = key.slice(2).replace(/Once$/, '');
    return ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, key[0].toLowerCase() + key.slice(1)) ||
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key)) ||
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, key));
}

/**
 * mark the current rendering instance for asset resolution (e.g.
 * resolveComponent, resolveDirective) during render
 */
let currentRenderingInstance = null;
let currentScopeId = null;
/**
 * Note: rendering calls maybe nested. The function returns the parent rendering
 * instance if present, which should be restored after the render is done:
 *
 * ```js
 * const prev = setCurrentRenderingInstance(i)
 * // ...render
 * setCurrentRenderingInstance(prev)
 * ```
 */
function setCurrentRenderingInstance(instance) {
    const prev = currentRenderingInstance;
    currentRenderingInstance = instance;
    currentScopeId = (instance && instance.type.__scopeId) || null;
    return prev;
}
/**
 * Set scope id when creating hoisted vnodes.
 * @private compiler helper
 */
function pushScopeId(id) {
    currentScopeId = id;
}
/**
 * Technically we no longer need this after 3.0.8 but we need to keep the same
 * API for backwards compat w/ code generated by compilers.
 * @private
 */
function popScopeId() {
    currentScopeId = null;
}
/**
 * Only for backwards compat
 * @private
 */
const withScopeId = (_id) => withCtx;
/**
 * Wrap a slot function to memoize current rendering instance
 * @private compiler helper
 */
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot // false only
) {
    if (!ctx)
        return fn;
    // already normalized
    if (fn._n) {
        return fn;
    }
    const renderFnWithContext = (...args) => {
        // If a user calls a compiled slot inside a template expression (#1745), it
        // can mess up block tracking, so by default we disable block tracking and
        // force bail out when invoking a compiled slot (indicated by the ._d flag).
        // This isn't necessary if rendering a compiled `<slot>`, so we flip the
        // ._d flag off when invoking the wrapped fn inside `renderSlot`.
        if (renderFnWithContext._d) {
            setBlockTracking(-1);
        }
        const prevInstance = setCurrentRenderingInstance(ctx);
        const res = fn(...args);
        setCurrentRenderingInstance(prevInstance);
        if (renderFnWithContext._d) {
            setBlockTracking(1);
        }
        if (true) {
            devtoolsComponentUpdated(ctx);
        }
        return res;
    };
    // mark normalized to avoid duplicated wrapping
    renderFnWithContext._n = true;
    // mark this as compiled by default
    // this is used in vnode.ts -> normalizeChildren() to set the slot
    // rendering flag.
    renderFnWithContext._c = true;
    // disable block tracking by default
    renderFnWithContext._d = true;
    return renderFnWithContext;
}

/**
 * dev only flag to track whether $attrs was used during render.
 * If $attrs was used during render then the warning for failed attrs
 * fallthrough can be suppressed.
 */
let accessedAttrs = false;
function markAttrsAccessed() {
    accessedAttrs = true;
}
function renderComponentRoot(instance) {
    const { type: Component, vnode, proxy, withProxy, props, propsOptions: [propsOptions], slots, attrs, emit, render, renderCache, data, setupState, ctx, inheritAttrs } = instance;
    let result;
    let fallthroughAttrs;
    const prev = setCurrentRenderingInstance(instance);
    if ((true)) {
        accessedAttrs = false;
    }
    try {
        if (vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */) {
            // withProxy is a proxy with a different `has` trap only for
            // runtime-compiled render functions using `with` block.
            const proxyToUse = withProxy || proxy;
            result = normalizeVNode(render.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx));
            fallthroughAttrs = attrs;
        }
        else {
            // functional
            const render = Component;
            // in dev, mark attrs accessed if optional props (attrs === props)
            if (( true) && attrs === props) {
                markAttrsAccessed();
            }
            result = normalizeVNode(render.length > 1
                ? render(props, ( true)
                    ? {
                        get attrs() {
                            markAttrsAccessed();
                            return attrs;
                        },
                        slots,
                        emit
                    }
                    : 0)
                : render(props, null /* we know it doesn't need it */));
            fallthroughAttrs = Component.props
                ? attrs
                : getFunctionalFallthrough(attrs);
        }
    }
    catch (err) {
        blockStack.length = 0;
        handleError(err, instance, 1 /* RENDER_FUNCTION */);
        result = createVNode(Comment);
    }
    // attr merging
    // in dev mode, comments are preserved, and it's possible for a template
    // to have comments along side the root element which makes it a fragment
    let root = result;
    let setRoot = undefined;
    if (( true) &&
        result.patchFlag > 0 &&
        result.patchFlag & 2048 /* DEV_ROOT_FRAGMENT */) {
        [root, setRoot] = getChildRoot(result);
    }
    if (fallthroughAttrs && inheritAttrs !== false) {
        const keys = Object.keys(fallthroughAttrs);
        const { shapeFlag } = root;
        if (keys.length) {
            if (shapeFlag & (1 /* ELEMENT */ | 6 /* COMPONENT */)) {
                if (propsOptions && keys.some(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)) {
                    // If a v-model listener (onUpdate:xxx) has a corresponding declared
                    // prop, it indicates this component expects to handle v-model and
                    // it should not fallthrough.
                    // related: #1543, #1643, #1989
                    fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
                }
                root = cloneVNode(root, fallthroughAttrs);
            }
            else if (( true) && !accessedAttrs && root.type !== Comment) {
                const allAttrs = Object.keys(attrs);
                const eventAttrs = [];
                const extraAttrs = [];
                for (let i = 0, l = allAttrs.length; i < l; i++) {
                    const key = allAttrs[i];
                    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
                        // ignore v-model handlers when they fail to fallthrough
                        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)(key)) {
                            // remove `on`, lowercase first letter to reflect event casing
                            // accurately
                            eventAttrs.push(key[2].toLowerCase() + key.slice(3));
                        }
                    }
                    else {
                        extraAttrs.push(key);
                    }
                }
                if (extraAttrs.length) {
                    warn(`Extraneous non-props attributes (` +
                        `${extraAttrs.join(', ')}) ` +
                        `were passed to component but could not be automatically inherited ` +
                        `because component renders fragment or text root nodes.`);
                }
                if (eventAttrs.length) {
                    warn(`Extraneous non-emits event listeners (` +
                        `${eventAttrs.join(', ')}) ` +
                        `were passed to component but could not be automatically inherited ` +
                        `because component renders fragment or text root nodes. ` +
                        `If the listener is intended to be a component custom event listener only, ` +
                        `declare it using the "emits" option.`);
                }
            }
        }
    }
    // inherit directives
    if (vnode.dirs) {
        if (( true) && !isElementRoot(root)) {
            warn(`Runtime directive used on component with non-element root node. ` +
                `The directives will not function as intended.`);
        }
        // clone before mutating since the root may be a hoisted vnode
        root = cloneVNode(root);
        root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
    }
    // inherit transition data
    if (vnode.transition) {
        if (( true) && !isElementRoot(root)) {
            warn(`Component inside <Transition> renders non-element root node ` +
                `that cannot be animated.`);
        }
        root.transition = vnode.transition;
    }
    if (( true) && setRoot) {
        setRoot(root);
    }
    else {
        result = root;
    }
    setCurrentRenderingInstance(prev);
    return result;
}
/**
 * dev only
 * In dev mode, template root level comments are rendered, which turns the
 * template into a fragment root, but we need to locate the single element
 * root for attrs and scope id processing.
 */
const getChildRoot = (vnode) => {
    const rawChildren = vnode.children;
    const dynamicChildren = vnode.dynamicChildren;
    const childRoot = filterSingleRoot(rawChildren);
    if (!childRoot) {
        return [vnode, undefined];
    }
    const index = rawChildren.indexOf(childRoot);
    const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;
    const setRoot = (updatedRoot) => {
        rawChildren[index] = updatedRoot;
        if (dynamicChildren) {
            if (dynamicIndex > -1) {
                dynamicChildren[dynamicIndex] = updatedRoot;
            }
            else if (updatedRoot.patchFlag > 0) {
                vnode.dynamicChildren = [...dynamicChildren, updatedRoot];
            }
        }
    };
    return [normalizeVNode(childRoot), setRoot];
};
function filterSingleRoot(children) {
    let singleRoot;
    for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (isVNode(child)) {
            // ignore user comment
            if (child.type !== Comment || child.children === 'v-if') {
                if (singleRoot) {
                    // has more than 1 non-comment child, return now
                    return;
                }
                else {
                    singleRoot = child;
                }
            }
        }
        else {
            return;
        }
    }
    return singleRoot;
}
const getFunctionalFallthrough = (attrs) => {
    let res;
    for (const key in attrs) {
        if (key === 'class' || key === 'style' || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
            (res || (res = {}))[key] = attrs[key];
        }
    }
    return res;
};
const filterModelListeners = (attrs, props) => {
    const res = {};
    for (const key in attrs) {
        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)(key) || !(key.slice(9) in props)) {
            res[key] = attrs[key];
        }
    }
    return res;
};
const isElementRoot = (vnode) => {
    return (vnode.shapeFlag & (6 /* COMPONENT */ | 1 /* ELEMENT */) ||
        vnode.type === Comment // potential v-if branch switch
    );
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
    const { props: prevProps, children: prevChildren, component } = prevVNode;
    const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
    const emits = component.emitsOptions;
    // Parent component's render function was hot-updated. Since this may have
    // caused the child component's slots content to have changed, we need to
    // force the child to update as well.
    if (( true) && (prevChildren || nextChildren) && isHmrUpdating) {
        return true;
    }
    // force child update for runtime directive or transition on component vnode.
    if (nextVNode.dirs || nextVNode.transition) {
        return true;
    }
    if (optimized && patchFlag >= 0) {
        if (patchFlag & 1024 /* DYNAMIC_SLOTS */) {
            // slot content that references values that might have changed,
            // e.g. in a v-for
            return true;
        }
        if (patchFlag & 16 /* FULL_PROPS */) {
            if (!prevProps) {
                return !!nextProps;
            }
            // presence of this flag indicates props are always non-null
            return hasPropsChanged(prevProps, nextProps, emits);
        }
        else if (patchFlag & 8 /* PROPS */) {
            const dynamicProps = nextVNode.dynamicProps;
            for (let i = 0; i < dynamicProps.length; i++) {
                const key = dynamicProps[i];
                if (nextProps[key] !== prevProps[key] &&
                    !isEmitListener(emits, key)) {
                    return true;
                }
            }
        }
    }
    else {
        // this path is only taken by manually written render functions
        // so presence of any children leads to a forced update
        if (prevChildren || nextChildren) {
            if (!nextChildren || !nextChildren.$stable) {
                return true;
            }
        }
        if (prevProps === nextProps) {
            return false;
        }
        if (!prevProps) {
            return !!nextProps;
        }
        if (!nextProps) {
            return true;
        }
        return hasPropsChanged(prevProps, nextProps, emits);
    }
    return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
    const nextKeys = Object.keys(nextProps);
    if (nextKeys.length !== Object.keys(prevProps).length) {
        return true;
    }
    for (let i = 0; i < nextKeys.length; i++) {
        const key = nextKeys[i];
        if (nextProps[key] !== prevProps[key] &&
            !isEmitListener(emitsOptions, key)) {
            return true;
        }
    }
    return false;
}
function updateHOCHostEl({ vnode, parent }, el // HostNode
) {
    while (parent && parent.subTree === vnode) {
        (vnode = parent.vnode).el = el;
        parent = parent.parent;
    }
}

const isSuspense = (type) => type.__isSuspense;
// Suspense exposes a component-like API, and is treated like a component
// in the compiler, but internally it's a special built-in type that hooks
// directly into the renderer.
const SuspenseImpl = {
    name: 'Suspense',
    // In order to make Suspense tree-shakable, we need to avoid importing it
    // directly in the renderer. The renderer checks for the __isSuspense flag
    // on a vnode's type and calls the `process` method, passing in renderer
    // internals.
    __isSuspense: true,
    process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, 
    // platform-specific impl passed from renderer
    rendererInternals) {
        if (n1 == null) {
            mountSuspense(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals);
        }
        else {
            patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, rendererInternals);
        }
    },
    hydrate: hydrateSuspense,
    create: createSuspenseBoundary,
    normalize: normalizeSuspenseChildren
};
// Force-casted public typing for h and TSX props inference
const Suspense = (SuspenseImpl );
function triggerEvent(vnode, name) {
    const eventListener = vnode.props && vnode.props[name];
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(eventListener)) {
        eventListener();
    }
}
function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
    const { p: patch, o: { createElement } } = rendererInternals;
    const hiddenContainer = createElement('div');
    const suspense = (vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals));
    // start mounting the content subtree in an off-dom container
    patch(null, (suspense.pendingBranch = vnode.ssContent), hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds);
    // now check if we have encountered any async deps
    if (suspense.deps > 0) {
        // has async
        // invoke @fallback event
        triggerEvent(vnode, 'onPending');
        triggerEvent(vnode, 'onFallback');
        // mount the fallback tree
        patch(null, vnode.ssFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
        isSVG, slotScopeIds);
        setActiveBranch(suspense, vnode.ssFallback);
    }
    else {
        // Suspense has no async deps. Just resolve.
        suspense.resolve();
    }
}
function patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement } }) {
    const suspense = (n2.suspense = n1.suspense);
    suspense.vnode = n2;
    n2.el = n1.el;
    const newBranch = n2.ssContent;
    const newFallback = n2.ssFallback;
    const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;
    if (pendingBranch) {
        suspense.pendingBranch = newBranch;
        if (isSameVNodeType(newBranch, pendingBranch)) {
            // same root type but content may have changed.
            patch(pendingBranch, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
            if (suspense.deps <= 0) {
                suspense.resolve();
            }
            else if (isInFallback) {
                patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
                isSVG, slotScopeIds, optimized);
                setActiveBranch(suspense, newFallback);
            }
        }
        else {
            // toggled before pending tree is resolved
            suspense.pendingId++;
            if (isHydrating) {
                // if toggled before hydration is finished, the current DOM tree is
                // no longer valid. set it as the active branch so it will be unmounted
                // when resolved
                suspense.isHydrating = false;
                suspense.activeBranch = pendingBranch;
            }
            else {
                unmount(pendingBranch, parentComponent, suspense);
            }
            // increment pending ID. this is used to invalidate async callbacks
            // reset suspense state
            suspense.deps = 0;
            // discard effects from pending branch
            suspense.effects.length = 0;
            // discard previous container
            suspense.hiddenContainer = createElement('div');
            if (isInFallback) {
                // already in fallback state
                patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
                if (suspense.deps <= 0) {
                    suspense.resolve();
                }
                else {
                    patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
                    isSVG, slotScopeIds, optimized);
                    setActiveBranch(suspense, newFallback);
                }
            }
            else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
                // toggled "back" to current active branch
                patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);
                // force resolve
                suspense.resolve(true);
            }
            else {
                // switched to a 3rd branch
                patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
                if (suspense.deps <= 0) {
                    suspense.resolve();
                }
            }
        }
    }
    else {
        if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
            // root did not change, just normal patch
            patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);
            setActiveBranch(suspense, newBranch);
        }
        else {
            // root node toggled
            // invoke @pending event
            triggerEvent(n2, 'onPending');
            // mount pending branch in off-dom container
            suspense.pendingBranch = newBranch;
            suspense.pendingId++;
            patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
            if (suspense.deps <= 0) {
                // incoming branch has no async deps, resolve now.
                suspense.resolve();
            }
            else {
                const { timeout, pendingId } = suspense;
                if (timeout > 0) {
                    setTimeout(() => {
                        if (suspense.pendingId === pendingId) {
                            suspense.fallback(newFallback);
                        }
                    }, timeout);
                }
                else if (timeout === 0) {
                    suspense.fallback(newFallback);
                }
            }
        }
    }
}
let hasWarned = false;
function createSuspenseBoundary(vnode, parent, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals, isHydrating = false) {
    /* istanbul ignore if */
    if ( true && !hasWarned) {
        hasWarned = true;
        // @ts-ignore `console.info` cannot be null error
        console[console.info ? 'info' : 'log'](`<Suspense> is an experimental feature and its API will likely change.`);
    }
    const { p: patch, m: move, um: unmount, n: next, o: { parentNode, remove } } = rendererInternals;
    const timeout = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(vnode.props && vnode.props.timeout);
    const suspense = {
        vnode,
        parent,
        parentComponent,
        isSVG,
        container,
        hiddenContainer,
        anchor,
        deps: 0,
        pendingId: 0,
        timeout: typeof timeout === 'number' ? timeout : -1,
        activeBranch: null,
        pendingBranch: null,
        isInFallback: true,
        isHydrating,
        isUnmounted: false,
        effects: [],
        resolve(resume = false) {
            if ((true)) {
                if (!resume && !suspense.pendingBranch) {
                    throw new Error(`suspense.resolve() is called without a pending branch.`);
                }
                if (suspense.isUnmounted) {
                    throw new Error(`suspense.resolve() is called on an already unmounted suspense boundary.`);
                }
            }
            const { vnode, activeBranch, pendingBranch, pendingId, effects, parentComponent, container } = suspense;
            if (suspense.isHydrating) {
                suspense.isHydrating = false;
            }
            else if (!resume) {
                const delayEnter = activeBranch &&
                    pendingBranch.transition &&
                    pendingBranch.transition.mode === 'out-in';
                if (delayEnter) {
                    activeBranch.transition.afterLeave = () => {
                        if (pendingId === suspense.pendingId) {
                            move(pendingBranch, container, anchor, 0 /* ENTER */);
                        }
                    };
                }
                // this is initial anchor on mount
                let { anchor } = suspense;
                // unmount current active tree
                if (activeBranch) {
                    // if the fallback tree was mounted, it may have been moved
                    // as part of a parent suspense. get the latest anchor for insertion
                    anchor = next(activeBranch);
                    unmount(activeBranch, parentComponent, suspense, true);
                }
                if (!delayEnter) {
                    // move content from off-dom container to actual container
                    move(pendingBranch, container, anchor, 0 /* ENTER */);
                }
            }
            setActiveBranch(suspense, pendingBranch);
            suspense.pendingBranch = null;
            suspense.isInFallback = false;
            // flush buffered effects
            // check if there is a pending parent suspense
            let parent = suspense.parent;
            let hasUnresolvedAncestor = false;
            while (parent) {
                if (parent.pendingBranch) {
                    // found a pending parent suspense, merge buffered post jobs
                    // into that parent
                    parent.effects.push(...effects);
                    hasUnresolvedAncestor = true;
                    break;
                }
                parent = parent.parent;
            }
            // no pending parent suspense, flush all jobs
            if (!hasUnresolvedAncestor) {
                queuePostFlushCb(effects);
            }
            suspense.effects = [];
            // invoke @resolve event
            triggerEvent(vnode, 'onResolve');
        },
        fallback(fallbackVNode) {
            if (!suspense.pendingBranch) {
                return;
            }
            const { vnode, activeBranch, parentComponent, container, isSVG } = suspense;
            // invoke @fallback event
            triggerEvent(vnode, 'onFallback');
            const anchor = next(activeBranch);
            const mountFallback = () => {
                if (!suspense.isInFallback) {
                    return;
                }
                // mount the fallback tree
                patch(null, fallbackVNode, container, anchor, parentComponent, null, // fallback tree will not have suspense context
                isSVG, slotScopeIds, optimized);
                setActiveBranch(suspense, fallbackVNode);
            };
            const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === 'out-in';
            if (delayEnter) {
                activeBranch.transition.afterLeave = mountFallback;
            }
            suspense.isInFallback = true;
            // unmount current active branch
            unmount(activeBranch, parentComponent, null, // no suspense so unmount hooks fire now
            true // shouldRemove
            );
            if (!delayEnter) {
                mountFallback();
            }
        },
        move(container, anchor, type) {
            suspense.activeBranch &&
                move(suspense.activeBranch, container, anchor, type);
            suspense.container = container;
        },
        next() {
            return suspense.activeBranch && next(suspense.activeBranch);
        },
        registerDep(instance, setupRenderEffect) {
            const isInPendingSuspense = !!suspense.pendingBranch;
            if (isInPendingSuspense) {
                suspense.deps++;
            }
            const hydratedEl = instance.vnode.el;
            instance
                .asyncDep.catch(err => {
                handleError(err, instance, 0 /* SETUP_FUNCTION */);
            })
                .then(asyncSetupResult => {
                // retry when the setup() promise resolves.
                // component may have been unmounted before resolve.
                if (instance.isUnmounted ||
                    suspense.isUnmounted ||
                    suspense.pendingId !== instance.suspenseId) {
                    return;
                }
                // retry from this component
                instance.asyncResolved = true;
                const { vnode } = instance;
                if ((true)) {
                    pushWarningContext(vnode);
                }
                handleSetupResult(instance, asyncSetupResult, false);
                if (hydratedEl) {
                    // vnode may have been replaced if an update happened before the
                    // async dep is resolved.
                    vnode.el = hydratedEl;
                }
                const placeholder = !hydratedEl && instance.subTree.el;
                setupRenderEffect(instance, vnode, 
                // component may have been moved before resolve.
                // if this is not a hydration, instance.subTree will be the comment
                // placeholder.
                parentNode(hydratedEl || instance.subTree.el), 
                // anchor will not be used if this is hydration, so only need to
                // consider the comment placeholder case.
                hydratedEl ? null : next(instance.subTree), suspense, isSVG, optimized);
                if (placeholder) {
                    remove(placeholder);
                }
                updateHOCHostEl(instance, vnode.el);
                if ((true)) {
                    popWarningContext();
                }
                // only decrease deps count if suspense is not already resolved
                if (isInPendingSuspense && --suspense.deps === 0) {
                    suspense.resolve();
                }
            });
        },
        unmount(parentSuspense, doRemove) {
            suspense.isUnmounted = true;
            if (suspense.activeBranch) {
                unmount(suspense.activeBranch, parentComponent, parentSuspense, doRemove);
            }
            if (suspense.pendingBranch) {
                unmount(suspense.pendingBranch, parentComponent, parentSuspense, doRemove);
            }
        }
    };
    return suspense;
}
function hydrateSuspense(node, vnode, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals, hydrateNode) {
    /* eslint-disable no-restricted-globals */
    const suspense = (vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, node.parentNode, document.createElement('div'), null, isSVG, slotScopeIds, optimized, rendererInternals, true /* hydrating */));
    // there are two possible scenarios for server-rendered suspense:
    // - success: ssr content should be fully resolved
    // - failure: ssr content should be the fallback branch.
    // however, on the client we don't really know if it has failed or not
    // attempt to hydrate the DOM assuming it has succeeded, but we still
    // need to construct a suspense boundary first
    const result = hydrateNode(node, (suspense.pendingBranch = vnode.ssContent), parentComponent, suspense, slotScopeIds, optimized);
    if (suspense.deps === 0) {
        suspense.resolve();
    }
    return result;
    /* eslint-enable no-restricted-globals */
}
function normalizeSuspenseChildren(vnode) {
    const { shapeFlag, children } = vnode;
    const isSlotChildren = shapeFlag & 32 /* SLOTS_CHILDREN */;
    vnode.ssContent = normalizeSuspenseSlot(isSlotChildren ? children.default : children);
    vnode.ssFallback = isSlotChildren
        ? normalizeSuspenseSlot(children.fallback)
        : createVNode(Comment);
}
function normalizeSuspenseSlot(s) {
    let block;
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(s)) {
        const trackBlock = isBlockTreeEnabled && s._c;
        if (trackBlock) {
            // disableTracking: false
            // allow block tracking for compiled slots
            // (see ./componentRenderContext.ts)
            s._d = false;
            openBlock();
        }
        s = s();
        if (trackBlock) {
            s._d = true;
            block = currentBlock;
            closeBlock();
        }
    }
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(s)) {
        const singleChild = filterSingleRoot(s);
        if (( true) && !singleChild) {
            warn(`<Suspense> slots expect a single root node.`);
        }
        s = singleChild;
    }
    s = normalizeVNode(s);
    if (block && !s.dynamicChildren) {
        s.dynamicChildren = block.filter(c => c !== s);
    }
    return s;
}
function queueEffectWithSuspense(fn, suspense) {
    if (suspense && suspense.pendingBranch) {
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(fn)) {
            suspense.effects.push(...fn);
        }
        else {
            suspense.effects.push(fn);
        }
    }
    else {
        queuePostFlushCb(fn);
    }
}
function setActiveBranch(suspense, branch) {
    suspense.activeBranch = branch;
    const { vnode, parentComponent } = suspense;
    const el = (vnode.el = branch.el);
    // in case suspense is the root node of a component,
    // recursively update the HOC el
    if (parentComponent && parentComponent.subTree === vnode) {
        parentComponent.vnode.el = el;
        updateHOCHostEl(parentComponent, el);
    }
}

function provide(key, value) {
    if (!currentInstance) {
        if ((true)) {
            warn(`provide() can only be used inside setup().`);
        }
    }
    else {
        let provides = currentInstance.provides;
        // by default an instance inherits its parent's provides object
        // but when it needs to provide values of its own, it creates its
        // own provides object using parent provides object as prototype.
        // this way in `inject` we can simply look up injections from direct
        // parent and let the prototype chain do the work.
        const parentProvides = currentInstance.parent && currentInstance.parent.provides;
        if (parentProvides === provides) {
            provides = currentInstance.provides = Object.create(parentProvides);
        }
        // TS doesn't allow symbol as index type
        provides[key] = value;
    }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
    // fallback to `currentRenderingInstance` so that this can be called in
    // a functional component
    const instance = currentInstance || currentRenderingInstance;
    if (instance) {
        // #2400
        // to support `app.use` plugins,
        // fallback to appContext's `provides` if the instance is at root
        const provides = instance.parent == null
            ? instance.vnode.appContext && instance.vnode.appContext.provides
            : instance.parent.provides;
        if (provides && key in provides) {
            // TS doesn't allow symbol as index type
            return provides[key];
        }
        else if (arguments.length > 1) {
            return treatDefaultAsFactory && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(defaultValue)
                ? defaultValue.call(instance.proxy)
                : defaultValue;
        }
        else if ((true)) {
            warn(`injection "${String(key)}" not found.`);
        }
    }
    else if ((true)) {
        warn(`inject() can only be used inside setup() or functional components.`);
    }
}

// Simple effect.
function watchEffect(effect, options) {
    return doWatch(effect, null, options);
}
function watchPostEffect(effect, options) {
    return doWatch(effect, null, (( true)
        ? Object.assign(Object.assign({}, options), { flush: 'post' }) : 0));
}
function watchSyncEffect(effect, options) {
    return doWatch(effect, null, (( true)
        ? Object.assign(Object.assign({}, options), { flush: 'sync' }) : 0));
}
// initial value for watchers to trigger on undefined initial values
const INITIAL_WATCHER_VALUE = {};
// implementation
function watch(source, cb, options) {
    if (( true) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(cb)) {
        warn(`\`watch(fn, options?)\` signature has been moved to a separate API. ` +
            `Use \`watchEffect(fn, options?)\` instead. \`watch\` now only ` +
            `supports \`watch(source, cb, options?) signature.`);
    }
    return doWatch(source, cb, options);
}
function doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {
    if (( true) && !cb) {
        if (immediate !== undefined) {
            warn(`watch() "immediate" option is only respected when using the ` +
                `watch(source, callback, options?) signature.`);
        }
        if (deep !== undefined) {
            warn(`watch() "deep" option is only respected when using the ` +
                `watch(source, callback, options?) signature.`);
        }
    }
    const warnInvalidSource = (s) => {
        warn(`Invalid watch source: `, s, `A watch source can only be a getter/effect function, a ref, ` +
            `a reactive object, or an array of these types.`);
    };
    const instance = currentInstance;
    let getter;
    let forceTrigger = false;
    let isMultiSource = false;
    if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(source)) {
        getter = () => source.value;
        forceTrigger = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isShallow)(source);
    }
    else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive)(source)) {
        getter = () => source;
        deep = true;
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(source)) {
        isMultiSource = true;
        forceTrigger = source.some(s => (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive)(s) || (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isShallow)(s));
        getter = () => source.map(s => {
            if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(s)) {
                return s.value;
            }
            else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive)(s)) {
                return traverse(s);
            }
            else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(s)) {
                return callWithErrorHandling(s, instance, 2 /* WATCH_GETTER */);
            }
            else {
                ( true) && warnInvalidSource(s);
            }
        });
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(source)) {
        if (cb) {
            // getter with cb
            getter = () => callWithErrorHandling(source, instance, 2 /* WATCH_GETTER */);
        }
        else {
            // no cb -> simple effect
            getter = () => {
                if (instance && instance.isUnmounted) {
                    return;
                }
                if (cleanup) {
                    cleanup();
                }
                return callWithAsyncErrorHandling(source, instance, 3 /* WATCH_CALLBACK */, [onCleanup]);
            };
        }
    }
    else {
        getter = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;
        ( true) && warnInvalidSource(source);
    }
    if (cb && deep) {
        const baseGetter = getter;
        getter = () => traverse(baseGetter());
    }
    let cleanup;
    let onCleanup = (fn) => {
        cleanup = effect.onStop = () => {
            callWithErrorHandling(fn, instance, 4 /* WATCH_CLEANUP */);
        };
    };
    // in SSR there is no need to setup an actual effect, and it should be noop
    // unless it's eager
    if (isInSSRComponentSetup) {
        // we will also not call the invalidate callback (+ runner is not set up)
        onCleanup = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;
        if (!cb) {
            getter();
        }
        else if (immediate) {
            callWithAsyncErrorHandling(cb, instance, 3 /* WATCH_CALLBACK */, [
                getter(),
                isMultiSource ? [] : undefined,
                onCleanup
            ]);
        }
        return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;
    }
    let oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;
    const job = () => {
        if (!effect.active) {
            return;
        }
        if (cb) {
            // watch(source, cb)
            const newValue = effect.run();
            if (deep ||
                forceTrigger ||
                (isMultiSource
                    ? newValue.some((v, i) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasChanged)(v, oldValue[i]))
                    : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasChanged)(newValue, oldValue)) ||
                (false  )) {
                // cleanup before running cb again
                if (cleanup) {
                    cleanup();
                }
                callWithAsyncErrorHandling(cb, instance, 3 /* WATCH_CALLBACK */, [
                    newValue,
                    // pass undefined as the old value when it's changed for the first time
                    oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue,
                    onCleanup
                ]);
                oldValue = newValue;
            }
        }
        else {
            // watchEffect
            effect.run();
        }
    };
    // important: mark the job as a watcher callback so that scheduler knows
    // it is allowed to self-trigger (#1727)
    job.allowRecurse = !!cb;
    let scheduler;
    if (flush === 'sync') {
        scheduler = job; // the scheduler function gets called directly
    }
    else if (flush === 'post') {
        scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
    }
    else {
        // default: 'pre'
        scheduler = () => queuePreFlushCb(job);
    }
    const effect = new _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ReactiveEffect(getter, scheduler);
    if ((true)) {
        effect.onTrack = onTrack;
        effect.onTrigger = onTrigger;
    }
    // initial run
    if (cb) {
        if (immediate) {
            job();
        }
        else {
            oldValue = effect.run();
        }
    }
    else if (flush === 'post') {
        queuePostRenderEffect(effect.run.bind(effect), instance && instance.suspense);
    }
    else {
        effect.run();
    }
    return () => {
        effect.stop();
        if (instance && instance.scope) {
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.remove)(instance.scope.effects, effect);
        }
    };
}
// this.$watch
function instanceWatch(source, value, options) {
    const publicThis = this.proxy;
    const getter = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(source)
        ? source.includes('.')
            ? createPathGetter(publicThis, source)
            : () => publicThis[source]
        : source.bind(publicThis, publicThis);
    let cb;
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {
        cb = value;
    }
    else {
        cb = value.handler;
        options = value;
    }
    const cur = currentInstance;
    setCurrentInstance(this);
    const res = doWatch(getter, cb.bind(publicThis), options);
    if (cur) {
        setCurrentInstance(cur);
    }
    else {
        unsetCurrentInstance();
    }
    return res;
}
function createPathGetter(ctx, path) {
    const segments = path.split('.');
    return () => {
        let cur = ctx;
        for (let i = 0; i < segments.length && cur; i++) {
            cur = cur[segments[i]];
        }
        return cur;
    };
}
function traverse(value, seen) {
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(value) || value["__v_skip" /* SKIP */]) {
        return value;
    }
    seen = seen || new Set();
    if (seen.has(value)) {
        return value;
    }
    seen.add(value);
    if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(value)) {
        traverse(value.value, seen);
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
        for (let i = 0; i < value.length; i++) {
            traverse(value[i], seen);
        }
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isMap)(value)) {
        value.forEach((v) => {
            traverse(v, seen);
        });
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(value)) {
        for (const key in value) {
            traverse(value[key], seen);
        }
    }
    return value;
}

function useTransitionState() {
    const state = {
        isMounted: false,
        isLeaving: false,
        isUnmounting: false,
        leavingVNodes: new Map()
    };
    onMounted(() => {
        state.isMounted = true;
    });
    onBeforeUnmount(() => {
        state.isUnmounting = true;
    });
    return state;
}
const TransitionHookValidator = [Function, Array];
const BaseTransitionImpl = {
    name: `BaseTransition`,
    props: {
        mode: String,
        appear: Boolean,
        persisted: Boolean,
        // enter
        onBeforeEnter: TransitionHookValidator,
        onEnter: TransitionHookValidator,
        onAfterEnter: TransitionHookValidator,
        onEnterCancelled: TransitionHookValidator,
        // leave
        onBeforeLeave: TransitionHookValidator,
        onLeave: TransitionHookValidator,
        onAfterLeave: TransitionHookValidator,
        onLeaveCancelled: TransitionHookValidator,
        // appear
        onBeforeAppear: TransitionHookValidator,
        onAppear: TransitionHookValidator,
        onAfterAppear: TransitionHookValidator,
        onAppearCancelled: TransitionHookValidator
    },
    setup(props, { slots }) {
        const instance = getCurrentInstance();
        const state = useTransitionState();
        let prevTransitionKey;
        return () => {
            const children = slots.default && getTransitionRawChildren(slots.default(), true);
            if (!children || !children.length) {
                return;
            }
            let child = children[0];
            if (children.length > 1) {
                let hasFound = false;
                // locate first non-comment child
                for (const c of children) {
                    if (c.type !== Comment) {
                        if (( true) && hasFound) {
                            // warn more than one non-comment child
                            warn('<transition> can only be used on a single element or component. ' +
                                'Use <transition-group> for lists.');
                            break;
                        }
                        child = c;
                        hasFound = true;
                        if (false)
                            {}
                    }
                }
            }
            // there's no need to track reactivity for these props so use the raw
            // props for a bit better perf
            const rawProps = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);
            const { mode } = rawProps;
            // check mode
            if (( true) &&
                mode &&
                mode !== 'in-out' &&
                mode !== 'out-in' &&
                mode !== 'default') {
                warn(`invalid <transition> mode: ${mode}`);
            }
            if (state.isLeaving) {
                return emptyPlaceholder(child);
            }
            // in the case of <transition><keep-alive/></transition>, we need to
            // compare the type of the kept-alive children.
            const innerChild = getKeepAliveChild(child);
            if (!innerChild) {
                return emptyPlaceholder(child);
            }
            const enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance);
            setTransitionHooks(innerChild, enterHooks);
            const oldChild = instance.subTree;
            const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
            let transitionKeyChanged = false;
            const { getTransitionKey } = innerChild.type;
            if (getTransitionKey) {
                const key = getTransitionKey();
                if (prevTransitionKey === undefined) {
                    prevTransitionKey = key;
                }
                else if (key !== prevTransitionKey) {
                    prevTransitionKey = key;
                    transitionKeyChanged = true;
                }
            }
            // handle mode
            if (oldInnerChild &&
                oldInnerChild.type !== Comment &&
                (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
                const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);
                // update old tree's hooks in case of dynamic transition
                setTransitionHooks(oldInnerChild, leavingHooks);
                // switching between different views
                if (mode === 'out-in') {
                    state.isLeaving = true;
                    // return placeholder node and queue update when leave finishes
                    leavingHooks.afterLeave = () => {
                        state.isLeaving = false;
                        instance.update();
                    };
                    return emptyPlaceholder(child);
                }
                else if (mode === 'in-out' && innerChild.type !== Comment) {
                    leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
                        const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);
                        leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
                        // early removal callback
                        el._leaveCb = () => {
                            earlyRemove();
                            el._leaveCb = undefined;
                            delete enterHooks.delayedLeave;
                        };
                        enterHooks.delayedLeave = delayedLeave;
                    };
                }
            }
            return child;
        };
    }
};
// export the public type for h/tsx inference
// also to avoid inline import() in generated d.ts files
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
    const { leavingVNodes } = state;
    let leavingVNodesCache = leavingVNodes.get(vnode.type);
    if (!leavingVNodesCache) {
        leavingVNodesCache = Object.create(null);
        leavingVNodes.set(vnode.type, leavingVNodesCache);
    }
    return leavingVNodesCache;
}
// The transition hooks are attached to the vnode as vnode.transition
// and will be called at appropriate timing in the renderer.
function resolveTransitionHooks(vnode, props, state, instance) {
    const { appear, mode, persisted = false, onBeforeEnter, onEnter, onAfterEnter, onEnterCancelled, onBeforeLeave, onLeave, onAfterLeave, onLeaveCancelled, onBeforeAppear, onAppear, onAfterAppear, onAppearCancelled } = props;
    const key = String(vnode.key);
    const leavingVNodesCache = getLeavingNodesForType(state, vnode);
    const callHook = (hook, args) => {
        hook &&
            callWithAsyncErrorHandling(hook, instance, 9 /* TRANSITION_HOOK */, args);
    };
    const callAsyncHook = (hook, args) => {
        const done = args[1];
        callHook(hook, args);
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook)) {
            if (hook.every(hook => hook.length <= 1))
                done();
        }
        else if (hook.length <= 1) {
            done();
        }
    };
    const hooks = {
        mode,
        persisted,
        beforeEnter(el) {
            let hook = onBeforeEnter;
            if (!state.isMounted) {
                if (appear) {
                    hook = onBeforeAppear || onBeforeEnter;
                }
                else {
                    return;
                }
            }
            // for same element (v-show)
            if (el._leaveCb) {
                el._leaveCb(true /* cancelled */);
            }
            // for toggled element with same key (v-if)
            const leavingVNode = leavingVNodesCache[key];
            if (leavingVNode &&
                isSameVNodeType(vnode, leavingVNode) &&
                leavingVNode.el._leaveCb) {
                // force early removal (not cancelled)
                leavingVNode.el._leaveCb();
            }
            callHook(hook, [el]);
        },
        enter(el) {
            let hook = onEnter;
            let afterHook = onAfterEnter;
            let cancelHook = onEnterCancelled;
            if (!state.isMounted) {
                if (appear) {
                    hook = onAppear || onEnter;
                    afterHook = onAfterAppear || onAfterEnter;
                    cancelHook = onAppearCancelled || onEnterCancelled;
                }
                else {
                    return;
                }
            }
            let called = false;
            const done = (el._enterCb = (cancelled) => {
                if (called)
                    return;
                called = true;
                if (cancelled) {
                    callHook(cancelHook, [el]);
                }
                else {
                    callHook(afterHook, [el]);
                }
                if (hooks.delayedLeave) {
                    hooks.delayedLeave();
                }
                el._enterCb = undefined;
            });
            if (hook) {
                callAsyncHook(hook, [el, done]);
            }
            else {
                done();
            }
        },
        leave(el, remove) {
            const key = String(vnode.key);
            if (el._enterCb) {
                el._enterCb(true /* cancelled */);
            }
            if (state.isUnmounting) {
                return remove();
            }
            callHook(onBeforeLeave, [el]);
            let called = false;
            const done = (el._leaveCb = (cancelled) => {
                if (called)
                    return;
                called = true;
                remove();
                if (cancelled) {
                    callHook(onLeaveCancelled, [el]);
                }
                else {
                    callHook(onAfterLeave, [el]);
                }
                el._leaveCb = undefined;
                if (leavingVNodesCache[key] === vnode) {
                    delete leavingVNodesCache[key];
                }
            });
            leavingVNodesCache[key] = vnode;
            if (onLeave) {
                callAsyncHook(onLeave, [el, done]);
            }
            else {
                done();
            }
        },
        clone(vnode) {
            return resolveTransitionHooks(vnode, props, state, instance);
        }
    };
    return hooks;
}
// the placeholder really only handles one special case: KeepAlive
// in the case of a KeepAlive in a leave phase we need to return a KeepAlive
// placeholder with empty content to avoid the KeepAlive instance from being
// unmounted.
function emptyPlaceholder(vnode) {
    if (isKeepAlive(vnode)) {
        vnode = cloneVNode(vnode);
        vnode.children = null;
        return vnode;
    }
}
function getKeepAliveChild(vnode) {
    return isKeepAlive(vnode)
        ? vnode.children
            ? vnode.children[0]
            : undefined
        : vnode;
}
function setTransitionHooks(vnode, hooks) {
    if (vnode.shapeFlag & 6 /* COMPONENT */ && vnode.component) {
        setTransitionHooks(vnode.component.subTree, hooks);
    }
    else if (vnode.shapeFlag & 128 /* SUSPENSE */) {
        vnode.ssContent.transition = hooks.clone(vnode.ssContent);
        vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
    }
    else {
        vnode.transition = hooks;
    }
}
function getTransitionRawChildren(children, keepComment = false, parentKey) {
    let ret = [];
    let keyedFragmentCount = 0;
    for (let i = 0; i < children.length; i++) {
        let child = children[i];
        // #5360 inherit parent key in case of <template v-for>
        const key = parentKey == null
            ? child.key
            : String(parentKey) + String(child.key != null ? child.key : i);
        // handle fragment children case, e.g. v-for
        if (child.type === Fragment) {
            if (child.patchFlag & 128 /* KEYED_FRAGMENT */)
                keyedFragmentCount++;
            ret = ret.concat(getTransitionRawChildren(child.children, keepComment, key));
        }
        // comment placeholders should be skipped, e.g. v-if
        else if (keepComment || child.type !== Comment) {
            ret.push(key != null ? cloneVNode(child, { key }) : child);
        }
    }
    // #1126 if a transition children list contains multiple sub fragments, these
    // fragments will be merged into a flat children array. Since each v-for
    // fragment may contain different static bindings inside, we need to de-op
    // these children to force full diffs to ensure correct behavior.
    if (keyedFragmentCount > 1) {
        for (let i = 0; i < ret.length; i++) {
            ret[i].patchFlag = -2 /* BAIL */;
        }
    }
    return ret;
}

// implementation, close to no-op
function defineComponent(options) {
    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(options) ? { setup: options, name: options.name } : options;
}

const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
function defineAsyncComponent(source) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(source)) {
        source = { loader: source };
    }
    const { loader, loadingComponent, errorComponent, delay = 200, timeout, // undefined = never times out
    suspensible = true, onError: userOnError } = source;
    let pendingRequest = null;
    let resolvedComp;
    let retries = 0;
    const retry = () => {
        retries++;
        pendingRequest = null;
        return load();
    };
    const load = () => {
        let thisRequest;
        return (pendingRequest ||
            (thisRequest = pendingRequest =
                loader()
                    .catch(err => {
                    err = err instanceof Error ? err : new Error(String(err));
                    if (userOnError) {
                        return new Promise((resolve, reject) => {
                            const userRetry = () => resolve(retry());
                            const userFail = () => reject(err);
                            userOnError(err, userRetry, userFail, retries + 1);
                        });
                    }
                    else {
                        throw err;
                    }
                })
                    .then((comp) => {
                    if (thisRequest !== pendingRequest && pendingRequest) {
                        return pendingRequest;
                    }
                    if (( true) && !comp) {
                        warn(`Async component loader resolved to undefined. ` +
                            `If you are using retry(), make sure to return its return value.`);
                    }
                    // interop module default
                    if (comp &&
                        (comp.__esModule || comp[Symbol.toStringTag] === 'Module')) {
                        comp = comp.default;
                    }
                    if (( true) && comp && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(comp) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(comp)) {
                        throw new Error(`Invalid async component load result: ${comp}`);
                    }
                    resolvedComp = comp;
                    return comp;
                })));
    };
    return defineComponent({
        name: 'AsyncComponentWrapper',
        __asyncLoader: load,
        get __asyncResolved() {
            return resolvedComp;
        },
        setup() {
            const instance = currentInstance;
            // already resolved
            if (resolvedComp) {
                return () => createInnerComp(resolvedComp, instance);
            }
            const onError = (err) => {
                pendingRequest = null;
                handleError(err, instance, 13 /* ASYNC_COMPONENT_LOADER */, !errorComponent /* do not throw in dev if user provided error component */);
            };
            // suspense-controlled or SSR.
            if ((suspensible && instance.suspense) ||
                (isInSSRComponentSetup)) {
                return load()
                    .then(comp => {
                    return () => createInnerComp(comp, instance);
                })
                    .catch(err => {
                    onError(err);
                    return () => errorComponent
                        ? createVNode(errorComponent, {
                            error: err
                        })
                        : null;
                });
            }
            const loaded = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)(false);
            const error = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)();
            const delayed = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)(!!delay);
            if (delay) {
                setTimeout(() => {
                    delayed.value = false;
                }, delay);
            }
            if (timeout != null) {
                setTimeout(() => {
                    if (!loaded.value && !error.value) {
                        const err = new Error(`Async component timed out after ${timeout}ms.`);
                        onError(err);
                        error.value = err;
                    }
                }, timeout);
            }
            load()
                .then(() => {
                loaded.value = true;
                if (instance.parent && isKeepAlive(instance.parent.vnode)) {
                    // parent is keep-alive, force update so the loaded component's
                    // name is taken into account
                    queueJob(instance.parent.update);
                }
            })
                .catch(err => {
                onError(err);
                error.value = err;
            });
            return () => {
                if (loaded.value && resolvedComp) {
                    return createInnerComp(resolvedComp, instance);
                }
                else if (error.value && errorComponent) {
                    return createVNode(errorComponent, {
                        error: error.value
                    });
                }
                else if (loadingComponent && !delayed.value) {
                    return createVNode(loadingComponent);
                }
            };
        }
    });
}
function createInnerComp(comp, { vnode: { ref, props, children, shapeFlag }, parent }) {
    const vnode = createVNode(comp, props, children);
    // ensure inner component inherits the async wrapper's ref owner
    vnode.ref = ref;
    return vnode;
}

const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
const KeepAliveImpl = {
    name: `KeepAlive`,
    // Marker for special handling inside the renderer. We are not using a ===
    // check directly on KeepAlive in the renderer, because importing it directly
    // would prevent it from being tree-shaken.
    __isKeepAlive: true,
    props: {
        include: [String, RegExp, Array],
        exclude: [String, RegExp, Array],
        max: [String, Number]
    },
    setup(props, { slots }) {
        const instance = getCurrentInstance();
        // KeepAlive communicates with the instantiated renderer via the
        // ctx where the renderer passes in its internals,
        // and the KeepAlive instance exposes activate/deactivate implementations.
        // The whole point of this is to avoid importing KeepAlive directly in the
        // renderer to facilitate tree-shaking.
        const sharedContext = instance.ctx;
        // if the internal renderer is not registered, it indicates that this is server-side rendering,
        // for KeepAlive, we just need to render its children
        if (!sharedContext.renderer) {
            return () => {
                const children = slots.default && slots.default();
                return children && children.length === 1 ? children[0] : children;
            };
        }
        const cache = new Map();
        const keys = new Set();
        let current = null;
        if (true) {
            instance.__v_cache = cache;
        }
        const parentSuspense = instance.suspense;
        const { renderer: { p: patch, m: move, um: _unmount, o: { createElement } } } = sharedContext;
        const storageContainer = createElement('div');
        sharedContext.activate = (vnode, container, anchor, isSVG, optimized) => {
            const instance = vnode.component;
            move(vnode, container, anchor, 0 /* ENTER */, parentSuspense);
            // in case props have changed
            patch(instance.vnode, vnode, container, anchor, instance, parentSuspense, isSVG, vnode.slotScopeIds, optimized);
            queuePostRenderEffect(() => {
                instance.isDeactivated = false;
                if (instance.a) {
                    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance.a);
                }
                const vnodeHook = vnode.props && vnode.props.onVnodeMounted;
                if (vnodeHook) {
                    invokeVNodeHook(vnodeHook, instance.parent, vnode);
                }
            }, parentSuspense);
            if (true) {
                // Update components tree
                devtoolsComponentAdded(instance);
            }
        };
        sharedContext.deactivate = (vnode) => {
            const instance = vnode.component;
            move(vnode, storageContainer, null, 1 /* LEAVE */, parentSuspense);
            queuePostRenderEffect(() => {
                if (instance.da) {
                    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance.da);
                }
                const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
                if (vnodeHook) {
                    invokeVNodeHook(vnodeHook, instance.parent, vnode);
                }
                instance.isDeactivated = true;
            }, parentSuspense);
            if (true) {
                // Update components tree
                devtoolsComponentAdded(instance);
            }
        };
        function unmount(vnode) {
            // reset the shapeFlag so it can be properly unmounted
            resetShapeFlag(vnode);
            _unmount(vnode, instance, parentSuspense, true);
        }
        function pruneCache(filter) {
            cache.forEach((vnode, key) => {
                const name = getComponentName(vnode.type);
                if (name && (!filter || !filter(name))) {
                    pruneCacheEntry(key);
                }
            });
        }
        function pruneCacheEntry(key) {
            const cached = cache.get(key);
            if (!current || cached.type !== current.type) {
                unmount(cached);
            }
            else if (current) {
                // current active instance should no longer be kept-alive.
                // we can't unmount it now but it might be later, so reset its flag now.
                resetShapeFlag(current);
            }
            cache.delete(key);
            keys.delete(key);
        }
        // prune cache on include/exclude prop change
        watch(() => [props.include, props.exclude], ([include, exclude]) => {
            include && pruneCache(name => matches(include, name));
            exclude && pruneCache(name => !matches(exclude, name));
        }, 
        // prune post-render after `current` has been updated
        { flush: 'post', deep: true });
        // cache sub tree after render
        let pendingCacheKey = null;
        const cacheSubtree = () => {
            // fix #1621, the pendingCacheKey could be 0
            if (pendingCacheKey != null) {
                cache.set(pendingCacheKey, getInnerChild(instance.subTree));
            }
        };
        onMounted(cacheSubtree);
        onUpdated(cacheSubtree);
        onBeforeUnmount(() => {
            cache.forEach(cached => {
                const { subTree, suspense } = instance;
                const vnode = getInnerChild(subTree);
                if (cached.type === vnode.type) {
                    // current instance will be unmounted as part of keep-alive's unmount
                    resetShapeFlag(vnode);
                    // but invoke its deactivated hook here
                    const da = vnode.component.da;
                    da && queuePostRenderEffect(da, suspense);
                    return;
                }
                unmount(cached);
            });
        });
        return () => {
            pendingCacheKey = null;
            if (!slots.default) {
                return null;
            }
            const children = slots.default();
            const rawVNode = children[0];
            if (children.length > 1) {
                if ((true)) {
                    warn(`KeepAlive should contain exactly one component child.`);
                }
                current = null;
                return children;
            }
            else if (!isVNode(rawVNode) ||
                (!(rawVNode.shapeFlag & 4 /* STATEFUL_COMPONENT */) &&
                    !(rawVNode.shapeFlag & 128 /* SUSPENSE */))) {
                current = null;
                return rawVNode;
            }
            let vnode = getInnerChild(rawVNode);
            const comp = vnode.type;
            // for async components, name check should be based in its loaded
            // inner component if available
            const name = getComponentName(isAsyncWrapper(vnode)
                ? vnode.type.__asyncResolved || {}
                : comp);
            const { include, exclude, max } = props;
            if ((include && (!name || !matches(include, name))) ||
                (exclude && name && matches(exclude, name))) {
                current = vnode;
                return rawVNode;
            }
            const key = vnode.key == null ? comp : vnode.key;
            const cachedVNode = cache.get(key);
            // clone vnode if it's reused because we are going to mutate it
            if (vnode.el) {
                vnode = cloneVNode(vnode);
                if (rawVNode.shapeFlag & 128 /* SUSPENSE */) {
                    rawVNode.ssContent = vnode;
                }
            }
            // #1513 it's possible for the returned vnode to be cloned due to attr
            // fallthrough or scopeId, so the vnode here may not be the final vnode
            // that is mounted. Instead of caching it directly, we store the pending
            // key and cache `instance.subTree` (the normalized vnode) in
            // beforeMount/beforeUpdate hooks.
            pendingCacheKey = key;
            if (cachedVNode) {
                // copy over mounted state
                vnode.el = cachedVNode.el;
                vnode.component = cachedVNode.component;
                if (vnode.transition) {
                    // recursively update transition hooks on subTree
                    setTransitionHooks(vnode, vnode.transition);
                }
                // avoid vnode being mounted as fresh
                vnode.shapeFlag |= 512 /* COMPONENT_KEPT_ALIVE */;
                // make this key the freshest
                keys.delete(key);
                keys.add(key);
            }
            else {
                keys.add(key);
                // prune oldest entry
                if (max && keys.size > parseInt(max, 10)) {
                    pruneCacheEntry(keys.values().next().value);
                }
            }
            // avoid vnode being unmounted
            vnode.shapeFlag |= 256 /* COMPONENT_SHOULD_KEEP_ALIVE */;
            current = vnode;
            return isSuspense(rawVNode.type) ? rawVNode : vnode;
        };
    }
};
// export the public type for h/tsx inference
// also to avoid inline import() in generated d.ts files
const KeepAlive = KeepAliveImpl;
function matches(pattern, name) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(pattern)) {
        return pattern.some((p) => matches(p, name));
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(pattern)) {
        return pattern.split(',').includes(name);
    }
    else if (pattern.test) {
        return pattern.test(name);
    }
    /* istanbul ignore next */
    return false;
}
function onActivated(hook, target) {
    registerKeepAliveHook(hook, "a" /* ACTIVATED */, target);
}
function onDeactivated(hook, target) {
    registerKeepAliveHook(hook, "da" /* DEACTIVATED */, target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
    // cache the deactivate branch check wrapper for injected hooks so the same
    // hook can be properly deduped by the scheduler. "__wdc" stands for "with
    // deactivation check".
    const wrappedHook = hook.__wdc ||
        (hook.__wdc = () => {
            // only fire the hook if the target instance is NOT in a deactivated branch.
            let current = target;
            while (current) {
                if (current.isDeactivated) {
                    return;
                }
                current = current.parent;
            }
            return hook();
        });
    injectHook(type, wrappedHook, target);
    // In addition to registering it on the target instance, we walk up the parent
    // chain and register it on all ancestor instances that are keep-alive roots.
    // This avoids the need to walk the entire component tree when invoking these
    // hooks, and more importantly, avoids the need to track child components in
    // arrays.
    if (target) {
        let current = target.parent;
        while (current && current.parent) {
            if (isKeepAlive(current.parent.vnode)) {
                injectToKeepAliveRoot(wrappedHook, type, target, current);
            }
            current = current.parent;
        }
    }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
    // injectHook wraps the original for error handling, so make sure to remove
    // the wrapped version.
    const injected = injectHook(type, hook, keepAliveRoot, true /* prepend */);
    onUnmounted(() => {
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.remove)(keepAliveRoot[type], injected);
    }, target);
}
function resetShapeFlag(vnode) {
    let shapeFlag = vnode.shapeFlag;
    if (shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */) {
        shapeFlag -= 256 /* COMPONENT_SHOULD_KEEP_ALIVE */;
    }
    if (shapeFlag & 512 /* COMPONENT_KEPT_ALIVE */) {
        shapeFlag -= 512 /* COMPONENT_KEPT_ALIVE */;
    }
    vnode.shapeFlag = shapeFlag;
}
function getInnerChild(vnode) {
    return vnode.shapeFlag & 128 /* SUSPENSE */ ? vnode.ssContent : vnode;
}

function injectHook(type, hook, target = currentInstance, prepend = false) {
    if (target) {
        const hooks = target[type] || (target[type] = []);
        // cache the error handling wrapper for injected hooks so the same hook
        // can be properly deduped by the scheduler. "__weh" stands for "with error
        // handling".
        const wrappedHook = hook.__weh ||
            (hook.__weh = (...args) => {
                if (target.isUnmounted) {
                    return;
                }
                // disable tracking inside all lifecycle hooks
                // since they can potentially be called inside effects.
                (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
                // Set currentInstance during hook invocation.
                // This assumes the hook does not synchronously trigger other hooks, which
                // can only be false when the user does something really funky.
                setCurrentInstance(target);
                const res = callWithAsyncErrorHandling(hook, target, type, args);
                unsetCurrentInstance();
                (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
                return res;
            });
        if (prepend) {
            hooks.unshift(wrappedHook);
        }
        else {
            hooks.push(wrappedHook);
        }
        return wrappedHook;
    }
    else if ((true)) {
        const apiName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(ErrorTypeStrings[type].replace(/ hook$/, ''));
        warn(`${apiName} is called when there is no active component instance to be ` +
            `associated with. ` +
            `Lifecycle injection APIs can only be used during execution of setup().` +
            (` If you are using async setup(), make sure to register lifecycle ` +
                    `hooks before the first await statement.`
                ));
    }
}
const createHook = (lifecycle) => (hook, target = currentInstance) => 
// post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
(!isInSSRComponentSetup || lifecycle === "sp" /* SERVER_PREFETCH */) &&
    injectHook(lifecycle, hook, target);
const onBeforeMount = createHook("bm" /* BEFORE_MOUNT */);
const onMounted = createHook("m" /* MOUNTED */);
const onBeforeUpdate = createHook("bu" /* BEFORE_UPDATE */);
const onUpdated = createHook("u" /* UPDATED */);
const onBeforeUnmount = createHook("bum" /* BEFORE_UNMOUNT */);
const onUnmounted = createHook("um" /* UNMOUNTED */);
const onServerPrefetch = createHook("sp" /* SERVER_PREFETCH */);
const onRenderTriggered = createHook("rtg" /* RENDER_TRIGGERED */);
const onRenderTracked = createHook("rtc" /* RENDER_TRACKED */);
function onErrorCaptured(hook, target = currentInstance) {
    injectHook("ec" /* ERROR_CAPTURED */, hook, target);
}

/**
Runtime helper for applying directives to a vnode. Example usage:

const comp = resolveComponent('comp')
const foo = resolveDirective('foo')
const bar = resolveDirective('bar')

return withDirectives(h(comp), [
  [foo, this.x],
  [bar, this.y]
])
*/
function validateDirectiveName(name) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isBuiltInDirective)(name)) {
        warn('Do not use built-in directive ids as custom directive id: ' + name);
    }
}
/**
 * Adds directives to a VNode.
 */
function withDirectives(vnode, directives) {
    const internalInstance = currentRenderingInstance;
    if (internalInstance === null) {
        ( true) && warn(`withDirectives can only be used inside render functions.`);
        return vnode;
    }
    const instance = getExposeProxy(internalInstance) ||
        internalInstance.proxy;
    const bindings = vnode.dirs || (vnode.dirs = []);
    for (let i = 0; i < directives.length; i++) {
        let [dir, value, arg, modifiers = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ] = directives[i];
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(dir)) {
            dir = {
                mounted: dir,
                updated: dir
            };
        }
        if (dir.deep) {
            traverse(value);
        }
        bindings.push({
            dir,
            instance,
            value,
            oldValue: void 0,
            arg,
            modifiers
        });
    }
    return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
    const bindings = vnode.dirs;
    const oldBindings = prevVNode && prevVNode.dirs;
    for (let i = 0; i < bindings.length; i++) {
        const binding = bindings[i];
        if (oldBindings) {
            binding.oldValue = oldBindings[i].value;
        }
        let hook = binding.dir[name];
        if (hook) {
            // disable tracking inside all lifecycle hooks
            // since they can potentially be called inside effects.
            (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
            callWithAsyncErrorHandling(hook, instance, 8 /* DIRECTIVE_HOOK */, [
                vnode.el,
                binding,
                vnode,
                prevVNode
            ]);
            (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
        }
    }
}

const COMPONENTS = 'components';
const DIRECTIVES = 'directives';
/**
 * @private
 */
function resolveComponent(name, maybeSelfReference) {
    return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}
const NULL_DYNAMIC_COMPONENT = Symbol();
/**
 * @private
 */
function resolveDynamicComponent(component) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(component)) {
        return resolveAsset(COMPONENTS, component, false) || component;
    }
    else {
        // invalid types will fallthrough to createVNode and raise warning
        return (component || NULL_DYNAMIC_COMPONENT);
    }
}
/**
 * @private
 */
function resolveDirective(name) {
    return resolveAsset(DIRECTIVES, name);
}
// implementation
function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
    const instance = currentRenderingInstance || currentInstance;
    if (instance) {
        const Component = instance.type;
        // explicit self name has highest priority
        if (type === COMPONENTS) {
            const selfName = getComponentName(Component);
            if (selfName &&
                (selfName === name ||
                    selfName === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name) ||
                    selfName === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name)))) {
                return Component;
            }
        }
        const res = 
        // local registration
        // check instance[type] first which is resolved for options API
        resolve(instance[type] || Component[type], name) ||
            // global registration
            resolve(instance.appContext[type], name);
        if (!res && maybeSelfReference) {
            // fallback to implicit self-reference
            return Component;
        }
        if (( true) && warnMissing && !res) {
            const extra = type === COMPONENTS
                ? `\nIf this is a native custom element, make sure to exclude it from ` +
                    `component resolution via compilerOptions.isCustomElement.`
                : ``;
            warn(`Failed to resolve ${type.slice(0, -1)}: ${name}${extra}`);
        }
        return res;
    }
    else if ((true)) {
        warn(`resolve${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)(type.slice(0, -1))} ` +
            `can only be used in render() or setup().`);
    }
}
function resolve(registry, name) {
    return (registry &&
        (registry[name] ||
            registry[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name)] ||
            registry[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name))]));
}

/**
 * Actual implementation
 */
function renderList(source, renderItem, cache, index) {
    let ret;
    const cached = (cache && cache[index]);
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(source) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(source)) {
        ret = new Array(source.length);
        for (let i = 0, l = source.length; i < l; i++) {
            ret[i] = renderItem(source[i], i, undefined, cached && cached[i]);
        }
    }
    else if (typeof source === 'number') {
        if (( true) && !Number.isInteger(source)) {
            warn(`The v-for range expect an integer value but got ${source}.`);
        }
        ret = new Array(source);
        for (let i = 0; i < source; i++) {
            ret[i] = renderItem(i + 1, i, undefined, cached && cached[i]);
        }
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(source)) {
        if (source[Symbol.iterator]) {
            ret = Array.from(source, (item, i) => renderItem(item, i, undefined, cached && cached[i]));
        }
        else {
            const keys = Object.keys(source);
            ret = new Array(keys.length);
            for (let i = 0, l = keys.length; i < l; i++) {
                const key = keys[i];
                ret[i] = renderItem(source[key], key, i, cached && cached[i]);
            }
        }
    }
    else {
        ret = [];
    }
    if (cache) {
        cache[index] = ret;
    }
    return ret;
}

/**
 * Compiler runtime helper for creating dynamic slots object
 * @private
 */
function createSlots(slots, dynamicSlots) {
    for (let i = 0; i < dynamicSlots.length; i++) {
        const slot = dynamicSlots[i];
        // array of dynamic slot generated by <template v-for="..." #[...]>
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(slot)) {
            for (let j = 0; j < slot.length; j++) {
                slots[slot[j].name] = slot[j].fn;
            }
        }
        else if (slot) {
            // conditional single slot generated by <template v-if="..." #foo>
            slots[slot.name] = slot.fn;
        }
    }
    return slots;
}

/**
 * Compiler runtime helper for rendering `<slot/>`
 * @private
 */
function renderSlot(slots, name, props = {}, 
// this is not a user-facing function, so the fallback is always generated by
// the compiler and guaranteed to be a function returning an array
fallback, noSlotted) {
    if (currentRenderingInstance.isCE ||
        (currentRenderingInstance.parent &&
            isAsyncWrapper(currentRenderingInstance.parent) &&
            currentRenderingInstance.parent.isCE)) {
        return createVNode('slot', name === 'default' ? null : { name }, fallback && fallback());
    }
    let slot = slots[name];
    if (( true) && slot && slot.length > 1) {
        warn(`SSR-optimized slot function detected in a non-SSR-optimized render ` +
            `function. You need to mark this component with $dynamic-slots in the ` +
            `parent template.`);
        slot = () => [];
    }
    // a compiled slot disables block tracking by default to avoid manual
    // invocation interfering with template-based block tracking, but in
    // `renderSlot` we can be sure that it's template-based so we can force
    // enable it.
    if (slot && slot._c) {
        slot._d = false;
    }
    openBlock();
    const validSlotContent = slot && ensureValidVNode(slot(props));
    const rendered = createBlock(Fragment, { key: props.key || `_${name}` }, validSlotContent || (fallback ? fallback() : []), validSlotContent && slots._ === 1 /* STABLE */
        ? 64 /* STABLE_FRAGMENT */
        : -2 /* BAIL */);
    if (!noSlotted && rendered.scopeId) {
        rendered.slotScopeIds = [rendered.scopeId + '-s'];
    }
    if (slot && slot._c) {
        slot._d = true;
    }
    return rendered;
}
function ensureValidVNode(vnodes) {
    return vnodes.some(child => {
        if (!isVNode(child))
            return true;
        if (child.type === Comment)
            return false;
        if (child.type === Fragment &&
            !ensureValidVNode(child.children))
            return false;
        return true;
    })
        ? vnodes
        : null;
}

/**
 * For prefixing keys in v-on="obj" with "on"
 * @private
 */
function toHandlers(obj) {
    const ret = {};
    if (( true) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(obj)) {
        warn(`v-on with no argument expects an object value.`);
        return ret;
    }
    for (const key in obj) {
        ret[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(key)] = obj[key];
    }
    return ret;
}

/**
 * #2437 In Vue 3, functional components do not have a public instance proxy but
 * they exist in the internal parent chain. For code that relies on traversing
 * public $parent chains, skip functional ones and go to the parent instead.
 */
const getPublicInstance = (i) => {
    if (!i)
        return null;
    if (isStatefulComponent(i))
        return getExposeProxy(i) || i.proxy;
    return getPublicInstance(i.parent);
};
const publicPropertiesMap = 
// Move PURE marker to new line to workaround compiler discarding it
// due to type annotation
/*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(Object.create(null), {
    $: i => i,
    $el: i => i.vnode.el,
    $data: i => i.data,
    $props: i => (( true) ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.props) : 0),
    $attrs: i => (( true) ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.attrs) : 0),
    $slots: i => (( true) ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.slots) : 0),
    $refs: i => (( true) ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.refs) : 0),
    $parent: i => getPublicInstance(i.parent),
    $root: i => getPublicInstance(i.root),
    $emit: i => i.emit,
    $options: i => (__VUE_OPTIONS_API__ ? resolveMergedOptions(i) : i.type),
    $forceUpdate: i => i.f || (i.f = () => queueJob(i.update)),
    $nextTick: i => i.n || (i.n = nextTick.bind(i.proxy)),
    $watch: i => (__VUE_OPTIONS_API__ ? instanceWatch.bind(i) : _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP)
});
const isReservedPrefix = (key) => key === '_' || key === '$';
const PublicInstanceProxyHandlers = {
    get({ _: instance }, key) {
        const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
        // for internal formatters to know that this is a Vue instance
        if (( true) && key === '__isVue') {
            return true;
        }
        // prioritize <script setup> bindings during dev.
        // this allows even properties that start with _ or $ to be used - so that
        // it aligns with the production behavior where the render fn is inlined and
        // indeed has access to all declared variables.
        if (( true) &&
            setupState !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ &&
            setupState.__isScriptSetup &&
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, key)) {
            return setupState[key];
        }
        // data / props / ctx
        // This getter gets called for every property access on the render context
        // during render and is a major hotspot. The most expensive part of this
        // is the multiple hasOwn() calls. It's much faster to do a simple property
        // access on a plain object, so we use an accessCache object (with null
        // prototype) to memoize what access type a key corresponds to.
        let normalizedProps;
        if (key[0] !== '$') {
            const n = accessCache[key];
            if (n !== undefined) {
                switch (n) {
                    case 1 /* SETUP */:
                        return setupState[key];
                    case 2 /* DATA */:
                        return data[key];
                    case 4 /* CONTEXT */:
                        return ctx[key];
                    case 3 /* PROPS */:
                        return props[key];
                    // default: just fallthrough
                }
            }
            else if (setupState !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, key)) {
                accessCache[key] = 1 /* SETUP */;
                return setupState[key];
            }
            else if (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key)) {
                accessCache[key] = 2 /* DATA */;
                return data[key];
            }
            else if (
            // only cache other properties when instance has declared (thus stable)
            // props
            (normalizedProps = instance.propsOptions[0]) &&
                (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(normalizedProps, key)) {
                accessCache[key] = 3 /* PROPS */;
                return props[key];
            }
            else if (ctx !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(ctx, key)) {
                accessCache[key] = 4 /* CONTEXT */;
                return ctx[key];
            }
            else if (!__VUE_OPTIONS_API__ || shouldCacheAccess) {
                accessCache[key] = 0 /* OTHER */;
            }
        }
        const publicGetter = publicPropertiesMap[key];
        let cssModule, globalProperties;
        // public $xxx properties
        if (publicGetter) {
            if (key === '$attrs') {
                (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.track)(instance, "get" /* GET */, key);
                ( true) && markAttrsAccessed();
            }
            return publicGetter(instance);
        }
        else if (
        // css module (injected by vue-loader)
        (cssModule = type.__cssModules) &&
            (cssModule = cssModule[key])) {
            return cssModule;
        }
        else if (ctx !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(ctx, key)) {
            // user may set custom properties to `this` that start with `$`
            accessCache[key] = 4 /* CONTEXT */;
            return ctx[key];
        }
        else if (
        // global properties
        ((globalProperties = appContext.config.globalProperties),
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(globalProperties, key))) {
            {
                return globalProperties[key];
            }
        }
        else if (( true) &&
            currentRenderingInstance &&
            (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(key) ||
                // #1091 avoid internal isRef/isVNode checks on component instance leading
                // to infinite warning loop
                key.indexOf('__v') !== 0)) {
            if (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && isReservedPrefix(key[0]) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key)) {
                warn(`Property ${JSON.stringify(key)} must be accessed via $data because it starts with a reserved ` +
                    `character ("$" or "_") and is not proxied on the render context.`);
            }
            else if (instance === currentRenderingInstance) {
                warn(`Property ${JSON.stringify(key)} was accessed during render ` +
                    `but is not defined on instance.`);
            }
        }
    },
    set({ _: instance }, key, value) {
        const { data, setupState, ctx } = instance;
        if (setupState !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, key)) {
            setupState[key] = value;
            return true;
        }
        else if (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key)) {
            data[key] = value;
            return true;
        }
        else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(instance.props, key)) {
            ( true) &&
                warn(`Attempting to mutate prop "${key}". Props are readonly.`, instance);
            return false;
        }
        if (key[0] === '$' && key.slice(1) in instance) {
            ( true) &&
                warn(`Attempting to mutate public property "${key}". ` +
                    `Properties starting with $ are reserved and readonly.`, instance);
            return false;
        }
        else {
            if (( true) && key in instance.appContext.config.globalProperties) {
                Object.defineProperty(ctx, key, {
                    enumerable: true,
                    configurable: true,
                    value
                });
            }
            else {
                ctx[key] = value;
            }
        }
        return true;
    },
    has({ _: { data, setupState, accessCache, ctx, appContext, propsOptions } }, key) {
        let normalizedProps;
        return (!!accessCache[key] ||
            (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key)) ||
            (setupState !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, key)) ||
            ((normalizedProps = propsOptions[0]) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(normalizedProps, key)) ||
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(ctx, key) ||
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(publicPropertiesMap, key) ||
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(appContext.config.globalProperties, key));
    },
    defineProperty(target, key, descriptor) {
        if (descriptor.get != null) {
            // invalidate key cache of a getter based property #5417
            target._.accessCache[key] = 0;
        }
        else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(descriptor, 'value')) {
            this.set(target, key, descriptor.value, null);
        }
        return Reflect.defineProperty(target, key, descriptor);
    }
};
if (true) {
    PublicInstanceProxyHandlers.ownKeys = (target) => {
        warn(`Avoid app logic that relies on enumerating keys on a component instance. ` +
            `The keys will be empty in production mode to avoid performance overhead.`);
        return Reflect.ownKeys(target);
    };
}
const RuntimeCompiledPublicInstanceProxyHandlers = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, PublicInstanceProxyHandlers, {
    get(target, key) {
        // fast path for unscopables when using `with` block
        if (key === Symbol.unscopables) {
            return;
        }
        return PublicInstanceProxyHandlers.get(target, key, target);
    },
    has(_, key) {
        const has = key[0] !== '_' && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isGloballyWhitelisted)(key);
        if (( true) && !has && PublicInstanceProxyHandlers.has(_, key)) {
            warn(`Property ${JSON.stringify(key)} should not start with _ which is a reserved prefix for Vue internals.`);
        }
        return has;
    }
});
// dev only
// In dev mode, the proxy target exposes the same properties as seen on `this`
// for easier console inspection. In prod mode it will be an empty object so
// these properties definitions can be skipped.
function createDevRenderContext(instance) {
    const target = {};
    // expose internal instance for proxy handlers
    Object.defineProperty(target, `_`, {
        configurable: true,
        enumerable: false,
        get: () => instance
    });
    // expose public properties
    Object.keys(publicPropertiesMap).forEach(key => {
        Object.defineProperty(target, key, {
            configurable: true,
            enumerable: false,
            get: () => publicPropertiesMap[key](instance),
            // intercepted by the proxy so no need for implementation,
            // but needed to prevent set errors
            set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP
        });
    });
    return target;
}
// dev only
function exposePropsOnRenderContext(instance) {
    const { ctx, propsOptions: [propsOptions] } = instance;
    if (propsOptions) {
        Object.keys(propsOptions).forEach(key => {
            Object.defineProperty(ctx, key, {
                enumerable: true,
                configurable: true,
                get: () => instance.props[key],
                set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP
            });
        });
    }
}
// dev only
function exposeSetupStateOnRenderContext(instance) {
    const { ctx, setupState } = instance;
    Object.keys((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(setupState)).forEach(key => {
        if (!setupState.__isScriptSetup) {
            if (isReservedPrefix(key[0])) {
                warn(`setup() return property ${JSON.stringify(key)} should not start with "$" or "_" ` +
                    `which are reserved prefixes for Vue internals.`);
                return;
            }
            Object.defineProperty(ctx, key, {
                enumerable: true,
                configurable: true,
                get: () => setupState[key],
                set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP
            });
        }
    });
}

function createDuplicateChecker() {
    const cache = Object.create(null);
    return (type, key) => {
        if (cache[key]) {
            warn(`${type} property "${key}" is already defined in ${cache[key]}.`);
        }
        else {
            cache[key] = type;
        }
    };
}
let shouldCacheAccess = true;
function applyOptions(instance) {
    const options = resolveMergedOptions(instance);
    const publicThis = instance.proxy;
    const ctx = instance.ctx;
    // do not cache property access on public proxy during state initialization
    shouldCacheAccess = false;
    // call beforeCreate first before accessing other options since
    // the hook may mutate resolved options (#2791)
    if (options.beforeCreate) {
        callHook(options.beforeCreate, instance, "bc" /* BEFORE_CREATE */);
    }
    const { 
    // state
    data: dataOptions, computed: computedOptions, methods, watch: watchOptions, provide: provideOptions, inject: injectOptions, 
    // lifecycle
    created, beforeMount, mounted, beforeUpdate, updated, activated, deactivated, beforeDestroy, beforeUnmount, destroyed, unmounted, render, renderTracked, renderTriggered, errorCaptured, serverPrefetch, 
    // public API
    expose, inheritAttrs, 
    // assets
    components, directives, filters } = options;
    const checkDuplicateProperties = ( true) ? createDuplicateChecker() : 0;
    if ((true)) {
        const [propsOptions] = instance.propsOptions;
        if (propsOptions) {
            for (const key in propsOptions) {
                checkDuplicateProperties("Props" /* PROPS */, key);
            }
        }
    }
    // options initialization order (to be consistent with Vue 2):
    // - props (already done outside of this function)
    // - inject
    // - methods
    // - data (deferred since it relies on `this` access)
    // - computed
    // - watch (deferred since it relies on `this` access)
    if (injectOptions) {
        resolveInjections(injectOptions, ctx, checkDuplicateProperties, instance.appContext.config.unwrapInjectedRef);
    }
    if (methods) {
        for (const key in methods) {
            const methodHandler = methods[key];
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(methodHandler)) {
                // In dev mode, we use the `createRenderContext` function to define
                // methods to the proxy target, and those are read-only but
                // reconfigurable, so it needs to be redefined here
                if ((true)) {
                    Object.defineProperty(ctx, key, {
                        value: methodHandler.bind(publicThis),
                        configurable: true,
                        enumerable: true,
                        writable: true
                    });
                }
                else {}
                if ((true)) {
                    checkDuplicateProperties("Methods" /* METHODS */, key);
                }
            }
            else if ((true)) {
                warn(`Method "${key}" has type "${typeof methodHandler}" in the component definition. ` +
                    `Did you reference the function correctly?`);
            }
        }
    }
    if (dataOptions) {
        if (( true) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(dataOptions)) {
            warn(`The data option must be a function. ` +
                `Plain object usage is no longer supported.`);
        }
        const data = dataOptions.call(publicThis, publicThis);
        if (( true) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(data)) {
            warn(`data() returned a Promise - note data() cannot be async; If you ` +
                `intend to perform data fetching before component renders, use ` +
                `async setup() + <Suspense>.`);
        }
        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(data)) {
            ( true) && warn(`data() should return an object.`);
        }
        else {
            instance.data = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.reactive)(data);
            if ((true)) {
                for (const key in data) {
                    checkDuplicateProperties("Data" /* DATA */, key);
                    // expose data on ctx during dev
                    if (!isReservedPrefix(key[0])) {
                        Object.defineProperty(ctx, key, {
                            configurable: true,
                            enumerable: true,
                            get: () => data[key],
                            set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP
                        });
                    }
                }
            }
        }
    }
    // state initialization complete at this point - start caching access
    shouldCacheAccess = true;
    if (computedOptions) {
        for (const key in computedOptions) {
            const opt = computedOptions[key];
            const get = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt)
                ? opt.bind(publicThis, publicThis)
                : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt.get)
                    ? opt.get.bind(publicThis, publicThis)
                    : _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;
            if (( true) && get === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP) {
                warn(`Computed property "${key}" has no getter.`);
            }
            const set = !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt.set)
                ? opt.set.bind(publicThis)
                : ( true)
                    ? () => {
                        warn(`Write operation failed: computed property "${key}" is readonly.`);
                    }
                    : 0;
            const c = computed({
                get,
                set
            });
            Object.defineProperty(ctx, key, {
                enumerable: true,
                configurable: true,
                get: () => c.value,
                set: v => (c.value = v)
            });
            if ((true)) {
                checkDuplicateProperties("Computed" /* COMPUTED */, key);
            }
        }
    }
    if (watchOptions) {
        for (const key in watchOptions) {
            createWatcher(watchOptions[key], ctx, publicThis, key);
        }
    }
    if (provideOptions) {
        const provides = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(provideOptions)
            ? provideOptions.call(publicThis)
            : provideOptions;
        Reflect.ownKeys(provides).forEach(key => {
            provide(key, provides[key]);
        });
    }
    if (created) {
        callHook(created, instance, "c" /* CREATED */);
    }
    function registerLifecycleHook(register, hook) {
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook)) {
            hook.forEach(_hook => register(_hook.bind(publicThis)));
        }
        else if (hook) {
            register(hook.bind(publicThis));
        }
    }
    registerLifecycleHook(onBeforeMount, beforeMount);
    registerLifecycleHook(onMounted, mounted);
    registerLifecycleHook(onBeforeUpdate, beforeUpdate);
    registerLifecycleHook(onUpdated, updated);
    registerLifecycleHook(onActivated, activated);
    registerLifecycleHook(onDeactivated, deactivated);
    registerLifecycleHook(onErrorCaptured, errorCaptured);
    registerLifecycleHook(onRenderTracked, renderTracked);
    registerLifecycleHook(onRenderTriggered, renderTriggered);
    registerLifecycleHook(onBeforeUnmount, beforeUnmount);
    registerLifecycleHook(onUnmounted, unmounted);
    registerLifecycleHook(onServerPrefetch, serverPrefetch);
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(expose)) {
        if (expose.length) {
            const exposed = instance.exposed || (instance.exposed = {});
            expose.forEach(key => {
                Object.defineProperty(exposed, key, {
                    get: () => publicThis[key],
                    set: val => (publicThis[key] = val)
                });
            });
        }
        else if (!instance.exposed) {
            instance.exposed = {};
        }
    }
    // options that are handled when creating the instance but also need to be
    // applied from mixins
    if (render && instance.render === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP) {
        instance.render = render;
    }
    if (inheritAttrs != null) {
        instance.inheritAttrs = inheritAttrs;
    }
    // asset options.
    if (components)
        instance.components = components;
    if (directives)
        instance.directives = directives;
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP, unwrapRef = false) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(injectOptions)) {
        injectOptions = normalizeInject(injectOptions);
    }
    for (const key in injectOptions) {
        const opt = injectOptions[key];
        let injected;
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(opt)) {
            if ('default' in opt) {
                injected = inject(opt.from || key, opt.default, true /* treat default function as factory */);
            }
            else {
                injected = inject(opt.from || key);
            }
        }
        else {
            injected = inject(opt);
        }
        if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(injected)) {
            // TODO remove the check in 3.3
            if (unwrapRef) {
                Object.defineProperty(ctx, key, {
                    enumerable: true,
                    configurable: true,
                    get: () => injected.value,
                    set: v => (injected.value = v)
                });
            }
            else {
                if ((true)) {
                    warn(`injected property "${key}" is a ref and will be auto-unwrapped ` +
                        `and no longer needs \`.value\` in the next minor release. ` +
                        `To opt-in to the new behavior now, ` +
                        `set \`app.config.unwrapInjectedRef = true\` (this config is ` +
                        `temporary and will not be needed in the future.)`);
                }
                ctx[key] = injected;
            }
        }
        else {
            ctx[key] = injected;
        }
        if ((true)) {
            checkDuplicateProperties("Inject" /* INJECT */, key);
        }
    }
}
function callHook(hook, instance, type) {
    callWithAsyncErrorHandling((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook)
        ? hook.map(h => h.bind(instance.proxy))
        : hook.bind(instance.proxy), instance, type);
}
function createWatcher(raw, ctx, publicThis, key) {
    const getter = key.includes('.')
        ? createPathGetter(publicThis, key)
        : () => publicThis[key];
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(raw)) {
        const handler = ctx[raw];
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(handler)) {
            watch(getter, handler);
        }
        else if ((true)) {
            warn(`Invalid watch handler specified by key "${raw}"`, handler);
        }
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(raw)) {
        watch(getter, raw.bind(publicThis));
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(raw)) {
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {
            raw.forEach(r => createWatcher(r, ctx, publicThis, key));
        }
        else {
            const handler = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(raw.handler)
                ? raw.handler.bind(publicThis)
                : ctx[raw.handler];
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(handler)) {
                watch(getter, handler, raw);
            }
            else if ((true)) {
                warn(`Invalid watch handler specified by key "${raw.handler}"`, handler);
            }
        }
    }
    else if ((true)) {
        warn(`Invalid watch option: "${key}"`, raw);
    }
}
/**
 * Resolve merged options and cache it on the component.
 * This is done only once per-component since the merging does not involve
 * instances.
 */
function resolveMergedOptions(instance) {
    const base = instance.type;
    const { mixins, extends: extendsOptions } = base;
    const { mixins: globalMixins, optionsCache: cache, config: { optionMergeStrategies } } = instance.appContext;
    const cached = cache.get(base);
    let resolved;
    if (cached) {
        resolved = cached;
    }
    else if (!globalMixins.length && !mixins && !extendsOptions) {
        {
            resolved = base;
        }
    }
    else {
        resolved = {};
        if (globalMixins.length) {
            globalMixins.forEach(m => mergeOptions(resolved, m, optionMergeStrategies, true));
        }
        mergeOptions(resolved, base, optionMergeStrategies);
    }
    cache.set(base, resolved);
    return resolved;
}
function mergeOptions(to, from, strats, asMixin = false) {
    const { mixins, extends: extendsOptions } = from;
    if (extendsOptions) {
        mergeOptions(to, extendsOptions, strats, true);
    }
    if (mixins) {
        mixins.forEach((m) => mergeOptions(to, m, strats, true));
    }
    for (const key in from) {
        if (asMixin && key === 'expose') {
            ( true) &&
                warn(`"expose" option is ignored when declared in mixins or extends. ` +
                    `It should only be declared in the base component itself.`);
        }
        else {
            const strat = internalOptionMergeStrats[key] || (strats && strats[key]);
            to[key] = strat ? strat(to[key], from[key]) : from[key];
        }
    }
    return to;
}
const internalOptionMergeStrats = {
    data: mergeDataFn,
    props: mergeObjectOptions,
    emits: mergeObjectOptions,
    // objects
    methods: mergeObjectOptions,
    computed: mergeObjectOptions,
    // lifecycle
    beforeCreate: mergeAsArray,
    created: mergeAsArray,
    beforeMount: mergeAsArray,
    mounted: mergeAsArray,
    beforeUpdate: mergeAsArray,
    updated: mergeAsArray,
    beforeDestroy: mergeAsArray,
    beforeUnmount: mergeAsArray,
    destroyed: mergeAsArray,
    unmounted: mergeAsArray,
    activated: mergeAsArray,
    deactivated: mergeAsArray,
    errorCaptured: mergeAsArray,
    serverPrefetch: mergeAsArray,
    // assets
    components: mergeObjectOptions,
    directives: mergeObjectOptions,
    // watch
    watch: mergeWatchOptions,
    // provide / inject
    provide: mergeDataFn,
    inject: mergeInject
};
function mergeDataFn(to, from) {
    if (!from) {
        return to;
    }
    if (!to) {
        return from;
    }
    return function mergedDataFn() {
        return ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend))((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(to) ? to.call(this, this) : to, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(from) ? from.call(this, this) : from);
    };
}
function mergeInject(to, from) {
    return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {
        const res = {};
        for (let i = 0; i < raw.length; i++) {
            res[raw[i]] = raw[i];
        }
        return res;
    }
    return raw;
}
function mergeAsArray(to, from) {
    return to ? [...new Set([].concat(to, from))] : from;
}
function mergeObjectOptions(to, from) {
    return to ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(Object.create(null), to), from) : from;
}
function mergeWatchOptions(to, from) {
    if (!to)
        return from;
    if (!from)
        return to;
    const merged = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(Object.create(null), to);
    for (const key in from) {
        merged[key] = mergeAsArray(to[key], from[key]);
    }
    return merged;
}

function initProps(instance, rawProps, isStateful, // result of bitwise flag comparison
isSSR = false) {
    const props = {};
    const attrs = {};
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.def)(attrs, InternalObjectKey, 1);
    instance.propsDefaults = Object.create(null);
    setFullProps(instance, rawProps, props, attrs);
    // ensure all declared prop keys are present
    for (const key in instance.propsOptions[0]) {
        if (!(key in props)) {
            props[key] = undefined;
        }
    }
    // validation
    if ((true)) {
        validateProps(rawProps || {}, props, instance);
    }
    if (isStateful) {
        // stateful
        instance.props = isSSR ? props : (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReactive)(props);
    }
    else {
        if (!instance.type.props) {
            // functional w/ optional props, props === attrs
            instance.props = attrs;
        }
        else {
            // functional w/ declared props
            instance.props = props;
        }
    }
    instance.attrs = attrs;
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
    const { props, attrs, vnode: { patchFlag } } = instance;
    const rawCurrentProps = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);
    const [options] = instance.propsOptions;
    let hasAttrsChanged = false;
    if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    !(( true) &&
        (instance.type.__hmrId ||
            (instance.parent && instance.parent.type.__hmrId))) &&
        (optimized || patchFlag > 0) &&
        !(patchFlag & 16 /* FULL_PROPS */)) {
        if (patchFlag & 8 /* PROPS */) {
            // Compiler-generated props & no keys change, just set the updated
            // the props.
            const propsToUpdate = instance.vnode.dynamicProps;
            for (let i = 0; i < propsToUpdate.length; i++) {
                let key = propsToUpdate[i];
                // skip if the prop key is a declared emit event listener
                if (isEmitListener(instance.emitsOptions, key)) {
                    continue;
                }
                // PROPS flag guarantees rawProps to be non-null
                const value = rawProps[key];
                if (options) {
                    // attr / props separation was done on init and will be consistent
                    // in this code path, so just check if attrs have it.
                    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(attrs, key)) {
                        if (value !== attrs[key]) {
                            attrs[key] = value;
                            hasAttrsChanged = true;
                        }
                    }
                    else {
                        const camelizedKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key);
                        props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance, false /* isAbsent */);
                    }
                }
                else {
                    if (value !== attrs[key]) {
                        attrs[key] = value;
                        hasAttrsChanged = true;
                    }
                }
            }
        }
    }
    else {
        // full props update.
        if (setFullProps(instance, rawProps, props, attrs)) {
            hasAttrsChanged = true;
        }
        // in case of dynamic props, check if we need to delete keys from
        // the props object
        let kebabKey;
        for (const key in rawCurrentProps) {
            if (!rawProps ||
                // for camelCase
                (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, key) &&
                    // it's possible the original props was passed in as kebab-case
                    // and converted to camelCase (#955)
                    ((kebabKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key)) === key || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, kebabKey)))) {
                if (options) {
                    if (rawPrevProps &&
                        // for camelCase
                        (rawPrevProps[key] !== undefined ||
                            // for kebab-case
                            rawPrevProps[kebabKey] !== undefined)) {
                        props[key] = resolvePropValue(options, rawCurrentProps, key, undefined, instance, true /* isAbsent */);
                    }
                }
                else {
                    delete props[key];
                }
            }
        }
        // in the case of functional component w/o props declaration, props and
        // attrs point to the same object so it should already have been updated.
        if (attrs !== rawCurrentProps) {
            for (const key in attrs) {
                if (!rawProps ||
                    (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, key) &&
                        (!false ))) {
                    delete attrs[key];
                    hasAttrsChanged = true;
                }
            }
        }
    }
    // trigger updates for $attrs in case it's used in component slots
    if (hasAttrsChanged) {
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.trigger)(instance, "set" /* SET */, '$attrs');
    }
    if ((true)) {
        validateProps(rawProps || {}, props, instance);
    }
}
function setFullProps(instance, rawProps, props, attrs) {
    const [options, needCastKeys] = instance.propsOptions;
    let hasAttrsChanged = false;
    let rawCastValues;
    if (rawProps) {
        for (let key in rawProps) {
            // key, ref are reserved and never passed down
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key)) {
                continue;
            }
            const value = rawProps[key];
            // prop option names are camelized during normalization, so to support
            // kebab -> camel conversion here we need to camelize the key.
            let camelKey;
            if (options && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, (camelKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key)))) {
                if (!needCastKeys || !needCastKeys.includes(camelKey)) {
                    props[camelKey] = value;
                }
                else {
                    (rawCastValues || (rawCastValues = {}))[camelKey] = value;
                }
            }
            else if (!isEmitListener(instance.emitsOptions, key)) {
                if (!(key in attrs) || value !== attrs[key]) {
                    attrs[key] = value;
                    hasAttrsChanged = true;
                }
            }
        }
    }
    if (needCastKeys) {
        const rawCurrentProps = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);
        const castValues = rawCastValues || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
        for (let i = 0; i < needCastKeys.length; i++) {
            const key = needCastKeys[i];
            props[key] = resolvePropValue(options, rawCurrentProps, key, castValues[key], instance, !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(castValues, key));
        }
    }
    return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance, isAbsent) {
    const opt = options[key];
    if (opt != null) {
        const hasDefault = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(opt, 'default');
        // default values
        if (hasDefault && value === undefined) {
            const defaultValue = opt.default;
            if (opt.type !== Function && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(defaultValue)) {
                const { propsDefaults } = instance;
                if (key in propsDefaults) {
                    value = propsDefaults[key];
                }
                else {
                    setCurrentInstance(instance);
                    value = propsDefaults[key] = defaultValue.call(null, props);
                    unsetCurrentInstance();
                }
            }
            else {
                value = defaultValue;
            }
        }
        // boolean casting
        if (opt[0 /* shouldCast */]) {
            if (isAbsent && !hasDefault) {
                value = false;
            }
            else if (opt[1 /* shouldCastTrue */] &&
                (value === '' || value === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key))) {
                value = true;
            }
        }
    }
    return value;
}
function normalizePropsOptions(comp, appContext, asMixin = false) {
    const cache = appContext.propsCache;
    const cached = cache.get(comp);
    if (cached) {
        return cached;
    }
    const raw = comp.props;
    const normalized = {};
    const needCastKeys = [];
    // apply mixin/extends props
    let hasExtends = false;
    if (__VUE_OPTIONS_API__ && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(comp)) {
        const extendProps = (raw) => {
            hasExtends = true;
            const [props, keys] = normalizePropsOptions(raw, appContext, true);
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(normalized, props);
            if (keys)
                needCastKeys.push(...keys);
        };
        if (!asMixin && appContext.mixins.length) {
            appContext.mixins.forEach(extendProps);
        }
        if (comp.extends) {
            extendProps(comp.extends);
        }
        if (comp.mixins) {
            comp.mixins.forEach(extendProps);
        }
    }
    if (!raw && !hasExtends) {
        cache.set(comp, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR);
        return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;
    }
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {
        for (let i = 0; i < raw.length; i++) {
            if (( true) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(raw[i])) {
                warn(`props must be strings when using array syntax.`, raw[i]);
            }
            const normalizedKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(raw[i]);
            if (validatePropName(normalizedKey)) {
                normalized[normalizedKey] = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
            }
        }
    }
    else if (raw) {
        if (( true) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(raw)) {
            warn(`invalid props options`, raw);
        }
        for (const key in raw) {
            const normalizedKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key);
            if (validatePropName(normalizedKey)) {
                const opt = raw[key];
                const prop = (normalized[normalizedKey] =
                    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(opt) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt) ? { type: opt } : opt);
                if (prop) {
                    const booleanIndex = getTypeIndex(Boolean, prop.type);
                    const stringIndex = getTypeIndex(String, prop.type);
                    prop[0 /* shouldCast */] = booleanIndex > -1;
                    prop[1 /* shouldCastTrue */] =
                        stringIndex < 0 || booleanIndex < stringIndex;
                    // if the prop needs boolean casting or default value
                    if (booleanIndex > -1 || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(prop, 'default')) {
                        needCastKeys.push(normalizedKey);
                    }
                }
            }
        }
    }
    const res = [normalized, needCastKeys];
    cache.set(comp, res);
    return res;
}
function validatePropName(key) {
    if (key[0] !== '$') {
        return true;
    }
    else if ((true)) {
        warn(`Invalid prop name: "${key}" is a reserved property.`);
    }
    return false;
}
// use function string name to check type constructors
// so that it works across vms / iframes.
function getType(ctor) {
    const match = ctor && ctor.toString().match(/^\s*function (\w+)/);
    return match ? match[1] : ctor === null ? 'null' : '';
}
function isSameType(a, b) {
    return getType(a) === getType(b);
}
function getTypeIndex(type, expectedTypes) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(expectedTypes)) {
        return expectedTypes.findIndex(t => isSameType(t, type));
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(expectedTypes)) {
        return isSameType(expectedTypes, type) ? 0 : -1;
    }
    return -1;
}
/**
 * dev only
 */
function validateProps(rawProps, props, instance) {
    const resolvedValues = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);
    const options = instance.propsOptions[0];
    for (const key in options) {
        let opt = options[key];
        if (opt == null)
            continue;
        validateProp(key, resolvedValues[key], opt, !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, key) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key)));
    }
}
/**
 * dev only
 */
function validateProp(name, value, prop, isAbsent) {
    const { type, required, validator } = prop;
    // required!
    if (required && isAbsent) {
        warn('Missing required prop: "' + name + '"');
        return;
    }
    // missing but optional
    if (value == null && !prop.required) {
        return;
    }
    // type check
    if (type != null && type !== true) {
        let isValid = false;
        const types = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(type) ? type : [type];
        const expectedTypes = [];
        // value is valid as long as one of the specified types match
        for (let i = 0; i < types.length && !isValid; i++) {
            const { valid, expectedType } = assertType(value, types[i]);
            expectedTypes.push(expectedType || '');
            isValid = valid;
        }
        if (!isValid) {
            warn(getInvalidTypeMessage(name, value, expectedTypes));
            return;
        }
    }
    // custom validator
    if (validator && !validator(value)) {
        warn('Invalid prop: custom validator check failed for prop "' + name + '".');
    }
}
const isSimpleType = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)('String,Number,Boolean,Function,Symbol,BigInt');
/**
 * dev only
 */
function assertType(value, type) {
    let valid;
    const expectedType = getType(type);
    if (isSimpleType(expectedType)) {
        const t = typeof value;
        valid = t === expectedType.toLowerCase();
        // for primitive wrapper objects
        if (!valid && t === 'object') {
            valid = value instanceof type;
        }
    }
    else if (expectedType === 'Object') {
        valid = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(value);
    }
    else if (expectedType === 'Array') {
        valid = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value);
    }
    else if (expectedType === 'null') {
        valid = value === null;
    }
    else {
        valid = value instanceof type;
    }
    return {
        valid,
        expectedType
    };
}
/**
 * dev only
 */
function getInvalidTypeMessage(name, value, expectedTypes) {
    let message = `Invalid prop: type check failed for prop "${name}".` +
        ` Expected ${expectedTypes.map(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize).join(' | ')}`;
    const expectedType = expectedTypes[0];
    const receivedType = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toRawType)(value);
    const expectedValue = styleValue(value, expectedType);
    const receivedValue = styleValue(value, receivedType);
    // check if we need to specify expected value
    if (expectedTypes.length === 1 &&
        isExplicable(expectedType) &&
        !isBoolean(expectedType, receivedType)) {
        message += ` with value ${expectedValue}`;
    }
    message += `, got ${receivedType} `;
    // check if we need to specify received value
    if (isExplicable(receivedType)) {
        message += `with value ${receivedValue}.`;
    }
    return message;
}
/**
 * dev only
 */
function styleValue(value, type) {
    if (type === 'String') {
        return `"${value}"`;
    }
    else if (type === 'Number') {
        return `${Number(value)}`;
    }
    else {
        return `${value}`;
    }
}
/**
 * dev only
 */
function isExplicable(type) {
    const explicitTypes = ['string', 'number', 'boolean'];
    return explicitTypes.some(elem => type.toLowerCase() === elem);
}
/**
 * dev only
 */
function isBoolean(...args) {
    return args.some(elem => elem.toLowerCase() === 'boolean');
}

const isInternalKey = (key) => key[0] === '_' || key === '$stable';
const normalizeSlotValue = (value) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)
    ? value.map(normalizeVNode)
    : [normalizeVNode(value)];
const normalizeSlot = (key, rawSlot, ctx) => {
    if (rawSlot._n) {
        // already normalized - #5353
        return rawSlot;
    }
    const normalized = withCtx((...args) => {
        if (( true) && currentInstance) {
            warn(`Slot "${key}" invoked outside of the render function: ` +
                `this will not track dependencies used in the slot. ` +
                `Invoke the slot function inside the render function instead.`);
        }
        return normalizeSlotValue(rawSlot(...args));
    }, ctx);
    normalized._c = false;
    return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
    const ctx = rawSlots._ctx;
    for (const key in rawSlots) {
        if (isInternalKey(key))
            continue;
        const value = rawSlots[key];
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {
            slots[key] = normalizeSlot(key, value, ctx);
        }
        else if (value != null) {
            if (true) {
                warn(`Non-function value encountered for slot "${key}". ` +
                    `Prefer function slots for better performance.`);
            }
            const normalized = normalizeSlotValue(value);
            slots[key] = () => normalized;
        }
    }
};
const normalizeVNodeSlots = (instance, children) => {
    if (( true) &&
        !isKeepAlive(instance.vnode) &&
        !(false )) {
        warn(`Non-function value encountered for default slot. ` +
            `Prefer function slots for better performance.`);
    }
    const normalized = normalizeSlotValue(children);
    instance.slots.default = () => normalized;
};
const initSlots = (instance, children) => {
    if (instance.vnode.shapeFlag & 32 /* SLOTS_CHILDREN */) {
        const type = children._;
        if (type) {
            // users can get the shallow readonly version of the slots object through `this.$slots`,
            // we should avoid the proxy object polluting the slots of the internal instance
            instance.slots = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(children);
            // make compiler marker non-enumerable
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.def)(children, '_', type);
        }
        else {
            normalizeObjectSlots(children, (instance.slots = {}));
        }
    }
    else {
        instance.slots = {};
        if (children) {
            normalizeVNodeSlots(instance, children);
        }
    }
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.def)(instance.slots, InternalObjectKey, 1);
};
const updateSlots = (instance, children, optimized) => {
    const { vnode, slots } = instance;
    let needDeletionCheck = true;
    let deletionComparisonTarget = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
    if (vnode.shapeFlag & 32 /* SLOTS_CHILDREN */) {
        const type = children._;
        if (type) {
            // compiled slots.
            if (( true) && isHmrUpdating) {
                // Parent was HMR updated so slot content may have changed.
                // force update slots and mark instance for hmr as well
                (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(slots, children);
            }
            else if (optimized && type === 1 /* STABLE */) {
                // compiled AND stable.
                // no need to update, and skip stale slots removal.
                needDeletionCheck = false;
            }
            else {
                // compiled but dynamic (v-if/v-for on slots) - update slots, but skip
                // normalization.
                (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(slots, children);
                // #2893
                // when rendering the optimized slots by manually written render function,
                // we need to delete the `slots._` flag if necessary to make subsequent updates reliable,
                // i.e. let the `renderSlot` create the bailed Fragment
                if (!optimized && type === 1 /* STABLE */) {
                    delete slots._;
                }
            }
        }
        else {
            needDeletionCheck = !children.$stable;
            normalizeObjectSlots(children, slots);
        }
        deletionComparisonTarget = children;
    }
    else if (children) {
        // non slot object children (direct value) passed to a component
        normalizeVNodeSlots(instance, children);
        deletionComparisonTarget = { default: 1 };
    }
    // delete stale slots
    if (needDeletionCheck) {
        for (const key in slots) {
            if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
                delete slots[key];
            }
        }
    }
};

function createAppContext() {
    return {
        app: null,
        config: {
            isNativeTag: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NO,
            performance: false,
            globalProperties: {},
            optionMergeStrategies: {},
            errorHandler: undefined,
            warnHandler: undefined,
            compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: Object.create(null),
        optionsCache: new WeakMap(),
        propsCache: new WeakMap(),
        emitsCache: new WeakMap()
    };
}
let uid = 0;
function createAppAPI(render, hydrate) {
    return function createApp(rootComponent, rootProps = null) {
        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(rootComponent)) {
            rootComponent = Object.assign({}, rootComponent);
        }
        if (rootProps != null && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(rootProps)) {
            ( true) && warn(`root props passed to app.mount() must be an object.`);
            rootProps = null;
        }
        const context = createAppContext();
        const installedPlugins = new Set();
        let isMounted = false;
        const app = (context.app = {
            _uid: uid++,
            _component: rootComponent,
            _props: rootProps,
            _container: null,
            _context: context,
            _instance: null,
            version,
            get config() {
                return context.config;
            },
            set config(v) {
                if ((true)) {
                    warn(`app.config cannot be replaced. Modify individual options instead.`);
                }
            },
            use(plugin, ...options) {
                if (installedPlugins.has(plugin)) {
                    ( true) && warn(`Plugin has already been applied to target app.`);
                }
                else if (plugin && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(plugin.install)) {
                    installedPlugins.add(plugin);
                    plugin.install(app, ...options);
                }
                else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(plugin)) {
                    installedPlugins.add(plugin);
                    plugin(app, ...options);
                }
                else if ((true)) {
                    warn(`A plugin must either be a function or an object with an "install" ` +
                        `function.`);
                }
                return app;
            },
            mixin(mixin) {
                if (__VUE_OPTIONS_API__) {
                    if (!context.mixins.includes(mixin)) {
                        context.mixins.push(mixin);
                    }
                    else if ((true)) {
                        warn('Mixin has already been applied to target app' +
                            (mixin.name ? `: ${mixin.name}` : ''));
                    }
                }
                else if ((true)) {
                    warn('Mixins are only available in builds supporting Options API');
                }
                return app;
            },
            component(name, component) {
                if ((true)) {
                    validateComponentName(name, context.config);
                }
                if (!component) {
                    return context.components[name];
                }
                if (( true) && context.components[name]) {
                    warn(`Component "${name}" has already been registered in target app.`);
                }
                context.components[name] = component;
                return app;
            },
            directive(name, directive) {
                if ((true)) {
                    validateDirectiveName(name);
                }
                if (!directive) {
                    return context.directives[name];
                }
                if (( true) && context.directives[name]) {
                    warn(`Directive "${name}" has already been registered in target app.`);
                }
                context.directives[name] = directive;
                return app;
            },
            mount(rootContainer, isHydrate, isSVG) {
                if (!isMounted) {
                    // #5571
                    if (( true) && rootContainer.__vue_app__) {
                        warn(`There is already an app instance mounted on the host container.\n` +
                            ` If you want to mount another app on the same host container,` +
                            ` you need to unmount the previous app by calling \`app.unmount()\` first.`);
                    }
                    const vnode = createVNode(rootComponent, rootProps);
                    // store app context on the root VNode.
                    // this will be set on the root instance on initial mount.
                    vnode.appContext = context;
                    // HMR root reload
                    if ((true)) {
                        context.reload = () => {
                            render(cloneVNode(vnode), rootContainer, isSVG);
                        };
                    }
                    if (isHydrate && hydrate) {
                        hydrate(vnode, rootContainer);
                    }
                    else {
                        render(vnode, rootContainer, isSVG);
                    }
                    isMounted = true;
                    app._container = rootContainer;
                    rootContainer.__vue_app__ = app;
                    if (true) {
                        app._instance = vnode.component;
                        devtoolsInitApp(app, version);
                    }
                    return getExposeProxy(vnode.component) || vnode.component.proxy;
                }
                else if ((true)) {
                    warn(`App has already been mounted.\n` +
                        `If you want to remount the same app, move your app creation logic ` +
                        `into a factory function and create fresh app instances for each ` +
                        `mount - e.g. \`const createMyApp = () => createApp(App)\``);
                }
            },
            unmount() {
                if (isMounted) {
                    render(null, app._container);
                    if (true) {
                        app._instance = null;
                        devtoolsUnmountApp(app);
                    }
                    delete app._container.__vue_app__;
                }
                else if ((true)) {
                    warn(`Cannot unmount an app that is not mounted.`);
                }
            },
            provide(key, value) {
                if (( true) && key in context.provides) {
                    warn(`App already provides property with key "${String(key)}". ` +
                        `It will be overwritten with the new value.`);
                }
                context.provides[key] = value;
                return app;
            }
        });
        return app;
    };
}

/**
 * Function for handling a template ref
 */
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(rawRef)) {
        rawRef.forEach((r, i) => setRef(r, oldRawRef && ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode, isUnmount));
        return;
    }
    if (isAsyncWrapper(vnode) && !isUnmount) {
        // when mounting async components, nothing needs to be done,
        // because the template ref is forwarded to inner component
        return;
    }
    const refValue = vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */
        ? getExposeProxy(vnode.component) || vnode.component.proxy
        : vnode.el;
    const value = isUnmount ? null : refValue;
    const { i: owner, r: ref } = rawRef;
    if (( true) && !owner) {
        warn(`Missing ref owner context. ref cannot be used on hoisted vnodes. ` +
            `A vnode with ref must be created inside the render function.`);
        return;
    }
    const oldRef = oldRawRef && oldRawRef.r;
    const refs = owner.refs === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ ? (owner.refs = {}) : owner.refs;
    const setupState = owner.setupState;
    // dynamic ref changed. unset old ref
    if (oldRef != null && oldRef !== ref) {
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(oldRef)) {
            refs[oldRef] = null;
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, oldRef)) {
                setupState[oldRef] = null;
            }
        }
        else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(oldRef)) {
            oldRef.value = null;
        }
    }
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(ref)) {
        callWithErrorHandling(ref, owner, 12 /* FUNCTION_REF */, [value, refs]);
    }
    else {
        const _isString = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(ref);
        const _isRef = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(ref);
        if (_isString || _isRef) {
            const doSet = () => {
                if (rawRef.f) {
                    const existing = _isString ? refs[ref] : ref.value;
                    if (isUnmount) {
                        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(existing) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.remove)(existing, refValue);
                    }
                    else {
                        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(existing)) {
                            if (_isString) {
                                refs[ref] = [refValue];
                                if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, ref)) {
                                    setupState[ref] = refs[ref];
                                }
                            }
                            else {
                                ref.value = [refValue];
                                if (rawRef.k)
                                    refs[rawRef.k] = ref.value;
                            }
                        }
                        else if (!existing.includes(refValue)) {
                            existing.push(refValue);
                        }
                    }
                }
                else if (_isString) {
                    refs[ref] = value;
                    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, ref)) {
                        setupState[ref] = value;
                    }
                }
                else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(ref)) {
                    ref.value = value;
                    if (rawRef.k)
                        refs[rawRef.k] = value;
                }
                else if ((true)) {
                    warn('Invalid template ref type:', ref, `(${typeof ref})`);
                }
            };
            if (value) {
                doSet.id = -1;
                queuePostRenderEffect(doSet, parentSuspense);
            }
            else {
                doSet();
            }
        }
        else if ((true)) {
            warn('Invalid template ref type:', ref, `(${typeof ref})`);
        }
    }
}

let hasMismatch = false;
const isSVGContainer = (container) => /svg/.test(container.namespaceURI) && container.tagName !== 'foreignObject';
const isComment = (node) => node.nodeType === 8 /* COMMENT */;
// Note: hydration is DOM-specific
// But we have to place it in core due to tight coupling with core - splitting
// it out creates a ton of unnecessary complexity.
// Hydration also depends on some renderer internal logic which needs to be
// passed in via arguments.
function createHydrationFunctions(rendererInternals) {
    const { mt: mountComponent, p: patch, o: { patchProp, createText, nextSibling, parentNode, remove, insert, createComment } } = rendererInternals;
    const hydrate = (vnode, container) => {
        if (!container.hasChildNodes()) {
            ( true) &&
                warn(`Attempting to hydrate existing markup but container is empty. ` +
                    `Performing full mount instead.`);
            patch(null, vnode, container);
            flushPostFlushCbs();
            return;
        }
        hasMismatch = false;
        hydrateNode(container.firstChild, vnode, null, null, null);
        flushPostFlushCbs();
        if (hasMismatch && !false) {
            // this error should show up in production
            console.error(`Hydration completed but contains mismatches.`);
        }
    };
    const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false) => {
        const isFragmentStart = isComment(node) && node.data === '[';
        const onMismatch = () => handleMismatch(node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragmentStart);
        const { type, ref, shapeFlag, patchFlag } = vnode;
        const domType = node.nodeType;
        vnode.el = node;
        if (patchFlag === -2 /* BAIL */) {
            optimized = false;
            vnode.dynamicChildren = null;
        }
        let nextNode = null;
        switch (type) {
            case Text:
                if (domType !== 3 /* TEXT */) {
                    // #5728 empty text node inside a slot can cause hydration failure
                    // because the server rendered HTML won't contain a text node
                    if (vnode.children === '') {
                        insert((vnode.el = createText('')), parentNode(node), node);
                        nextNode = node;
                    }
                    else {
                        nextNode = onMismatch();
                    }
                }
                else {
                    if (node.data !== vnode.children) {
                        hasMismatch = true;
                        ( true) &&
                            warn(`Hydration text mismatch:` +
                                `\n- Client: ${JSON.stringify(node.data)}` +
                                `\n- Server: ${JSON.stringify(vnode.children)}`);
                        node.data = vnode.children;
                    }
                    nextNode = nextSibling(node);
                }
                break;
            case Comment:
                if (domType !== 8 /* COMMENT */ || isFragmentStart) {
                    nextNode = onMismatch();
                }
                else {
                    nextNode = nextSibling(node);
                }
                break;
            case Static:
                if (domType !== 1 /* ELEMENT */) {
                    nextNode = onMismatch();
                }
                else {
                    // determine anchor, adopt content
                    nextNode = node;
                    // if the static vnode has its content stripped during build,
                    // adopt it from the server-rendered HTML.
                    const needToAdoptContent = !vnode.children.length;
                    for (let i = 0; i < vnode.staticCount; i++) {
                        if (needToAdoptContent)
                            vnode.children += nextNode.outerHTML;
                        if (i === vnode.staticCount - 1) {
                            vnode.anchor = nextNode;
                        }
                        nextNode = nextSibling(nextNode);
                    }
                    return nextNode;
                }
                break;
            case Fragment:
                if (!isFragmentStart) {
                    nextNode = onMismatch();
                }
                else {
                    nextNode = hydrateFragment(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
                }
                break;
            default:
                if (shapeFlag & 1 /* ELEMENT */) {
                    if (domType !== 1 /* ELEMENT */ ||
                        vnode.type.toLowerCase() !==
                            node.tagName.toLowerCase()) {
                        nextNode = onMismatch();
                    }
                    else {
                        nextNode = hydrateElement(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
                    }
                }
                else if (shapeFlag & 6 /* COMPONENT */) {
                    // when setting up the render effect, if the initial vnode already
                    // has .el set, the component will perform hydration instead of mount
                    // on its sub-tree.
                    vnode.slotScopeIds = slotScopeIds;
                    const container = parentNode(node);
                    mountComponent(vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), optimized);
                    // component may be async, so in the case of fragments we cannot rely
                    // on component's rendered output to determine the end of the fragment
                    // instead, we do a lookahead to find the end anchor node.
                    nextNode = isFragmentStart
                        ? locateClosingAsyncAnchor(node)
                        : nextSibling(node);
                    // #4293 teleport as component root
                    if (nextNode &&
                        isComment(nextNode) &&
                        nextNode.data === 'teleport end') {
                        nextNode = nextSibling(nextNode);
                    }
                    // #3787
                    // if component is async, it may get moved / unmounted before its
                    // inner component is loaded, so we need to give it a placeholder
                    // vnode that matches its adopted DOM.
                    if (isAsyncWrapper(vnode)) {
                        let subTree;
                        if (isFragmentStart) {
                            subTree = createVNode(Fragment);
                            subTree.anchor = nextNode
                                ? nextNode.previousSibling
                                : container.lastChild;
                        }
                        else {
                            subTree =
                                node.nodeType === 3 ? createTextVNode('') : createVNode('div');
                        }
                        subTree.el = node;
                        vnode.component.subTree = subTree;
                    }
                }
                else if (shapeFlag & 64 /* TELEPORT */) {
                    if (domType !== 8 /* COMMENT */) {
                        nextNode = onMismatch();
                    }
                    else {
                        nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, rendererInternals, hydrateChildren);
                    }
                }
                else if (shapeFlag & 128 /* SUSPENSE */) {
                    nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, isSVGContainer(parentNode(node)), slotScopeIds, optimized, rendererInternals, hydrateNode);
                }
                else if ((true)) {
                    warn('Invalid HostVNode type:', type, `(${typeof type})`);
                }
        }
        if (ref != null) {
            setRef(ref, null, parentSuspense, vnode);
        }
        return nextNode;
    };
    const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
        optimized = optimized || !!vnode.dynamicChildren;
        const { type, props, patchFlag, shapeFlag, dirs } = vnode;
        // #4006 for form elements with non-string v-model value bindings
        // e.g. <option :value="obj">, <input type="checkbox" :true-value="1">
        const forcePatchValue = (type === 'input' && dirs) || type === 'option';
        // skip props & children if this is hoisted static nodes
        // #5405 in dev, always hydrate children for HMR
        if (true /* HOISTED */) {
            if (dirs) {
                invokeDirectiveHook(vnode, null, parentComponent, 'created');
            }
            // props
            if (props) {
                if (forcePatchValue ||
                    !optimized ||
                    patchFlag & (16 /* FULL_PROPS */ | 32 /* HYDRATE_EVENTS */)) {
                    for (const key in props) {
                        if ((forcePatchValue && key.endsWith('value')) ||
                            ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key))) {
                            patchProp(el, key, null, props[key], false, undefined, parentComponent);
                        }
                    }
                }
                else if (props.onClick) {
                    // Fast path for click listeners (which is most often) to avoid
                    // iterating through props.
                    patchProp(el, 'onClick', null, props.onClick, false, undefined, parentComponent);
                }
            }
            // vnode / directive hooks
            let vnodeHooks;
            if ((vnodeHooks = props && props.onVnodeBeforeMount)) {
                invokeVNodeHook(vnodeHooks, parentComponent, vnode);
            }
            if (dirs) {
                invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount');
            }
            if ((vnodeHooks = props && props.onVnodeMounted) || dirs) {
                queueEffectWithSuspense(() => {
                    vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
                    dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted');
                }, parentSuspense);
            }
            // children
            if (shapeFlag & 16 /* ARRAY_CHILDREN */ &&
                // skip if element has innerHTML / textContent
                !(props && (props.innerHTML || props.textContent))) {
                let next = hydrateChildren(el.firstChild, vnode, el, parentComponent, parentSuspense, slotScopeIds, optimized);
                let hasWarned = false;
                while (next) {
                    hasMismatch = true;
                    if (( true) && !hasWarned) {
                        warn(`Hydration children mismatch in <${vnode.type}>: ` +
                            `server rendered element contains more child nodes than client vdom.`);
                        hasWarned = true;
                    }
                    // The SSRed DOM contains more nodes than it should. Remove them.
                    const cur = next;
                    next = next.nextSibling;
                    remove(cur);
                }
            }
            else if (shapeFlag & 8 /* TEXT_CHILDREN */) {
                if (el.textContent !== vnode.children) {
                    hasMismatch = true;
                    ( true) &&
                        warn(`Hydration text content mismatch in <${vnode.type}>:\n` +
                            `- Client: ${el.textContent}\n` +
                            `- Server: ${vnode.children}`);
                    el.textContent = vnode.children;
                }
            }
        }
        return el.nextSibling;
    };
    const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) => {
        optimized = optimized || !!parentVNode.dynamicChildren;
        const children = parentVNode.children;
        const l = children.length;
        let hasWarned = false;
        for (let i = 0; i < l; i++) {
            const vnode = optimized
                ? children[i]
                : (children[i] = normalizeVNode(children[i]));
            if (node) {
                node = hydrateNode(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
            }
            else if (vnode.type === Text && !vnode.children) {
                continue;
            }
            else {
                hasMismatch = true;
                if (( true) && !hasWarned) {
                    warn(`Hydration children mismatch in <${container.tagName.toLowerCase()}>: ` +
                        `server rendered element contains fewer child nodes than client vdom.`);
                    hasWarned = true;
                }
                // the SSRed DOM didn't contain enough nodes. Mount the missing ones.
                patch(null, vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
            }
        }
        return node;
    };
    const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
        const { slotScopeIds: fragmentSlotScopeIds } = vnode;
        if (fragmentSlotScopeIds) {
            slotScopeIds = slotScopeIds
                ? slotScopeIds.concat(fragmentSlotScopeIds)
                : fragmentSlotScopeIds;
        }
        const container = parentNode(node);
        const next = hydrateChildren(nextSibling(node), vnode, container, parentComponent, parentSuspense, slotScopeIds, optimized);
        if (next && isComment(next) && next.data === ']') {
            return nextSibling((vnode.anchor = next));
        }
        else {
            // fragment didn't hydrate successfully, since we didn't get a end anchor
            // back. This should have led to node/children mismatch warnings.
            hasMismatch = true;
            // since the anchor is missing, we need to create one and insert it
            insert((vnode.anchor = createComment(`]`)), container, next);
            return next;
        }
    };
    const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) => {
        hasMismatch = true;
        ( true) &&
            warn(`Hydration node mismatch:\n- Client vnode:`, vnode.type, `\n- Server rendered DOM:`, node, node.nodeType === 3 /* TEXT */
                ? `(text)`
                : isComment(node) && node.data === '['
                    ? `(start of fragment)`
                    : ``);
        vnode.el = null;
        if (isFragment) {
            // remove excessive fragment nodes
            const end = locateClosingAsyncAnchor(node);
            while (true) {
                const next = nextSibling(node);
                if (next && next !== end) {
                    remove(next);
                }
                else {
                    break;
                }
            }
        }
        const next = nextSibling(node);
        const container = parentNode(node);
        remove(node);
        patch(null, vnode, container, next, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
        return next;
    };
    const locateClosingAsyncAnchor = (node) => {
        let match = 0;
        while (node) {
            node = nextSibling(node);
            if (node && isComment(node)) {
                if (node.data === '[')
                    match++;
                if (node.data === ']') {
                    if (match === 0) {
                        return nextSibling(node);
                    }
                    else {
                        match--;
                    }
                }
            }
        }
        return node;
    };
    return [hydrate, hydrateNode];
}

/* eslint-disable no-restricted-globals */
let supported;
let perf;
function startMeasure(instance, type) {
    if (instance.appContext.config.performance && isSupported()) {
        perf.mark(`vue-${type}-${instance.uid}`);
    }
    if (true) {
        devtoolsPerfStart(instance, type, isSupported() ? perf.now() : Date.now());
    }
}
function endMeasure(instance, type) {
    if (instance.appContext.config.performance && isSupported()) {
        const startTag = `vue-${type}-${instance.uid}`;
        const endTag = startTag + `:end`;
        perf.mark(endTag);
        perf.measure(`<${formatComponentName(instance, instance.type)}> ${type}`, startTag, endTag);
        perf.clearMarks(startTag);
        perf.clearMarks(endTag);
    }
    if (true) {
        devtoolsPerfEnd(instance, type, isSupported() ? perf.now() : Date.now());
    }
}
function isSupported() {
    if (supported !== undefined) {
        return supported;
    }
    if (typeof window !== 'undefined' && window.performance) {
        supported = true;
        perf = window.performance;
    }
    else {
        supported = false;
    }
    return supported;
}

/**
 * This is only called in esm-bundler builds.
 * It is called when a renderer is created, in `baseCreateRenderer` so that
 * importing runtime-core is side-effects free.
 *
 * istanbul-ignore-next
 */
function initFeatureFlags() {
    const needWarn = [];
    if (typeof __VUE_OPTIONS_API__ !== 'boolean') {
        ( true) && needWarn.push(`__VUE_OPTIONS_API__`);
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)().__VUE_OPTIONS_API__ = true;
    }
    if (typeof __VUE_PROD_DEVTOOLS__ !== 'boolean') {
        ( true) && needWarn.push(`__VUE_PROD_DEVTOOLS__`);
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)().__VUE_PROD_DEVTOOLS__ = false;
    }
    if (( true) && needWarn.length) {
        const multi = needWarn.length > 1;
        console.warn(`Feature flag${multi ? `s` : ``} ${needWarn.join(', ')} ${multi ? `are` : `is`} not explicitly defined. You are running the esm-bundler build of Vue, ` +
            `which expects these compile-time feature flags to be globally injected ` +
            `via the bundler config in order to get better tree-shaking in the ` +
            `production bundle.\n\n` +
            `For more details, see https://link.vuejs.org/feature-flags.`);
    }
}

const queuePostRenderEffect = queueEffectWithSuspense
    ;
/**
 * The createRenderer function accepts two generic arguments:
 * HostNode and HostElement, corresponding to Node and Element types in the
 * host environment. For example, for runtime-dom, HostNode would be the DOM
 * `Node` interface and HostElement would be the DOM `Element` interface.
 *
 * Custom renderers can pass in the platform specific types like this:
 *
 * ``` js
 * const { render, createApp } = createRenderer<Node, Element>({
 *   patchProp,
 *   ...nodeOps
 * })
 * ```
 */
function createRenderer(options) {
    return baseCreateRenderer(options);
}
// Separate API for creating hydration-enabled renderer.
// Hydration logic is only used when calling this function, making it
// tree-shakable.
function createHydrationRenderer(options) {
    return baseCreateRenderer(options, createHydrationFunctions);
}
// implementation
function baseCreateRenderer(options, createHydrationFns) {
    // compile-time feature flags check
    {
        initFeatureFlags();
    }
    const target = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)();
    target.__VUE__ = true;
    if (true) {
        setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);
    }
    const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP, cloneNode: hostCloneNode, insertStaticContent: hostInsertStaticContent } = options;
    // Note: functions inside this closure should use `const xxx = () => {}`
    // style in order to prevent being inlined by minifiers.
    const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = ( true) && isHmrUpdating ? false : !!n2.dynamicChildren) => {
        if (n1 === n2) {
            return;
        }
        // patching & not same type, unmount old tree
        if (n1 && !isSameVNodeType(n1, n2)) {
            anchor = getNextHostNode(n1);
            unmount(n1, parentComponent, parentSuspense, true);
            n1 = null;
        }
        if (n2.patchFlag === -2 /* BAIL */) {
            optimized = false;
            n2.dynamicChildren = null;
        }
        const { type, ref, shapeFlag } = n2;
        switch (type) {
            case Text:
                processText(n1, n2, container, anchor);
                break;
            case Comment:
                processCommentNode(n1, n2, container, anchor);
                break;
            case Static:
                if (n1 == null) {
                    mountStaticNode(n2, container, anchor, isSVG);
                }
                else if ((true)) {
                    patchStaticNode(n1, n2, container, isSVG);
                }
                break;
            case Fragment:
                processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                break;
            default:
                if (shapeFlag & 1 /* ELEMENT */) {
                    processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                }
                else if (shapeFlag & 6 /* COMPONENT */) {
                    processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                }
                else if (shapeFlag & 64 /* TELEPORT */) {
                    type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
                }
                else if (shapeFlag & 128 /* SUSPENSE */) {
                    type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
                }
                else if ((true)) {
                    warn('Invalid VNode type:', type, `(${typeof type})`);
                }
        }
        // set ref
        if (ref != null && parentComponent) {
            setRef(ref, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
        }
    };
    const processText = (n1, n2, container, anchor) => {
        if (n1 == null) {
            hostInsert((n2.el = hostCreateText(n2.children)), container, anchor);
        }
        else {
            const el = (n2.el = n1.el);
            if (n2.children !== n1.children) {
                hostSetText(el, n2.children);
            }
        }
    };
    const processCommentNode = (n1, n2, container, anchor) => {
        if (n1 == null) {
            hostInsert((n2.el = hostCreateComment(n2.children || '')), container, anchor);
        }
        else {
            // there's no support for dynamic comments
            n2.el = n1.el;
        }
    };
    const mountStaticNode = (n2, container, anchor, isSVG) => {
        [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG, n2.el, n2.anchor);
    };
    /**
     * Dev / HMR only
     */
    const patchStaticNode = (n1, n2, container, isSVG) => {
        // static nodes are only patched during dev for HMR
        if (n2.children !== n1.children) {
            const anchor = hostNextSibling(n1.anchor);
            // remove existing
            removeStaticNode(n1);
            [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);
        }
        else {
            n2.el = n1.el;
            n2.anchor = n1.anchor;
        }
    };
    const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
        let next;
        while (el && el !== anchor) {
            next = hostNextSibling(el);
            hostInsert(el, container, nextSibling);
            el = next;
        }
        hostInsert(anchor, container, nextSibling);
    };
    const removeStaticNode = ({ el, anchor }) => {
        let next;
        while (el && el !== anchor) {
            next = hostNextSibling(el);
            hostRemove(el);
            el = next;
        }
        hostRemove(anchor);
    };
    const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        isSVG = isSVG || n2.type === 'svg';
        if (n1 == null) {
            mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
        else {
            patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
    };
    const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        let el;
        let vnodeHook;
        const { type, props, shapeFlag, transition, patchFlag, dirs } = vnode;
        if (false /* HOISTED */) {}
        else {
            el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is, props);
            // mount children first, since some props may rely on child content
            // being already rendered, e.g. `<select value>`
            if (shapeFlag & 8 /* TEXT_CHILDREN */) {
                hostSetElementText(el, vnode.children);
            }
            else if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type !== 'foreignObject', slotScopeIds, optimized);
            }
            if (dirs) {
                invokeDirectiveHook(vnode, null, parentComponent, 'created');
            }
            // props
            if (props) {
                for (const key in props) {
                    if (key !== 'value' && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key)) {
                        hostPatchProp(el, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
                    }
                }
                /**
                 * Special case for setting value on DOM elements:
                 * - it can be order-sensitive (e.g. should be set *after* min/max, #2325, #4024)
                 * - it needs to be forced (#1471)
                 * #2353 proposes adding another renderer option to configure this, but
                 * the properties affects are so finite it is worth special casing it
                 * here to reduce the complexity. (Special casing it also should not
                 * affect non-DOM renderers)
                 */
                if ('value' in props) {
                    hostPatchProp(el, 'value', null, props.value);
                }
                if ((vnodeHook = props.onVnodeBeforeMount)) {
                    invokeVNodeHook(vnodeHook, parentComponent, vnode);
                }
            }
            // scopeId
            setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
        }
        if (true) {
            Object.defineProperty(el, '__vnode', {
                value: vnode,
                enumerable: false
            });
            Object.defineProperty(el, '__vueParentComponent', {
                value: parentComponent,
                enumerable: false
            });
        }
        if (dirs) {
            invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount');
        }
        // #1583 For inside suspense + suspense not resolved case, enter hook should call when suspense resolved
        // #1689 For inside suspense + suspense resolved case, just call it
        const needCallTransitionHooks = (!parentSuspense || (parentSuspense && !parentSuspense.pendingBranch)) &&
            transition &&
            !transition.persisted;
        if (needCallTransitionHooks) {
            transition.beforeEnter(el);
        }
        hostInsert(el, container, anchor);
        if ((vnodeHook = props && props.onVnodeMounted) ||
            needCallTransitionHooks ||
            dirs) {
            queuePostRenderEffect(() => {
                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
                needCallTransitionHooks && transition.enter(el);
                dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted');
            }, parentSuspense);
        }
    };
    const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
        if (scopeId) {
            hostSetScopeId(el, scopeId);
        }
        if (slotScopeIds) {
            for (let i = 0; i < slotScopeIds.length; i++) {
                hostSetScopeId(el, slotScopeIds[i]);
            }
        }
        if (parentComponent) {
            let subTree = parentComponent.subTree;
            if (( true) &&
                subTree.patchFlag > 0 &&
                subTree.patchFlag & 2048 /* DEV_ROOT_FRAGMENT */) {
                subTree =
                    filterSingleRoot(subTree.children) || subTree;
            }
            if (vnode === subTree) {
                const parentVNode = parentComponent.vnode;
                setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
            }
        }
    };
    const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0) => {
        for (let i = start; i < children.length; i++) {
            const child = (children[i] = optimized
                ? cloneIfMounted(children[i])
                : normalizeVNode(children[i]));
            patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
    };
    const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        const el = (n2.el = n1.el);
        let { patchFlag, dynamicChildren, dirs } = n2;
        // #1426 take the old vnode's patch flag into account since user may clone a
        // compiler-generated vnode, which de-opts to FULL_PROPS
        patchFlag |= n1.patchFlag & 16 /* FULL_PROPS */;
        const oldProps = n1.props || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
        const newProps = n2.props || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
        let vnodeHook;
        // disable recurse in beforeUpdate hooks
        parentComponent && toggleRecurse(parentComponent, false);
        if ((vnodeHook = newProps.onVnodeBeforeUpdate)) {
            invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        }
        if (dirs) {
            invokeDirectiveHook(n2, n1, parentComponent, 'beforeUpdate');
        }
        parentComponent && toggleRecurse(parentComponent, true);
        if (( true) && isHmrUpdating) {
            // HMR updated, force full diff
            patchFlag = 0;
            optimized = false;
            dynamicChildren = null;
        }
        const areChildrenSVG = isSVG && n2.type !== 'foreignObject';
        if (dynamicChildren) {
            patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);
            if (( true) && parentComponent && parentComponent.type.__hmrId) {
                traverseStaticChildren(n1, n2);
            }
        }
        else if (!optimized) {
            // full diff
            patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);
        }
        if (patchFlag > 0) {
            // the presence of a patchFlag means this element's render code was
            // generated by the compiler and can take the fast path.
            // in this path old node and new node are guaranteed to have the same shape
            // (i.e. at the exact same position in the source template)
            if (patchFlag & 16 /* FULL_PROPS */) {
                // element props contain dynamic keys, full diff needed
                patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
            }
            else {
                // class
                // this flag is matched when the element has dynamic class bindings.
                if (patchFlag & 2 /* CLASS */) {
                    if (oldProps.class !== newProps.class) {
                        hostPatchProp(el, 'class', null, newProps.class, isSVG);
                    }
                }
                // style
                // this flag is matched when the element has dynamic style bindings
                if (patchFlag & 4 /* STYLE */) {
                    hostPatchProp(el, 'style', oldProps.style, newProps.style, isSVG);
                }
                // props
                // This flag is matched when the element has dynamic prop/attr bindings
                // other than class and style. The keys of dynamic prop/attrs are saved for
                // faster iteration.
                // Note dynamic keys like :[foo]="bar" will cause this optimization to
                // bail out and go through a full diff because we need to unset the old key
                if (patchFlag & 8 /* PROPS */) {
                    // if the flag is present then dynamicProps must be non-null
                    const propsToUpdate = n2.dynamicProps;
                    for (let i = 0; i < propsToUpdate.length; i++) {
                        const key = propsToUpdate[i];
                        const prev = oldProps[key];
                        const next = newProps[key];
                        // #1471 force patch value
                        if (next !== prev || key === 'value') {
                            hostPatchProp(el, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);
                        }
                    }
                }
            }
            // text
            // This flag is matched when the element has only dynamic text children.
            if (patchFlag & 1 /* TEXT */) {
                if (n1.children !== n2.children) {
                    hostSetElementText(el, n2.children);
                }
            }
        }
        else if (!optimized && dynamicChildren == null) {
            // unoptimized, full diff
            patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
        }
        if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
            queuePostRenderEffect(() => {
                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
                dirs && invokeDirectiveHook(n2, n1, parentComponent, 'updated');
            }, parentSuspense);
        }
    };
    // The fast path for blocks.
    const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {
        for (let i = 0; i < newChildren.length; i++) {
            const oldVNode = oldChildren[i];
            const newVNode = newChildren[i];
            // Determine the container (parent element) for the patch.
            const container = 
            // oldVNode may be an errored async setup() component inside Suspense
            // which will not have a mounted element
            oldVNode.el &&
                // - In the case of a Fragment, we need to provide the actual parent
                // of the Fragment itself so it can move its children.
                (oldVNode.type === Fragment ||
                    // - In the case of different nodes, there is going to be a replacement
                    // which also requires the correct parent container
                    !isSameVNodeType(oldVNode, newVNode) ||
                    // - In the case of a component, it could contain anything.
                    oldVNode.shapeFlag & (6 /* COMPONENT */ | 64 /* TELEPORT */))
                ? hostParentNode(oldVNode.el)
                : // In other cases, the parent container is not actually used so we
                    // just pass the block element here to avoid a DOM parentNode call.
                    fallbackContainer;
            patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);
        }
    };
    const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
        if (oldProps !== newProps) {
            for (const key in newProps) {
                // empty string is not valid prop
                if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key))
                    continue;
                const next = newProps[key];
                const prev = oldProps[key];
                // defer patching value
                if (next !== prev && key !== 'value') {
                    hostPatchProp(el, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
                }
            }
            if (oldProps !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {
                for (const key in oldProps) {
                    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key) && !(key in newProps)) {
                        hostPatchProp(el, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
                    }
                }
            }
            if ('value' in newProps) {
                hostPatchProp(el, 'value', oldProps.value, newProps.value);
            }
        }
    };
    const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        const fragmentStartAnchor = (n2.el = n1 ? n1.el : hostCreateText(''));
        const fragmentEndAnchor = (n2.anchor = n1 ? n1.anchor : hostCreateText(''));
        let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
        if (( true) &&
            // #5523 dev root fragment may inherit directives
            (isHmrUpdating || patchFlag & 2048 /* DEV_ROOT_FRAGMENT */)) {
            // HMR updated / Dev root fragment (w/ comments), force full diff
            patchFlag = 0;
            optimized = false;
            dynamicChildren = null;
        }
        // check if this is a slot fragment with :slotted scope ids
        if (fragmentSlotScopeIds) {
            slotScopeIds = slotScopeIds
                ? slotScopeIds.concat(fragmentSlotScopeIds)
                : fragmentSlotScopeIds;
        }
        if (n1 == null) {
            hostInsert(fragmentStartAnchor, container, anchor);
            hostInsert(fragmentEndAnchor, container, anchor);
            // a fragment can only have array children
            // since they are either generated by the compiler, or implicitly created
            // from arrays.
            mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
        else {
            if (patchFlag > 0 &&
                patchFlag & 64 /* STABLE_FRAGMENT */ &&
                dynamicChildren &&
                // #2715 the previous fragment could've been a BAILed one as a result
                // of renderSlot() with no valid children
                n1.dynamicChildren) {
                // a stable fragment (template root or <template v-for>) doesn't need to
                // patch children order, but it may contain dynamicChildren.
                patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);
                if (( true) && parentComponent && parentComponent.type.__hmrId) {
                    traverseStaticChildren(n1, n2);
                }
                else if (
                // #2080 if the stable fragment has a key, it's a <template v-for> that may
                //  get moved around. Make sure all root level vnodes inherit el.
                // #2134 or if it's a component root, it may also get moved around
                // as the component is being moved.
                n2.key != null ||
                    (parentComponent && n2 === parentComponent.subTree)) {
                    traverseStaticChildren(n1, n2, true /* shallow */);
                }
            }
            else {
                // keyed / unkeyed, or manual fragments.
                // for keyed & unkeyed, since they are compiler generated from v-for,
                // each child is guaranteed to be a block so the fragment will never
                // have dynamicChildren.
                patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            }
        }
    };
    const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        n2.slotScopeIds = slotScopeIds;
        if (n1 == null) {
            if (n2.shapeFlag & 512 /* COMPONENT_KEPT_ALIVE */) {
                parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);
            }
            else {
                mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
            }
        }
        else {
            updateComponent(n1, n2, optimized);
        }
    };
    const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
        const instance = (initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense));
        if (( true) && instance.type.__hmrId) {
            registerHMR(instance);
        }
        if ((true)) {
            pushWarningContext(initialVNode);
            startMeasure(instance, `mount`);
        }
        // inject renderer internals for keepAlive
        if (isKeepAlive(initialVNode)) {
            instance.ctx.renderer = internals;
        }
        // resolve props and slots for setup context
        {
            if ((true)) {
                startMeasure(instance, `init`);
            }
            setupComponent(instance);
            if ((true)) {
                endMeasure(instance, `init`);
            }
        }
        // setup() is async. This component relies on async logic to be resolved
        // before proceeding
        if (instance.asyncDep) {
            parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
            // Give it a placeholder if this is not hydration
            // TODO handle self-defined fallback
            if (!initialVNode.el) {
                const placeholder = (instance.subTree = createVNode(Comment));
                processCommentNode(null, placeholder, container, anchor);
            }
            return;
        }
        setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);
        if ((true)) {
            popWarningContext();
            endMeasure(instance, `mount`);
        }
    };
    const updateComponent = (n1, n2, optimized) => {
        const instance = (n2.component = n1.component);
        if (shouldUpdateComponent(n1, n2, optimized)) {
            if (instance.asyncDep &&
                !instance.asyncResolved) {
                // async & still pending - just update props and slots
                // since the component's reactive effect for render isn't set-up yet
                if ((true)) {
                    pushWarningContext(n2);
                }
                updateComponentPreRender(instance, n2, optimized);
                if ((true)) {
                    popWarningContext();
                }
                return;
            }
            else {
                // normal update
                instance.next = n2;
                // in case the child component is also queued, remove it to avoid
                // double updating the same child component in the same flush.
                invalidateJob(instance.update);
                // instance.update is the reactive effect.
                instance.update();
            }
        }
        else {
            // no update needed. just copy over properties
            n2.el = n1.el;
            instance.vnode = n2;
        }
    };
    const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
        const componentUpdateFn = () => {
            if (!instance.isMounted) {
                let vnodeHook;
                const { el, props } = initialVNode;
                const { bm, m, parent } = instance;
                const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
                toggleRecurse(instance, false);
                // beforeMount hook
                if (bm) {
                    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(bm);
                }
                // onVnodeBeforeMount
                if (!isAsyncWrapperVNode &&
                    (vnodeHook = props && props.onVnodeBeforeMount)) {
                    invokeVNodeHook(vnodeHook, parent, initialVNode);
                }
                toggleRecurse(instance, true);
                if (el && hydrateNode) {
                    // vnode has adopted host node - perform hydration instead of mount.
                    const hydrateSubTree = () => {
                        if ((true)) {
                            startMeasure(instance, `render`);
                        }
                        instance.subTree = renderComponentRoot(instance);
                        if ((true)) {
                            endMeasure(instance, `render`);
                        }
                        if ((true)) {
                            startMeasure(instance, `hydrate`);
                        }
                        hydrateNode(el, instance.subTree, instance, parentSuspense, null);
                        if ((true)) {
                            endMeasure(instance, `hydrate`);
                        }
                    };
                    if (isAsyncWrapperVNode) {
                        initialVNode.type.__asyncLoader().then(
                        // note: we are moving the render call into an async callback,
                        // which means it won't track dependencies - but it's ok because
                        // a server-rendered async wrapper is already in resolved state
                        // and it will never need to change.
                        () => !instance.isUnmounted && hydrateSubTree());
                    }
                    else {
                        hydrateSubTree();
                    }
                }
                else {
                    if ((true)) {
                        startMeasure(instance, `render`);
                    }
                    const subTree = (instance.subTree = renderComponentRoot(instance));
                    if ((true)) {
                        endMeasure(instance, `render`);
                    }
                    if ((true)) {
                        startMeasure(instance, `patch`);
                    }
                    patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);
                    if ((true)) {
                        endMeasure(instance, `patch`);
                    }
                    initialVNode.el = subTree.el;
                }
                // mounted hook
                if (m) {
                    queuePostRenderEffect(m, parentSuspense);
                }
                // onVnodeMounted
                if (!isAsyncWrapperVNode &&
                    (vnodeHook = props && props.onVnodeMounted)) {
                    const scopedInitialVNode = initialVNode;
                    queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode), parentSuspense);
                }
                // activated hook for keep-alive roots.
                // #1742 activated hook must be accessed after first render
                // since the hook may be injected by a child keep-alive
                if (initialVNode.shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */ ||
                    (parent &&
                        isAsyncWrapper(parent.vnode) &&
                        parent.vnode.shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */)) {
                    instance.a && queuePostRenderEffect(instance.a, parentSuspense);
                }
                instance.isMounted = true;
                if (true) {
                    devtoolsComponentAdded(instance);
                }
                // #2458: deference mount-only object parameters to prevent memleaks
                initialVNode = container = anchor = null;
            }
            else {
                // updateComponent
                // This is triggered by mutation of component's own state (next: null)
                // OR parent calling processComponent (next: VNode)
                let { next, bu, u, parent, vnode } = instance;
                let originNext = next;
                let vnodeHook;
                if ((true)) {
                    pushWarningContext(next || instance.vnode);
                }
                // Disallow component effect recursion during pre-lifecycle hooks.
                toggleRecurse(instance, false);
                if (next) {
                    next.el = vnode.el;
                    updateComponentPreRender(instance, next, optimized);
                }
                else {
                    next = vnode;
                }
                // beforeUpdate hook
                if (bu) {
                    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(bu);
                }
                // onVnodeBeforeUpdate
                if ((vnodeHook = next.props && next.props.onVnodeBeforeUpdate)) {
                    invokeVNodeHook(vnodeHook, parent, next, vnode);
                }
                toggleRecurse(instance, true);
                // render
                if ((true)) {
                    startMeasure(instance, `render`);
                }
                const nextTree = renderComponentRoot(instance);
                if ((true)) {
                    endMeasure(instance, `render`);
                }
                const prevTree = instance.subTree;
                instance.subTree = nextTree;
                if ((true)) {
                    startMeasure(instance, `patch`);
                }
                patch(prevTree, nextTree, 
                // parent may have changed if it's in a teleport
                hostParentNode(prevTree.el), 
                // anchor may have changed if it's in a fragment
                getNextHostNode(prevTree), instance, parentSuspense, isSVG);
                if ((true)) {
                    endMeasure(instance, `patch`);
                }
                next.el = nextTree.el;
                if (originNext === null) {
                    // self-triggered update. In case of HOC, update parent component
                    // vnode el. HOC is indicated by parent instance's subTree pointing
                    // to child component's vnode
                    updateHOCHostEl(instance, nextTree.el);
                }
                // updated hook
                if (u) {
                    queuePostRenderEffect(u, parentSuspense);
                }
                // onVnodeUpdated
                if ((vnodeHook = next.props && next.props.onVnodeUpdated)) {
                    queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, next, vnode), parentSuspense);
                }
                if (true) {
                    devtoolsComponentUpdated(instance);
                }
                if ((true)) {
                    popWarningContext();
                }
            }
        };
        // create reactive effect for rendering
        const effect = (instance.effect = new _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ReactiveEffect(componentUpdateFn, () => queueJob(update), instance.scope // track it in component's effect scope
        ));
        const update = (instance.update = () => effect.run());
        update.id = instance.uid;
        // allowRecurse
        // #1801, #2043 component render effects should allow recursive updates
        toggleRecurse(instance, true);
        if ((true)) {
            effect.onTrack = instance.rtc
                ? e => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance.rtc, e)
                : void 0;
            effect.onTrigger = instance.rtg
                ? e => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance.rtg, e)
                : void 0;
            update.ownerInstance = instance;
        }
        update();
    };
    const updateComponentPreRender = (instance, nextVNode, optimized) => {
        nextVNode.component = instance;
        const prevProps = instance.vnode.props;
        instance.vnode = nextVNode;
        instance.next = null;
        updateProps(instance, nextVNode.props, prevProps, optimized);
        updateSlots(instance, nextVNode.children, optimized);
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
        // props update may have triggered pre-flush watchers.
        // flush them before the render update.
        flushPreFlushCbs(undefined, instance.update);
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
    };
    const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {
        const c1 = n1 && n1.children;
        const prevShapeFlag = n1 ? n1.shapeFlag : 0;
        const c2 = n2.children;
        const { patchFlag, shapeFlag } = n2;
        // fast path
        if (patchFlag > 0) {
            if (patchFlag & 128 /* KEYED_FRAGMENT */) {
                // this could be either fully-keyed or mixed (some keyed some not)
                // presence of patchFlag means children are guaranteed to be arrays
                patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                return;
            }
            else if (patchFlag & 256 /* UNKEYED_FRAGMENT */) {
                // unkeyed
                patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                return;
            }
        }
        // children has 3 possibilities: text, array or no children.
        if (shapeFlag & 8 /* TEXT_CHILDREN */) {
            // text children fast path
            if (prevShapeFlag & 16 /* ARRAY_CHILDREN */) {
                unmountChildren(c1, parentComponent, parentSuspense);
            }
            if (c2 !== c1) {
                hostSetElementText(container, c2);
            }
        }
        else {
            if (prevShapeFlag & 16 /* ARRAY_CHILDREN */) {
                // prev children was array
                if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                    // two arrays, cannot assume anything, do full diff
                    patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                }
                else {
                    // no new children, just unmount old
                    unmountChildren(c1, parentComponent, parentSuspense, true);
                }
            }
            else {
                // prev children was text OR null
                // new children is array OR null
                if (prevShapeFlag & 8 /* TEXT_CHILDREN */) {
                    hostSetElementText(container, '');
                }
                // mount new if array
                if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                    mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                }
            }
        }
    };
    const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        c1 = c1 || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;
        c2 = c2 || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;
        const oldLength = c1.length;
        const newLength = c2.length;
        const commonLength = Math.min(oldLength, newLength);
        let i;
        for (i = 0; i < commonLength; i++) {
            const nextChild = (c2[i] = optimized
                ? cloneIfMounted(c2[i])
                : normalizeVNode(c2[i]));
            patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
        if (oldLength > newLength) {
            // remove old
            unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);
        }
        else {
            // mount new
            mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);
        }
    };
    // can be all-keyed or mixed
    const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        let i = 0;
        const l2 = c2.length;
        let e1 = c1.length - 1; // prev ending index
        let e2 = l2 - 1; // next ending index
        // 1. sync from start
        // (a b) c
        // (a b) d e
        while (i <= e1 && i <= e2) {
            const n1 = c1[i];
            const n2 = (c2[i] = optimized
                ? cloneIfMounted(c2[i])
                : normalizeVNode(c2[i]));
            if (isSameVNodeType(n1, n2)) {
                patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            }
            else {
                break;
            }
            i++;
        }
        // 2. sync from end
        // a (b c)
        // d e (b c)
        while (i <= e1 && i <= e2) {
            const n1 = c1[e1];
            const n2 = (c2[e2] = optimized
                ? cloneIfMounted(c2[e2])
                : normalizeVNode(c2[e2]));
            if (isSameVNodeType(n1, n2)) {
                patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            }
            else {
                break;
            }
            e1--;
            e2--;
        }
        // 3. common sequence + mount
        // (a b)
        // (a b) c
        // i = 2, e1 = 1, e2 = 2
        // (a b)
        // c (a b)
        // i = 0, e1 = -1, e2 = 0
        if (i > e1) {
            if (i <= e2) {
                const nextPos = e2 + 1;
                const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
                while (i <= e2) {
                    patch(null, (c2[i] = optimized
                        ? cloneIfMounted(c2[i])
                        : normalizeVNode(c2[i])), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                    i++;
                }
            }
        }
        // 4. common sequence + unmount
        // (a b) c
        // (a b)
        // i = 2, e1 = 2, e2 = 1
        // a (b c)
        // (b c)
        // i = 0, e1 = 0, e2 = -1
        else if (i > e2) {
            while (i <= e1) {
                unmount(c1[i], parentComponent, parentSuspense, true);
                i++;
            }
        }
        // 5. unknown sequence
        // [i ... e1 + 1]: a b [c d e] f g
        // [i ... e2 + 1]: a b [e d c h] f g
        // i = 2, e1 = 4, e2 = 5
        else {
            const s1 = i; // prev starting index
            const s2 = i; // next starting index
            // 5.1 build key:index map for newChildren
            const keyToNewIndexMap = new Map();
            for (i = s2; i <= e2; i++) {
                const nextChild = (c2[i] = optimized
                    ? cloneIfMounted(c2[i])
                    : normalizeVNode(c2[i]));
                if (nextChild.key != null) {
                    if (( true) && keyToNewIndexMap.has(nextChild.key)) {
                        warn(`Duplicate keys found during update:`, JSON.stringify(nextChild.key), `Make sure keys are unique.`);
                    }
                    keyToNewIndexMap.set(nextChild.key, i);
                }
            }
            // 5.2 loop through old children left to be patched and try to patch
            // matching nodes & remove nodes that are no longer present
            let j;
            let patched = 0;
            const toBePatched = e2 - s2 + 1;
            let moved = false;
            // used to track whether any node has moved
            let maxNewIndexSoFar = 0;
            // works as Map<newIndex, oldIndex>
            // Note that oldIndex is offset by +1
            // and oldIndex = 0 is a special value indicating the new node has
            // no corresponding old node.
            // used for determining longest stable subsequence
            const newIndexToOldIndexMap = new Array(toBePatched);
            for (i = 0; i < toBePatched; i++)
                newIndexToOldIndexMap[i] = 0;
            for (i = s1; i <= e1; i++) {
                const prevChild = c1[i];
                if (patched >= toBePatched) {
                    // all new children have been patched so this can only be a removal
                    unmount(prevChild, parentComponent, parentSuspense, true);
                    continue;
                }
                let newIndex;
                if (prevChild.key != null) {
                    newIndex = keyToNewIndexMap.get(prevChild.key);
                }
                else {
                    // key-less node, try to locate a key-less node of the same type
                    for (j = s2; j <= e2; j++) {
                        if (newIndexToOldIndexMap[j - s2] === 0 &&
                            isSameVNodeType(prevChild, c2[j])) {
                            newIndex = j;
                            break;
                        }
                    }
                }
                if (newIndex === undefined) {
                    unmount(prevChild, parentComponent, parentSuspense, true);
                }
                else {
                    newIndexToOldIndexMap[newIndex - s2] = i + 1;
                    if (newIndex >= maxNewIndexSoFar) {
                        maxNewIndexSoFar = newIndex;
                    }
                    else {
                        moved = true;
                    }
                    patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                    patched++;
                }
            }
            // 5.3 move and mount
            // generate longest stable subsequence only when nodes have moved
            const increasingNewIndexSequence = moved
                ? getSequence(newIndexToOldIndexMap)
                : _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;
            j = increasingNewIndexSequence.length - 1;
            // looping backwards so that we can use last patched node as anchor
            for (i = toBePatched - 1; i >= 0; i--) {
                const nextIndex = s2 + i;
                const nextChild = c2[nextIndex];
                const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
                if (newIndexToOldIndexMap[i] === 0) {
                    // mount new
                    patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                }
                else if (moved) {
                    // move if:
                    // There is no stable subsequence (e.g. a reverse)
                    // OR current node is not among the stable sequence
                    if (j < 0 || i !== increasingNewIndexSequence[j]) {
                        move(nextChild, container, anchor, 2 /* REORDER */);
                    }
                    else {
                        j--;
                    }
                }
            }
        }
    };
    const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
        const { el, type, transition, children, shapeFlag } = vnode;
        if (shapeFlag & 6 /* COMPONENT */) {
            move(vnode.component.subTree, container, anchor, moveType);
            return;
        }
        if (shapeFlag & 128 /* SUSPENSE */) {
            vnode.suspense.move(container, anchor, moveType);
            return;
        }
        if (shapeFlag & 64 /* TELEPORT */) {
            type.move(vnode, container, anchor, internals);
            return;
        }
        if (type === Fragment) {
            hostInsert(el, container, anchor);
            for (let i = 0; i < children.length; i++) {
                move(children[i], container, anchor, moveType);
            }
            hostInsert(vnode.anchor, container, anchor);
            return;
        }
        if (type === Static) {
            moveStaticNode(vnode, container, anchor);
            return;
        }
        // single nodes
        const needTransition = moveType !== 2 /* REORDER */ &&
            shapeFlag & 1 /* ELEMENT */ &&
            transition;
        if (needTransition) {
            if (moveType === 0 /* ENTER */) {
                transition.beforeEnter(el);
                hostInsert(el, container, anchor);
                queuePostRenderEffect(() => transition.enter(el), parentSuspense);
            }
            else {
                const { leave, delayLeave, afterLeave } = transition;
                const remove = () => hostInsert(el, container, anchor);
                const performLeave = () => {
                    leave(el, () => {
                        remove();
                        afterLeave && afterLeave();
                    });
                };
                if (delayLeave) {
                    delayLeave(el, remove, performLeave);
                }
                else {
                    performLeave();
                }
            }
        }
        else {
            hostInsert(el, container, anchor);
        }
    };
    const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
        const { type, props, ref, children, dynamicChildren, shapeFlag, patchFlag, dirs } = vnode;
        // unset ref
        if (ref != null) {
            setRef(ref, null, parentSuspense, vnode, true);
        }
        if (shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */) {
            parentComponent.ctx.deactivate(vnode);
            return;
        }
        const shouldInvokeDirs = shapeFlag & 1 /* ELEMENT */ && dirs;
        const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
        let vnodeHook;
        if (shouldInvokeVnodeHook &&
            (vnodeHook = props && props.onVnodeBeforeUnmount)) {
            invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
        if (shapeFlag & 6 /* COMPONENT */) {
            unmountComponent(vnode.component, parentSuspense, doRemove);
        }
        else {
            if (shapeFlag & 128 /* SUSPENSE */) {
                vnode.suspense.unmount(parentSuspense, doRemove);
                return;
            }
            if (shouldInvokeDirs) {
                invokeDirectiveHook(vnode, null, parentComponent, 'beforeUnmount');
            }
            if (shapeFlag & 64 /* TELEPORT */) {
                vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);
            }
            else if (dynamicChildren &&
                // #1153: fast path should not be taken for non-stable (v-for) fragments
                (type !== Fragment ||
                    (patchFlag > 0 && patchFlag & 64 /* STABLE_FRAGMENT */))) {
                // fast path for block nodes: only need to unmount dynamic children.
                unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
            }
            else if ((type === Fragment &&
                patchFlag &
                    (128 /* KEYED_FRAGMENT */ | 256 /* UNKEYED_FRAGMENT */)) ||
                (!optimized && shapeFlag & 16 /* ARRAY_CHILDREN */)) {
                unmountChildren(children, parentComponent, parentSuspense);
            }
            if (doRemove) {
                remove(vnode);
            }
        }
        if ((shouldInvokeVnodeHook &&
            (vnodeHook = props && props.onVnodeUnmounted)) ||
            shouldInvokeDirs) {
            queuePostRenderEffect(() => {
                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
                shouldInvokeDirs &&
                    invokeDirectiveHook(vnode, null, parentComponent, 'unmounted');
            }, parentSuspense);
        }
    };
    const remove = vnode => {
        const { type, el, anchor, transition } = vnode;
        if (type === Fragment) {
            if (( true) &&
                vnode.patchFlag > 0 &&
                vnode.patchFlag & 2048 /* DEV_ROOT_FRAGMENT */ &&
                transition &&
                !transition.persisted) {
                vnode.children.forEach(child => {
                    if (child.type === Comment) {
                        hostRemove(child.el);
                    }
                    else {
                        remove(child);
                    }
                });
            }
            else {
                removeFragment(el, anchor);
            }
            return;
        }
        if (type === Static) {
            removeStaticNode(vnode);
            return;
        }
        const performRemove = () => {
            hostRemove(el);
            if (transition && !transition.persisted && transition.afterLeave) {
                transition.afterLeave();
            }
        };
        if (vnode.shapeFlag & 1 /* ELEMENT */ &&
            transition &&
            !transition.persisted) {
            const { leave, delayLeave } = transition;
            const performLeave = () => leave(el, performRemove);
            if (delayLeave) {
                delayLeave(vnode.el, performRemove, performLeave);
            }
            else {
                performLeave();
            }
        }
        else {
            performRemove();
        }
    };
    const removeFragment = (cur, end) => {
        // For fragments, directly remove all contained DOM nodes.
        // (fragment child nodes cannot have transition)
        let next;
        while (cur !== end) {
            next = hostNextSibling(cur);
            hostRemove(cur);
            cur = next;
        }
        hostRemove(end);
    };
    const unmountComponent = (instance, parentSuspense, doRemove) => {
        if (( true) && instance.type.__hmrId) {
            unregisterHMR(instance);
        }
        const { bum, scope, update, subTree, um } = instance;
        // beforeUnmount hook
        if (bum) {
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(bum);
        }
        // stop effects in component scope
        scope.stop();
        // update may be null if a component is unmounted before its async
        // setup has resolved.
        if (update) {
            // so that scheduler will no longer invoke it
            update.active = false;
            unmount(subTree, instance, parentSuspense, doRemove);
        }
        // unmounted hook
        if (um) {
            queuePostRenderEffect(um, parentSuspense);
        }
        queuePostRenderEffect(() => {
            instance.isUnmounted = true;
        }, parentSuspense);
        // A component with async dep inside a pending suspense is unmounted before
        // its async dep resolves. This should remove the dep from the suspense, and
        // cause the suspense to resolve immediately if that was the last dep.
        if (parentSuspense &&
            parentSuspense.pendingBranch &&
            !parentSuspense.isUnmounted &&
            instance.asyncDep &&
            !instance.asyncResolved &&
            instance.suspenseId === parentSuspense.pendingId) {
            parentSuspense.deps--;
            if (parentSuspense.deps === 0) {
                parentSuspense.resolve();
            }
        }
        if (true) {
            devtoolsComponentRemoved(instance);
        }
    };
    const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
        for (let i = start; i < children.length; i++) {
            unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
        }
    };
    const getNextHostNode = vnode => {
        if (vnode.shapeFlag & 6 /* COMPONENT */) {
            return getNextHostNode(vnode.component.subTree);
        }
        if (vnode.shapeFlag & 128 /* SUSPENSE */) {
            return vnode.suspense.next();
        }
        return hostNextSibling((vnode.anchor || vnode.el));
    };
    const render = (vnode, container, isSVG) => {
        if (vnode == null) {
            if (container._vnode) {
                unmount(container._vnode, null, null, true);
            }
        }
        else {
            patch(container._vnode || null, vnode, container, null, null, null, isSVG);
        }
        flushPostFlushCbs();
        container._vnode = vnode;
    };
    const internals = {
        p: patch,
        um: unmount,
        m: move,
        r: remove,
        mt: mountComponent,
        mc: mountChildren,
        pc: patchChildren,
        pbc: patchBlockChildren,
        n: getNextHostNode,
        o: options
    };
    let hydrate;
    let hydrateNode;
    if (createHydrationFns) {
        [hydrate, hydrateNode] = createHydrationFns(internals);
    }
    return {
        render,
        hydrate,
        createApp: createAppAPI(render, hydrate)
    };
}
function toggleRecurse({ effect, update }, allowed) {
    effect.allowRecurse = update.allowRecurse = allowed;
}
/**
 * #1156
 * When a component is HMR-enabled, we need to make sure that all static nodes
 * inside a block also inherit the DOM element from the previous tree so that
 * HMR updates (which are full updates) can retrieve the element for patching.
 *
 * #2080
 * Inside keyed `template` fragment static children, if a fragment is moved,
 * the children will always be moved. Therefore, in order to ensure correct move
 * position, el should be inherited from previous nodes.
 */
function traverseStaticChildren(n1, n2, shallow = false) {
    const ch1 = n1.children;
    const ch2 = n2.children;
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(ch1) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(ch2)) {
        for (let i = 0; i < ch1.length; i++) {
            // this is only called in the optimized path so array children are
            // guaranteed to be vnodes
            const c1 = ch1[i];
            let c2 = ch2[i];
            if (c2.shapeFlag & 1 /* ELEMENT */ && !c2.dynamicChildren) {
                if (c2.patchFlag <= 0 || c2.patchFlag === 32 /* HYDRATE_EVENTS */) {
                    c2 = ch2[i] = cloneIfMounted(ch2[i]);
                    c2.el = c1.el;
                }
                if (!shallow)
                    traverseStaticChildren(c1, c2);
            }
            // also inherit for comment nodes, but not placeholders (e.g. v-if which
            // would have received .el during block patch)
            if (( true) && c2.type === Comment && !c2.el) {
                c2.el = c1.el;
            }
        }
    }
}
// https://en.wikipedia.org/wiki/Longest_increasing_subsequence
function getSequence(arr) {
    const p = arr.slice();
    const result = [0];
    let i, j, u, v, c;
    const len = arr.length;
    for (i = 0; i < len; i++) {
        const arrI = arr[i];
        if (arrI !== 0) {
            j = result[result.length - 1];
            if (arr[j] < arrI) {
                p[i] = j;
                result.push(i);
                continue;
            }
            u = 0;
            v = result.length - 1;
            while (u < v) {
                c = (u + v) >> 1;
                if (arr[result[c]] < arrI) {
                    u = c + 1;
                }
                else {
                    v = c;
                }
            }
            if (arrI < arr[result[u]]) {
                if (u > 0) {
                    p[i] = result[u - 1];
                }
                result[u] = i;
            }
        }
    }
    u = result.length;
    v = result[u - 1];
    while (u-- > 0) {
        result[u] = v;
        v = p[v];
    }
    return result;
}

const isTeleport = (type) => type.__isTeleport;
const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === '');
const isTargetSVG = (target) => typeof SVGElement !== 'undefined' && target instanceof SVGElement;
const resolveTarget = (props, select) => {
    const targetSelector = props && props.to;
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(targetSelector)) {
        if (!select) {
            ( true) &&
                warn(`Current renderer does not support string target for Teleports. ` +
                    `(missing querySelector renderer option)`);
            return null;
        }
        else {
            const target = select(targetSelector);
            if (!target) {
                ( true) &&
                    warn(`Failed to locate Teleport target with selector "${targetSelector}". ` +
                        `Note the target element must exist before the component is mounted - ` +
                        `i.e. the target cannot be rendered by the component itself, and ` +
                        `ideally should be outside of the entire Vue component tree.`);
            }
            return target;
        }
    }
    else {
        if (( true) && !targetSelector && !isTeleportDisabled(props)) {
            warn(`Invalid Teleport target: ${targetSelector}`);
        }
        return targetSelector;
    }
};
const TeleportImpl = {
    __isTeleport: true,
    process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {
        const { mc: mountChildren, pc: patchChildren, pbc: patchBlockChildren, o: { insert, querySelector, createText, createComment } } = internals;
        const disabled = isTeleportDisabled(n2.props);
        let { shapeFlag, children, dynamicChildren } = n2;
        // #3302
        // HMR updated, force full diff
        if (( true) && isHmrUpdating) {
            optimized = false;
            dynamicChildren = null;
        }
        if (n1 == null) {
            // insert anchors in the main view
            const placeholder = (n2.el = ( true)
                ? createComment('teleport start')
                : 0);
            const mainAnchor = (n2.anchor = ( true)
                ? createComment('teleport end')
                : 0);
            insert(placeholder, container, anchor);
            insert(mainAnchor, container, anchor);
            const target = (n2.target = resolveTarget(n2.props, querySelector));
            const targetAnchor = (n2.targetAnchor = createText(''));
            if (target) {
                insert(targetAnchor, target);
                // #2652 we could be teleporting from a non-SVG tree into an SVG tree
                isSVG = isSVG || isTargetSVG(target);
            }
            else if (( true) && !disabled) {
                warn('Invalid Teleport target on mount:', target, `(${typeof target})`);
            }
            const mount = (container, anchor) => {
                // Teleport *always* has Array children. This is enforced in both the
                // compiler and vnode children normalization.
                if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                    mountChildren(children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                }
            };
            if (disabled) {
                mount(container, mainAnchor);
            }
            else if (target) {
                mount(target, targetAnchor);
            }
        }
        else {
            // update content
            n2.el = n1.el;
            const mainAnchor = (n2.anchor = n1.anchor);
            const target = (n2.target = n1.target);
            const targetAnchor = (n2.targetAnchor = n1.targetAnchor);
            const wasDisabled = isTeleportDisabled(n1.props);
            const currentContainer = wasDisabled ? container : target;
            const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
            isSVG = isSVG || isTargetSVG(target);
            if (dynamicChildren) {
                // fast path when the teleport happens to be a block root
                patchBlockChildren(n1.dynamicChildren, dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG, slotScopeIds);
                // even in block tree mode we need to make sure all root-level nodes
                // in the teleport inherit previous DOM references so that they can
                // be moved in future patches.
                traverseStaticChildren(n1, n2, true);
            }
            else if (!optimized) {
                patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, false);
            }
            if (disabled) {
                if (!wasDisabled) {
                    // enabled -> disabled
                    // move into main container
                    moveTeleport(n2, container, mainAnchor, internals, 1 /* TOGGLE */);
                }
            }
            else {
                // target changed
                if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
                    const nextTarget = (n2.target = resolveTarget(n2.props, querySelector));
                    if (nextTarget) {
                        moveTeleport(n2, nextTarget, null, internals, 0 /* TARGET_CHANGE */);
                    }
                    else if ((true)) {
                        warn('Invalid Teleport target on update:', target, `(${typeof target})`);
                    }
                }
                else if (wasDisabled) {
                    // disabled -> enabled
                    // move into teleport target
                    moveTeleport(n2, target, targetAnchor, internals, 1 /* TOGGLE */);
                }
            }
        }
    },
    remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {
        const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;
        if (target) {
            hostRemove(targetAnchor);
        }
        // an unmounted teleport should always remove its children if not disabled
        if (doRemove || !isTeleportDisabled(props)) {
            hostRemove(anchor);
            if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                for (let i = 0; i < children.length; i++) {
                    const child = children[i];
                    unmount(child, parentComponent, parentSuspense, true, !!child.dynamicChildren);
                }
            }
        }
    },
    move: moveTeleport,
    hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2 /* REORDER */) {
    // move target anchor if this is a target change.
    if (moveType === 0 /* TARGET_CHANGE */) {
        insert(vnode.targetAnchor, container, parentAnchor);
    }
    const { el, anchor, shapeFlag, children, props } = vnode;
    const isReorder = moveType === 2 /* REORDER */;
    // move main view anchor if this is a re-order.
    if (isReorder) {
        insert(el, container, parentAnchor);
    }
    // if this is a re-order and teleport is enabled (content is in target)
    // do not move children. So the opposite is: only move children if this
    // is not a reorder, or the teleport is disabled
    if (!isReorder || isTeleportDisabled(props)) {
        // Teleport has either Array children or no children.
        if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
            for (let i = 0; i < children.length; i++) {
                move(children[i], container, parentAnchor, 2 /* REORDER */);
            }
        }
    }
    // move main view anchor if this is a re-order.
    if (isReorder) {
        insert(anchor, container, parentAnchor);
    }
}
function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, { o: { nextSibling, parentNode, querySelector } }, hydrateChildren) {
    const target = (vnode.target = resolveTarget(vnode.props, querySelector));
    if (target) {
        // if multiple teleports rendered to the same target element, we need to
        // pick up from where the last teleport finished instead of the first node
        const targetNode = target._lpa || target.firstChild;
        if (vnode.shapeFlag & 16 /* ARRAY_CHILDREN */) {
            if (isTeleportDisabled(vnode.props)) {
                vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, slotScopeIds, optimized);
                vnode.targetAnchor = targetNode;
            }
            else {
                vnode.anchor = nextSibling(node);
                // lookahead until we find the target anchor
                // we cannot rely on return value of hydrateChildren() because there
                // could be nested teleports
                let targetAnchor = targetNode;
                while (targetAnchor) {
                    targetAnchor = nextSibling(targetAnchor);
                    if (targetAnchor &&
                        targetAnchor.nodeType === 8 &&
                        targetAnchor.data === 'teleport anchor') {
                        vnode.targetAnchor = targetAnchor;
                        target._lpa =
                            vnode.targetAnchor && nextSibling(vnode.targetAnchor);
                        break;
                    }
                }
                hydrateChildren(targetNode, vnode, target, parentComponent, parentSuspense, slotScopeIds, optimized);
            }
        }
    }
    return vnode.anchor && nextSibling(vnode.anchor);
}
// Force-casted public typing for h and TSX props inference
const Teleport = TeleportImpl;

const Fragment = Symbol(( true) ? 'Fragment' : 0);
const Text = Symbol(( true) ? 'Text' : 0);
const Comment = Symbol(( true) ? 'Comment' : 0);
const Static = Symbol(( true) ? 'Static' : 0);
// Since v-if and v-for are the two possible ways node structure can dynamically
// change, once we consider v-if branches and each v-for fragment a block, we
// can divide a template into nested blocks, and within each block the node
// structure would be stable. This allows us to skip most children diffing
// and only worry about the dynamic nodes (indicated by patch flags).
const blockStack = [];
let currentBlock = null;
/**
 * Open a block.
 * This must be called before `createBlock`. It cannot be part of `createBlock`
 * because the children of the block are evaluated before `createBlock` itself
 * is called. The generated code typically looks like this:
 *
 * ```js
 * function render() {
 *   return (openBlock(),createBlock('div', null, [...]))
 * }
 * ```
 * disableTracking is true when creating a v-for fragment block, since a v-for
 * fragment always diffs its children.
 *
 * @private
 */
function openBlock(disableTracking = false) {
    blockStack.push((currentBlock = disableTracking ? null : []));
}
function closeBlock() {
    blockStack.pop();
    currentBlock = blockStack[blockStack.length - 1] || null;
}
// Whether we should be tracking dynamic child nodes inside a block.
// Only tracks when this value is > 0
// We are not using a simple boolean because this value may need to be
// incremented/decremented by nested usage of v-once (see below)
let isBlockTreeEnabled = 1;
/**
 * Block tracking sometimes needs to be disabled, for example during the
 * creation of a tree that needs to be cached by v-once. The compiler generates
 * code like this:
 *
 * ``` js
 * _cache[1] || (
 *   setBlockTracking(-1),
 *   _cache[1] = createVNode(...),
 *   setBlockTracking(1),
 *   _cache[1]
 * )
 * ```
 *
 * @private
 */
function setBlockTracking(value) {
    isBlockTreeEnabled += value;
}
function setupBlock(vnode) {
    // save current block children on the block vnode
    vnode.dynamicChildren =
        isBlockTreeEnabled > 0 ? currentBlock || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR : null;
    // close block
    closeBlock();
    // a block is always going to be patched, so track it as a child of its
    // parent block
    if (isBlockTreeEnabled > 0 && currentBlock) {
        currentBlock.push(vnode);
    }
    return vnode;
}
/**
 * @private
 */
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
    return setupBlock(createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, true /* isBlock */));
}
/**
 * Create a block root vnode. Takes the same exact arguments as `createVNode`.
 * A block root keeps track of dynamic nodes within the block in the
 * `dynamicChildren` array.
 *
 * @private
 */
function createBlock(type, props, children, patchFlag, dynamicProps) {
    return setupBlock(createVNode(type, props, children, patchFlag, dynamicProps, true /* isBlock: prevent a block from tracking itself */));
}
function isVNode(value) {
    return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
    if (( true) &&
        n2.shapeFlag & 6 /* COMPONENT */ &&
        hmrDirtyComponents.has(n2.type)) {
        // HMR only: if the component has been hot-updated, force a reload.
        return false;
    }
    return n1.type === n2.type && n1.key === n2.key;
}
let vnodeArgsTransformer;
/**
 * Internal API for registering an arguments transform for createVNode
 * used for creating stubs in the test-utils
 * It is *internal* but needs to be exposed for test-utils to pick up proper
 * typings
 */
function transformVNodeArgs(transformer) {
    vnodeArgsTransformer = transformer;
}
const createVNodeWithArgsTransform = (...args) => {
    return _createVNode(...(vnodeArgsTransformer
        ? vnodeArgsTransformer(args, currentRenderingInstance)
        : args));
};
const InternalObjectKey = `__vInternal`;
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({ ref, ref_key, ref_for }) => {
    return (ref != null
        ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(ref) || (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(ref) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(ref)
            ? { i: currentRenderingInstance, r: ref, k: ref_key, f: !!ref_for }
            : ref
        : null);
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1 /* ELEMENT */, isBlockNode = false, needFullChildrenNormalization = false) {
    const vnode = {
        __v_isVNode: true,
        __v_skip: true,
        type,
        props,
        key: props && normalizeKey(props),
        ref: props && normalizeRef(props),
        scopeId: currentScopeId,
        slotScopeIds: null,
        children,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag,
        patchFlag,
        dynamicProps,
        dynamicChildren: null,
        appContext: null
    };
    if (needFullChildrenNormalization) {
        normalizeChildren(vnode, children);
        // normalize suspense children
        if (shapeFlag & 128 /* SUSPENSE */) {
            type.normalize(vnode);
        }
    }
    else if (children) {
        // compiled element vnode - if children is passed, only possible types are
        // string or Array.
        vnode.shapeFlag |= (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(children)
            ? 8 /* TEXT_CHILDREN */
            : 16 /* ARRAY_CHILDREN */;
    }
    // validate key
    if (( true) && vnode.key !== vnode.key) {
        warn(`VNode created with invalid key (NaN). VNode type:`, vnode.type);
    }
    // track vnode for block tree
    if (isBlockTreeEnabled > 0 &&
        // avoid a block node from tracking itself
        !isBlockNode &&
        // has current parent block
        currentBlock &&
        // presence of a patch flag indicates this node needs patching on updates.
        // component nodes also should always be patched, because even if the
        // component doesn't need to update, it needs to persist the instance on to
        // the next vnode so that it can be properly unmounted later.
        (vnode.patchFlag > 0 || shapeFlag & 6 /* COMPONENT */) &&
        // the EVENTS flag is only for hydration and if it is the only flag, the
        // vnode should not be considered dynamic due to handler caching.
        vnode.patchFlag !== 32 /* HYDRATE_EVENTS */) {
        currentBlock.push(vnode);
    }
    return vnode;
}
const createVNode = (( true) ? createVNodeWithArgsTransform : 0);
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
    if (!type || type === NULL_DYNAMIC_COMPONENT) {
        if (( true) && !type) {
            warn(`Invalid vnode type when creating vnode: ${type}.`);
        }
        type = Comment;
    }
    if (isVNode(type)) {
        // createVNode receiving an existing vnode. This happens in cases like
        // <component :is="vnode"/>
        // #2078 make sure to merge refs during the clone instead of overwriting it
        const cloned = cloneVNode(type, props, true /* mergeRef: true */);
        if (children) {
            normalizeChildren(cloned, children);
        }
        if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
            if (cloned.shapeFlag & 6 /* COMPONENT */) {
                currentBlock[currentBlock.indexOf(type)] = cloned;
            }
            else {
                currentBlock.push(cloned);
            }
        }
        cloned.patchFlag |= -2 /* BAIL */;
        return cloned;
    }
    // class component normalization.
    if (isClassComponent(type)) {
        type = type.__vccOpts;
    }
    // class & style normalization.
    if (props) {
        // for reactive or proxy objects, we need to clone it to enable mutation.
        props = guardReactiveProps(props);
        let { class: klass, style } = props;
        if (klass && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(klass)) {
            props.class = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)(klass);
        }
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(style)) {
            // reactive state objects need to be cloned since they are likely to be
            // mutated
            if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy)(style) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(style)) {
                style = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, style);
            }
            props.style = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeStyle)(style);
        }
    }
    // encode the vnode type information into a bitmap
    const shapeFlag = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(type)
        ? 1 /* ELEMENT */
        : isSuspense(type)
            ? 128 /* SUSPENSE */
            : isTeleport(type)
                ? 64 /* TELEPORT */
                : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(type)
                    ? 4 /* STATEFUL_COMPONENT */
                    : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(type)
                        ? 2 /* FUNCTIONAL_COMPONENT */
                        : 0;
    if (( true) && shapeFlag & 4 /* STATEFUL_COMPONENT */ && (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy)(type)) {
        type = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(type);
        warn(`Vue received a Component which was made a reactive object. This can ` +
            `lead to unnecessary performance overhead, and should be avoided by ` +
            `marking the component with \`markRaw\` or using \`shallowRef\` ` +
            `instead of \`ref\`.`, `\nComponent that was made reactive: `, type);
    }
    return createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);
}
function guardReactiveProps(props) {
    if (!props)
        return null;
    return (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy)(props) || InternalObjectKey in props
        ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, props)
        : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false) {
    // This is intentionally NOT using spread or extend to avoid the runtime
    // key enumeration cost.
    const { props, ref, patchFlag, children } = vnode;
    const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
    const cloned = {
        __v_isVNode: true,
        __v_skip: true,
        type: vnode.type,
        props: mergedProps,
        key: mergedProps && normalizeKey(mergedProps),
        ref: extraProps && extraProps.ref
            ? // #2078 in the case of <component :is="vnode" ref="extra"/>
                // if the vnode itself already has a ref, cloneVNode will need to merge
                // the refs so the single vnode can be set on multiple refs
                mergeRef && ref
                    ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(ref)
                        ? ref.concat(normalizeRef(extraProps))
                        : [ref, normalizeRef(extraProps)]
                    : normalizeRef(extraProps)
            : ref,
        scopeId: vnode.scopeId,
        slotScopeIds: vnode.slotScopeIds,
        children: ( true) && patchFlag === -1 /* HOISTED */ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(children)
            ? children.map(deepCloneVNode)
            : children,
        target: vnode.target,
        targetAnchor: vnode.targetAnchor,
        staticCount: vnode.staticCount,
        shapeFlag: vnode.shapeFlag,
        // if the vnode is cloned with extra props, we can no longer assume its
        // existing patch flag to be reliable and need to add the FULL_PROPS flag.
        // note: preserve flag for fragments since they use the flag for children
        // fast paths only.
        patchFlag: extraProps && vnode.type !== Fragment
            ? patchFlag === -1 // hoisted node
                ? 16 /* FULL_PROPS */
                : patchFlag | 16 /* FULL_PROPS */
            : patchFlag,
        dynamicProps: vnode.dynamicProps,
        dynamicChildren: vnode.dynamicChildren,
        appContext: vnode.appContext,
        dirs: vnode.dirs,
        transition: vnode.transition,
        // These should technically only be non-null on mounted VNodes. However,
        // they *should* be copied for kept-alive vnodes. So we just always copy
        // them since them being non-null during a mount doesn't affect the logic as
        // they will simply be overwritten.
        component: vnode.component,
        suspense: vnode.suspense,
        ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
        ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
        el: vnode.el,
        anchor: vnode.anchor
    };
    return cloned;
}
/**
 * Dev only, for HMR of hoisted vnodes reused in v-for
 * https://github.com/vitejs/vite/issues/2022
 */
function deepCloneVNode(vnode) {
    const cloned = cloneVNode(vnode);
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(vnode.children)) {
        cloned.children = vnode.children.map(deepCloneVNode);
    }
    return cloned;
}
/**
 * @private
 */
function createTextVNode(text = ' ', flag = 0) {
    return createVNode(Text, null, text, flag);
}
/**
 * @private
 */
function createStaticVNode(content, numberOfNodes) {
    // A static vnode can contain multiple stringified elements, and the number
    // of elements is necessary for hydration.
    const vnode = createVNode(Static, null, content);
    vnode.staticCount = numberOfNodes;
    return vnode;
}
/**
 * @private
 */
function createCommentVNode(text = '', 
// when used as the v-else branch, the comment node must be created as a
// block to ensure correct updates.
asBlock = false) {
    return asBlock
        ? (openBlock(), createBlock(Comment, null, text))
        : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
    if (child == null || typeof child === 'boolean') {
        // empty placeholder
        return createVNode(Comment);
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(child)) {
        // fragment
        return createVNode(Fragment, null, 
        // #3666, avoid reference pollution when reusing vnode
        child.slice());
    }
    else if (typeof child === 'object') {
        // already vnode, this should be the most common since compiled templates
        // always produce all-vnode children arrays
        return cloneIfMounted(child);
    }
    else {
        // strings and numbers
        return createVNode(Text, null, String(child));
    }
}
// optimized normalization for template-compiled render fns
function cloneIfMounted(child) {
    return child.el === null || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
    let type = 0;
    const { shapeFlag } = vnode;
    if (children == null) {
        children = null;
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(children)) {
        type = 16 /* ARRAY_CHILDREN */;
    }
    else if (typeof children === 'object') {
        if (shapeFlag & (1 /* ELEMENT */ | 64 /* TELEPORT */)) {
            // Normalize slot to plain children for plain element and Teleport
            const slot = children.default;
            if (slot) {
                // _c marker is added by withCtx() indicating this is a compiled slot
                slot._c && (slot._d = false);
                normalizeChildren(vnode, slot());
                slot._c && (slot._d = true);
            }
            return;
        }
        else {
            type = 32 /* SLOTS_CHILDREN */;
            const slotFlag = children._;
            if (!slotFlag && !(InternalObjectKey in children)) {
                children._ctx = currentRenderingInstance;
            }
            else if (slotFlag === 3 /* FORWARDED */ && currentRenderingInstance) {
                // a child component receives forwarded slots from the parent.
                // its slot type is determined by its parent's slot type.
                if (currentRenderingInstance.slots._ === 1 /* STABLE */) {
                    children._ = 1 /* STABLE */;
                }
                else {
                    children._ = 2 /* DYNAMIC */;
                    vnode.patchFlag |= 1024 /* DYNAMIC_SLOTS */;
                }
            }
        }
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(children)) {
        children = { default: children, _ctx: currentRenderingInstance };
        type = 32 /* SLOTS_CHILDREN */;
    }
    else {
        children = String(children);
        // force teleport children to array so it can be moved around
        if (shapeFlag & 64 /* TELEPORT */) {
            type = 16 /* ARRAY_CHILDREN */;
            children = [createTextVNode(children)];
        }
        else {
            type = 8 /* TEXT_CHILDREN */;
        }
    }
    vnode.children = children;
    vnode.shapeFlag |= type;
}
function mergeProps(...args) {
    const ret = {};
    for (let i = 0; i < args.length; i++) {
        const toMerge = args[i];
        for (const key in toMerge) {
            if (key === 'class') {
                if (ret.class !== toMerge.class) {
                    ret.class = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)([ret.class, toMerge.class]);
                }
            }
            else if (key === 'style') {
                ret.style = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeStyle)([ret.style, toMerge.style]);
            }
            else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
                const existing = ret[key];
                const incoming = toMerge[key];
                if (incoming &&
                    existing !== incoming &&
                    !((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(existing) && existing.includes(incoming))) {
                    ret[key] = existing
                        ? [].concat(existing, incoming)
                        : incoming;
                }
            }
            else if (key !== '') {
                ret[key] = toMerge[key];
            }
        }
    }
    return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
    callWithAsyncErrorHandling(hook, instance, 7 /* VNODE_HOOK */, [
        vnode,
        prevVNode
    ]);
}

const emptyAppContext = createAppContext();
let uid$1 = 0;
function createComponentInstance(vnode, parent, suspense) {
    const type = vnode.type;
    // inherit parent app context - or - if root, adopt from root vnode
    const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
    const instance = {
        uid: uid$1++,
        vnode,
        type,
        parent,
        appContext,
        root: null,
        next: null,
        subTree: null,
        effect: null,
        update: null,
        scope: new _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.EffectScope(true /* detached */),
        render: null,
        proxy: null,
        exposed: null,
        exposeProxy: null,
        withProxy: null,
        provides: parent ? parent.provides : Object.create(appContext.provides),
        accessCache: null,
        renderCache: [],
        // local resolved assets
        components: null,
        directives: null,
        // resolved props and emits options
        propsOptions: normalizePropsOptions(type, appContext),
        emitsOptions: normalizeEmitsOptions(type, appContext),
        // emit
        emit: null,
        emitted: null,
        // props default value
        propsDefaults: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
        // inheritAttrs
        inheritAttrs: type.inheritAttrs,
        // state
        ctx: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
        data: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
        props: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
        attrs: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
        slots: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
        refs: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
        setupState: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
        setupContext: null,
        // suspense related
        suspense,
        suspenseId: suspense ? suspense.pendingId : 0,
        asyncDep: null,
        asyncResolved: false,
        // lifecycle hooks
        // not using enums here because it results in computed properties
        isMounted: false,
        isUnmounted: false,
        isDeactivated: false,
        bc: null,
        c: null,
        bm: null,
        m: null,
        bu: null,
        u: null,
        um: null,
        bum: null,
        da: null,
        a: null,
        rtg: null,
        rtc: null,
        ec: null,
        sp: null
    };
    if ((true)) {
        instance.ctx = createDevRenderContext(instance);
    }
    else {}
    instance.root = parent ? parent.root : instance;
    instance.emit = emit$1.bind(null, instance);
    // apply custom element special handling
    if (vnode.ce) {
        vnode.ce(instance);
    }
    return instance;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
const setCurrentInstance = (instance) => {
    currentInstance = instance;
    instance.scope.on();
};
const unsetCurrentInstance = () => {
    currentInstance && currentInstance.scope.off();
    currentInstance = null;
};
const isBuiltInTag = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)('slot,component');
function validateComponentName(name, config) {
    const appIsNativeTag = config.isNativeTag || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NO;
    if (isBuiltInTag(name) || appIsNativeTag(name)) {
        warn('Do not use built-in or reserved HTML elements as component id: ' + name);
    }
}
function isStatefulComponent(instance) {
    return instance.vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
    isInSSRComponentSetup = isSSR;
    const { props, children } = instance.vnode;
    const isStateful = isStatefulComponent(instance);
    initProps(instance, props, isStateful, isSSR);
    initSlots(instance, children);
    const setupResult = isStateful
        ? setupStatefulComponent(instance, isSSR)
        : undefined;
    isInSSRComponentSetup = false;
    return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
    var _a;
    const Component = instance.type;
    if ((true)) {
        if (Component.name) {
            validateComponentName(Component.name, instance.appContext.config);
        }
        if (Component.components) {
            const names = Object.keys(Component.components);
            for (let i = 0; i < names.length; i++) {
                validateComponentName(names[i], instance.appContext.config);
            }
        }
        if (Component.directives) {
            const names = Object.keys(Component.directives);
            for (let i = 0; i < names.length; i++) {
                validateDirectiveName(names[i]);
            }
        }
        if (Component.compilerOptions && isRuntimeOnly()) {
            warn(`"compilerOptions" is only supported when using a build of Vue that ` +
                `includes the runtime compiler. Since you are using a runtime-only ` +
                `build, the options should be passed via your build tool config instead.`);
        }
    }
    // 0. create render proxy property access cache
    instance.accessCache = Object.create(null);
    // 1. create public instance / render proxy
    // also mark it raw so it's never observed
    instance.proxy = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.markRaw)(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
    if ((true)) {
        exposePropsOnRenderContext(instance);
    }
    // 2. call setup()
    const { setup } = Component;
    if (setup) {
        const setupContext = (instance.setupContext =
            setup.length > 1 ? createSetupContext(instance) : null);
        setCurrentInstance(instance);
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
        const setupResult = callWithErrorHandling(setup, instance, 0 /* SETUP_FUNCTION */, [( true) ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(instance.props) : 0, setupContext]);
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
        unsetCurrentInstance();
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(setupResult)) {
            setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
            if (isSSR) {
                // return the promise so server-renderer can wait on it
                return setupResult
                    .then((resolvedResult) => {
                    handleSetupResult(instance, resolvedResult, isSSR);
                })
                    .catch(e => {
                    handleError(e, instance, 0 /* SETUP_FUNCTION */);
                });
            }
            else {
                // async setup returned Promise.
                // bail here and wait for re-entry.
                instance.asyncDep = setupResult;
                if (( true) && !instance.suspense) {
                    const name = (_a = Component.name) !== null && _a !== void 0 ? _a : 'Anonymous';
                    warn(`Component <${name}>: setup function returned a promise, but no ` +
                        `<Suspense> boundary was found in the parent component tree. ` +
                        `A component with async setup() must be nested in a <Suspense> ` +
                        `in order to be rendered.`);
                }
            }
        }
        else {
            handleSetupResult(instance, setupResult, isSSR);
        }
    }
    else {
        finishComponentSetup(instance, isSSR);
    }
}
function handleSetupResult(instance, setupResult, isSSR) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(setupResult)) {
        // setup returned an inline render function
        if (instance.type.__ssrInlineRender) {
            // when the function's name is `ssrRender` (compiled by SFC inline mode),
            // set it as ssrRender instead.
            instance.ssrRender = setupResult;
        }
        else {
            instance.render = setupResult;
        }
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(setupResult)) {
        if (( true) && isVNode(setupResult)) {
            warn(`setup() should not return VNodes directly - ` +
                `return a render function instead.`);
        }
        // setup returned bindings.
        // assuming a render function compiled from template is present.
        if (true) {
            instance.devtoolsRawSetupState = setupResult;
        }
        instance.setupState = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.proxyRefs)(setupResult);
        if ((true)) {
            exposeSetupStateOnRenderContext(instance);
        }
    }
    else if (( true) && setupResult !== undefined) {
        warn(`setup() should return an object. Received: ${setupResult === null ? 'null' : typeof setupResult}`);
    }
    finishComponentSetup(instance, isSSR);
}
let compile;
let installWithProxy;
/**
 * For runtime-dom to register the compiler.
 * Note the exported method uses any to avoid d.ts relying on the compiler types.
 */
function registerRuntimeCompiler(_compile) {
    compile = _compile;
    installWithProxy = i => {
        if (i.render._rc) {
            i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
        }
    };
}
// dev only
const isRuntimeOnly = () => !compile;
function finishComponentSetup(instance, isSSR, skipOptions) {
    const Component = instance.type;
    // template / render function normalization
    // could be already set when returned from setup()
    if (!instance.render) {
        // only do on-the-fly compile if not in SSR - SSR on-the-fly compilation
        // is done by server-renderer
        if (!isSSR && compile && !Component.render) {
            const template = Component.template;
            if (template) {
                if ((true)) {
                    startMeasure(instance, `compile`);
                }
                const { isCustomElement, compilerOptions } = instance.appContext.config;
                const { delimiters, compilerOptions: componentCompilerOptions } = Component;
                const finalCompilerOptions = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({
                    isCustomElement,
                    delimiters
                }, compilerOptions), componentCompilerOptions);
                Component.render = compile(template, finalCompilerOptions);
                if ((true)) {
                    endMeasure(instance, `compile`);
                }
            }
        }
        instance.render = (Component.render || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP);
        // for runtime-compiled render functions using `with` blocks, the render
        // proxy used needs a different `has` handler which is more performant and
        // also only allows a whitelist of globals to fallthrough.
        if (installWithProxy) {
            installWithProxy(instance);
        }
    }
    // support for 2.x options
    if (__VUE_OPTIONS_API__ && !(false )) {
        setCurrentInstance(instance);
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
        applyOptions(instance);
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
        unsetCurrentInstance();
    }
    // warn missing template/render
    // the runtime compilation of template in SSR is done by server-render
    if (( true) && !Component.render && instance.render === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP && !isSSR) {
        /* istanbul ignore if */
        if (!compile && Component.template) {
            warn(`Component provided template option but ` +
                `runtime compilation is not supported in this build of Vue.` +
                (` Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`
                    ) /* should not happen */);
        }
        else {
            warn(`Component is missing template or render function.`);
        }
    }
}
function createAttrsProxy(instance) {
    return new Proxy(instance.attrs, ( true)
        ? {
            get(target, key) {
                markAttrsAccessed();
                (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.track)(instance, "get" /* GET */, '$attrs');
                return target[key];
            },
            set() {
                warn(`setupContext.attrs is readonly.`);
                return false;
            },
            deleteProperty() {
                warn(`setupContext.attrs is readonly.`);
                return false;
            }
        }
        : 0);
}
function createSetupContext(instance) {
    const expose = exposed => {
        if (( true) && instance.exposed) {
            warn(`expose() should be called only once per setup().`);
        }
        instance.exposed = exposed || {};
    };
    let attrs;
    if ((true)) {
        // We use getters in dev in case libs like test-utils overwrite instance
        // properties (overwrites should not be done in prod)
        return Object.freeze({
            get attrs() {
                return attrs || (attrs = createAttrsProxy(instance));
            },
            get slots() {
                return (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(instance.slots);
            },
            get emit() {
                return (event, ...args) => instance.emit(event, ...args);
            },
            expose
        });
    }
    else {}
}
function getExposeProxy(instance) {
    if (instance.exposed) {
        return (instance.exposeProxy ||
            (instance.exposeProxy = new Proxy((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.proxyRefs)((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.markRaw)(instance.exposed)), {
                get(target, key) {
                    if (key in target) {
                        return target[key];
                    }
                    else if (key in publicPropertiesMap) {
                        return publicPropertiesMap[key](instance);
                    }
                }
            })));
    }
}
const classifyRE = /(?:^|[-_])(\w)/g;
const classify = (str) => str.replace(classifyRE, c => c.toUpperCase()).replace(/[-_]/g, '');
function getComponentName(Component) {
    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(Component)
        ? Component.displayName || Component.name
        : Component.name;
}
/* istanbul ignore next */
function formatComponentName(instance, Component, isRoot = false) {
    let name = getComponentName(Component);
    if (!name && Component.__file) {
        const match = Component.__file.match(/([^/\\]+)\.\w+$/);
        if (match) {
            name = match[1];
        }
    }
    if (!name && instance && instance.parent) {
        // try to infer the name based on reverse resolution
        const inferFromRegistry = (registry) => {
            for (const key in registry) {
                if (registry[key] === Component) {
                    return key;
                }
            }
        };
        name =
            inferFromRegistry(instance.components ||
                instance.parent.type.components) || inferFromRegistry(instance.appContext.components);
    }
    return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}
function isClassComponent(value) {
    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value) && '__vccOpts' in value;
}

const computed = ((getterOrOptions, debugOptions) => {
    // @ts-ignore
    return (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.computed)(getterOrOptions, debugOptions, isInSSRComponentSetup);
});

// dev only
const warnRuntimeUsage = (method) => warn(`${method}() is a compiler-hint helper that is only usable inside ` +
    `<script setup> of a single file component. Its arguments should be ` +
    `compiled away and passing it at runtime has no effect.`);
// implementation
function defineProps() {
    if ((true)) {
        warnRuntimeUsage(`defineProps`);
    }
    return null;
}
// implementation
function defineEmits() {
    if ((true)) {
        warnRuntimeUsage(`defineEmits`);
    }
    return null;
}
/**
 * Vue `<script setup>` compiler macro for declaring a component's exposed
 * instance properties when it is accessed by a parent component via template
 * refs.
 *
 * `<script setup>` components are closed by default - i.e. variables inside
 * the `<script setup>` scope is not exposed to parent unless explicitly exposed
 * via `defineExpose`.
 *
 * This is only usable inside `<script setup>`, is compiled away in the
 * output and should **not** be actually called at runtime.
 */
function defineExpose(exposed) {
    if ((true)) {
        warnRuntimeUsage(`defineExpose`);
    }
}
/**
 * Vue `<script setup>` compiler macro for providing props default values when
 * using type-based `defineProps` declaration.
 *
 * Example usage:
 * ```ts
 * withDefaults(defineProps<{
 *   size?: number
 *   labels?: string[]
 * }>(), {
 *   size: 3,
 *   labels: () => ['default label']
 * })
 * ```
 *
 * This is only usable inside `<script setup>`, is compiled away in the output
 * and should **not** be actually called at runtime.
 */
function withDefaults(props, defaults) {
    if ((true)) {
        warnRuntimeUsage(`withDefaults`);
    }
    return null;
}
function useSlots() {
    return getContext().slots;
}
function useAttrs() {
    return getContext().attrs;
}
function getContext() {
    const i = getCurrentInstance();
    if (( true) && !i) {
        warn(`useContext() called without active instance.`);
    }
    return i.setupContext || (i.setupContext = createSetupContext(i));
}
/**
 * Runtime helper for merging default declarations. Imported by compiled code
 * only.
 * @internal
 */
function mergeDefaults(raw, defaults) {
    const props = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)
        ? raw.reduce((normalized, p) => ((normalized[p] = {}), normalized), {})
        : raw;
    for (const key in defaults) {
        const opt = props[key];
        if (opt) {
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(opt) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt)) {
                props[key] = { type: opt, default: defaults[key] };
            }
            else {
                opt.default = defaults[key];
            }
        }
        else if (opt === null) {
            props[key] = { default: defaults[key] };
        }
        else if ((true)) {
            warn(`props default key "${key}" has no corresponding declaration.`);
        }
    }
    return props;
}
/**
 * Used to create a proxy for the rest element when destructuring props with
 * defineProps().
 * @internal
 */
function createPropsRestProxy(props, excludedKeys) {
    const ret = {};
    for (const key in props) {
        if (!excludedKeys.includes(key)) {
            Object.defineProperty(ret, key, {
                enumerable: true,
                get: () => props[key]
            });
        }
    }
    return ret;
}
/**
 * `<script setup>` helper for persisting the current instance context over
 * async/await flows.
 *
 * `@vue/compiler-sfc` converts the following:
 *
 * ```ts
 * const x = await foo()
 * ```
 *
 * into:
 *
 * ```ts
 * let __temp, __restore
 * const x = (([__temp, __restore] = withAsyncContext(() => foo())),__temp=await __temp,__restore(),__temp)
 * ```
 * @internal
 */
function withAsyncContext(getAwaitable) {
    const ctx = getCurrentInstance();
    if (( true) && !ctx) {
        warn(`withAsyncContext called without active current instance. ` +
            `This is likely a bug.`);
    }
    let awaitable = getAwaitable();
    unsetCurrentInstance();
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(awaitable)) {
        awaitable = awaitable.catch(e => {
            setCurrentInstance(ctx);
            throw e;
        });
    }
    return [awaitable, () => setCurrentInstance(ctx)];
}

// Actual implementation
function h(type, propsOrChildren, children) {
    const l = arguments.length;
    if (l === 2) {
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(propsOrChildren) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(propsOrChildren)) {
            // single vnode without props
            if (isVNode(propsOrChildren)) {
                return createVNode(type, null, [propsOrChildren]);
            }
            // props without children
            return createVNode(type, propsOrChildren);
        }
        else {
            // omit props
            return createVNode(type, null, propsOrChildren);
        }
    }
    else {
        if (l > 3) {
            children = Array.prototype.slice.call(arguments, 2);
        }
        else if (l === 3 && isVNode(children)) {
            children = [children];
        }
        return createVNode(type, propsOrChildren, children);
    }
}

const ssrContextKey = Symbol(( true) ? `ssrContext` : 0);
const useSSRContext = () => {
    {
        const ctx = inject(ssrContextKey);
        if (!ctx) {
            warn(`Server rendering context not provided. Make sure to only call ` +
                `useSSRContext() conditionally in the server build.`);
        }
        return ctx;
    }
};

function isShallow(value) {
    return !!(value && value["__v_isShallow" /* IS_SHALLOW */]);
}

function initCustomFormatter() {
    /* eslint-disable no-restricted-globals */
    if ( false || typeof window === 'undefined') {
        return;
    }
    const vueStyle = { style: 'color:#3ba776' };
    const numberStyle = { style: 'color:#0b1bc9' };
    const stringStyle = { style: 'color:#b62e24' };
    const keywordStyle = { style: 'color:#9d288c' };
    // custom formatter for Chrome
    // https://www.mattzeunert.com/2016/02/19/custom-chrome-devtools-object-formatters.html
    const formatter = {
        header(obj) {
            // TODO also format ComponentPublicInstance & ctx.slots/attrs in setup
            if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(obj)) {
                return null;
            }
            if (obj.__isVue) {
                return ['div', vueStyle, `VueInstance`];
            }
            else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(obj)) {
                return [
                    'div',
                    {},
                    ['span', vueStyle, genRefFlag(obj)],
                    '<',
                    formatValue(obj.value),
                    `>`
                ];
            }
            else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive)(obj)) {
                return [
                    'div',
                    {},
                    ['span', vueStyle, isShallow(obj) ? 'ShallowReactive' : 'Reactive'],
                    '<',
                    formatValue(obj),
                    `>${(0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReadonly)(obj) ? ` (readonly)` : ``}`
                ];
            }
            else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReadonly)(obj)) {
                return [
                    'div',
                    {},
                    ['span', vueStyle, isShallow(obj) ? 'ShallowReadonly' : 'Readonly'],
                    '<',
                    formatValue(obj),
                    '>'
                ];
            }
            return null;
        },
        hasBody(obj) {
            return obj && obj.__isVue;
        },
        body(obj) {
            if (obj && obj.__isVue) {
                return [
                    'div',
                    {},
                    ...formatInstance(obj.$)
                ];
            }
        }
    };
    function formatInstance(instance) {
        const blocks = [];
        if (instance.type.props && instance.props) {
            blocks.push(createInstanceBlock('props', (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(instance.props)));
        }
        if (instance.setupState !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {
            blocks.push(createInstanceBlock('setup', instance.setupState));
        }
        if (instance.data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {
            blocks.push(createInstanceBlock('data', (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(instance.data)));
        }
        const computed = extractKeys(instance, 'computed');
        if (computed) {
            blocks.push(createInstanceBlock('computed', computed));
        }
        const injected = extractKeys(instance, 'inject');
        if (injected) {
            blocks.push(createInstanceBlock('injected', injected));
        }
        blocks.push([
            'div',
            {},
            [
                'span',
                {
                    style: keywordStyle.style + ';opacity:0.66'
                },
                '$ (internal): '
            ],
            ['object', { object: instance }]
        ]);
        return blocks;
    }
    function createInstanceBlock(type, target) {
        target = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, target);
        if (!Object.keys(target).length) {
            return ['span', {}];
        }
        return [
            'div',
            { style: 'line-height:1.25em;margin-bottom:0.6em' },
            [
                'div',
                {
                    style: 'color:#476582'
                },
                type
            ],
            [
                'div',
                {
                    style: 'padding-left:1.25em'
                },
                ...Object.keys(target).map(key => {
                    return [
                        'div',
                        {},
                        ['span', keywordStyle, key + ': '],
                        formatValue(target[key], false)
                    ];
                })
            ]
        ];
    }
    function formatValue(v, asRaw = true) {
        if (typeof v === 'number') {
            return ['span', numberStyle, v];
        }
        else if (typeof v === 'string') {
            return ['span', stringStyle, JSON.stringify(v)];
        }
        else if (typeof v === 'boolean') {
            return ['span', keywordStyle, v];
        }
        else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(v)) {
            return ['object', { object: asRaw ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(v) : v }];
        }
        else {
            return ['span', stringStyle, String(v)];
        }
    }
    function extractKeys(instance, type) {
        const Comp = instance.type;
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(Comp)) {
            return;
        }
        const extracted = {};
        for (const key in instance.ctx) {
            if (isKeyOfType(Comp, key, type)) {
                extracted[key] = instance.ctx[key];
            }
        }
        return extracted;
    }
    function isKeyOfType(Comp, key, type) {
        const opts = Comp[type];
        if (((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(opts) && opts.includes(key)) ||
            ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(opts) && key in opts)) {
            return true;
        }
        if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {
            return true;
        }
        if (Comp.mixins && Comp.mixins.some(m => isKeyOfType(m, key, type))) {
            return true;
        }
    }
    function genRefFlag(v) {
        if (isShallow(v)) {
            return `ShallowRef`;
        }
        if (v.effect) {
            return `ComputedRef`;
        }
        return `Ref`;
    }
    if (window.devtoolsFormatters) {
        window.devtoolsFormatters.push(formatter);
    }
    else {
        window.devtoolsFormatters = [formatter];
    }
}

function withMemo(memo, render, cache, index) {
    const cached = cache[index];
    if (cached && isMemoSame(cached, memo)) {
        return cached;
    }
    const ret = render();
    // shallow clone
    ret.memo = memo.slice();
    return (cache[index] = ret);
}
function isMemoSame(cached, memo) {
    const prev = cached.memo;
    if (prev.length != memo.length) {
        return false;
    }
    for (let i = 0; i < prev.length; i++) {
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasChanged)(prev[i], memo[i])) {
            return false;
        }
    }
    // make sure to let parent block track it when returning cached
    if (isBlockTreeEnabled > 0 && currentBlock) {
        currentBlock.push(cached);
    }
    return true;
}

// Core API ------------------------------------------------------------------
const version = "3.2.36";
const _ssrUtils = {
    createComponentInstance,
    setupComponent,
    renderComponentRoot,
    setCurrentRenderingInstance,
    isVNode,
    normalizeVNode
};
/**
 * SSR utils for \@vue/server-renderer. Only exposed in cjs builds.
 * @internal
 */
const ssrUtils = (_ssrUtils );
/**
 * @internal only exposed in compat builds
 */
const resolveFilter = null;
/**
 * @internal only exposed in compat builds.
 */
const compatUtils = (null);




/***/ }),

/***/ "./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseTransition": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.BaseTransition; },
/* harmony export */   "Comment": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Comment; },
/* harmony export */   "EffectScope": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.EffectScope; },
/* harmony export */   "Fragment": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Fragment; },
/* harmony export */   "KeepAlive": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.KeepAlive; },
/* harmony export */   "ReactiveEffect": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ReactiveEffect; },
/* harmony export */   "Static": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Static; },
/* harmony export */   "Suspense": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Suspense; },
/* harmony export */   "Teleport": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Teleport; },
/* harmony export */   "Text": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Text; },
/* harmony export */   "Transition": function() { return /* binding */ Transition; },
/* harmony export */   "TransitionGroup": function() { return /* binding */ TransitionGroup; },
/* harmony export */   "VueElement": function() { return /* binding */ VueElement; },
/* harmony export */   "callWithAsyncErrorHandling": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.callWithAsyncErrorHandling; },
/* harmony export */   "callWithErrorHandling": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.callWithErrorHandling; },
/* harmony export */   "camelize": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.camelize; },
/* harmony export */   "capitalize": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.capitalize; },
/* harmony export */   "cloneVNode": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.cloneVNode; },
/* harmony export */   "compatUtils": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.compatUtils; },
/* harmony export */   "computed": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.computed; },
/* harmony export */   "createApp": function() { return /* binding */ createApp; },
/* harmony export */   "createBlock": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createBlock; },
/* harmony export */   "createCommentVNode": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode; },
/* harmony export */   "createElementBlock": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createElementBlock; },
/* harmony export */   "createElementVNode": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createElementVNode; },
/* harmony export */   "createHydrationRenderer": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createHydrationRenderer; },
/* harmony export */   "createPropsRestProxy": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createPropsRestProxy; },
/* harmony export */   "createRenderer": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createRenderer; },
/* harmony export */   "createSSRApp": function() { return /* binding */ createSSRApp; },
/* harmony export */   "createSlots": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createSlots; },
/* harmony export */   "createStaticVNode": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createStaticVNode; },
/* harmony export */   "createTextVNode": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createTextVNode; },
/* harmony export */   "createVNode": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createVNode; },
/* harmony export */   "customRef": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.customRef; },
/* harmony export */   "defineAsyncComponent": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineAsyncComponent; },
/* harmony export */   "defineComponent": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineComponent; },
/* harmony export */   "defineCustomElement": function() { return /* binding */ defineCustomElement; },
/* harmony export */   "defineEmits": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineEmits; },
/* harmony export */   "defineExpose": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineExpose; },
/* harmony export */   "defineProps": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineProps; },
/* harmony export */   "defineSSRCustomElement": function() { return /* binding */ defineSSRCustomElement; },
/* harmony export */   "devtools": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.devtools; },
/* harmony export */   "effect": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.effect; },
/* harmony export */   "effectScope": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.effectScope; },
/* harmony export */   "getCurrentInstance": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance; },
/* harmony export */   "getCurrentScope": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentScope; },
/* harmony export */   "getTransitionRawChildren": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getTransitionRawChildren; },
/* harmony export */   "guardReactiveProps": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.guardReactiveProps; },
/* harmony export */   "h": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.h; },
/* harmony export */   "handleError": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.handleError; },
/* harmony export */   "hydrate": function() { return /* binding */ hydrate; },
/* harmony export */   "initCustomFormatter": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.initCustomFormatter; },
/* harmony export */   "initDirectivesForSSR": function() { return /* binding */ initDirectivesForSSR; },
/* harmony export */   "inject": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.inject; },
/* harmony export */   "isMemoSame": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isMemoSame; },
/* harmony export */   "isProxy": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isProxy; },
/* harmony export */   "isReactive": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isReactive; },
/* harmony export */   "isReadonly": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isReadonly; },
/* harmony export */   "isRef": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isRef; },
/* harmony export */   "isRuntimeOnly": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isRuntimeOnly; },
/* harmony export */   "isShallow": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isShallow; },
/* harmony export */   "isVNode": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isVNode; },
/* harmony export */   "markRaw": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.markRaw; },
/* harmony export */   "mergeDefaults": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.mergeDefaults; },
/* harmony export */   "mergeProps": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.mergeProps; },
/* harmony export */   "nextTick": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.nextTick; },
/* harmony export */   "normalizeClass": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.normalizeClass; },
/* harmony export */   "normalizeProps": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.normalizeProps; },
/* harmony export */   "normalizeStyle": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.normalizeStyle; },
/* harmony export */   "onActivated": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onActivated; },
/* harmony export */   "onBeforeMount": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onBeforeMount; },
/* harmony export */   "onBeforeUnmount": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount; },
/* harmony export */   "onBeforeUpdate": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onBeforeUpdate; },
/* harmony export */   "onDeactivated": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onDeactivated; },
/* harmony export */   "onErrorCaptured": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onErrorCaptured; },
/* harmony export */   "onMounted": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onMounted; },
/* harmony export */   "onRenderTracked": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onRenderTracked; },
/* harmony export */   "onRenderTriggered": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onRenderTriggered; },
/* harmony export */   "onScopeDispose": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onScopeDispose; },
/* harmony export */   "onServerPrefetch": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onServerPrefetch; },
/* harmony export */   "onUnmounted": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUnmounted; },
/* harmony export */   "onUpdated": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUpdated; },
/* harmony export */   "openBlock": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.openBlock; },
/* harmony export */   "popScopeId": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.popScopeId; },
/* harmony export */   "provide": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.provide; },
/* harmony export */   "proxyRefs": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.proxyRefs; },
/* harmony export */   "pushScopeId": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.pushScopeId; },
/* harmony export */   "queuePostFlushCb": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.queuePostFlushCb; },
/* harmony export */   "reactive": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.reactive; },
/* harmony export */   "readonly": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.readonly; },
/* harmony export */   "ref": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ref; },
/* harmony export */   "registerRuntimeCompiler": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.registerRuntimeCompiler; },
/* harmony export */   "render": function() { return /* binding */ render; },
/* harmony export */   "renderList": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.renderList; },
/* harmony export */   "renderSlot": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.renderSlot; },
/* harmony export */   "resolveComponent": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveComponent; },
/* harmony export */   "resolveDirective": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveDirective; },
/* harmony export */   "resolveDynamicComponent": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveDynamicComponent; },
/* harmony export */   "resolveFilter": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveFilter; },
/* harmony export */   "resolveTransitionHooks": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks; },
/* harmony export */   "setBlockTracking": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setBlockTracking; },
/* harmony export */   "setDevtoolsHook": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setDevtoolsHook; },
/* harmony export */   "setTransitionHooks": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks; },
/* harmony export */   "shallowReactive": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.shallowReactive; },
/* harmony export */   "shallowReadonly": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly; },
/* harmony export */   "shallowRef": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.shallowRef; },
/* harmony export */   "ssrContextKey": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ssrContextKey; },
/* harmony export */   "ssrUtils": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ssrUtils; },
/* harmony export */   "stop": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.stop; },
/* harmony export */   "toDisplayString": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toDisplayString; },
/* harmony export */   "toHandlerKey": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toHandlerKey; },
/* harmony export */   "toHandlers": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toHandlers; },
/* harmony export */   "toRaw": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toRaw; },
/* harmony export */   "toRef": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toRef; },
/* harmony export */   "toRefs": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toRefs; },
/* harmony export */   "transformVNodeArgs": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.transformVNodeArgs; },
/* harmony export */   "triggerRef": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.triggerRef; },
/* harmony export */   "unref": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.unref; },
/* harmony export */   "useAttrs": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useAttrs; },
/* harmony export */   "useCssModule": function() { return /* binding */ useCssModule; },
/* harmony export */   "useCssVars": function() { return /* binding */ useCssVars; },
/* harmony export */   "useSSRContext": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useSSRContext; },
/* harmony export */   "useSlots": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useSlots; },
/* harmony export */   "useTransitionState": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useTransitionState; },
/* harmony export */   "vModelCheckbox": function() { return /* binding */ vModelCheckbox; },
/* harmony export */   "vModelDynamic": function() { return /* binding */ vModelDynamic; },
/* harmony export */   "vModelRadio": function() { return /* binding */ vModelRadio; },
/* harmony export */   "vModelSelect": function() { return /* binding */ vModelSelect; },
/* harmony export */   "vModelText": function() { return /* binding */ vModelText; },
/* harmony export */   "vShow": function() { return /* binding */ vShow; },
/* harmony export */   "version": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.version; },
/* harmony export */   "warn": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn; },
/* harmony export */   "watch": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watch; },
/* harmony export */   "watchEffect": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watchEffect; },
/* harmony export */   "watchPostEffect": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watchPostEffect; },
/* harmony export */   "watchSyncEffect": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watchSyncEffect; },
/* harmony export */   "withAsyncContext": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withAsyncContext; },
/* harmony export */   "withCtx": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withCtx; },
/* harmony export */   "withDefaults": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withDefaults; },
/* harmony export */   "withDirectives": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withDirectives; },
/* harmony export */   "withKeys": function() { return /* binding */ withKeys; },
/* harmony export */   "withMemo": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withMemo; },
/* harmony export */   "withModifiers": function() { return /* binding */ withModifiers; },
/* harmony export */   "withScopeId": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withScopeId; }
/* harmony export */ });
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");
/* harmony import */ var _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/runtime-core */ "./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js");
/* harmony import */ var _vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @vue/runtime-core */ "./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js");




const svgNS = 'http://www.w3.org/2000/svg';
const doc = (typeof document !== 'undefined' ? document : null);
const templateContainer = doc && /*#__PURE__*/ doc.createElement('template');
const nodeOps = {
    insert: (child, parent, anchor) => {
        parent.insertBefore(child, anchor || null);
    },
    remove: child => {
        const parent = child.parentNode;
        if (parent) {
            parent.removeChild(child);
        }
    },
    createElement: (tag, isSVG, is, props) => {
        const el = isSVG
            ? doc.createElementNS(svgNS, tag)
            : doc.createElement(tag, is ? { is } : undefined);
        if (tag === 'select' && props && props.multiple != null) {
            el.setAttribute('multiple', props.multiple);
        }
        return el;
    },
    createText: text => doc.createTextNode(text),
    createComment: text => doc.createComment(text),
    setText: (node, text) => {
        node.nodeValue = text;
    },
    setElementText: (el, text) => {
        el.textContent = text;
    },
    parentNode: node => node.parentNode,
    nextSibling: node => node.nextSibling,
    querySelector: selector => doc.querySelector(selector),
    setScopeId(el, id) {
        el.setAttribute(id, '');
    },
    cloneNode(el) {
        const cloned = el.cloneNode(true);
        // #3072
        // - in `patchDOMProp`, we store the actual value in the `el._value` property.
        // - normally, elements using `:value` bindings will not be hoisted, but if
        //   the bound value is a constant, e.g. `:value="true"` - they do get
        //   hoisted.
        // - in production, hoisted nodes are cloned when subsequent inserts, but
        //   cloneNode() does not copy the custom property we attached.
        // - This may need to account for other custom DOM properties we attach to
        //   elements in addition to `_value` in the future.
        if (`_value` in el) {
            cloned._value = el._value;
        }
        return cloned;
    },
    // __UNSAFE__
    // Reason: innerHTML.
    // Static content here can only come from compiled templates.
    // As long as the user only uses trusted templates, this is safe.
    insertStaticContent(content, parent, anchor, isSVG, start, end) {
        // <parent> before | first ... last | anchor </parent>
        const before = anchor ? anchor.previousSibling : parent.lastChild;
        // #5308 can only take cached path if:
        // - has a single root node
        // - nextSibling info is still available
        if (start && (start === end || start.nextSibling)) {
            // cached
            while (true) {
                parent.insertBefore(start.cloneNode(true), anchor);
                if (start === end || !(start = start.nextSibling))
                    break;
            }
        }
        else {
            // fresh insert
            templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
            const template = templateContainer.content;
            if (isSVG) {
                // remove outer svg wrapper
                const wrapper = template.firstChild;
                while (wrapper.firstChild) {
                    template.appendChild(wrapper.firstChild);
                }
                template.removeChild(wrapper);
            }
            parent.insertBefore(template, anchor);
        }
        return [
            // first
            before ? before.nextSibling : parent.firstChild,
            // last
            anchor ? anchor.previousSibling : parent.lastChild
        ];
    }
};

// compiler should normalize class + :class bindings on the same element
// into a single binding ['staticClass', dynamic]
function patchClass(el, value, isSVG) {
    // directly setting className should be faster than setAttribute in theory
    // if this is an element during a transition, take the temporary transition
    // classes into account.
    const transitionClasses = el._vtc;
    if (transitionClasses) {
        value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(' ');
    }
    if (value == null) {
        el.removeAttribute('class');
    }
    else if (isSVG) {
        el.setAttribute('class', value);
    }
    else {
        el.className = value;
    }
}

function patchStyle(el, prev, next) {
    const style = el.style;
    const isCssString = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(next);
    if (next && !isCssString) {
        for (const key in next) {
            setStyle(style, key, next[key]);
        }
        if (prev && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(prev)) {
            for (const key in prev) {
                if (next[key] == null) {
                    setStyle(style, key, '');
                }
            }
        }
    }
    else {
        const currentDisplay = style.display;
        if (isCssString) {
            if (prev !== next) {
                style.cssText = next;
            }
        }
        else if (prev) {
            el.removeAttribute('style');
        }
        // indicates that the `display` of the element is controlled by `v-show`,
        // so we always keep the current `display` value regardless of the `style`
        // value, thus handing over control to `v-show`.
        if ('_vod' in el) {
            style.display = currentDisplay;
        }
    }
}
const importantRE = /\s*!important$/;
function setStyle(style, name, val) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(val)) {
        val.forEach(v => setStyle(style, name, v));
    }
    else {
        if (val == null)
            val = '';
        if (name.startsWith('--')) {
            // custom property definition
            style.setProperty(name, val);
        }
        else {
            const prefixed = autoPrefix(style, name);
            if (importantRE.test(val)) {
                // !important
                style.setProperty((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(prefixed), val.replace(importantRE, ''), 'important');
            }
            else {
                style[prefixed] = val;
            }
        }
    }
}
const prefixes = ['Webkit', 'Moz', 'ms'];
const prefixCache = {};
function autoPrefix(style, rawName) {
    const cached = prefixCache[rawName];
    if (cached) {
        return cached;
    }
    let name = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(rawName);
    if (name !== 'filter' && name in style) {
        return (prefixCache[rawName] = name);
    }
    name = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)(name);
    for (let i = 0; i < prefixes.length; i++) {
        const prefixed = prefixes[i] + name;
        if (prefixed in style) {
            return (prefixCache[rawName] = prefixed);
        }
    }
    return rawName;
}

const xlinkNS = 'http://www.w3.org/1999/xlink';
function patchAttr(el, key, value, isSVG, instance) {
    if (isSVG && key.startsWith('xlink:')) {
        if (value == null) {
            el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
        }
        else {
            el.setAttributeNS(xlinkNS, key, value);
        }
    }
    else {
        // note we are only checking boolean attributes that don't have a
        // corresponding dom prop of the same name here.
        const isBoolean = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSpecialBooleanAttr)(key);
        if (value == null || (isBoolean && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.includeBooleanAttr)(value))) {
            el.removeAttribute(key);
        }
        else {
            el.setAttribute(key, isBoolean ? '' : value);
        }
    }
}

// __UNSAFE__
// functions. The user is responsible for using them with only trusted content.
function patchDOMProp(el, key, value, 
// the following args are passed only due to potential innerHTML/textContent
// overriding existing VNodes, in which case the old tree must be properly
// unmounted.
prevChildren, parentComponent, parentSuspense, unmountChildren) {
    if (key === 'innerHTML' || key === 'textContent') {
        if (prevChildren) {
            unmountChildren(prevChildren, parentComponent, parentSuspense);
        }
        el[key] = value == null ? '' : value;
        return;
    }
    if (key === 'value' &&
        el.tagName !== 'PROGRESS' &&
        // custom elements may use _value internally
        !el.tagName.includes('-')) {
        // store value as _value as well since
        // non-string values will be stringified.
        el._value = value;
        const newValue = value == null ? '' : value;
        if (el.value !== newValue ||
            // #4956: always set for OPTION elements because its value falls back to
            // textContent if no value attribute is present. And setting .value for
            // OPTION has no side effect
            el.tagName === 'OPTION') {
            el.value = newValue;
        }
        if (value == null) {
            el.removeAttribute(key);
        }
        return;
    }
    let needRemove = false;
    if (value === '' || value == null) {
        const type = typeof el[key];
        if (type === 'boolean') {
            // e.g. <select multiple> compiles to { multiple: '' }
            value = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.includeBooleanAttr)(value);
        }
        else if (value == null && type === 'string') {
            // e.g. <div :id="null">
            value = '';
            needRemove = true;
        }
        else if (type === 'number') {
            // e.g. <img :width="null">
            // the value of some IDL attr must be greater than 0, e.g. input.size = 0 -> error
            value = 0;
            needRemove = true;
        }
    }
    // some properties perform value validation and throw,
    // some properties has getter, no setter, will error in 'use strict'
    // eg. <select :type="null"></select> <select :willValidate="null"></select>
    try {
        el[key] = value;
    }
    catch (e) {
        if ((true)) {
            (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Failed setting prop "${key}" on <${el.tagName.toLowerCase()}>: ` +
                `value ${value} is invalid.`, e);
        }
    }
    needRemove && el.removeAttribute(key);
}

// Async edge case fix requires storing an event listener's attach timestamp.
const [_getNow, skipTimestampCheck] = /*#__PURE__*/ (() => {
    let _getNow = Date.now;
    let skipTimestampCheck = false;
    if (typeof window !== 'undefined') {
        // Determine what event timestamp the browser is using. Annoyingly, the
        // timestamp can either be hi-res (relative to page load) or low-res
        // (relative to UNIX epoch), so in order to compare time we have to use the
        // same timestamp type when saving the flush timestamp.
        if (Date.now() > document.createEvent('Event').timeStamp) {
            // if the low-res timestamp which is bigger than the event timestamp
            // (which is evaluated AFTER) it means the event is using a hi-res timestamp,
            // and we need to use the hi-res version for event listeners as well.
            _getNow = performance.now.bind(performance);
        }
        // #3485: Firefox <= 53 has incorrect Event.timeStamp implementation
        // and does not fire microtasks in between event propagation, so safe to exclude.
        const ffMatch = navigator.userAgent.match(/firefox\/(\d+)/i);
        skipTimestampCheck = !!(ffMatch && Number(ffMatch[1]) <= 53);
    }
    return [_getNow, skipTimestampCheck];
})();
// To avoid the overhead of repeatedly calling performance.now(), we cache
// and use the same timestamp for all event listeners attached in the same tick.
let cachedNow = 0;
const p = /*#__PURE__*/ Promise.resolve();
const reset = () => {
    cachedNow = 0;
};
const getNow = () => cachedNow || (p.then(reset), (cachedNow = _getNow()));
function addEventListener(el, event, handler, options) {
    el.addEventListener(event, handler, options);
}
function removeEventListener(el, event, handler, options) {
    el.removeEventListener(event, handler, options);
}
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
    // vei = vue event invokers
    const invokers = el._vei || (el._vei = {});
    const existingInvoker = invokers[rawName];
    if (nextValue && existingInvoker) {
        // patch
        existingInvoker.value = nextValue;
    }
    else {
        const [name, options] = parseName(rawName);
        if (nextValue) {
            // add
            const invoker = (invokers[rawName] = createInvoker(nextValue, instance));
            addEventListener(el, name, invoker, options);
        }
        else if (existingInvoker) {
            // remove
            removeEventListener(el, name, existingInvoker, options);
            invokers[rawName] = undefined;
        }
    }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
    let options;
    if (optionsModifierRE.test(name)) {
        options = {};
        let m;
        while ((m = name.match(optionsModifierRE))) {
            name = name.slice(0, name.length - m[0].length);
            options[m[0].toLowerCase()] = true;
        }
    }
    return [(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(name.slice(2)), options];
}
function createInvoker(initialValue, instance) {
    const invoker = (e) => {
        // async edge case #6566: inner click event triggers patch, event handler
        // attached to outer element during patch, and triggered again. This
        // happens because browsers fire microtask ticks between event propagation.
        // the solution is simple: we save the timestamp when a handler is attached,
        // and the handler would only fire if the event passed to it was fired
        // AFTER it was attached.
        const timeStamp = e.timeStamp || _getNow();
        if (skipTimestampCheck || timeStamp >= invoker.attached - 1) {
            (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.callWithAsyncErrorHandling)(patchStopImmediatePropagation(e, invoker.value), instance, 5 /* NATIVE_EVENT_HANDLER */, [e]);
        }
    };
    invoker.value = initialValue;
    invoker.attached = getNow();
    return invoker;
}
function patchStopImmediatePropagation(e, value) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
        const originalStop = e.stopImmediatePropagation;
        e.stopImmediatePropagation = () => {
            originalStop.call(e);
            e._stopped = true;
        };
        return value.map(fn => (e) => !e._stopped && fn && fn(e));
    }
    else {
        return value;
    }
}

const nativeOnRE = /^on[a-z]/;
const patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
    if (key === 'class') {
        patchClass(el, nextValue, isSVG);
    }
    else if (key === 'style') {
        patchStyle(el, prevValue, nextValue);
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
        // ignore v-model listeners
        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)(key)) {
            patchEvent(el, key, prevValue, nextValue, parentComponent);
        }
    }
    else if (key[0] === '.'
        ? ((key = key.slice(1)), true)
        : key[0] === '^'
            ? ((key = key.slice(1)), false)
            : shouldSetAsProp(el, key, nextValue, isSVG)) {
        patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);
    }
    else {
        // special case for <input v-model type="checkbox"> with
        // :true-value & :false-value
        // store value as dom properties since non-string values will be
        // stringified.
        if (key === 'true-value') {
            el._trueValue = nextValue;
        }
        else if (key === 'false-value') {
            el._falseValue = nextValue;
        }
        patchAttr(el, key, nextValue, isSVG);
    }
};
function shouldSetAsProp(el, key, value, isSVG) {
    if (isSVG) {
        // most keys must be set as attribute on svg elements to work
        // ...except innerHTML & textContent
        if (key === 'innerHTML' || key === 'textContent') {
            return true;
        }
        // or native onclick with function values
        if (key in el && nativeOnRE.test(key) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {
            return true;
        }
        return false;
    }
    // these are enumerated attrs, however their corresponding DOM properties
    // are actually booleans - this leads to setting it with a string "false"
    // value leading it to be coerced to `true`, so we need to always treat
    // them as attributes.
    // Note that `contentEditable` doesn't have this problem: its DOM
    // property is also enumerated string values.
    if (key === 'spellcheck' || key === 'draggable' || key === 'translate') {
        return false;
    }
    // #1787, #2840 form property on form elements is readonly and must be set as
    // attribute.
    if (key === 'form') {
        return false;
    }
    // #1526 <input list> must be set as attribute
    if (key === 'list' && el.tagName === 'INPUT') {
        return false;
    }
    // #2766 <textarea type> must be set as attribute
    if (key === 'type' && el.tagName === 'TEXTAREA') {
        return false;
    }
    // native onclick with string value, must be set as attribute
    if (nativeOnRE.test(key) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(value)) {
        return false;
    }
    return key in el;
}

function defineCustomElement(options, hydrate) {
    const Comp = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineComponent)(options);
    class VueCustomElement extends VueElement {
        constructor(initialProps) {
            super(Comp, initialProps, hydrate);
        }
    }
    VueCustomElement.def = Comp;
    return VueCustomElement;
}
const defineSSRCustomElement = ((options) => {
    // @ts-ignore
    return defineCustomElement(options, hydrate);
});
const BaseClass = (typeof HTMLElement !== 'undefined' ? HTMLElement : class {
});
class VueElement extends BaseClass {
    constructor(_def, _props = {}, hydrate) {
        super();
        this._def = _def;
        this._props = _props;
        /**
         * @internal
         */
        this._instance = null;
        this._connected = false;
        this._resolved = false;
        this._numberProps = null;
        if (this.shadowRoot && hydrate) {
            hydrate(this._createVNode(), this.shadowRoot);
        }
        else {
            if (( true) && this.shadowRoot) {
                (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Custom element has pre-rendered declarative shadow root but is not ` +
                    `defined as hydratable. Use \`defineSSRCustomElement\`.`);
            }
            this.attachShadow({ mode: 'open' });
        }
    }
    connectedCallback() {
        this._connected = true;
        if (!this._instance) {
            this._resolveDef();
        }
    }
    disconnectedCallback() {
        this._connected = false;
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.nextTick)(() => {
            if (!this._connected) {
                render(null, this.shadowRoot);
                this._instance = null;
            }
        });
    }
    /**
     * resolve inner component definition (handle possible async component)
     */
    _resolveDef() {
        if (this._resolved) {
            return;
        }
        this._resolved = true;
        // set initial attrs
        for (let i = 0; i < this.attributes.length; i++) {
            this._setAttr(this.attributes[i].name);
        }
        // watch future attr changes
        new MutationObserver(mutations => {
            for (const m of mutations) {
                this._setAttr(m.attributeName);
            }
        }).observe(this, { attributes: true });
        const resolve = (def) => {
            const { props, styles } = def;
            const hasOptions = !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(props);
            const rawKeys = props ? (hasOptions ? Object.keys(props) : props) : [];
            // cast Number-type props set before resolve
            let numberProps;
            if (hasOptions) {
                for (const key in this._props) {
                    const opt = props[key];
                    if (opt === Number || (opt && opt.type === Number)) {
                        this._props[key] = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(this._props[key]);
                        (numberProps || (numberProps = Object.create(null)))[key] = true;
                    }
                }
            }
            this._numberProps = numberProps;
            // check if there are props set pre-upgrade or connect
            for (const key of Object.keys(this)) {
                if (key[0] !== '_') {
                    this._setProp(key, this[key], true, false);
                }
            }
            // defining getter/setters on prototype
            for (const key of rawKeys.map(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)) {
                Object.defineProperty(this, key, {
                    get() {
                        return this._getProp(key);
                    },
                    set(val) {
                        this._setProp(key, val);
                    }
                });
            }
            // apply CSS
            this._applyStyles(styles);
            // initial render
            this._update();
        };
        const asyncDef = this._def.__asyncLoader;
        if (asyncDef) {
            asyncDef().then(resolve);
        }
        else {
            resolve(this._def);
        }
    }
    _setAttr(key) {
        let value = this.getAttribute(key);
        if (this._numberProps && this._numberProps[key]) {
            value = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(value);
        }
        this._setProp((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key), value, false);
    }
    /**
     * @internal
     */
    _getProp(key) {
        return this._props[key];
    }
    /**
     * @internal
     */
    _setProp(key, val, shouldReflect = true, shouldUpdate = true) {
        if (val !== this._props[key]) {
            this._props[key] = val;
            if (shouldUpdate && this._instance) {
                this._update();
            }
            // reflect
            if (shouldReflect) {
                if (val === true) {
                    this.setAttribute((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key), '');
                }
                else if (typeof val === 'string' || typeof val === 'number') {
                    this.setAttribute((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key), val + '');
                }
                else if (!val) {
                    this.removeAttribute((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key));
                }
            }
        }
    }
    _update() {
        render(this._createVNode(), this.shadowRoot);
    }
    _createVNode() {
        const vnode = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createVNode)(this._def, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, this._props));
        if (!this._instance) {
            vnode.ce = instance => {
                this._instance = instance;
                instance.isCE = true;
                // HMR
                if ((true)) {
                    instance.ceReload = newStyles => {
                        // always reset styles
                        if (this._styles) {
                            this._styles.forEach(s => this.shadowRoot.removeChild(s));
                            this._styles.length = 0;
                        }
                        this._applyStyles(newStyles);
                        // if this is an async component, ceReload is called from the inner
                        // component so no need to reload the async wrapper
                        if (!this._def.__asyncLoader) {
                            // reload
                            this._instance = null;
                            this._update();
                        }
                    };
                }
                // intercept emit
                instance.emit = (event, ...args) => {
                    this.dispatchEvent(new CustomEvent(event, {
                        detail: args
                    }));
                };
                // locate nearest Vue custom element parent for provide/inject
                let parent = this;
                while ((parent =
                    parent && (parent.parentNode || parent.host))) {
                    if (parent instanceof VueElement) {
                        instance.parent = parent._instance;
                        break;
                    }
                }
            };
        }
        return vnode;
    }
    _applyStyles(styles) {
        if (styles) {
            styles.forEach(css => {
                const s = document.createElement('style');
                s.textContent = css;
                this.shadowRoot.appendChild(s);
                // record for HMR
                if ((true)) {
                    (this._styles || (this._styles = [])).push(s);
                }
            });
        }
    }
}

function useCssModule(name = '$style') {
    /* istanbul ignore else */
    {
        const instance = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();
        if (!instance) {
            ( true) && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`useCssModule must be called inside setup()`);
            return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
        }
        const modules = instance.type.__cssModules;
        if (!modules) {
            ( true) && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Current instance does not have CSS modules injected.`);
            return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
        }
        const mod = modules[name];
        if (!mod) {
            ( true) &&
                (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Current instance does not have CSS module named "${name}".`);
            return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
        }
        return mod;
    }
}

/**
 * Runtime helper for SFC's CSS variable injection feature.
 * @private
 */
function useCssVars(getter) {
    const instance = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();
    /* istanbul ignore next */
    if (!instance) {
        ( true) &&
            (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`useCssVars is called without current active component instance.`);
        return;
    }
    const setVars = () => setVarsOnVNode(instance.subTree, getter(instance.proxy));
    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watchPostEffect)(setVars);
    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {
        const ob = new MutationObserver(setVars);
        ob.observe(instance.subTree.el.parentNode, { childList: true });
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUnmounted)(() => ob.disconnect());
    });
}
function setVarsOnVNode(vnode, vars) {
    if (vnode.shapeFlag & 128 /* SUSPENSE */) {
        const suspense = vnode.suspense;
        vnode = suspense.activeBranch;
        if (suspense.pendingBranch && !suspense.isHydrating) {
            suspense.effects.push(() => {
                setVarsOnVNode(suspense.activeBranch, vars);
            });
        }
    }
    // drill down HOCs until it's a non-component vnode
    while (vnode.component) {
        vnode = vnode.component.subTree;
    }
    if (vnode.shapeFlag & 1 /* ELEMENT */ && vnode.el) {
        setVarsOnNode(vnode.el, vars);
    }
    else if (vnode.type === _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Fragment) {
        vnode.children.forEach(c => setVarsOnVNode(c, vars));
    }
    else if (vnode.type === _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Static) {
        let { el, anchor } = vnode;
        while (el) {
            setVarsOnNode(el, vars);
            if (el === anchor)
                break;
            el = el.nextSibling;
        }
    }
}
function setVarsOnNode(el, vars) {
    if (el.nodeType === 1) {
        const style = el.style;
        for (const key in vars) {
            style.setProperty(`--${key}`, vars[key]);
        }
    }
}

const TRANSITION = 'transition';
const ANIMATION = 'animation';
// DOM Transition is a higher-order-component based on the platform-agnostic
// base Transition component, with DOM-specific logic.
const Transition = (props, { slots }) => (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.h)(_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.BaseTransition, resolveTransitionProps(props), slots);
Transition.displayName = 'Transition';
const DOMTransitionPropsValidators = {
    name: String,
    type: String,
    css: {
        type: Boolean,
        default: true
    },
    duration: [String, Number, Object],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
};
const TransitionPropsValidators = (Transition.props =
    /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.BaseTransition.props, DOMTransitionPropsValidators));
/**
 * #3227 Incoming hooks may be merged into arrays when wrapping Transition
 * with custom HOCs.
 */
const callHook = (hook, args = []) => {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook)) {
        hook.forEach(h => h(...args));
    }
    else if (hook) {
        hook(...args);
    }
};
/**
 * Check if a hook expects a callback (2nd arg), which means the user
 * intends to explicitly control the end of the transition.
 */
const hasExplicitCallback = (hook) => {
    return hook
        ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook)
            ? hook.some(h => h.length > 1)
            : hook.length > 1
        : false;
};
function resolveTransitionProps(rawProps) {
    const baseProps = {};
    for (const key in rawProps) {
        if (!(key in DOMTransitionPropsValidators)) {
            baseProps[key] = rawProps[key];
        }
    }
    if (rawProps.css === false) {
        return baseProps;
    }
    const { name = 'v', type, duration, enterFromClass = `${name}-enter-from`, enterActiveClass = `${name}-enter-active`, enterToClass = `${name}-enter-to`, appearFromClass = enterFromClass, appearActiveClass = enterActiveClass, appearToClass = enterToClass, leaveFromClass = `${name}-leave-from`, leaveActiveClass = `${name}-leave-active`, leaveToClass = `${name}-leave-to` } = rawProps;
    const durations = normalizeDuration(duration);
    const enterDuration = durations && durations[0];
    const leaveDuration = durations && durations[1];
    const { onBeforeEnter, onEnter, onEnterCancelled, onLeave, onLeaveCancelled, onBeforeAppear = onBeforeEnter, onAppear = onEnter, onAppearCancelled = onEnterCancelled } = baseProps;
    const finishEnter = (el, isAppear, done) => {
        removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
        removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
        done && done();
    };
    const finishLeave = (el, done) => {
        el._isLeaving = false;
        removeTransitionClass(el, leaveFromClass);
        removeTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveActiveClass);
        done && done();
    };
    const makeEnterHook = (isAppear) => {
        return (el, done) => {
            const hook = isAppear ? onAppear : onEnter;
            const resolve = () => finishEnter(el, isAppear, done);
            callHook(hook, [el, resolve]);
            nextFrame(() => {
                removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
                addTransitionClass(el, isAppear ? appearToClass : enterToClass);
                if (!hasExplicitCallback(hook)) {
                    whenTransitionEnds(el, type, enterDuration, resolve);
                }
            });
        };
    };
    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(baseProps, {
        onBeforeEnter(el) {
            callHook(onBeforeEnter, [el]);
            addTransitionClass(el, enterFromClass);
            addTransitionClass(el, enterActiveClass);
        },
        onBeforeAppear(el) {
            callHook(onBeforeAppear, [el]);
            addTransitionClass(el, appearFromClass);
            addTransitionClass(el, appearActiveClass);
        },
        onEnter: makeEnterHook(false),
        onAppear: makeEnterHook(true),
        onLeave(el, done) {
            el._isLeaving = true;
            const resolve = () => finishLeave(el, done);
            addTransitionClass(el, leaveFromClass);
            // force reflow so *-leave-from classes immediately take effect (#2593)
            forceReflow();
            addTransitionClass(el, leaveActiveClass);
            nextFrame(() => {
                if (!el._isLeaving) {
                    // cancelled
                    return;
                }
                removeTransitionClass(el, leaveFromClass);
                addTransitionClass(el, leaveToClass);
                if (!hasExplicitCallback(onLeave)) {
                    whenTransitionEnds(el, type, leaveDuration, resolve);
                }
            });
            callHook(onLeave, [el, resolve]);
        },
        onEnterCancelled(el) {
            finishEnter(el, false);
            callHook(onEnterCancelled, [el]);
        },
        onAppearCancelled(el) {
            finishEnter(el, true);
            callHook(onAppearCancelled, [el]);
        },
        onLeaveCancelled(el) {
            finishLeave(el);
            callHook(onLeaveCancelled, [el]);
        }
    });
}
function normalizeDuration(duration) {
    if (duration == null) {
        return null;
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(duration)) {
        return [NumberOf(duration.enter), NumberOf(duration.leave)];
    }
    else {
        const n = NumberOf(duration);
        return [n, n];
    }
}
function NumberOf(val) {
    const res = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(val);
    if ((true))
        validateDuration(res);
    return res;
}
function validateDuration(val) {
    if (typeof val !== 'number') {
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`<transition> explicit duration is not a valid number - ` +
            `got ${JSON.stringify(val)}.`);
    }
    else if (isNaN(val)) {
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`<transition> explicit duration is NaN - ` +
            'the duration expression might be incorrect.');
    }
}
function addTransitionClass(el, cls) {
    cls.split(/\s+/).forEach(c => c && el.classList.add(c));
    (el._vtc ||
        (el._vtc = new Set())).add(cls);
}
function removeTransitionClass(el, cls) {
    cls.split(/\s+/).forEach(c => c && el.classList.remove(c));
    const { _vtc } = el;
    if (_vtc) {
        _vtc.delete(cls);
        if (!_vtc.size) {
            el._vtc = undefined;
        }
    }
}
function nextFrame(cb) {
    requestAnimationFrame(() => {
        requestAnimationFrame(cb);
    });
}
let endId = 0;
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {
    const id = (el._endId = ++endId);
    const resolveIfNotStale = () => {
        if (id === el._endId) {
            resolve();
        }
    };
    if (explicitTimeout) {
        return setTimeout(resolveIfNotStale, explicitTimeout);
    }
    const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
    if (!type) {
        return resolve();
    }
    const endEvent = type + 'end';
    let ended = 0;
    const end = () => {
        el.removeEventListener(endEvent, onEnd);
        resolveIfNotStale();
    };
    const onEnd = (e) => {
        if (e.target === el && ++ended >= propCount) {
            end();
        }
    };
    setTimeout(() => {
        if (ended < propCount) {
            end();
        }
    }, timeout + 1);
    el.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el, expectedType) {
    const styles = window.getComputedStyle(el);
    // JSDOM may return undefined for transition properties
    const getStyleProperties = (key) => (styles[key] || '').split(', ');
    const transitionDelays = getStyleProperties(TRANSITION + 'Delay');
    const transitionDurations = getStyleProperties(TRANSITION + 'Duration');
    const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
    const animationDelays = getStyleProperties(ANIMATION + 'Delay');
    const animationDurations = getStyleProperties(ANIMATION + 'Duration');
    const animationTimeout = getTimeout(animationDelays, animationDurations);
    let type = null;
    let timeout = 0;
    let propCount = 0;
    /* istanbul ignore if */
    if (expectedType === TRANSITION) {
        if (transitionTimeout > 0) {
            type = TRANSITION;
            timeout = transitionTimeout;
            propCount = transitionDurations.length;
        }
    }
    else if (expectedType === ANIMATION) {
        if (animationTimeout > 0) {
            type = ANIMATION;
            timeout = animationTimeout;
            propCount = animationDurations.length;
        }
    }
    else {
        timeout = Math.max(transitionTimeout, animationTimeout);
        type =
            timeout > 0
                ? transitionTimeout > animationTimeout
                    ? TRANSITION
                    : ANIMATION
                : null;
        propCount = type
            ? type === TRANSITION
                ? transitionDurations.length
                : animationDurations.length
            : 0;
    }
    const hasTransform = type === TRANSITION &&
        /\b(transform|all)(,|$)/.test(styles[TRANSITION + 'Property']);
    return {
        type,
        timeout,
        propCount,
        hasTransform
    };
}
function getTimeout(delays, durations) {
    while (delays.length < durations.length) {
        delays = delays.concat(delays);
    }
    return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
}
// Old versions of Chromium (below 61.0.3163.100) formats floating pointer
// numbers in a locale-dependent way, using a comma instead of a dot.
// If comma is not replaced with a dot, the input will be rounded down
// (i.e. acting as a floor function) causing unexpected behaviors
function toMs(s) {
    return Number(s.slice(0, -1).replace(',', '.')) * 1000;
}
// synchronously force layout to put elements into a certain state
function forceReflow() {
    return document.body.offsetHeight;
}

const positionMap = new WeakMap();
const newPositionMap = new WeakMap();
const TransitionGroupImpl = {
    name: 'TransitionGroup',
    props: /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, TransitionPropsValidators, {
        tag: String,
        moveClass: String
    }),
    setup(props, { slots }) {
        const instance = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();
        const state = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useTransitionState)();
        let prevChildren;
        let children;
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUpdated)(() => {
            // children is guaranteed to exist after initial render
            if (!prevChildren.length) {
                return;
            }
            const moveClass = props.moveClass || `${props.name || 'v'}-move`;
            if (!hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass)) {
                return;
            }
            // we divide the work into three loops to avoid mixing DOM reads and writes
            // in each iteration - which helps prevent layout thrashing.
            prevChildren.forEach(callPendingCbs);
            prevChildren.forEach(recordPosition);
            const movedChildren = prevChildren.filter(applyTranslation);
            // force reflow to put everything in position
            forceReflow();
            movedChildren.forEach(c => {
                const el = c.el;
                const style = el.style;
                addTransitionClass(el, moveClass);
                style.transform = style.webkitTransform = style.transitionDuration = '';
                const cb = (el._moveCb = (e) => {
                    if (e && e.target !== el) {
                        return;
                    }
                    if (!e || /transform$/.test(e.propertyName)) {
                        el.removeEventListener('transitionend', cb);
                        el._moveCb = null;
                        removeTransitionClass(el, moveClass);
                    }
                });
                el.addEventListener('transitionend', cb);
            });
        });
        return () => {
            const rawProps = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.toRaw)(props);
            const cssTransitionProps = resolveTransitionProps(rawProps);
            let tag = rawProps.tag || _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Fragment;
            prevChildren = children;
            children = slots.default ? (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getTransitionRawChildren)(slots.default()) : [];
            for (let i = 0; i < children.length; i++) {
                const child = children[i];
                if (child.key != null) {
                    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks)(child, (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks)(child, cssTransitionProps, state, instance));
                }
                else if ((true)) {
                    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`<TransitionGroup> children must be keyed.`);
                }
            }
            if (prevChildren) {
                for (let i = 0; i < prevChildren.length; i++) {
                    const child = prevChildren[i];
                    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks)(child, (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks)(child, cssTransitionProps, state, instance));
                    positionMap.set(child, child.el.getBoundingClientRect());
                }
            }
            return (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createVNode)(tag, null, children);
        };
    }
};
const TransitionGroup = TransitionGroupImpl;
function callPendingCbs(c) {
    const el = c.el;
    if (el._moveCb) {
        el._moveCb();
    }
    if (el._enterCb) {
        el._enterCb();
    }
}
function recordPosition(c) {
    newPositionMap.set(c, c.el.getBoundingClientRect());
}
function applyTranslation(c) {
    const oldPos = positionMap.get(c);
    const newPos = newPositionMap.get(c);
    const dx = oldPos.left - newPos.left;
    const dy = oldPos.top - newPos.top;
    if (dx || dy) {
        const s = c.el.style;
        s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
        s.transitionDuration = '0s';
        return c;
    }
}
function hasCSSTransform(el, root, moveClass) {
    // Detect whether an element with the move class applied has
    // CSS transitions. Since the element may be inside an entering
    // transition at this very moment, we make a clone of it and remove
    // all other transition classes applied to ensure only the move class
    // is applied.
    const clone = el.cloneNode();
    if (el._vtc) {
        el._vtc.forEach(cls => {
            cls.split(/\s+/).forEach(c => c && clone.classList.remove(c));
        });
    }
    moveClass.split(/\s+/).forEach(c => c && clone.classList.add(c));
    clone.style.display = 'none';
    const container = (root.nodeType === 1 ? root : root.parentNode);
    container.appendChild(clone);
    const { hasTransform } = getTransitionInfo(clone);
    container.removeChild(clone);
    return hasTransform;
}

const getModelAssigner = (vnode) => {
    const fn = vnode.props['onUpdate:modelValue'] ||
        (false );
    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(fn) ? value => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(fn, value) : fn;
};
function onCompositionStart(e) {
    e.target.composing = true;
}
function onCompositionEnd(e) {
    const target = e.target;
    if (target.composing) {
        target.composing = false;
        target.dispatchEvent(new Event('input'));
    }
}
// We are exporting the v-model runtime directly as vnode hooks so that it can
// be tree-shaken in case v-model is never used.
const vModelText = {
    created(el, { modifiers: { lazy, trim, number } }, vnode) {
        el._assign = getModelAssigner(vnode);
        const castToNumber = number || (vnode.props && vnode.props.type === 'number');
        addEventListener(el, lazy ? 'change' : 'input', e => {
            if (e.target.composing)
                return;
            let domValue = el.value;
            if (trim) {
                domValue = domValue.trim();
            }
            if (castToNumber) {
                domValue = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(domValue);
            }
            el._assign(domValue);
        });
        if (trim) {
            addEventListener(el, 'change', () => {
                el.value = el.value.trim();
            });
        }
        if (!lazy) {
            addEventListener(el, 'compositionstart', onCompositionStart);
            addEventListener(el, 'compositionend', onCompositionEnd);
            // Safari < 10.2 & UIWebView doesn't fire compositionend when
            // switching focus before confirming composition choice
            // this also fixes the issue where some browsers e.g. iOS Chrome
            // fires "change" instead of "input" on autocomplete.
            addEventListener(el, 'change', onCompositionEnd);
        }
    },
    // set value on mounted so it's after min/max for type="range"
    mounted(el, { value }) {
        el.value = value == null ? '' : value;
    },
    beforeUpdate(el, { value, modifiers: { lazy, trim, number } }, vnode) {
        el._assign = getModelAssigner(vnode);
        // avoid clearing unresolved text. #2302
        if (el.composing)
            return;
        if (document.activeElement === el && el.type !== 'range') {
            if (lazy) {
                return;
            }
            if (trim && el.value.trim() === value) {
                return;
            }
            if ((number || el.type === 'number') && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(el.value) === value) {
                return;
            }
        }
        const newValue = value == null ? '' : value;
        if (el.value !== newValue) {
            el.value = newValue;
        }
    }
};
const vModelCheckbox = {
    // #4096 array checkboxes need to be deep traversed
    deep: true,
    created(el, _, vnode) {
        el._assign = getModelAssigner(vnode);
        addEventListener(el, 'change', () => {
            const modelValue = el._modelValue;
            const elementValue = getValue(el);
            const checked = el.checked;
            const assign = el._assign;
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(modelValue)) {
                const index = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseIndexOf)(modelValue, elementValue);
                const found = index !== -1;
                if (checked && !found) {
                    assign(modelValue.concat(elementValue));
                }
                else if (!checked && found) {
                    const filtered = [...modelValue];
                    filtered.splice(index, 1);
                    assign(filtered);
                }
            }
            else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(modelValue)) {
                const cloned = new Set(modelValue);
                if (checked) {
                    cloned.add(elementValue);
                }
                else {
                    cloned.delete(elementValue);
                }
                assign(cloned);
            }
            else {
                assign(getCheckboxValue(el, checked));
            }
        });
    },
    // set initial checked on mount to wait for true-value/false-value
    mounted: setChecked,
    beforeUpdate(el, binding, vnode) {
        el._assign = getModelAssigner(vnode);
        setChecked(el, binding, vnode);
    }
};
function setChecked(el, { value, oldValue }, vnode) {
    el._modelValue = value;
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
        el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseIndexOf)(value, vnode.props.value) > -1;
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value)) {
        el.checked = value.has(vnode.props.value);
    }
    else if (value !== oldValue) {
        el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(value, getCheckboxValue(el, true));
    }
}
const vModelRadio = {
    created(el, { value }, vnode) {
        el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(value, vnode.props.value);
        el._assign = getModelAssigner(vnode);
        addEventListener(el, 'change', () => {
            el._assign(getValue(el));
        });
    },
    beforeUpdate(el, { value, oldValue }, vnode) {
        el._assign = getModelAssigner(vnode);
        if (value !== oldValue) {
            el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(value, vnode.props.value);
        }
    }
};
const vModelSelect = {
    // <select multiple> value need to be deep traversed
    deep: true,
    created(el, { value, modifiers: { number } }, vnode) {
        const isSetModel = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value);
        addEventListener(el, 'change', () => {
            const selectedVal = Array.prototype.filter
                .call(el.options, (o) => o.selected)
                .map((o) => number ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(getValue(o)) : getValue(o));
            el._assign(el.multiple
                ? isSetModel
                    ? new Set(selectedVal)
                    : selectedVal
                : selectedVal[0]);
        });
        el._assign = getModelAssigner(vnode);
    },
    // set value in mounted & updated because <select> relies on its children
    // <option>s.
    mounted(el, { value }) {
        setSelected(el, value);
    },
    beforeUpdate(el, _binding, vnode) {
        el._assign = getModelAssigner(vnode);
    },
    updated(el, { value }) {
        setSelected(el, value);
    }
};
function setSelected(el, value) {
    const isMultiple = el.multiple;
    if (isMultiple && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value)) {
        ( true) &&
            (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`<select multiple v-model> expects an Array or Set value for its binding, ` +
                `but got ${Object.prototype.toString.call(value).slice(8, -1)}.`);
        return;
    }
    for (let i = 0, l = el.options.length; i < l; i++) {
        const option = el.options[i];
        const optionValue = getValue(option);
        if (isMultiple) {
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
                option.selected = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseIndexOf)(value, optionValue) > -1;
            }
            else {
                option.selected = value.has(optionValue);
            }
        }
        else {
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(getValue(option), value)) {
                if (el.selectedIndex !== i)
                    el.selectedIndex = i;
                return;
            }
        }
    }
    if (!isMultiple && el.selectedIndex !== -1) {
        el.selectedIndex = -1;
    }
}
// retrieve raw value set via :value bindings
function getValue(el) {
    return '_value' in el ? el._value : el.value;
}
// retrieve raw value for true-value and false-value set via :true-value or :false-value bindings
function getCheckboxValue(el, checked) {
    const key = checked ? '_trueValue' : '_falseValue';
    return key in el ? el[key] : checked;
}
const vModelDynamic = {
    created(el, binding, vnode) {
        callModelHook(el, binding, vnode, null, 'created');
    },
    mounted(el, binding, vnode) {
        callModelHook(el, binding, vnode, null, 'mounted');
    },
    beforeUpdate(el, binding, vnode, prevVNode) {
        callModelHook(el, binding, vnode, prevVNode, 'beforeUpdate');
    },
    updated(el, binding, vnode, prevVNode) {
        callModelHook(el, binding, vnode, prevVNode, 'updated');
    }
};
function resolveDynamicModel(tagName, type) {
    switch (tagName) {
        case 'SELECT':
            return vModelSelect;
        case 'TEXTAREA':
            return vModelText;
        default:
            switch (type) {
                case 'checkbox':
                    return vModelCheckbox;
                case 'radio':
                    return vModelRadio;
                default:
                    return vModelText;
            }
    }
}
function callModelHook(el, binding, vnode, prevVNode, hook) {
    const modelToUse = resolveDynamicModel(el.tagName, vnode.props && vnode.props.type);
    const fn = modelToUse[hook];
    fn && fn(el, binding, vnode, prevVNode);
}
// SSR vnode transforms, only used when user includes client-oriented render
// function in SSR
function initVModelForSSR() {
    vModelText.getSSRProps = ({ value }) => ({ value });
    vModelRadio.getSSRProps = ({ value }, vnode) => {
        if (vnode.props && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(vnode.props.value, value)) {
            return { checked: true };
        }
    };
    vModelCheckbox.getSSRProps = ({ value }, vnode) => {
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
            if (vnode.props && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseIndexOf)(value, vnode.props.value) > -1) {
                return { checked: true };
            }
        }
        else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value)) {
            if (vnode.props && value.has(vnode.props.value)) {
                return { checked: true };
            }
        }
        else if (value) {
            return { checked: true };
        }
    };
    vModelDynamic.getSSRProps = (binding, vnode) => {
        if (typeof vnode.type !== 'string') {
            return;
        }
        const modelToUse = resolveDynamicModel(
        // resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase
        vnode.type.toUpperCase(), vnode.props && vnode.props.type);
        if (modelToUse.getSSRProps) {
            return modelToUse.getSSRProps(binding, vnode);
        }
    };
}

const systemModifiers = ['ctrl', 'shift', 'alt', 'meta'];
const modifierGuards = {
    stop: e => e.stopPropagation(),
    prevent: e => e.preventDefault(),
    self: e => e.target !== e.currentTarget,
    ctrl: e => !e.ctrlKey,
    shift: e => !e.shiftKey,
    alt: e => !e.altKey,
    meta: e => !e.metaKey,
    left: e => 'button' in e && e.button !== 0,
    middle: e => 'button' in e && e.button !== 1,
    right: e => 'button' in e && e.button !== 2,
    exact: (e, modifiers) => systemModifiers.some(m => e[`${m}Key`] && !modifiers.includes(m))
};
/**
 * @private
 */
const withModifiers = (fn, modifiers) => {
    return (event, ...args) => {
        for (let i = 0; i < modifiers.length; i++) {
            const guard = modifierGuards[modifiers[i]];
            if (guard && guard(event, modifiers))
                return;
        }
        return fn(event, ...args);
    };
};
// Kept for 2.x compat.
// Note: IE11 compat for `spacebar` and `del` is removed for now.
const keyNames = {
    esc: 'escape',
    space: ' ',
    up: 'arrow-up',
    left: 'arrow-left',
    right: 'arrow-right',
    down: 'arrow-down',
    delete: 'backspace'
};
/**
 * @private
 */
const withKeys = (fn, modifiers) => {
    return (event) => {
        if (!('key' in event)) {
            return;
        }
        const eventKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(event.key);
        if (modifiers.some(k => k === eventKey || keyNames[k] === eventKey)) {
            return fn(event);
        }
    };
};

const vShow = {
    beforeMount(el, { value }, { transition }) {
        el._vod = el.style.display === 'none' ? '' : el.style.display;
        if (transition && value) {
            transition.beforeEnter(el);
        }
        else {
            setDisplay(el, value);
        }
    },
    mounted(el, { value }, { transition }) {
        if (transition && value) {
            transition.enter(el);
        }
    },
    updated(el, { value, oldValue }, { transition }) {
        if (!value === !oldValue)
            return;
        if (transition) {
            if (value) {
                transition.beforeEnter(el);
                setDisplay(el, true);
                transition.enter(el);
            }
            else {
                transition.leave(el, () => {
                    setDisplay(el, false);
                });
            }
        }
        else {
            setDisplay(el, value);
        }
    },
    beforeUnmount(el, { value }) {
        setDisplay(el, value);
    }
};
function setDisplay(el, value) {
    el.style.display = value ? el._vod : 'none';
}
// SSR vnode transforms, only used when user includes client-oriented render
// function in SSR
function initVShowForSSR() {
    vShow.getSSRProps = ({ value }) => {
        if (!value) {
            return { style: { display: 'none' } };
        }
    };
}

const rendererOptions = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({ patchProp }, nodeOps);
// lazy create the renderer - this makes core renderer logic tree-shakable
// in case the user only imports reactivity utilities from Vue.
let renderer;
let enabledHydration = false;
function ensureRenderer() {
    return (renderer ||
        (renderer = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createRenderer)(rendererOptions)));
}
function ensureHydrationRenderer() {
    renderer = enabledHydration
        ? renderer
        : (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createHydrationRenderer)(rendererOptions);
    enabledHydration = true;
    return renderer;
}
// use explicit type casts here to avoid import() calls in rolled-up d.ts
const render = ((...args) => {
    ensureRenderer().render(...args);
});
const hydrate = ((...args) => {
    ensureHydrationRenderer().hydrate(...args);
});
const createApp = ((...args) => {
    const app = ensureRenderer().createApp(...args);
    if ((true)) {
        injectNativeTagCheck(app);
        injectCompilerOptionsCheck(app);
    }
    const { mount } = app;
    app.mount = (containerOrSelector) => {
        const container = normalizeContainer(containerOrSelector);
        if (!container)
            return;
        const component = app._component;
        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(component) && !component.render && !component.template) {
            // __UNSAFE__
            // Reason: potential execution of JS expressions in in-DOM template.
            // The user must make sure the in-DOM template is trusted. If it's
            // rendered by the server, the template should not contain any user data.
            component.template = container.innerHTML;
        }
        // clear content before mounting
        container.innerHTML = '';
        const proxy = mount(container, false, container instanceof SVGElement);
        if (container instanceof Element) {
            container.removeAttribute('v-cloak');
            container.setAttribute('data-v-app', '');
        }
        return proxy;
    };
    return app;
});
const createSSRApp = ((...args) => {
    const app = ensureHydrationRenderer().createApp(...args);
    if ((true)) {
        injectNativeTagCheck(app);
        injectCompilerOptionsCheck(app);
    }
    const { mount } = app;
    app.mount = (containerOrSelector) => {
        const container = normalizeContainer(containerOrSelector);
        if (container) {
            return mount(container, true, container instanceof SVGElement);
        }
    };
    return app;
});
function injectNativeTagCheck(app) {
    // Inject `isNativeTag`
    // this is used for component name validation (dev only)
    Object.defineProperty(app.config, 'isNativeTag', {
        value: (tag) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isHTMLTag)(tag) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSVGTag)(tag),
        writable: false
    });
}
// dev only
function injectCompilerOptionsCheck(app) {
    if ((0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isRuntimeOnly)()) {
        const isCustomElement = app.config.isCustomElement;
        Object.defineProperty(app.config, 'isCustomElement', {
            get() {
                return isCustomElement;
            },
            set() {
                (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`The \`isCustomElement\` config option is deprecated. Use ` +
                    `\`compilerOptions.isCustomElement\` instead.`);
            }
        });
        const compilerOptions = app.config.compilerOptions;
        const msg = `The \`compilerOptions\` config option is only respected when using ` +
            `a build of Vue.js that includes the runtime compiler (aka "full build"). ` +
            `Since you are using the runtime-only build, \`compilerOptions\` ` +
            `must be passed to \`@vue/compiler-dom\` in the build setup instead.\n` +
            `- For vue-loader: pass it via vue-loader's \`compilerOptions\` loader option.\n` +
            `- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n` +
            `- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-dom`;
        Object.defineProperty(app.config, 'compilerOptions', {
            get() {
                (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(msg);
                return compilerOptions;
            },
            set() {
                (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(msg);
            }
        });
    }
}
function normalizeContainer(container) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(container)) {
        const res = document.querySelector(container);
        if (( true) && !res) {
            (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Failed to mount app: mount target selector "${container}" returned null.`);
        }
        return res;
    }
    if (( true) &&
        window.ShadowRoot &&
        container instanceof window.ShadowRoot &&
        container.mode === 'closed') {
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`mounting on a ShadowRoot with \`{mode: "closed"}\` may lead to unpredictable bugs`);
    }
    return container;
}
let ssrDirectiveInitialized = false;
/**
 * @internal
 */
const initDirectivesForSSR = () => {
        if (!ssrDirectiveInitialized) {
            ssrDirectiveInitialized = true;
            initVModelForSSR();
            initVShowForSSR();
        }
    }
    ;




/***/ }),

/***/ "./node_modules/@vue/shared/dist/shared.esm-bundler.js":
/*!*************************************************************!*\
  !*** ./node_modules/@vue/shared/dist/shared.esm-bundler.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EMPTY_ARR": function() { return /* binding */ EMPTY_ARR; },
/* harmony export */   "EMPTY_OBJ": function() { return /* binding */ EMPTY_OBJ; },
/* harmony export */   "NO": function() { return /* binding */ NO; },
/* harmony export */   "NOOP": function() { return /* binding */ NOOP; },
/* harmony export */   "PatchFlagNames": function() { return /* binding */ PatchFlagNames; },
/* harmony export */   "camelize": function() { return /* binding */ camelize; },
/* harmony export */   "capitalize": function() { return /* binding */ capitalize; },
/* harmony export */   "def": function() { return /* binding */ def; },
/* harmony export */   "escapeHtml": function() { return /* binding */ escapeHtml; },
/* harmony export */   "escapeHtmlComment": function() { return /* binding */ escapeHtmlComment; },
/* harmony export */   "extend": function() { return /* binding */ extend; },
/* harmony export */   "genPropsAccessExp": function() { return /* binding */ genPropsAccessExp; },
/* harmony export */   "generateCodeFrame": function() { return /* binding */ generateCodeFrame; },
/* harmony export */   "getGlobalThis": function() { return /* binding */ getGlobalThis; },
/* harmony export */   "hasChanged": function() { return /* binding */ hasChanged; },
/* harmony export */   "hasOwn": function() { return /* binding */ hasOwn; },
/* harmony export */   "hyphenate": function() { return /* binding */ hyphenate; },
/* harmony export */   "includeBooleanAttr": function() { return /* binding */ includeBooleanAttr; },
/* harmony export */   "invokeArrayFns": function() { return /* binding */ invokeArrayFns; },
/* harmony export */   "isArray": function() { return /* binding */ isArray; },
/* harmony export */   "isBooleanAttr": function() { return /* binding */ isBooleanAttr; },
/* harmony export */   "isBuiltInDirective": function() { return /* binding */ isBuiltInDirective; },
/* harmony export */   "isDate": function() { return /* binding */ isDate; },
/* harmony export */   "isFunction": function() { return /* binding */ isFunction; },
/* harmony export */   "isGloballyWhitelisted": function() { return /* binding */ isGloballyWhitelisted; },
/* harmony export */   "isHTMLTag": function() { return /* binding */ isHTMLTag; },
/* harmony export */   "isIntegerKey": function() { return /* binding */ isIntegerKey; },
/* harmony export */   "isKnownHtmlAttr": function() { return /* binding */ isKnownHtmlAttr; },
/* harmony export */   "isKnownSvgAttr": function() { return /* binding */ isKnownSvgAttr; },
/* harmony export */   "isMap": function() { return /* binding */ isMap; },
/* harmony export */   "isModelListener": function() { return /* binding */ isModelListener; },
/* harmony export */   "isNoUnitNumericStyleProp": function() { return /* binding */ isNoUnitNumericStyleProp; },
/* harmony export */   "isObject": function() { return /* binding */ isObject; },
/* harmony export */   "isOn": function() { return /* binding */ isOn; },
/* harmony export */   "isPlainObject": function() { return /* binding */ isPlainObject; },
/* harmony export */   "isPromise": function() { return /* binding */ isPromise; },
/* harmony export */   "isReservedProp": function() { return /* binding */ isReservedProp; },
/* harmony export */   "isSSRSafeAttrName": function() { return /* binding */ isSSRSafeAttrName; },
/* harmony export */   "isSVGTag": function() { return /* binding */ isSVGTag; },
/* harmony export */   "isSet": function() { return /* binding */ isSet; },
/* harmony export */   "isSpecialBooleanAttr": function() { return /* binding */ isSpecialBooleanAttr; },
/* harmony export */   "isString": function() { return /* binding */ isString; },
/* harmony export */   "isSymbol": function() { return /* binding */ isSymbol; },
/* harmony export */   "isVoidTag": function() { return /* binding */ isVoidTag; },
/* harmony export */   "looseEqual": function() { return /* binding */ looseEqual; },
/* harmony export */   "looseIndexOf": function() { return /* binding */ looseIndexOf; },
/* harmony export */   "makeMap": function() { return /* binding */ makeMap; },
/* harmony export */   "normalizeClass": function() { return /* binding */ normalizeClass; },
/* harmony export */   "normalizeProps": function() { return /* binding */ normalizeProps; },
/* harmony export */   "normalizeStyle": function() { return /* binding */ normalizeStyle; },
/* harmony export */   "objectToString": function() { return /* binding */ objectToString; },
/* harmony export */   "parseStringStyle": function() { return /* binding */ parseStringStyle; },
/* harmony export */   "propsToAttrMap": function() { return /* binding */ propsToAttrMap; },
/* harmony export */   "remove": function() { return /* binding */ remove; },
/* harmony export */   "slotFlagsText": function() { return /* binding */ slotFlagsText; },
/* harmony export */   "stringifyStyle": function() { return /* binding */ stringifyStyle; },
/* harmony export */   "toDisplayString": function() { return /* binding */ toDisplayString; },
/* harmony export */   "toHandlerKey": function() { return /* binding */ toHandlerKey; },
/* harmony export */   "toNumber": function() { return /* binding */ toNumber; },
/* harmony export */   "toRawType": function() { return /* binding */ toRawType; },
/* harmony export */   "toTypeString": function() { return /* binding */ toTypeString; }
/* harmony export */ });
/**
 * Make a map and return a function for checking if a key
 * is in that map.
 * IMPORTANT: all calls of this function must be prefixed with
 * \/\*#\_\_PURE\_\_\*\/
 * So that rollup can tree-shake them if necessary.
 */
function makeMap(str, expectsLowerCase) {
    const map = Object.create(null);
    const list = str.split(',');
    for (let i = 0; i < list.length; i++) {
        map[list[i]] = true;
    }
    return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];
}

/**
 * dev only flag -> name mapping
 */
const PatchFlagNames = {
    [1 /* TEXT */]: `TEXT`,
    [2 /* CLASS */]: `CLASS`,
    [4 /* STYLE */]: `STYLE`,
    [8 /* PROPS */]: `PROPS`,
    [16 /* FULL_PROPS */]: `FULL_PROPS`,
    [32 /* HYDRATE_EVENTS */]: `HYDRATE_EVENTS`,
    [64 /* STABLE_FRAGMENT */]: `STABLE_FRAGMENT`,
    [128 /* KEYED_FRAGMENT */]: `KEYED_FRAGMENT`,
    [256 /* UNKEYED_FRAGMENT */]: `UNKEYED_FRAGMENT`,
    [512 /* NEED_PATCH */]: `NEED_PATCH`,
    [1024 /* DYNAMIC_SLOTS */]: `DYNAMIC_SLOTS`,
    [2048 /* DEV_ROOT_FRAGMENT */]: `DEV_ROOT_FRAGMENT`,
    [-1 /* HOISTED */]: `HOISTED`,
    [-2 /* BAIL */]: `BAIL`
};

/**
 * Dev only
 */
const slotFlagsText = {
    [1 /* STABLE */]: 'STABLE',
    [2 /* DYNAMIC */]: 'DYNAMIC',
    [3 /* FORWARDED */]: 'FORWARDED'
};

const GLOBALS_WHITE_LISTED = 'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +
    'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +
    'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt';
const isGloballyWhitelisted = /*#__PURE__*/ makeMap(GLOBALS_WHITE_LISTED);

const range = 2;
function generateCodeFrame(source, start = 0, end = source.length) {
    // Split the content into individual lines but capture the newline sequence
    // that separated each line. This is important because the actual sequence is
    // needed to properly take into account the full line length for offset
    // comparison
    let lines = source.split(/(\r?\n)/);
    // Separate the lines and newline sequences into separate arrays for easier referencing
    const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);
    lines = lines.filter((_, idx) => idx % 2 === 0);
    let count = 0;
    const res = [];
    for (let i = 0; i < lines.length; i++) {
        count +=
            lines[i].length +
                ((newlineSequences[i] && newlineSequences[i].length) || 0);
        if (count >= start) {
            for (let j = i - range; j <= i + range || end > count; j++) {
                if (j < 0 || j >= lines.length)
                    continue;
                const line = j + 1;
                res.push(`${line}${' '.repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);
                const lineLength = lines[j].length;
                const newLineSeqLength = (newlineSequences[j] && newlineSequences[j].length) || 0;
                if (j === i) {
                    // push underline
                    const pad = start - (count - (lineLength + newLineSeqLength));
                    const length = Math.max(1, end > count ? lineLength - pad : end - start);
                    res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length));
                }
                else if (j > i) {
                    if (end > count) {
                        const length = Math.max(Math.min(end - count, lineLength), 1);
                        res.push(`   |  ` + '^'.repeat(length));
                    }
                    count += lineLength + newLineSeqLength;
                }
            }
            break;
        }
    }
    return res.join('\n');
}

/**
 * On the client we only need to offer special cases for boolean attributes that
 * have different names from their corresponding dom properties:
 * - itemscope -> N/A
 * - allowfullscreen -> allowFullscreen
 * - formnovalidate -> formNoValidate
 * - ismap -> isMap
 * - nomodule -> noModule
 * - novalidate -> noValidate
 * - readonly -> readOnly
 */
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs);
/**
 * The full list is needed during SSR to produce the correct initial markup.
 */
const isBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs +
    `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,` +
    `loop,open,required,reversed,scoped,seamless,` +
    `checked,muted,multiple,selected`);
/**
 * Boolean attributes should be included if the value is truthy or ''.
 * e.g. `<select multiple>` compiles to `{ multiple: '' }`
 */
function includeBooleanAttr(value) {
    return !!value || value === '';
}
const unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
const attrValidationCache = {};
function isSSRSafeAttrName(name) {
    if (attrValidationCache.hasOwnProperty(name)) {
        return attrValidationCache[name];
    }
    const isUnsafe = unsafeAttrCharRE.test(name);
    if (isUnsafe) {
        console.error(`unsafe attribute name: ${name}`);
    }
    return (attrValidationCache[name] = !isUnsafe);
}
const propsToAttrMap = {
    acceptCharset: 'accept-charset',
    className: 'class',
    htmlFor: 'for',
    httpEquiv: 'http-equiv'
};
/**
 * CSS properties that accept plain numbers
 */
const isNoUnitNumericStyleProp = /*#__PURE__*/ makeMap(`animation-iteration-count,border-image-outset,border-image-slice,` +
    `border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,` +
    `columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,` +
    `grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,` +
    `grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,` +
    `line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,` +
    // SVG
    `fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,` +
    `stroke-miterlimit,stroke-opacity,stroke-width`);
/**
 * Known attributes, this is used for stringification of runtime static nodes
 * so that we don't stringify bindings that cannot be set from HTML.
 * Don't also forget to allow `data-*` and `aria-*`!
 * Generated from https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes
 */
const isKnownHtmlAttr = /*#__PURE__*/ makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,` +
    `autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,` +
    `border,buffered,capture,challenge,charset,checked,cite,class,code,` +
    `codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,` +
    `coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,` +
    `disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,` +
    `formaction,formenctype,formmethod,formnovalidate,formtarget,headers,` +
    `height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,` +
    `ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,` +
    `manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,` +
    `open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,` +
    `referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,` +
    `selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,` +
    `start,step,style,summary,tabindex,target,title,translate,type,usemap,` +
    `value,width,wrap`);
/**
 * Generated from https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute
 */
const isKnownSvgAttr = /*#__PURE__*/ makeMap(`xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,` +
    `arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,` +
    `baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,` +
    `clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,` +
    `color-interpolation-filters,color-profile,color-rendering,` +
    `contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,` +
    `descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,` +
    `dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,` +
    `fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,` +
    `font-family,font-size,font-size-adjust,font-stretch,font-style,` +
    `font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,` +
    `glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,` +
    `gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,` +
    `horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,` +
    `k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,` +
    `lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,` +
    `marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,` +
    `mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,` +
    `name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,` +
    `overflow,overline-position,overline-thickness,panose-1,paint-order,path,` +
    `pathLength,patternContentUnits,patternTransform,patternUnits,ping,` +
    `pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,` +
    `preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,` +
    `rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,` +
    `restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,` +
    `specularConstant,specularExponent,speed,spreadMethod,startOffset,` +
    `stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,` +
    `strikethrough-position,strikethrough-thickness,string,stroke,` +
    `stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,` +
    `stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,` +
    `systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,` +
    `text-decoration,text-rendering,textLength,to,transform,transform-origin,` +
    `type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,` +
    `unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,` +
    `v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,` +
    `vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,` +
    `writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,` +
    `xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,` +
    `xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`);

function normalizeStyle(value) {
    if (isArray(value)) {
        const res = {};
        for (let i = 0; i < value.length; i++) {
            const item = value[i];
            const normalized = isString(item)
                ? parseStringStyle(item)
                : normalizeStyle(item);
            if (normalized) {
                for (const key in normalized) {
                    res[key] = normalized[key];
                }
            }
        }
        return res;
    }
    else if (isString(value)) {
        return value;
    }
    else if (isObject(value)) {
        return value;
    }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:(.+)/;
function parseStringStyle(cssText) {
    const ret = {};
    cssText.split(listDelimiterRE).forEach(item => {
        if (item) {
            const tmp = item.split(propertyDelimiterRE);
            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
        }
    });
    return ret;
}
function stringifyStyle(styles) {
    let ret = '';
    if (!styles || isString(styles)) {
        return ret;
    }
    for (const key in styles) {
        const value = styles[key];
        const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);
        if (isString(value) ||
            (typeof value === 'number' && isNoUnitNumericStyleProp(normalizedKey))) {
            // only render valid values
            ret += `${normalizedKey}:${value};`;
        }
    }
    return ret;
}
function normalizeClass(value) {
    let res = '';
    if (isString(value)) {
        res = value;
    }
    else if (isArray(value)) {
        for (let i = 0; i < value.length; i++) {
            const normalized = normalizeClass(value[i]);
            if (normalized) {
                res += normalized + ' ';
            }
        }
    }
    else if (isObject(value)) {
        for (const name in value) {
            if (value[name]) {
                res += name + ' ';
            }
        }
    }
    return res.trim();
}
function normalizeProps(props) {
    if (!props)
        return null;
    let { class: klass, style } = props;
    if (klass && !isString(klass)) {
        props.class = normalizeClass(klass);
    }
    if (style) {
        props.style = normalizeStyle(style);
    }
    return props;
}

// These tag configs are shared between compiler-dom and runtime-dom, so they
// https://developer.mozilla.org/en-US/docs/Web/HTML/Element
const HTML_TAGS = 'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +
    'header,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,' +
    'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +
    'data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,' +
    'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +
    'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +
    'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +
    'option,output,progress,select,textarea,details,dialog,menu,' +
    'summary,template,blockquote,iframe,tfoot';
// https://developer.mozilla.org/en-US/docs/Web/SVG/Element
const SVG_TAGS = 'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +
    'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +
    'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +
    'feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +
    'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +
    'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +
    'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +
    'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +
    'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +
    'text,textPath,title,tspan,unknown,use,view';
const VOID_TAGS = 'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr';
/**
 * Compiler only.
 * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.
 */
const isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS);
/**
 * Compiler only.
 * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.
 */
const isSVGTag = /*#__PURE__*/ makeMap(SVG_TAGS);
/**
 * Compiler only.
 * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.
 */
const isVoidTag = /*#__PURE__*/ makeMap(VOID_TAGS);

const escapeRE = /["'&<>]/;
function escapeHtml(string) {
    const str = '' + string;
    const match = escapeRE.exec(str);
    if (!match) {
        return str;
    }
    let html = '';
    let escaped;
    let index;
    let lastIndex = 0;
    for (index = match.index; index < str.length; index++) {
        switch (str.charCodeAt(index)) {
            case 34: // "
                escaped = '&quot;';
                break;
            case 38: // &
                escaped = '&amp;';
                break;
            case 39: // '
                escaped = '&#39;';
                break;
            case 60: // <
                escaped = '&lt;';
                break;
            case 62: // >
                escaped = '&gt;';
                break;
            default:
                continue;
        }
        if (lastIndex !== index) {
            html += str.slice(lastIndex, index);
        }
        lastIndex = index + 1;
        html += escaped;
    }
    return lastIndex !== index ? html + str.slice(lastIndex, index) : html;
}
// https://www.w3.org/TR/html52/syntax.html#comments
const commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;
function escapeHtmlComment(src) {
    return src.replace(commentStripRE, '');
}

function looseCompareArrays(a, b) {
    if (a.length !== b.length)
        return false;
    let equal = true;
    for (let i = 0; equal && i < a.length; i++) {
        equal = looseEqual(a[i], b[i]);
    }
    return equal;
}
function looseEqual(a, b) {
    if (a === b)
        return true;
    let aValidType = isDate(a);
    let bValidType = isDate(b);
    if (aValidType || bValidType) {
        return aValidType && bValidType ? a.getTime() === b.getTime() : false;
    }
    aValidType = isSymbol(a);
    bValidType = isSymbol(b);
    if (aValidType || bValidType) {
        return a === b;
    }
    aValidType = isArray(a);
    bValidType = isArray(b);
    if (aValidType || bValidType) {
        return aValidType && bValidType ? looseCompareArrays(a, b) : false;
    }
    aValidType = isObject(a);
    bValidType = isObject(b);
    if (aValidType || bValidType) {
        /* istanbul ignore if: this if will probably never be called */
        if (!aValidType || !bValidType) {
            return false;
        }
        const aKeysCount = Object.keys(a).length;
        const bKeysCount = Object.keys(b).length;
        if (aKeysCount !== bKeysCount) {
            return false;
        }
        for (const key in a) {
            const aHasKey = a.hasOwnProperty(key);
            const bHasKey = b.hasOwnProperty(key);
            if ((aHasKey && !bHasKey) ||
                (!aHasKey && bHasKey) ||
                !looseEqual(a[key], b[key])) {
                return false;
            }
        }
    }
    return String(a) === String(b);
}
function looseIndexOf(arr, val) {
    return arr.findIndex(item => looseEqual(item, val));
}

/**
 * For converting {{ interpolation }} values to displayed strings.
 * @private
 */
const toDisplayString = (val) => {
    return isString(val)
        ? val
        : val == null
            ? ''
            : isArray(val) ||
                (isObject(val) &&
                    (val.toString === objectToString || !isFunction(val.toString)))
                ? JSON.stringify(val, replacer, 2)
                : String(val);
};
const replacer = (_key, val) => {
    // can't use isRef here since @vue/shared has no deps
    if (val && val.__v_isRef) {
        return replacer(_key, val.value);
    }
    else if (isMap(val)) {
        return {
            [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val]) => {
                entries[`${key} =>`] = val;
                return entries;
            }, {})
        };
    }
    else if (isSet(val)) {
        return {
            [`Set(${val.size})`]: [...val.values()]
        };
    }
    else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {
        return String(val);
    }
    return val;
};

const EMPTY_OBJ = ( true)
    ? Object.freeze({})
    : 0;
const EMPTY_ARR = ( true) ? Object.freeze([]) : 0;
const NOOP = () => { };
/**
 * Always return false.
 */
const NO = () => false;
const onRE = /^on[^a-z]/;
const isOn = (key) => onRE.test(key);
const isModelListener = (key) => key.startsWith('onUpdate:');
const extend = Object.assign;
const remove = (arr, el) => {
    const i = arr.indexOf(el);
    if (i > -1) {
        arr.splice(i, 1);
    }
};
const hasOwnProperty = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty.call(val, key);
const isArray = Array.isArray;
const isMap = (val) => toTypeString(val) === '[object Map]';
const isSet = (val) => toTypeString(val) === '[object Set]';
const isDate = (val) => toTypeString(val) === '[object Date]';
const isFunction = (val) => typeof val === 'function';
const isString = (val) => typeof val === 'string';
const isSymbol = (val) => typeof val === 'symbol';
const isObject = (val) => val !== null && typeof val === 'object';
const isPromise = (val) => {
    return isObject(val) && isFunction(val.then) && isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const toRawType = (value) => {
    // extract "RawType" from strings like "[object RawType]"
    return toTypeString(value).slice(8, -1);
};
const isPlainObject = (val) => toTypeString(val) === '[object Object]';
const isIntegerKey = (key) => isString(key) &&
    key !== 'NaN' &&
    key[0] !== '-' &&
    '' + parseInt(key, 10) === key;
const isReservedProp = /*#__PURE__*/ makeMap(
// the leading comma is intentional so empty string "" is also included
',key,ref,ref_for,ref_key,' +
    'onVnodeBeforeMount,onVnodeMounted,' +
    'onVnodeBeforeUpdate,onVnodeUpdated,' +
    'onVnodeBeforeUnmount,onVnodeUnmounted');
const isBuiltInDirective = /*#__PURE__*/ makeMap('bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo');
const cacheStringFunction = (fn) => {
    const cache = Object.create(null);
    return ((str) => {
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
    });
};
const camelizeRE = /-(\w)/g;
/**
 * @private
 */
const camelize = cacheStringFunction((str) => {
    return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));
});
const hyphenateRE = /\B([A-Z])/g;
/**
 * @private
 */
const hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, '-$1').toLowerCase());
/**
 * @private
 */
const capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
/**
 * @private
 */
const toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);
// compare whether a value has changed, accounting for NaN.
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, arg) => {
    for (let i = 0; i < fns.length; i++) {
        fns[i](arg);
    }
};
const def = (obj, key, value) => {
    Object.defineProperty(obj, key, {
        configurable: true,
        enumerable: false,
        value
    });
};
const toNumber = (val) => {
    const n = parseFloat(val);
    return isNaN(n) ? val : n;
};
let _globalThis;
const getGlobalThis = () => {
    return (_globalThis ||
        (_globalThis =
            typeof globalThis !== 'undefined'
                ? globalThis
                : typeof self !== 'undefined'
                    ? self
                    : typeof window !== 'undefined'
                        ? window
                        : typeof __webpack_require__.g !== 'undefined'
                            ? __webpack_require__.g
                            : {}));
};
const identRE = /^[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*$/;
function genPropsAccessExp(name) {
    return identRE.test(name)
        ? `__props.${name}`
        : `__props[${JSON.stringify(name)}]`;
}




/***/ }),

/***/ "./node_modules/axios/index.js":
/*!*************************************!*\
  !*** ./node_modules/axios/index.js ***!
  \*************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./lib/axios */ "./node_modules/axios/lib/axios.js");

/***/ }),

/***/ "./node_modules/axios/lib/adapters/xhr.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/adapters/xhr.js ***!
  \************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var settle = __webpack_require__(/*! ./../core/settle */ "./node_modules/axios/lib/core/settle.js");
var cookies = __webpack_require__(/*! ./../helpers/cookies */ "./node_modules/axios/lib/helpers/cookies.js");
var buildURL = __webpack_require__(/*! ./../helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");
var buildFullPath = __webpack_require__(/*! ../core/buildFullPath */ "./node_modules/axios/lib/core/buildFullPath.js");
var parseHeaders = __webpack_require__(/*! ./../helpers/parseHeaders */ "./node_modules/axios/lib/helpers/parseHeaders.js");
var isURLSameOrigin = __webpack_require__(/*! ./../helpers/isURLSameOrigin */ "./node_modules/axios/lib/helpers/isURLSameOrigin.js");
var transitionalDefaults = __webpack_require__(/*! ../defaults/transitional */ "./node_modules/axios/lib/defaults/transitional.js");
var AxiosError = __webpack_require__(/*! ../core/AxiosError */ "./node_modules/axios/lib/core/AxiosError.js");
var CanceledError = __webpack_require__(/*! ../cancel/CanceledError */ "./node_modules/axios/lib/cancel/CanceledError.js");
var parseProtocol = __webpack_require__(/*! ../helpers/parseProtocol */ "./node_modules/axios/lib/helpers/parseProtocol.js");

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;
    var responseType = config.responseType;
    var onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }

      if (config.signal) {
        config.signal.removeEventListener('abort', onCanceled);
      }
    }

    if (utils.isFormData(requestData) && utils.isStandardBrowserEnv()) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    var fullPath = buildFullPath(config.baseURL, config.url);

    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    function onloadend() {
      if (!request) {
        return;
      }
      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !responseType || responseType === 'text' ||  responseType === 'json' ?
        request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);

      // Clean up request
      request = null;
    }

    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }
        // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'
        setTimeout(onloadend);
      };
    }

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(new AxiosError('Request aborted', AxiosError.ECONNABORTED, config, request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';
      var transitional = config.transitional || transitionalDefaults;
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(new AxiosError(
        timeoutErrorMessage,
        transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
        config,
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
        cookies.read(config.xsrfCookieName) :
        undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }

    // Add responseType to request if needed
    if (responseType && responseType !== 'json') {
      request.responseType = config.responseType;
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken || config.signal) {
      // Handle cancellation
      // eslint-disable-next-line func-names
      onCanceled = function(cancel) {
        if (!request) {
          return;
        }
        reject(!cancel || (cancel && cancel.type) ? new CanceledError() : cancel);
        request.abort();
        request = null;
      };

      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);
      }
    }

    if (!requestData) {
      requestData = null;
    }

    var protocol = parseProtocol(fullPath);

    if (protocol && [ 'http', 'https', 'file' ].indexOf(protocol) === -1) {
      reject(new AxiosError('Unsupported protocol ' + protocol + ':', AxiosError.ERR_BAD_REQUEST, config));
      return;
    }


    // Send the request
    request.send(requestData);
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/axios.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/axios.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");
var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");
var Axios = __webpack_require__(/*! ./core/Axios */ "./node_modules/axios/lib/core/Axios.js");
var mergeConfig = __webpack_require__(/*! ./core/mergeConfig */ "./node_modules/axios/lib/core/mergeConfig.js");
var defaults = __webpack_require__(/*! ./defaults */ "./node_modules/axios/lib/defaults/index.js");

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  // Factory for creating new instances
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Expose Cancel & CancelToken
axios.CanceledError = __webpack_require__(/*! ./cancel/CanceledError */ "./node_modules/axios/lib/cancel/CanceledError.js");
axios.CancelToken = __webpack_require__(/*! ./cancel/CancelToken */ "./node_modules/axios/lib/cancel/CancelToken.js");
axios.isCancel = __webpack_require__(/*! ./cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");
axios.VERSION = (__webpack_require__(/*! ./env/data */ "./node_modules/axios/lib/env/data.js").version);
axios.toFormData = __webpack_require__(/*! ./helpers/toFormData */ "./node_modules/axios/lib/helpers/toFormData.js");

// Expose AxiosError class
axios.AxiosError = __webpack_require__(/*! ../lib/core/AxiosError */ "./node_modules/axios/lib/core/AxiosError.js");

// alias for CanceledError for backward compatibility
axios.Cancel = axios.CanceledError;

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = __webpack_require__(/*! ./helpers/spread */ "./node_modules/axios/lib/helpers/spread.js");

// Expose isAxiosError
axios.isAxiosError = __webpack_require__(/*! ./helpers/isAxiosError */ "./node_modules/axios/lib/helpers/isAxiosError.js");

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports["default"] = axios;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/CancelToken.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/cancel/CancelToken.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var CanceledError = __webpack_require__(/*! ./CanceledError */ "./node_modules/axios/lib/cancel/CanceledError.js");

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;

  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;

  // eslint-disable-next-line func-names
  this.promise.then(function(cancel) {
    if (!token._listeners) return;

    var i;
    var l = token._listeners.length;

    for (i = 0; i < l; i++) {
      token._listeners[i](cancel);
    }
    token._listeners = null;
  });

  // eslint-disable-next-line func-names
  this.promise.then = function(onfulfilled) {
    var _resolve;
    // eslint-disable-next-line func-names
    var promise = new Promise(function(resolve) {
      token.subscribe(resolve);
      _resolve = resolve;
    }).then(onfulfilled);

    promise.cancel = function reject() {
      token.unsubscribe(_resolve);
    };

    return promise;
  };

  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new CanceledError(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `CanceledError` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Subscribe to the cancel signal
 */

CancelToken.prototype.subscribe = function subscribe(listener) {
  if (this.reason) {
    listener(this.reason);
    return;
  }

  if (this._listeners) {
    this._listeners.push(listener);
  } else {
    this._listeners = [listener];
  }
};

/**
 * Unsubscribe from the cancel signal
 */

CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
  if (!this._listeners) {
    return;
  }
  var index = this._listeners.indexOf(listener);
  if (index !== -1) {
    this._listeners.splice(index, 1);
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/CanceledError.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/cancel/CanceledError.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var AxiosError = __webpack_require__(/*! ../core/AxiosError */ "./node_modules/axios/lib/core/AxiosError.js");
var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");

/**
 * A `CanceledError` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function CanceledError(message) {
  // eslint-disable-next-line no-eq-null,eqeqeq
  AxiosError.call(this, message == null ? 'canceled' : message, AxiosError.ERR_CANCELED);
  this.name = 'CanceledError';
}

utils.inherits(CanceledError, AxiosError, {
  __CANCEL__: true
});

module.exports = CanceledError;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/isCancel.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/cancel/isCancel.js ***!
  \***************************************************/
/***/ (function(module) {

"use strict";


module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};


/***/ }),

/***/ "./node_modules/axios/lib/core/Axios.js":
/*!**********************************************!*\
  !*** ./node_modules/axios/lib/core/Axios.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var buildURL = __webpack_require__(/*! ../helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");
var InterceptorManager = __webpack_require__(/*! ./InterceptorManager */ "./node_modules/axios/lib/core/InterceptorManager.js");
var dispatchRequest = __webpack_require__(/*! ./dispatchRequest */ "./node_modules/axios/lib/core/dispatchRequest.js");
var mergeConfig = __webpack_require__(/*! ./mergeConfig */ "./node_modules/axios/lib/core/mergeConfig.js");
var buildFullPath = __webpack_require__(/*! ./buildFullPath */ "./node_modules/axios/lib/core/buildFullPath.js");
var validator = __webpack_require__(/*! ../helpers/validator */ "./node_modules/axios/lib/helpers/validator.js");

var validators = validator.validators;
/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(configOrUrl, config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof configOrUrl === 'string') {
    config = config || {};
    config.url = configOrUrl;
  } else {
    config = configOrUrl || {};
  }

  config = mergeConfig(this.defaults, config);

  // Set config.method
  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = 'get';
  }

  var transitional = config.transitional;

  if (transitional !== undefined) {
    validator.assertOptions(transitional, {
      silentJSONParsing: validators.transitional(validators.boolean),
      forcedJSONParsing: validators.transitional(validators.boolean),
      clarifyTimeoutError: validators.transitional(validators.boolean)
    }, false);
  }

  // filter out skipped interceptors
  var requestInterceptorChain = [];
  var synchronousRequestInterceptors = true;
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
      return;
    }

    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  var responseInterceptorChain = [];
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
  });

  var promise;

  if (!synchronousRequestInterceptors) {
    var chain = [dispatchRequest, undefined];

    Array.prototype.unshift.apply(chain, requestInterceptorChain);
    chain = chain.concat(responseInterceptorChain);

    promise = Promise.resolve(config);
    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }

    return promise;
  }


  var newConfig = config;
  while (requestInterceptorChain.length) {
    var onFulfilled = requestInterceptorChain.shift();
    var onRejected = requestInterceptorChain.shift();
    try {
      newConfig = onFulfilled(newConfig);
    } catch (error) {
      onRejected(error);
      break;
    }
  }

  try {
    promise = dispatchRequest(newConfig);
  } catch (error) {
    return Promise.reject(error);
  }

  while (responseInterceptorChain.length) {
    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  var fullPath = buildFullPath(config.baseURL, config.url);
  return buildURL(fullPath, config.params, config.paramsSerializer);
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: (config || {}).data
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/

  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method: method,
        headers: isForm ? {
          'Content-Type': 'multipart/form-data'
        } : {},
        url: url,
        data: data
      }));
    };
  }

  Axios.prototype[method] = generateHTTPMethod();

  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);
});

module.exports = Axios;


/***/ }),

/***/ "./node_modules/axios/lib/core/AxiosError.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/core/AxiosError.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [config] The config.
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
function AxiosError(message, code, config, request, response) {
  Error.call(this);
  this.message = message;
  this.name = 'AxiosError';
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  response && (this.response = response);
}

utils.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});

var prototype = AxiosError.prototype;
var descriptors = {};

[
  'ERR_BAD_OPTION_VALUE',
  'ERR_BAD_OPTION',
  'ECONNABORTED',
  'ETIMEDOUT',
  'ERR_NETWORK',
  'ERR_FR_TOO_MANY_REDIRECTS',
  'ERR_DEPRECATED',
  'ERR_BAD_RESPONSE',
  'ERR_BAD_REQUEST',
  'ERR_CANCELED'
// eslint-disable-next-line func-names
].forEach(function(code) {
  descriptors[code] = {value: code};
});

Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, 'isAxiosError', {value: true});

// eslint-disable-next-line func-names
AxiosError.from = function(error, code, config, request, response, customProps) {
  var axiosError = Object.create(prototype);

  utils.toFlatObject(error, axiosError, function filter(obj) {
    return obj !== Error.prototype;
  });

  AxiosError.call(axiosError, error.message, code, config, request, response);

  axiosError.name = error.name;

  customProps && Object.assign(axiosError, customProps);

  return axiosError;
};

module.exports = AxiosError;


/***/ }),

/***/ "./node_modules/axios/lib/core/InterceptorManager.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/core/InterceptorManager.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected,
    synchronous: options ? options.synchronous : false,
    runWhen: options ? options.runWhen : null
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;


/***/ }),

/***/ "./node_modules/axios/lib/core/buildFullPath.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/buildFullPath.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var isAbsoluteURL = __webpack_require__(/*! ../helpers/isAbsoluteURL */ "./node_modules/axios/lib/helpers/isAbsoluteURL.js");
var combineURLs = __webpack_require__(/*! ../helpers/combineURLs */ "./node_modules/axios/lib/helpers/combineURLs.js");

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */
module.exports = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
};


/***/ }),

/***/ "./node_modules/axios/lib/core/dispatchRequest.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/core/dispatchRequest.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var transformData = __webpack_require__(/*! ./transformData */ "./node_modules/axios/lib/core/transformData.js");
var isCancel = __webpack_require__(/*! ../cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");
var defaults = __webpack_require__(/*! ../defaults */ "./node_modules/axios/lib/defaults/index.js");
var CanceledError = __webpack_require__(/*! ../cancel/CanceledError */ "./node_modules/axios/lib/cancel/CanceledError.js");

/**
 * Throws a `CanceledError` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }

  if (config.signal && config.signal.aborted) {
    throw new CanceledError();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData.call(
    config,
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData.call(
      config,
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/core/mergeConfig.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/mergeConfig.js ***!
  \****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */
module.exports = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};

  function getMergedValue(target, source) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge(target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  // eslint-disable-next-line consistent-return
  function mergeDeepProperties(prop) {
    if (!utils.isUndefined(config2[prop])) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      return getMergedValue(undefined, config1[prop]);
    }
  }

  // eslint-disable-next-line consistent-return
  function valueFromConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      return getMergedValue(undefined, config2[prop]);
    }
  }

  // eslint-disable-next-line consistent-return
  function defaultToConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      return getMergedValue(undefined, config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      return getMergedValue(undefined, config1[prop]);
    }
  }

  // eslint-disable-next-line consistent-return
  function mergeDirectKeys(prop) {
    if (prop in config2) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      return getMergedValue(undefined, config1[prop]);
    }
  }

  var mergeMap = {
    'url': valueFromConfig2,
    'method': valueFromConfig2,
    'data': valueFromConfig2,
    'baseURL': defaultToConfig2,
    'transformRequest': defaultToConfig2,
    'transformResponse': defaultToConfig2,
    'paramsSerializer': defaultToConfig2,
    'timeout': defaultToConfig2,
    'timeoutMessage': defaultToConfig2,
    'withCredentials': defaultToConfig2,
    'adapter': defaultToConfig2,
    'responseType': defaultToConfig2,
    'xsrfCookieName': defaultToConfig2,
    'xsrfHeaderName': defaultToConfig2,
    'onUploadProgress': defaultToConfig2,
    'onDownloadProgress': defaultToConfig2,
    'decompress': defaultToConfig2,
    'maxContentLength': defaultToConfig2,
    'maxBodyLength': defaultToConfig2,
    'beforeRedirect': defaultToConfig2,
    'transport': defaultToConfig2,
    'httpAgent': defaultToConfig2,
    'httpsAgent': defaultToConfig2,
    'cancelToken': defaultToConfig2,
    'socketPath': defaultToConfig2,
    'responseEncoding': defaultToConfig2,
    'validateStatus': mergeDirectKeys
  };

  utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
    var merge = mergeMap[prop] || mergeDeepProperties;
    var configValue = merge(prop);
    (utils.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);
  });

  return config;
};


/***/ }),

/***/ "./node_modules/axios/lib/core/settle.js":
/*!***********************************************!*\
  !*** ./node_modules/axios/lib/core/settle.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var AxiosError = __webpack_require__(/*! ./AxiosError */ "./node_modules/axios/lib/core/AxiosError.js");

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError(
      'Request failed with status code ' + response.status,
      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
};


/***/ }),

/***/ "./node_modules/axios/lib/core/transformData.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/transformData.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var defaults = __webpack_require__(/*! ../defaults */ "./node_modules/axios/lib/defaults/index.js");

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  var context = this || defaults;
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn.call(context, data, headers);
  });

  return data;
};


/***/ }),

/***/ "./node_modules/axios/lib/defaults/index.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/defaults/index.js ***!
  \**************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");
var normalizeHeaderName = __webpack_require__(/*! ../helpers/normalizeHeaderName */ "./node_modules/axios/lib/helpers/normalizeHeaderName.js");
var AxiosError = __webpack_require__(/*! ../core/AxiosError */ "./node_modules/axios/lib/core/AxiosError.js");
var transitionalDefaults = __webpack_require__(/*! ./transitional */ "./node_modules/axios/lib/defaults/transitional.js");
var toFormData = __webpack_require__(/*! ../helpers/toFormData */ "./node_modules/axios/lib/helpers/toFormData.js");

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__(/*! ../adapters/xhr */ "./node_modules/axios/lib/adapters/xhr.js");
  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // For node use HTTP adapter
    adapter = __webpack_require__(/*! ../adapters/http */ "./node_modules/axios/lib/adapters/xhr.js");
  }
  return adapter;
}

function stringifySafely(rawValue, parser, encoder) {
  if (utils.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

var defaults = {

  transitional: transitionalDefaults,

  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');

    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }

    var isObjectPayload = utils.isObject(data);
    var contentType = headers && headers['Content-Type'];

    var isFileList;

    if ((isFileList = utils.isFileList(data)) || (isObjectPayload && contentType === 'multipart/form-data')) {
      var _FormData = this.env && this.env.FormData;
      return toFormData(isFileList ? {'files[]': data} : data, _FormData && new _FormData());
    } else if (isObjectPayload || contentType === 'application/json') {
      setContentTypeIfUnset(headers, 'application/json');
      return stringifySafely(data);
    }

    return data;
  }],

  transformResponse: [function transformResponse(data) {
    var transitional = this.transitional || defaults.transitional;
    var silentJSONParsing = transitional && transitional.silentJSONParsing;
    var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';

    if (strictJSONParsing || (forcedJSONParsing && utils.isString(data) && data.length)) {
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  env: {
    FormData: __webpack_require__(/*! ./env/FormData */ "./node_modules/axios/lib/helpers/null.js")
  },

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },

  headers: {
    common: {
      'Accept': 'application/json, text/plain, */*'
    }
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;


/***/ }),

/***/ "./node_modules/axios/lib/defaults/transitional.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/defaults/transitional.js ***!
  \*********************************************************/
/***/ (function(module) {

"use strict";


module.exports = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};


/***/ }),

/***/ "./node_modules/axios/lib/env/data.js":
/*!********************************************!*\
  !*** ./node_modules/axios/lib/env/data.js ***!
  \********************************************/
/***/ (function(module) {

module.exports = {
  "version": "0.27.2"
};

/***/ }),

/***/ "./node_modules/axios/lib/helpers/bind.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/bind.js ***!
  \************************************************/
/***/ (function(module) {

"use strict";


module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/buildURL.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/buildURL.js ***!
  \****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

function encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    var hashmarkIndex = url.indexOf('#');
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }

    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/combineURLs.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/combineURLs.js ***!
  \*******************************************************/
/***/ (function(module) {

"use strict";


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/cookies.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/helpers/cookies.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
    (function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + '=' + encodeURIComponent(value));

          if (utils.isNumber(expires)) {
            cookie.push('expires=' + new Date(expires).toGMTString());
          }

          if (utils.isString(path)) {
            cookie.push('path=' + path);
          }

          if (utils.isString(domain)) {
            cookie.push('domain=' + domain);
          }

          if (secure === true) {
            cookie.push('secure');
          }

          document.cookie = cookie.join('; ');
        },

        read: function read(name) {
          var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
          return (match ? decodeURIComponent(match[3]) : null);
        },

        remove: function remove(name) {
          this.write(name, '', Date.now() - 86400000);
        }
      };
    })() :

  // Non standard browser env (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return {
        write: function write() {},
        read: function read() { return null; },
        remove: function remove() {}
      };
    })()
);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAbsoluteURL.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAbsoluteURL.js ***!
  \*********************************************************/
/***/ (function(module) {

"use strict";


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAxiosError.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAxiosError.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
module.exports = function isAxiosError(payload) {
  return utils.isObject(payload) && (payload.isAxiosError === true);
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isURLSameOrigin.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isURLSameOrigin.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
    (function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement('a');
      var originURL;

      /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
      function resolveURL(url) {
        var href = url;

        if (msie) {
        // IE needs attribute set twice to normalize properties
          urlParsingNode.setAttribute('href', href);
          href = urlParsingNode.href;
        }

        urlParsingNode.setAttribute('href', href);

        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
            urlParsingNode.pathname :
            '/' + urlParsingNode.pathname
        };
      }

      originURL = resolveURL(window.location.href);

      /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
      return function isURLSameOrigin(requestURL) {
        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
        return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
      };
    })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    })()
);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/normalizeHeaderName.js":
/*!***************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/normalizeHeaderName.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/null.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/null.js ***!
  \************************************************/
/***/ (function(module) {

// eslint-disable-next-line strict
module.exports = null;


/***/ }),

/***/ "./node_modules/axios/lib/helpers/parseHeaders.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/parseHeaders.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/parseProtocol.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/parseProtocol.js ***!
  \*********************************************************/
/***/ (function(module) {

"use strict";


module.exports = function parseProtocol(url) {
  var match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || '';
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/spread.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/helpers/spread.js ***!
  \**************************************************/
/***/ (function(module) {

"use strict";


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/toFormData.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/toFormData.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");

/**
 * Convert a data object to FormData
 * @param {Object} obj
 * @param {?Object} [formData]
 * @returns {Object}
 **/

function toFormData(obj, formData) {
  // eslint-disable-next-line no-param-reassign
  formData = formData || new FormData();

  var stack = [];

  function convertValue(value) {
    if (value === null) return '';

    if (utils.isDate(value)) {
      return value.toISOString();
    }

    if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {
      return typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);
    }

    return value;
  }

  function build(data, parentKey) {
    if (utils.isPlainObject(data) || utils.isArray(data)) {
      if (stack.indexOf(data) !== -1) {
        throw Error('Circular reference detected in ' + parentKey);
      }

      stack.push(data);

      utils.forEach(data, function each(value, key) {
        if (utils.isUndefined(value)) return;
        var fullKey = parentKey ? parentKey + '.' + key : key;
        var arr;

        if (value && !parentKey && typeof value === 'object') {
          if (utils.endsWith(key, '{}')) {
            // eslint-disable-next-line no-param-reassign
            value = JSON.stringify(value);
          } else if (utils.endsWith(key, '[]') && (arr = utils.toArray(value))) {
            // eslint-disable-next-line func-names
            arr.forEach(function(el) {
              !utils.isUndefined(el) && formData.append(fullKey, convertValue(el));
            });
            return;
          }
        }

        build(value, fullKey);
      });

      stack.pop();
    } else {
      formData.append(parentKey, convertValue(data));
    }
  }

  build(obj);

  return formData;
}

module.exports = toFormData;


/***/ }),

/***/ "./node_modules/axios/lib/helpers/validator.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/validator.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var VERSION = (__webpack_require__(/*! ../env/data */ "./node_modules/axios/lib/env/data.js").version);
var AxiosError = __webpack_require__(/*! ../core/AxiosError */ "./node_modules/axios/lib/core/AxiosError.js");

var validators = {};

// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function(type, i) {
  validators[type] = function validator(thing) {
    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});

var deprecatedWarnings = {};

/**
 * Transitional option validator
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 * @returns {function}
 */
validators.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return '[Axios v' + VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }

  // eslint-disable-next-line func-names
  return function(value, opt, opts) {
    if (validator === false) {
      throw new AxiosError(
        formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),
        AxiosError.ERR_DEPRECATED
      );
    }

    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(
        formatMessage(
          opt,
          ' has been deprecated since v' + version + ' and will be removed in the near future'
        )
      );
    }

    return validator ? validator(value, opt, opts) : true;
  };
};

/**
 * Assert object's properties type
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 */

function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new AxiosError('options must be an object', AxiosError.ERR_BAD_OPTION_VALUE);
  }
  var keys = Object.keys(options);
  var i = keys.length;
  while (i-- > 0) {
    var opt = keys[i];
    var validator = schema[opt];
    if (validator) {
      var value = options[opt];
      var result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError('option ' + opt + ' must be ' + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError('Unknown option ' + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}

module.exports = {
  assertOptions: assertOptions,
  validators: validators
};


/***/ }),

/***/ "./node_modules/axios/lib/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/utils.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

// eslint-disable-next-line func-names
var kindOf = (function(cache) {
  // eslint-disable-next-line func-names
  return function(thing) {
    var str = toString.call(thing);
    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
  };
})(Object.create(null));

function kindOfTest(type) {
  type = type.toLowerCase();
  return function isKindOf(thing) {
    return kindOf(thing) === type;
  };
}

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return Array.isArray(val);
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
var isArrayBuffer = kindOfTest('ArrayBuffer');


/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a plain Object
 *
 * @param {Object} val The value to test
 * @return {boolean} True if value is a plain Object, otherwise false
 */
function isPlainObject(val) {
  if (kindOf(val) !== 'object') {
    return false;
  }

  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}

/**
 * Determine if a value is a Date
 *
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
var isDate = kindOfTest('Date');

/**
 * Determine if a value is a File
 *
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
var isFile = kindOfTest('File');

/**
 * Determine if a value is a Blob
 *
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
var isBlob = kindOfTest('Blob');

/**
 * Determine if a value is a FileList
 *
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
var isFileList = kindOfTest('FileList');

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} thing The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(thing) {
  var pattern = '[object FormData]';
  return thing && (
    (typeof FormData === 'function' && thing instanceof FormData) ||
    toString.call(thing) === pattern ||
    (isFunction(thing.toString) && thing.toString() === pattern)
  );
}

/**
 * Determine if a value is a URLSearchParams object
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
var isURLSearchParams = kindOfTest('URLSearchParams');

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                           navigator.product === 'NativeScript' ||
                                           navigator.product === 'NS')) {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge({}, val);
    } else if (isArray(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 * @return {string} content value without BOM
 */
function stripBOM(content) {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
}

/**
 * Inherit the prototype methods from one constructor into another
 * @param {function} constructor
 * @param {function} superConstructor
 * @param {object} [props]
 * @param {object} [descriptors]
 */

function inherits(constructor, superConstructor, props, descriptors) {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors);
  constructor.prototype.constructor = constructor;
  props && Object.assign(constructor.prototype, props);
}

/**
 * Resolve object with deep prototype chain to a flat object
 * @param {Object} sourceObj source object
 * @param {Object} [destObj]
 * @param {Function} [filter]
 * @returns {Object}
 */

function toFlatObject(sourceObj, destObj, filter) {
  var props;
  var i;
  var prop;
  var merged = {};

  destObj = destObj || {};

  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if (!merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = Object.getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);

  return destObj;
}

/*
 * determines whether a string ends with the characters of a specified string
 * @param {String} str
 * @param {String} searchString
 * @param {Number} [position= 0]
 * @returns {boolean}
 */
function endsWith(str, searchString, position) {
  str = String(str);
  if (position === undefined || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  var lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
}


/**
 * Returns new array from array like object
 * @param {*} [thing]
 * @returns {Array}
 */
function toArray(thing) {
  if (!thing) return null;
  var i = thing.length;
  if (isUndefined(i)) return null;
  var arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
}

// eslint-disable-next-line func-names
var isTypedArray = (function(TypedArray) {
  // eslint-disable-next-line func-names
  return function(thing) {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== 'undefined' && Object.getPrototypeOf(Uint8Array));

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isPlainObject: isPlainObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim,
  stripBOM: stripBOM,
  inherits: inherits,
  toFlatObject: toFlatObject,
  kindOf: kindOf,
  kindOfTest: kindOfTest,
  endsWith: endsWith,
  toArray: toArray,
  isTypedArray: isTypedArray,
  isFileList: isFileList
};


/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/Resources/private/js/App.vue?vue&type=script&lang=js":
/*!**********************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/Resources/private/js/App.vue?vue&type=script&lang=js ***!
  \**********************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _components_TheSearch_vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./components/TheSearch.vue */ "./src/Resources/private/js/components/TheSearch.vue");
/* harmony import */ var _components_TheMap_vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/TheMap.vue */ "./src/Resources/private/js/components/TheMap.vue");
/* harmony import */ var _components_TheRetailer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/TheRetailer */ "./src/Resources/private/js/components/TheRetailer.vue");
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm-bundler.js");
/* harmony import */ var vuex__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vuex */ "./node_modules/vuex/dist/vuex.esm-bundler.js");





/* harmony default export */ __webpack_exports__["default"] = ({
  name: "App",
  components: {
    Search: _components_TheSearch_vue__WEBPACK_IMPORTED_MODULE_0__["default"],
    Map: _components_TheMap_vue__WEBPACK_IMPORTED_MODULE_1__["default"],
    Retailer: _components_TheRetailer__WEBPACK_IMPORTED_MODULE_2__["default"]
  },
  props: {
    config: String
  },

  provide() {
    return {
      ajaxRoute: JSON.parse(this.config).ajaxRoute,
      imageRoute: JSON.parse(this.config).imageRoute,
      defaultValues: JSON.parse(this.config).default,
      formatPhoneNumber: this.formatPhoneNumber,
      searchField: JSON.parse(this.config).searchField,
      findButton: JSON.parse(this.config).findButton,
      emptyResultsMessage: JSON.parse(this.config).emptyResultsMessage
    };
  },

  setup(props) {
    const store = (0,vuex__WEBPACK_IMPORTED_MODULE_4__.useStore)();
    const imgRoute = JSON.parse(props.config).imageRoute;
    const imageURL = document.location.origin + '/' + imgRoute;

    function formatPhoneNumber(number) {
      // Hugo Duval -- Code :
      const MASKS = {
        '000 0 00 00 00 00': v => v.startsWith('+33') && v.length === 12,
        '00 00 00 00 00': v => v.startsWith('0') && v.length === 10
      };
      const [mask] = Object.entries(MASKS).find(_ref => {
        let [_, condition] = _ref;
        return condition(number);
      }) ?? [];
      if (!mask) return number;
      const numberArr = [...number];
      let numberIndex = 0;
      return [...mask].reduce((acc, v) => {
        if (v === ' ') return acc + ' ';
        acc += numberArr[numberIndex];
        numberIndex++;
        return acc;
      }, '');
    }

    return { ...props,
      store,
      imgRoute,
      imageURL,
      formatPhoneNumber,
      ...props
    };
  }

});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/Resources/private/js/components/RetailerMapIcon.vue?vue&type=script&lang=js":
/*!*********************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/Resources/private/js/components/RetailerMapIcon.vue?vue&type=script&lang=js ***!
  \*********************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _vue_leaflet_vue_leaflet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue-leaflet/vue-leaflet */ "./node_modules/@vue-leaflet/vue-leaflet/dist/vue-leaflet.esm.js");
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm-bundler.js");


/* harmony default export */ __webpack_exports__["default"] = ({
  components: {
    LIcon: _vue_leaflet_vue_leaflet__WEBPACK_IMPORTED_MODULE_1__.LIcon,
    LMarker: _vue_leaflet_vue_leaflet__WEBPACK_IMPORTED_MODULE_1__.LMarker,
    LPopup: _vue_leaflet_vue_leaflet__WEBPACK_IMPORTED_MODULE_1__.LPopup
  },
  props: {
    marker: {
      type: Object,
      required: true
    }
  },

  setup(props) {
    const formatPhoneNumber = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)('formatPhoneNumber');
    const content = '<b>' + props.marker.name + '</b><br />' + props.marker.street + '<br />' + props.marker.city.toUpperCase() + ' ' + props.marker.postcode + `<br /><a href="tel:${props.marker.phoneNumber}">${formatPhoneNumber(props.marker.phoneNumber)}</a>`;
    return { ...props,
      content
    };
  }

});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/Resources/private/js/components/TheMap.vue?vue&type=script&lang=js":
/*!************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/Resources/private/js/components/TheMap.vue?vue&type=script&lang=js ***!
  \************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _vue_leaflet_vue_leaflet__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @vue-leaflet/vue-leaflet */ "./node_modules/@vue-leaflet/vue-leaflet/dist/vue-leaflet.esm.js");
/* harmony import */ var _RetailerMapIcon_vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RetailerMapIcon.vue */ "./src/Resources/private/js/components/RetailerMapIcon.vue");
/* harmony import */ var leaflet_dist_leaflet_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! leaflet/dist/leaflet.css */ "./node_modules/leaflet/dist/leaflet.css");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! axios */ "./node_modules/axios/index.js");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm-bundler.js");
/* harmony import */ var vuex__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! vuex */ "./node_modules/vuex/dist/vuex.esm-bundler.js");






/* harmony default export */ __webpack_exports__["default"] = ({
  name: "TheMap",
  components: {
    LMap: _vue_leaflet_vue_leaflet__WEBPACK_IMPORTED_MODULE_4__.LMap,
    LTileLayer: _vue_leaflet_vue_leaflet__WEBPACK_IMPORTED_MODULE_4__.LTileLayer,
    Marker: _RetailerMapIcon_vue__WEBPACK_IMPORTED_MODULE_0__["default"]
  },

  setup(props, context) {
    const store = (0,vuex__WEBPACK_IMPORTED_MODULE_5__.useStore)();
    const routeAjax = (0,vue__WEBPACK_IMPORTED_MODULE_3__.inject)('ajaxRoute');
    const imageRoute = (0,vue__WEBPACK_IMPORTED_MODULE_3__.inject)('imageRoute');
    const defaultValues = (0,vue__WEBPACK_IMPORTED_MODULE_3__.inject)('defaultValues');
    const url = 'https://tiles.stadiamaps.com/tiles/alidade_smooth/{z}/{x}/{y}{r}.png';
    const center = (0,vue__WEBPACK_IMPORTED_MODULE_3__.ref)([defaultValues.latitude, defaultValues.longitude]);
    const markers = (0,vue__WEBPACK_IMPORTED_MODULE_3__.ref)([]);
    const zoom = 14;
    const retailers = (0,vue__WEBPACK_IMPORTED_MODULE_3__.computed)(() => {
      return store.state.retailers;
    });
    const centerByClick = (0,vue__WEBPACK_IMPORTED_MODULE_3__.computed)(() => {
      return store.state.centerByClick;
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_3__.watch)(retailers, function (newValue, oldValue) {
      const [object] = newValue;
      center.value = [parseFloat(object.latitude), parseFloat(object.longitude)];
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_3__.watch)(centerByClick, function (newValue, oldValue) {
      center.value = newValue;
    });
    (0,vue__WEBPACK_IMPORTED_MODULE_3__.onBeforeMount)(async () => {
      const center = [defaultValues.latitude, defaultValues.longitude];
      const routeAjax = (0,vue__WEBPACK_IMPORTED_MODULE_3__.inject)('ajaxRoute').replace('0', '');
      const imageRoute = (0,vue__WEBPACK_IMPORTED_MODULE_3__.inject)('imageRoute');
      const objects = await axios__WEBPACK_IMPORTED_MODULE_2___default().get(routeAjax, {
        headers: {
          'Accept': 'application/json',
          'Content-Type': 'application/json'
        }
      });
      const retailers = objects.data._embedded.items;
      if (!retailers) return;
      const imageUrl = document.location.origin + '/' + imageRoute;
      retailers.forEach(item => {
        let imagePath = imageUrl + item.path;

        if (item.path === null || item.path === undefined) {
          imagePath = undefined;
        }

        markers.value.push({
          id: item.id,
          name: item.name,
          street: item.street,
          city: item.city,
          postcode: item.postcode,
          phoneNumber: item.phoneNumber,
          image: imagePath,
          coordinates: [parseFloat(item.latitude), parseFloat(item.longitude)]
        });
      });
      const {
        circleMarker
      } = await __webpack_require__.e(/*! import() */ "vendors-node_modules_leaflet_src_Leaflet_js").then(__webpack_require__.bind(__webpack_require__, /*! leaflet/src/Leaflet */ "./node_modules/leaflet/src/Leaflet.js"));
    });
    return {
      store,
      routeAjax,
      defaultValues,
      imageRoute,
      url,
      center,
      zoom,
      markers
    };
  }

});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/Resources/private/js/components/TheRetailer.vue?vue&type=script&lang=js":
/*!*****************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/Resources/private/js/components/TheRetailer.vue?vue&type=script&lang=js ***!
  \*****************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var vuex__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vuex */ "./node_modules/vuex/dist/vuex.esm-bundler.js");
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm-bundler.js");


/* harmony default export */ __webpack_exports__["default"] = ({
  name: "TheRetailer",
  props: {
    retailer: JSON,
    image: String
  },

  setup(props) {
    const store = (0,vuex__WEBPACK_IMPORTED_MODULE_1__.useStore)();
    const formatPhoneNumber = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)('formatPhoneNumber');

    function updateCenter(latitude, longitude) {
      store.state.centerByClick = [latitude, longitude];
    }

    return {
      formatPhoneNumber,
      updateCenter,
      ...props
    };
  }

});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/Resources/private/js/components/TheSearch.vue?vue&type=script&lang=js":
/*!***************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/Resources/private/js/components/TheSearch.vue?vue&type=script&lang=js ***!
  \***************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var vuex__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vuex */ "./node_modules/vuex/dist/vuex.esm-bundler.js");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ "./node_modules/axios/index.js");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm-bundler.js");



/* harmony default export */ __webpack_exports__["default"] = ({
  name: "TheSearch",

  setup() {
    const routeAjax = (0,vue__WEBPACK_IMPORTED_MODULE_1__.inject)('ajaxRoute');
    const store = (0,vuex__WEBPACK_IMPORTED_MODULE_2__.useStore)();
    const searchFieldText = (0,vue__WEBPACK_IMPORTED_MODULE_1__.inject)('searchField');
    const findButtonText = (0,vue__WEBPACK_IMPORTED_MODULE_1__.inject)('findButton');
    let userInput = (0,vue__WEBPACK_IMPORTED_MODULE_1__.ref)(null);
    let urlRequest = routeAjax.replace('0', userInput.value);
    (0,vue__WEBPACK_IMPORTED_MODULE_1__.watch)(userInput, function (newValue, oldValue) {
      urlRequest = urlRequest.replace(oldValue, newValue);
    });

    async function search(input) {
      store.state.searchResultsLength = 0;
      input = userInput.value;
      if (!input) return;
      const object = await axios__WEBPACK_IMPORTED_MODULE_0___default().get(urlRequest, {
        headers: {
          'Accept': 'application/json',
          'Content-Type': 'application/json'
        }
      });
      if (!object.data._embedded.items) return;
      store.state.searchResultsLength = object.data._embedded.items.length;
      store.state.retailers = object.data._embedded.items;
    }

    return {
      routeAjax,
      store,
      searchFieldText,
      findButtonText,
      userInput,
      urlRequest,
      search
    };
  }

});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/Resources/private/js/App.vue?vue&type=template&id=43325c2c&scoped=true":
/*!**************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/Resources/private/js/App.vue?vue&type=template&id=43325c2c&scoped=true ***!
  \**************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": function() { return /* binding */ render; }
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm-bundler.js");


const _withScopeId = n => ((0,vue__WEBPACK_IMPORTED_MODULE_0__.pushScopeId)("data-v-43325c2c"), n = n(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.popScopeId)(), n);

const _hoisted_1 = {
  key: 0,
  class: "ui cards",
  id: "list"
};
const _hoisted_2 = {
  key: 1,
  class: "ui ignored info message"
};
function render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Search = (0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveComponent)("Search");

  const _component_Map = (0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveComponent)("Map");

  const _component_Retailer = (0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveComponent)("Retailer");

  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(vue__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)(_component_Search), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)(_component_Map), $setup.store.state.searchResultsLength > 0 ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", _hoisted_1, [((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(true), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(vue__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderList)($setup.store.state.retailers, retailer => {
    return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)(_component_Retailer, {
      key: retailer.id,
      retailer: retailer,
      image: $setup.imageURL + retailer.path
    }, null, 8
    /* PROPS */
    , ["retailer", "image"]);
  }), 128
  /* KEYED_FRAGMENT */
  ))])) : ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", _hoisted_2, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(JSON.parse(this.$props.config).emptyResultsMessage), 1
  /* TEXT */
  ))], 64
  /* STABLE_FRAGMENT */
  );
}

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/Resources/private/js/components/RetailerMapIcon.vue?vue&type=template&id=58261f73&scoped=true":
/*!*************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/Resources/private/js/components/RetailerMapIcon.vue?vue&type=template&id=58261f73&scoped=true ***!
  \*************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": function() { return /* binding */ render; }
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm-bundler.js");


const _withScopeId = n => ((0,vue__WEBPACK_IMPORTED_MODULE_0__.pushScopeId)("data-v-58261f73"), n = n(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.popScopeId)(), n);

const _hoisted_1 = ["src"];
function render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_l_icon = (0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveComponent)("l-icon");

  const _component_l_popup = (0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveComponent)("l-popup");

  const _component_l_marker = (0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveComponent)("l-marker");

  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)(_component_l_marker, {
    key: $props.marker.id,
    "lat-lng": $props.marker.coordinates
  }, {
    default: (0,vue__WEBPACK_IMPORTED_MODULE_0__.withCtx)(() => [$props.marker.image !== undefined ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)(_component_l_icon, {
      key: 0,
      ref: "icon"
    }, {
      default: (0,vue__WEBPACK_IMPORTED_MODULE_0__.withCtx)(() => [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("img", {
        class: "retailer-icon",
        src: $props.marker.image
      }, null, 8
      /* PROPS */
      , _hoisted_1)]),
      _: 1
      /* STABLE */

    }, 512
    /* NEED_PATCH */
    )) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("v-if", true), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)(_component_l_popup, {
      content: $setup.content
    }, null, 8
    /* PROPS */
    , ["content"])]),
    _: 1
    /* STABLE */

  }, 8
  /* PROPS */
  , ["lat-lng"]);
}

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/Resources/private/js/components/TheMap.vue?vue&type=template&id=fbd115e6&scoped=true":
/*!****************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/Resources/private/js/components/TheMap.vue?vue&type=template&id=fbd115e6&scoped=true ***!
  \****************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": function() { return /* binding */ render; }
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm-bundler.js");

function render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_l_tile_layer = (0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveComponent)("l-tile-layer");

  const _component_Marker = (0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveComponent)("Marker");

  const _component_l_map = (0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveComponent)("l-map");

  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", null, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)(_component_l_map, {
    center: $setup.center,
    zoom: $setup.zoom,
    class: "map",
    ref: "map"
  }, {
    default: (0,vue__WEBPACK_IMPORTED_MODULE_0__.withCtx)(() => [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)(_component_l_tile_layer, {
      url: $setup.url
    }, null, 8
    /* PROPS */
    , ["url"]), ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(true), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(vue__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderList)($setup.markers, marker => {
      return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)(_component_Marker, {
        key: marker.id,
        marker: marker
      }, null, 8
      /* PROPS */
      , ["marker"]);
    }), 128
    /* KEYED_FRAGMENT */
    ))]),
    _: 1
    /* STABLE */

  }, 8
  /* PROPS */
  , ["center", "zoom"])]);
}

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/Resources/private/js/components/TheRetailer.vue?vue&type=template&id=abbd3fe2":
/*!*********************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/Resources/private/js/components/TheRetailer.vue?vue&type=template&id=abbd3fe2 ***!
  \*********************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": function() { return /* binding */ render; }
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm-bundler.js");

const _hoisted_1 = {
  class: "column"
};
const _hoisted_2 = {
  class: "content"
};
const _hoisted_3 = {
  class: "left floated author"
};
const _hoisted_4 = ["src"];
const _hoisted_5 = {
  class: "extra content"
};
const _hoisted_6 = {
  class: "meta"
};

const _hoisted_7 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("i", {
  class: "map marker alternate icon"
}, null, -1
/* HOISTED */
);

const _hoisted_8 = {
  class: "meta"
};

const _hoisted_9 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("i", {
  class: "phone icon"
}, null, -1
/* HOISTED */
);

function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", _hoisted_1, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("div", {
    class: "ui blue fluid card",
    onClick: _cache[0] || (_cache[0] = $event => $setup.updateCenter($props.retailer.latitude, $props.retailer.longitude))
  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("div", _hoisted_2, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("div", _hoisted_3, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("img", {
    class: "ui avatar image",
    src: $props.image
  }, null, 8
  /* PROPS */
  , _hoisted_4), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createTextVNode)(" " + (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)($props.retailer.name), 1
  /* TEXT */
  )])]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("div", _hoisted_5, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("div", _hoisted_6, [_hoisted_7, (0,vue__WEBPACK_IMPORTED_MODULE_0__.createTextVNode)((0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)($props.retailer.street) + ", " + (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)($props.retailer.city.toUpperCase()) + " " + (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)($props.retailer.postcode), 1
  /* TEXT */
  )]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("div", _hoisted_8, [_hoisted_9, (0,vue__WEBPACK_IMPORTED_MODULE_0__.createTextVNode)((0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)($setup.formatPhoneNumber($props.retailer.phoneNumber)), 1
  /* TEXT */
  )])])])]);
}

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/Resources/private/js/components/TheSearch.vue?vue&type=template&id=6f7752f2":
/*!*******************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/Resources/private/js/components/TheSearch.vue?vue&type=template&id=6f7752f2 ***!
  \*******************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": function() { return /* binding */ render; }
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm-bundler.js");

const _hoisted_1 = {
  class: "ui action input"
};
const _hoisted_2 = ["placeholder"];
function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", _hoisted_1, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)((0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("input", {
    id: "retailerAddress",
    type: "text",
    placeholder: $setup.searchFieldText,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => $setup.userInput = $event)
  }, null, 8
  /* PROPS */
  , _hoisted_2), [[vue__WEBPACK_IMPORTED_MODULE_0__.vModelText, $setup.userInput]]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("button", {
    class: "ui button blue",
    onClick: _cache[1] || (_cache[1] = function () {
      return $setup.search && $setup.search(...arguments);
    })
  }, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)($setup.findButtonText), 1
  /* TEXT */
  )]);
}

/***/ }),

/***/ "./node_modules/leaflet/dist/leaflet.css":
/*!***********************************************!*\
  !*** ./node_modules/leaflet/dist/leaflet.css ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./node_modules/semantic-ui-css/semantic.min.css":
/*!*******************************************************!*\
  !*** ./node_modules/semantic-ui-css/semantic.min.css ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./node_modules/mini-css-extract-plugin/dist/loader.js??clonedRuleSet-4.use[0]!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-4.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-4.use[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/Resources/private/js/App.vue?vue&type=style&index=0&id=43325c2c&scoped=true&lang=css":
/*!*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/mini-css-extract-plugin/dist/loader.js??clonedRuleSet-4.use[0]!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-4.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-4.use[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/Resources/private/js/App.vue?vue&type=style&index=0&id=43325c2c&scoped=true&lang=css ***!
  \*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./node_modules/mini-css-extract-plugin/dist/loader.js??clonedRuleSet-4.use[0]!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-4.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-4.use[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/Resources/private/js/components/RetailerMapIcon.vue?vue&type=style&index=0&id=58261f73&scoped=true&lang=css":
/*!****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/mini-css-extract-plugin/dist/loader.js??clonedRuleSet-4.use[0]!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-4.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-4.use[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/Resources/private/js/components/RetailerMapIcon.vue?vue&type=style&index=0&id=58261f73&scoped=true&lang=css ***!
  \****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./node_modules/mini-css-extract-plugin/dist/loader.js??clonedRuleSet-4.use[0]!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-4.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-4.use[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/Resources/private/js/components/TheMap.vue?vue&type=style&index=0&id=fbd115e6&scoped=true&lang=css":
/*!*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/mini-css-extract-plugin/dist/loader.js??clonedRuleSet-4.use[0]!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-4.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-4.use[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/Resources/private/js/components/TheMap.vue?vue&type=style&index=0&id=fbd115e6&scoped=true&lang=css ***!
  \*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./node_modules/semantic-ui-vue/dist/commonjs/semantic-ui-vue.js":
/*!***********************************************************************!*\
  !*** ./node_modules/semantic-ui-vue/dist/commonjs/semantic-ui-vue.js ***!
  \***********************************************************************/
/***/ (function(module) {

module.exports=function(e){var t={};function i(n){if(t[n])return t[n].exports;var r=t[n]={i:n,l:!1,exports:{}};return e[n].call(r.exports,r,r.exports,i),r.l=!0,r.exports}return i.m=e,i.c=t,i.d=function(e,t,n){i.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},i.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},i.t=function(e,t){if(1&t&&(e=i(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(i.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var r in e)i.d(n,r,function(t){return e[t]}.bind(null,r));return n},i.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return i.d(t,"a",t),t},i.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},i.p="/",i(i.s=1)}([function(e,t,i){"use strict";function n(){return(n=Object.assign||function(e){for(var t,i=1;i<arguments.length;i++)for(var n in t=arguments[i])Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e}).apply(this,arguments)}var r=["attrs","props","domProps"],s=["class","style","directives"],o=["on","nativeOn"],a=function(e,t){return function(){e&&e.apply(this,arguments),t&&t.apply(this,arguments)}};e.exports=function(e){return e.reduce((function(e,t){for(var i in t)if(e[i])if(-1!==r.indexOf(i))e[i]=n({},e[i],t[i]);else if(-1!==s.indexOf(i)){var c=e[i]instanceof Array?e[i]:[e[i]],l=t[i]instanceof Array?t[i]:[t[i]];e[i]=c.concat(l)}else if(-1!==o.indexOf(i))for(var d in t[i])if(e[i][d]){var u=e[i][d]instanceof Array?e[i][d]:[e[i][d]],h=t[i][d]instanceof Array?t[i][d]:[t[i][d]];e[i][d]=u.concat(h)}else e[i][d]=t[i][d];else if("hook"==i)for(var p in t[i])e[i][p]=e[i][p]?a(e[i][p],t[i][p]):t[i][p];else e[i]=t[i];else e[i]=t[i];return e}),{})}},function(e,t,i){"use strict";i.r(t);var n={};i.r(n),i.d(n,"Breadcrumb",(function(){return U})),i.d(n,"BreadcrumbDivider",(function(){return N})),i.d(n,"BreadcrumbSection",(function(){return R})),i.d(n,"Form",(function(){return W})),i.d(n,"FormField",(function(){return Y})),i.d(n,"FormFields",(function(){return K})),i.d(n,"Grid",(function(){return X})),i.d(n,"GridColumn",(function(){return J})),i.d(n,"GridRow",(function(){return Z})),i.d(n,"Menu",(function(){return re})),i.d(n,"MenuHeader",(function(){return se})),i.d(n,"MenuItem",(function(){return ee})),i.d(n,"MenuMenu",(function(){return oe})),i.d(n,"Message",(function(){return ue})),i.d(n,"MessageContent",(function(){return ae})),i.d(n,"MessageHeader",(function(){return ce})),i.d(n,"MessageItem",(function(){return le})),i.d(n,"MessageList",(function(){return de})),i.d(n,"Table",(function(){return he})),i.d(n,"TableBody",(function(){return pe})),i.d(n,"TableCell",(function(){return fe})),i.d(n,"TableFooter",(function(){return me})),i.d(n,"TableHeader",(function(){return ge})),i.d(n,"TableHeaderCell",(function(){return be})),i.d(n,"TableRow",(function(){return ye}));var r={};i.r(r),i.d(r,"floated",(function(){return ve}));var s={};i.r(s),i.d(s,"Button",(function(){return Se})),i.d(s,"ButtonContent",(function(){return we})),i.d(s,"ButtonGroup",(function(){return Ae})),i.d(s,"ButtonOr",(function(){return Be})),i.d(s,"Container",(function(){return Ce})),i.d(s,"Divider",(function(){return je})),i.d(s,"Flag",(function(){return Ee})),i.d(s,"Header",(function(){return Te})),i.d(s,"HeaderContent",(function(){return $e})),i.d(s,"HeaderSubheader",(function(){return Le})),i.d(s,"Icon",(function(){return Q})),i.d(s,"IconGroup",(function(){return ke})),i.d(s,"Image",(function(){return De})),i.d(s,"ImageGroup",(function(){return Ie})),i.d(s,"Input",(function(){return Re})),i.d(s,"Label",(function(){return Ne})),i.d(s,"LabelDetail",(function(){return He})),i.d(s,"List",(function(){return We})),i.d(s,"ListContent",(function(){return _e})),i.d(s,"ListDescription",(function(){return Ye})),i.d(s,"ListHeader",(function(){return Ke})),i.d(s,"ListIcon",(function(){return Ge})),i.d(s,"ListItem",(function(){return Ue})),i.d(s,"ListList",(function(){return Xe})),i.d(s,"Loader",(function(){return Je})),i.d(s,"Rail",(function(){return Ze})),i.d(s,"Reveal",(function(){return Qe})),i.d(s,"RevealContent",(function(){return et})),i.d(s,"Segment",(function(){return tt})),i.d(s,"Segments",(function(){return it})),i.d(s,"Step",(function(){return ot})),i.d(s,"StepContent",(function(){return st})),i.d(s,"StepDescription",(function(){return nt})),i.d(s,"StepGroup",(function(){return dt})),i.d(s,"StepTitle",(function(){return rt}));var o={};i.r(o),i.d(o,"Accordion",(function(){return pt})),i.d(o,"AccordionContent",(function(){return bt})),i.d(o,"AccordionTitle",(function(){return St})),i.d(o,"Checkbox",(function(){return wt})),i.d(o,"Dimmer",(function(){return At})),i.d(o,"DimmerDimmable",(function(){return Ot})),i.d(o,"Dropdown",(function(){return Vt})),i.d(o,"DropdownDivider",(function(){return qt})),i.d(o,"DropdownHeader",(function(){return Gt})),i.d(o,"DropdownItem",(function(){return Ct})),i.d(o,"DropdownMenu",(function(){return Lt})),i.d(o,"Embed",(function(){return _t})),i.d(o,"Modal",(function(){return Qt})),i.d(o,"ModalActions",(function(){return ei})),i.d(o,"ModalContent",(function(){return ti})),i.d(o,"ModalDescription",(function(){return ii})),i.d(o,"ModalHeader",(function(){return ni})),i.d(o,"Rating",(function(){return ai})),i.d(o,"Search",(function(){return bi})),i.d(o,"Sidebar",(function(){return yi})),i.d(o,"SidebarPushable",(function(){return vi})),i.d(o,"SidebarPusher",(function(){return Si})),i.d(o,"Popup",(function(){return Ei})),i.d(o,"PopupContent",(function(){return ji})),i.d(o,"PopupHeader",(function(){return Ci})),i.d(o,"Progress",(function(){return Ti})),i.d(o,"TabPane",(function(){return Mi})),i.d(o,"Tab",(function(){return Ii}));var a={};i.r(a),i.d(a,"Card",(function(){return Fi})),i.d(a,"CardContent",(function(){return zi})),i.d(a,"CardDescription",(function(){return Ri})),i.d(a,"CardGroup",(function(){return Ni})),i.d(a,"CardHeader",(function(){return Hi})),i.d(a,"CardMeta",(function(){return Vi})),i.d(a,"Comment",(function(){return qi})),i.d(a,"CommentAction",(function(){return Gi})),i.d(a,"CommentActions",(function(){return _i})),i.d(a,"CommentAuthor",(function(){return Ui})),i.d(a,"CommentAvatar",(function(){return Wi})),i.d(a,"CommentContent",(function(){return Yi})),i.d(a,"CommentGroup",(function(){return Ki})),i.d(a,"CommentMetadata",(function(){return Xi})),i.d(a,"CommentText",(function(){return Ji})),i.d(a,"Feed",(function(){return nn})),i.d(a,"FeedContent",(function(){return rn})),i.d(a,"FeedDate",(function(){return sn})),i.d(a,"FeedEvent",(function(){return Zi})),i.d(a,"FeedExtra",(function(){return on})),i.d(a,"FeedLabel",(function(){return an})),i.d(a,"FeedLike",(function(){return cn})),i.d(a,"FeedMeta",(function(){return ln})),i.d(a,"FeedSummary",(function(){return dn})),i.d(a,"FeedUser",(function(){return un})),i.d(a,"Item",(function(){return hn})),i.d(a,"ItemGroup",(function(){return pn})),i.d(a,"ItemContent",(function(){return fn})),i.d(a,"ItemImage",(function(){return mn})),i.d(a,"ItemHeader",(function(){return gn})),i.d(a,"ItemMeta",(function(){return bn})),i.d(a,"ItemDescription",(function(){return yn})),i.d(a,"ItemExtra",(function(){return vn})),i.d(a,"Statistic",(function(){return Sn})),i.d(a,"StatisticValue",(function(){return wn})),i.d(a,"StatisticLabel",(function(){return An})),i.d(a,"StatisticGroup",(function(){return On})),i.d(a,"Advertisement",(function(){return xn}));var c=i(0),l=i.n(c);function d(e){return(d="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}var u="object"===("undefined"==typeof document?"undefined":d(document))&&null!==document,h="object"===("undefined"==typeof window?"undefined":d(window))&&null!==window&&window.self===window,p=u&&h;function f(e){return(f="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function m(e){return e.match(/[A-Z\xC0-\xD6\xD8-\xDE]?[a-z\xDF-\xF6\xF8-\xFF]+|[A-Z\xC0-\xD6\xD8-\xDE]+(?![a-z\xDF-\xF6\xF8-\xFF])|\d+/g)}function g(e){return e.charAt(0).toUpperCase()+e.slice(1)}function b(e){return m(e).reduce((function(e,t){var i=t.toLowerCase();return e+(e?g(i):i)}),"")}function y(e){return m(e).map((function(e){return e.toLowerCase()})).join("-")}function v(e){return e.filter((function(t,i){return e.indexOf(t)===i}))}function S(e,t){var i=Object.assign({},e);return Object.keys(t).forEach((function(e){var n=t[e];Object.prototype.hasOwnProperty.call(i,e)?"object"===f(n)&&"object"===f(i[e])&&(i[e]=S(i[e],n)):i[e]=n})),i}function w(e,t){var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;return t.split(".").reduce((function(e,t){return e&&Object.prototype.hasOwnProperty.call(e,t)?e[t]:i}),e)}function A(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n)}return i}function O(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}function x(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){if(!(Symbol.iterator in Object(e)||"[object Arguments]"===Object.prototype.toString.call(e)))return;var i=[],n=!0,r=!1,s=void 0;try{for(var o,a=e[Symbol.iterator]();!(n=(o=a.next()).done)&&(i.push(o.value),!t||i.length!==t);n=!0);}catch(e){r=!0,s=e}finally{try{n||null==a.return||a.return()}finally{if(r)throw s}}return i}(e,t)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}()}function P(e){return(P="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function B(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){if(!(Symbol.iterator in Object(e)||"[object Arguments]"===Object.prototype.toString.call(e)))return;var i=[],n=!0,r=!1,s=void 0;try{for(var o,a=e[Symbol.iterator]();!(n=(o=a.next()).done)&&(i.push(o.value),!t||i.length!==t);n=!0);}catch(e){r=!0,s=e}finally{try{n||null==a.return||a.return()}finally{if(r)throw s}}return i}(e,t)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}()}function C(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n)}return i}function j(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}function E(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){if(!(Symbol.iterator in Object(e)||"[object Arguments]"===Object.prototype.toString.call(e)))return;var i=[],n=!0,r=!1,s=void 0;try{for(var o,a=e[Symbol.iterator]();!(n=(o=a.next()).done)&&(i.push(o.value),!t||i.length!==t);n=!0);}catch(e){r=!0,s=e}finally{try{n||null==a.return||a.return()}finally{if(r)throw s}}return i}(e,t)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}()}var T=["one","two","three","four","five","six","seven","eight","nine","ten","eleven","twelve","thirteen","fourteen","fifteen","sixteen"];var $={name:"API",namespace:"api",debug:!1,verbose:!1,performance:!0,api:{},cache:!0,interruptRequests:!0,on:"auto",stateContext:!1,loadingDuration:0,hideError:"auto",errorDuration:2e3,encodeParameters:!0,action:!1,url:!1,base:"",urlData:{},defaultData:!0,serializeForm:!1,throttle:0,throttleFirstRequest:!0,method:"get",data:{},dataType:"json",mockResponse:!1,mockResponseAsync:!1,response:!1,responseAsync:!1,beforeSend:function(e){return e},beforeXHR:function(e){},onRequest:function(e,t){},onResponse:!1,onSuccess:function(e,t){},onComplete:function(e,t){},onFailure:function(e,t){},onError:function(e,t){},onAbort:function(e,t){},successTest:!1,error:{beforeSend:"The before send function has aborted the request",error:"There was an error with your request",exitConditions:"API Request Aborted. Exit conditions met",JSONParse:"JSON could not be parsed during error handling",legacyParameters:"You are using legacy API success callback names",method:"The method you called is not defined",missingAction:"API action used but no url was defined",missingSerialize:"jquery-serialize-object is required to add form data to an existing data object",missingURL:"No URL specified for api event",noReturnedValue:"The beforeSend callback must return a settings object, beforeSend ignored.",noStorage:"Caching responses locally requires session storage",parseError:"There was an error parsing your request",requiredParameter:"Missing a required URL parameter: ",statusMessage:"Server gave an error: ",timeout:"Your request timed out"},regExp:{required:/\{\$*[A-z0-9]+\}/g,optional:/\{\/\$*[A-z0-9]+\}/g},className:{loading:"loading",error:"error"},selector:{disabled:".disabled",form:"form"},metadata:{action:"action",url:"url"}},L={inject:{_sui:{from:"sui",default:function(){return{api:{}}}}},props:{sui:{type:Object,default:function(){return{api:S(this._sui?this._sui.api:{},$)}}}},methods:{num:function(e){return"number"==typeof e?T[e-1]:e},classes:function(){for(var e=arguments.length,t=new Array(e),i=0;i<e;i++)t[i]=arguments[i];return t.filter((function(e){return e&&!0!==e})).join(" ")},getEndpoint:function(e,t){var i=w(this.sui,"api.api.".concat(e));if(!i)throw new Error("Action '".concat(e,"' not provided"));var n=w(this.sui,"api.base",""),r="".concat(n).concat(i);return Object.keys(t).reduce((function(e,i){return e.replace("{".concat(i,"}"),t[i])}),r)},executeAction:function(e,t){var i,n,r=(i=this.sui.api.method,n=e,new Promise((function(e,t){var r=new XMLHttpRequest;r.open(i,n,!0),r.onreadystatechange=function(){4===this.readyState&&(this.status>=200&&this.status<400?e(JSON.parse(this.responseText)):t(this.response))},r.send()})));return this.sui.api.onResponse&&(r=r.then(this.sui.api.onResponse)),r},getElementType:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"div",t=this.$vnode&&this.$vnode.data.tag;if(!t||"component"===t)return e;var i=this.$vnode.context,n=Object.entries(i.$options.components||{}).find((function(e){return y(E(e,1)[0])===t}));return n?n[1]:t},getChildProps:function(){if(!this.$vnode||!this.$vnode.data.attrs)return{};var e,t=this.getElementType();if("string"==typeof t){var i,n=this.$options.components,r=n[t]||n[i=b(t)]||n[g(i)];if(!r)return{};e=r.options.props}else{if("object"!==P(t))return{};e=t.props}return Object.entries(this.$vnode.data.attrs).filter((function(t){return b(x(t,1)[0])in e})).map((function(t){var i=x(t,2),n=i[0],r=i[1],s=b(n);return e[s].type===Boolean?!1===r?[s,!1]:[s,!0]:[s,r]})).reduce((function(e,t){var i=x(t,2);return function(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?A(Object(i),!0).forEach((function(t){O(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):A(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}({},e,O({},i[0],i[1]))}),{})},getChildListeners:function(){var e=function(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?C(Object(i),!0).forEach((function(t){j(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):C(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}({},this.$listeners);return Object.entries(this.$options.events||{}).forEach((function(t){var i=B(t,2),n=i[0];i[1].custom&&delete e[n]})),e},getChildPropsAndListeners:function(){var e=this.getChildProps();return{props:e,attrs:e,on:this.getChildListeners()}}}},k={methods:{getUIClass:function(){var e=this.constructor.options&&this.constructor.options.name,t=this.$parent&&this.$parent.constructor.options&&this.$parent.constructor.options.name;return e&&t&&t.match(new RegExp("^".concat(e,".*Group$")))?"":"ui"},getParentName:function(){return this.$parent&&this.$parent.constructor.options&&this.$parent.constructor.options.name||""}}},D=function(){return window&&window.webkitAnimationEnd?"webkitAnimationEnd":"animationend"};function I(e){return e&&("justify"===e?"justified":"".concat(e," aligned"))}function M(e){return e&&"".concat(e," flipped")}function F(e){return e&&"".concat(e," rotated")}function z(e){return e&&"".concat(e," corner")}var R={name:"SuiBreadcrumbSection",mixins:[L],props:{active:Boolean,link:Boolean},render:function(){var e=arguments[0],t=this.getElementType(this.link?"a":"div");return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes(this.active&&"active",this.link&&"link","section")}]),[this.$slots.default])},meta:{parent:"SuiBreadcrumb"}},N={name:"SuiBreadcrumbDivider",mixins:[L],props:{icon:String},render:function(){var e=arguments[0],t=this.getElementType(this.icon?"i":"div");return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes(this.icon,this.icon&&"icon","divider")}]),[!this.icon&&(this.$slots.default||"/")])},meta:{parent:"SuiBreadcrumb"}};function H(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n)}return i}function V(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?H(Object(i),!0).forEach((function(t){q(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):H(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}function q(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}function G(e){return function(e){if(Array.isArray(e)){for(var t=0,i=new Array(e.length);t<e.length;t++)i[t]=e[t];return i}}(e)||function(e){if(Symbol.iterator in Object(e)||"[object Arguments]"===Object.prototype.toString.call(e))return Array.from(e)}(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance")}()}function _(){var e,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=G(t);Array.isArray(i.choices)&&n.push.apply(n,G(i.choices));var r=v(t.map((function(e){return e.constructor})));return i.type?Array.isArray(i.type)?(i.type.includes(Boolean)&&n.unshift(!0),e=v([].concat(G(i.type),G(r)))):(i.type===Boolean&&n.unshift(!0),e=v([i.type].concat(G(r)))):e=1===r.length?r[0]:r,V({},i,{choices:n,type:e,validator:function(e){return!r.includes(e.constructor)||n.includes(e)}})}Object.defineProperty(_,"Extend",{value:function(e){return function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return _(e,t)}}}),_.State=_.Extend(["active","disabled","error","warning","success"]),_.Size=_.Extend(["mini","tiny","small","standard","medium","large","big","huge","massive"]),_.Color=_.Extend(["red","orange","yellow","olive","green","teal","blue","violet","purple","pink","brown","grey","black"]),_.Attached=_.Extend(["top","bottom"]),_.TextAlign=_.Extend(["left","right","center","justified"]),_.VerticalAlign=_.Extend(["top","middle","bottom"]),_.Social=_.Extend(["facebook","twitter","google","google plus","vk","instagram","linkedin","youtube"]),_.Number=_.Extend([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,"one","two","three","four","five","six","seven","eight","nine","ten","eleven","twelve","thirteen","fourteen","fifteen","sixteen"]),_.Padded=_.Extend(["very"]),_.Emphasis=_.Extend(["secondary","tertiary"]),_.Floated=_.Extend(["right","left"]),_.Direction=_.Extend(["horizontally","vertically"]),_.RotateDirection=_.Extend(["clockwise","counterclockwise"]),_.Corner=_.Extend(["top left","top right","bottom left","bottom right"]);var U={name:"SuiBreadcrumb",components:{SuiBreadcrumbDivider:N,SuiBreadcrumbSection:R},mixins:[L],props:{icon:String,sections:Array,size:_.Size()},render:function(){var e=this,t=arguments[0],i=this.getElementType();return t(i,l()([{},this.getChildPropsAndListeners(),{class:this.classes("ui",this.size,"breadcrumb")}]),[this.$slots.default||this.sections.map((function(i,n){var r=i.active,s=i.content,o=i.key,a=i.link,c=t(R,{key:o,attrs:{active:r,link:a}},[s]);return 0===n?c:[" ",t(N,{attrs:{icon:e.icon}})," ",c]}))])}},W={name:"SuiForm",mixins:[L],props:{size:_.Size({description:"A form can vary in size."}),loading:{type:Boolean,description:"If a form is in loading state, it will automatically show a loading indicator."},success:{type:Boolean,description:"Automatically show any success Message children."},warning:{type:Boolean,description:"Automatically show any warning Message children."},error:{type:Boolean,description:"Automatically show any error Message children."},state:_(["success","warning","error","loading"],{description:"You can set the state of form using one variable"}),inverted:{type:Boolean,description:"A form can have its color inverted for contrast."},equalWidth:{type:Boolean,description:"Forms can automatically divide fields to be equal width."},unstackable:{type:Boolean,description:"A form can prevent itself from stacking on mobile."}},render:function(){var e=arguments[0],t=this.getElementType("form");return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes("ui",this.unstackable&&"unstackable",this.equalWidth&&"equal width",this.inverted&&"inverted",this.size,this.loading&&"loading","form",this.success&&"success",this.warning&&"warning",this.error&&"error",this.state)}]),[this.$slots.default])}},Y={name:"SuiFormField",mixins:[L],props:{width:_.Number({description:"A field can specify its width in grid columns"}),inline:{type:Boolean,description:"A field can have its label next to instead of above it."},required:{type:Boolean,description:"A field can show that input is mandatory."},disabled:{type:Boolean,description:"Individual fields may be disabled."},error:{type:Boolean,description:"Individual fields may display an error state."}},render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes(this.width&&"".concat(this.num(this.width)," wide"),this.inline&&"inline",this.required&&"required",this.disabled&&"disabled","field",this.error&&"error")}]),[this.$slots.default])},meta:{parent:"SuiForm"}},K={name:"SuiFormFields",mixins:[L],props:{inline:{type:Boolean,description:"Multiple fields may be inline in a row."},equalWidth:{type:Boolean,description:"Field group can automatically divide fields to be equal width."},grouped:{type:Boolean,description:"Fields can show related choices."},fields:_.Number({choices:["equal"],description:"Represents number of fields in group"}),unstackable:{type:Boolean,description:"A form group can prevent itself from stacking on mobile."}},render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes(this.unstackable&&"unstackable",this.inline&&"inline",this.equalWidth&&"equal width",this.grouped&&"grouped",this.num(this.fields),"fields")}]),[this.$slots.default])},meta:{parent:"SuiForm"}},X={name:"SuiGrid",mixins:[L],description:"A grid is used to harmonize negative space in a layout.",props:{celled:_(["internally"],{type:Boolean,description:"A grid can have rows divided into cells."}),centered:{type:Boolean,description:"A grid can have its columns centered."},columns:_.Number({choices:["equal"],description:"Represents column count per row in Grid."}),container:{type:Boolean,description:"A grid can be combined with a container to use the available layout and alignment."},divided:_(["vertically"],{type:Boolean,description:"A grid can have dividers between its columns."}),doubling:{type:Boolean,description:"A grid can double its column width on tablet and mobile sizes."},padded:_(["horizontally","vertically"],{type:Boolean,description:"A grid can preserve its vertical and horizontal gutters on first and last columns."}),relaxed:_(["very"],{type:Boolean,description:"A grid can increase its gutters to allow for more negative space."}),reversed:_(["mobile","tablet","computer"],{description:"A grid can specify that its columns should reverse order at different device types."}),stackable:{type:Boolean,description:"A grid can have its columns stack on-top of each other after reaching mobile breakpoints."},stretched:{type:Boolean,description:"A grid can stretch its contents to take up the entire grid height."},textAlign:_.TextAlign({description:"A grid can specify its text alignment."}),verticalAlign:_.VerticalAlign({description:"A grid can specify its vertical alignment to have all its columns vertically centered."}),verticallyReversed:_(["mobile","tablet","computer"],{description:"A grid can specify that its rows should reverse order at different device types."})},render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes("ui",this.reversed&&"".concat(this.reversed," reversed"),this.verticallyReversed&&"".concat(this.verticallyReversed," vertically reversed"),this.columns&&"".concat(this.num(this.columns)," column"),this.stackable&&"stackable",this.stretched&&"stretched",this.doubling&&"doubling",this.padded,this.padded&&"padded",this.verticalAlign,this.verticalAlign&&"aligned",I(this.textAlign),this.centered&&"centered",this.divided,this.divided&&"divided",this.celled,this.celled&&"celled",this.relaxed,this.relaxed&&"relaxed","grid",this.container&&"container")}]),[this.$slots.default])}},J={name:"SuiGridColumn",mixins:[L],description:"A column sub-component for Grid.",props:{color:_.Color({description:"A grid column can be colored."}),centered:Boolean,width:_.Number({description:"Represents width of column."}),mobile:_.Number({description:"A column can specify a width for a mobile device."}),tablet:_.Number({description:"A column can specify a width for a tablet device."}),computer:_.Number({description:"A column can specify a width for a computer."}),largeScreen:_.Number({description:"A column can specify a width for a large screen device."}),widescreen:_.Number({description:"A column can specify a width for a widescreen device."}),floated:_(["left","right"],{description:"A column can sit flush against the left or right edge of a row."}),textAlign:_.TextAlign({description:"A column can specify its text alignment."}),verticalAlign:_.VerticalAlign({description:"A column can specify its vertical alignment to have all its columns vertically centered."}),only:_(["mobile","tablet","computer","widescreen","large screen"],{description:"A column can appear only for a specific device, or screen sizes."}),stretched:{type:Boolean,description:"A column can stretch its contents to take up the entire grid or row height."}},render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes(this.floated&&"".concat(this.floated," floated"),I(this.textAlign),this.verticalAlign&&"".concat(this.verticalAlign," aligned"),this.width&&"".concat(this.num(this.width)," wide"),this.mobile&&"".concat(this.num(this.mobile)," wide mobile"),this.tablet&&"".concat(this.num(this.tablet)," wide tablet"),this.computer&&"".concat(this.num(this.computer)," wide computer"),this.widescreen&&"".concat(this.num(this.widescreen)," wide widescreen"),this.largeScreen&&"".concat(this.num(this.largeScreen)," wide large screen"),this.only&&"".concat(this.only," only"),this.centered&&"centered",this.stretched&&"stretched",this.color,"column")}]),[this.$slots.default])},meta:{parent:"SuiGrid"}},Z={name:"SuiGridRow",mixins:[L],description:"A row sub-component for Grid",props:{columns:_.Number({description:"Represents column count per line in Row."}),centered:{type:Boolean,description:"A row can have its columns centered."},only:_(["mobile","tablet","computer","widescreen","large screen"],{description:"A row can appear only for a specific device, or screen sizes."}),divided:{type:Boolean,description:"A row can have dividers between its columns."},color:_.Color({description:"A grid row can be colored."}),reversed:_(["mobile","tablet","computer"],{description:"A row can specify that its columns should reverse order at different device types."}),stretched:{type:Boolean,description:"A row can stretch its contents to take up the entire column height."},textAlign:_.TextAlign({description:"A row can specify its text alignment."}),verticalAlign:_.VerticalAlign({description:"A row can specify its vertical alignment to have all its columns vertically centered."})},render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes(this.reversed&&"".concat(this.reversed," reversed"),this.only&&"".concat(this.only," only"),this.divided&&"divided",I(this.textAlign),this.verticalAlign&&"".concat(this.verticalAlign," aligned"),this.centered&&"centered",this.stretched&&"stretched",this.color,this.columns&&"".concat(this.num(this.columns)," column"),"row")}]),[this.$slots.default])},meta:{parent:"SuiGrid"}},Q={name:"SuiIcon",mixins:[L],props:{bordered:{type:Boolean,description:"Add squared border to icon."},circular:{type:Boolean,description:"Add circular border to icon."},color:_.Color({description:"Icon color."}),corner:_.Corner({type:[Boolean,String],description:"Align icon to corner"}),disabled:{type:Boolean,description:'Reducing icon opacity to create "disabled icon" effect.'},fitted:{type:Boolean,description:"Remove margin from icon"},flipped:_.Direction({description:"Icon flip direction."}),inverted:{type:Boolean,description:"Add black background to icon, also change icon color to contrasted variant."},link:{type:Boolean,description:"Add hover animation to icon."},loading:{type:Boolean,description:"Add rotate animation to icon."},name:{type:String,required:!0,description:"Icon name."},outline:{type:Boolean,description:"Set font-family icon to outlined"},rotated:_.RotateDirection({description:"Icon rotate direction."}),size:_.Size({description:"Icon size."})},render:function(){var e=arguments[0],t=this.getElementType("i");return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes(M(this.flipped),F(this.rotated),this.bordered&&"bordered",this.circular&&"circular",this.inverted&&"inverted",z(this.corner),this.color,this.name,this.size,this.disabled&&"disabled",this.fitted&&"fitted",this.link&&"link",this.loading&&"loading",this.outline&&"outline","icon")}]))}},ee={name:"SuiMenuItem",mixins:[L],props:{active:{type:Boolean,description:"A menu item can be active."},color:_.Color({description:"Additional colors can be specified."}),content:{type:String,description:"Shorthand for primary content."},header:{type:Boolean,description:"A menu item may include a header or may itself be a header."},icon:{type:[Boolean,String],description:"MenuItem can be only icon."},link:{type:Boolean,description:"A menu item can be link."},position:_(["left","right"],{description:"A menu item can take left or right position."}),disabled:{type:Boolean,description:"A menu item can be disabled."},fitted:_(["horizontally","vertically"],{type:Boolean,description:"A menu item or menu can remove element padding, vertically or horizontally.."})},render:function(){var e=arguments[0],t=this.getElementType(this.link?"a":"div");return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes(this.disabled&&"disabled",this.active&&"active",this.fitted,this.fitted&&"fitted",this.header&&"header",this.link&&"link",this.icon&&"icon",this.position,"item")}]),["string"==typeof this.icon&&e(Q,{attrs:{name:this.icon}}),this.$slots.default||this.content])},meta:{parent:"SuiMenu"}};function te(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n)}return i}function ie(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?te(Object(i),!0).forEach((function(t){ne(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):te(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}function ne(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}var re={name:"SuiMenu",components:{SuiMenuItem:ee},mixins:[L],props:{activeIndex:{type:Number,description:"Index of the currently active item."},attached:_.Attached({type:Boolean,description:"A menu may be attached to other content segments."}),color:_.Color({description:"Additional colors can be specified."}),compact:{type:Boolean,description:"A menu can take up only the space necessary to fit its content."},fixed:_(["right","left","bottom","top"],{description:"A menu can be fixed to a side of its context.",type:Boolean}),icon:_(["labeled"],{type:Boolean,description:"A menu may have just icons (bool) or labeled icons"}),inverted:{type:Boolean,description:"A menu may have its colors inverted to show greater contrast."},items:{type:Array,description:"Shorthand array of props for Menu items."},floated:_(["right"],{type:Boolean,description:"A menu can be floated."}),fluid:{type:Boolean,default:!1,description:"A vertical menu may take the size of its container."},secondary:{type:Boolean,description:"A menu can adjust its appearance to de-emphasize its contents."},pointing:{type:Boolean,description:"A menu can point to show its relationship to nearby content."},tabular:_(["right"],{type:Boolean,description:"A menu can be formatted to show tabs of information"}),text:{type:Boolean,description:"A menu can be formatted for text content."},vertical:{type:Boolean,description:"A vertical menu displays elements vertically."},widths:_.Number({description:"A menu can have its items divided evenly."}),borderless:{type:Boolean,default:!1,description:"A menu item or menu can have no borders."},pagination:{type:Boolean,description:"A pagination menu is specially formatted to present links to pages of content."}},render:function(){var e=this,t=arguments[0],i=this.getElementType();return t(i,l()([{},this.getChildPropsAndListeners(),{class:this.classes("ui",this.attached&&"".concat(this.attached," attached"),this.vertical&&"vertical",this.fluid&&"fluid",this.compact&&"compact",this.fixed&&"".concat(this.fixed," fixed"),this.text&&"text",this.icon,this.icon&&"icon",this.inverted&&"inverted",this.pagination&&"pagination",this.borderless&&"borderless",this.floated,this.floated&&"floated",this.widths&&"".concat(this.num(this.widths)," item"),this.secondary&&"secondary",this.pointing&&"pointing",this.tabular,this.tabular&&"tabular",this.color,"menu")}]),[this.$slots.default||this.items&&this.items.map((function(i,n){return t(ee,{props:ie({},i),attrs:{active:i.active||e.activeIndex===n}})}))])}},se={name:"SuiMenuHeader",mixins:[L],props:{content:{type:String,description:"Shorthand for primary content."}},render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:"header"}]),[this.$slots.default||this.content])},meta:{parent:"SuiMenu"}},oe={name:"SuiMenuMenu",mixins:[L],props:{position:_(["left","right"],{description:"A sub menu can take left or right position"})},render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes(this.position,"menu")}]),[this.$slots.default])},meta:{parent:"SuiMenu"}},ae={name:"SuiMessageContent",mixins:[L],render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes("content")}]),[this.$slots.default])},meta:{parent:"SuiMessage"}},ce={name:"SuiMessageHeader",mixins:[L],render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes("header")}]),[this.$slots.default])},meta:{parent:"SuiMessage"}},le={name:"SuiMessageItem",mixins:[L],render:function(){var e=arguments[0],t=this.getElementType("li");return e(t,l()([{},this.getChildPropsAndListeners()]),[this.$slots.default])},meta:{parent:"SuiMessage"}},de={name:"SuiMessageList",mixins:[L],render:function(){var e=arguments[0],t=this.getElementType("ul");return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes("list")}]),[this.$slots.default])},meta:{parent:"SuiMessage"}},ue={name:"SuiMessage",components:{SuiIcon:Q,SuiMessageContent:ae,SuiMessageHeader:ce,SuiMessageItem:le,SuiMessageList:de},mixins:[L],props:{content:{type:String,description:"Shorthand for primary content."},dismissable:{type:Boolean,description:"A message can be dismissable"},header:{type:String,description:"Shorthand for SuiMessageHeader."},icon:{type:[Boolean,String],description:"A message can contain an icon."},list:{type:Array,description:"Array shorthand items for the SuiMessageList"},size:_(["mini","tiny","small","large","big","huge","massive"],{description:"A message can have different sizes."}),attached:_(["bottom","top"],{type:Boolean,description:"A message can be formatted to attach itself to other content."}),color:_.Color({description:"A message can be formatted to be different colors."}),compact:{type:Boolean,description:"A message can only take up the width of its content."},floating:{type:Boolean,description:"A message can float above content that it is related to."},info:{type:Boolean,description:"A message may be formatted to display information."},warning:{type:Boolean,description:"A message may be formatted to display warning messages."},error:{type:Boolean,description:"A message may be formatted to display a negative message. Same as `negative`."},negative:{type:Boolean,description:"A message may be formatted to display a negative message. Same as `error`."},success:{type:Boolean,description:"A message may be formatted to display a positive message. Same as `positive`."},positive:{type:Boolean,description:"A message may be formatted to display a positive message. Same as `success`."},hidden:{type:Boolean,description:"A message can be hidden."},visible:{type:Boolean,description:"A message can be set to visible to force itself to be shown."}},events:{dismiss:{custom:!0}},methods:{handleDismiss:function(){this.$emit("dismiss")}},render:function(){var e=arguments[0],t=[this.header&&e(ce,[this.header]),this.content,this.$slots.default,this.list&&e(de,[this.list.map((function(t){return e(le,[t])}))])],i=this.getElementType();return e(i,l()([{},this.getChildPropsAndListeners(),{class:this.classes("ui",this.color,this.size,this.floating&&"floating",this.info&&"info",this.warning&&"warning",this.success&&"success",this.positive&&"positive",this.error&&"error",this.negative&&"negative",this.attached,this.attached&&"attached",this.icon&&"icon",this.compact&&"compact",this.hidden&&"hidden",this.visible&&"visible","message")}]),[this.dismissable&&e(Q,{attrs:{name:"close"},nativeOn:{click:this.handleDismiss}}),"string"==typeof this.icon&&e(Q,{attrs:{name:this.icon}}),!this.icon&&t])}},he={name:"SuiTable",mixins:[L],description:"A table displays a collections of data grouped into rows.",props:{basic:_(["very"],{type:Boolean,description:"A table can reduce its complexity to increase readability."}),celled:Boolean,padded:_(["very"],{type:Boolean}),collapsing:Boolean,compact:_(["very"],{type:Boolean,description:"A table may sometimes need to be more compact to make more rows visible at a time."}),definition:Boolean,striped:Boolean,textAlign:_(["left","right","center"]),fixed:Boolean,unstackable:Boolean,stackable:Boolean,selectable:Boolean,inverted:Boolean,color:_.Color(),size:_(["small","large"]),singleLine:Boolean,columns:_.Number()},render:function(){var e=arguments[0],t=this.getElementType("table");return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes("ui",this.textAlign,this.textAlign&&"aligned",this.basic,this.basic&&"basic",this.celled&&"celled",this.padded,this.padded&&"padded",this.collapsing&&"collapsing",this.compact,this.compact&&"compact",this.definition&&"definition",this.striped&&"striped",this.fixed&&"fixed",this.unstackable&&"unstackable",this.stackable&&"tablet stackable",this.selectable&&"selectable",this.inverted&&"inverted",this.color,this.size,this.singleLine&&"single line",this.columns&&"".concat(this.num(this.columns)," column"),"table")}]),[this.$slots.default])}},pe={name:"SuiTableBody",mixins:[L],render:function(){var e=arguments[0],t=this.getElementType("tbody");return e(t,l()([{},this.getChildPropsAndListeners()]),[this.$slots.default])},meta:{parent:"SuiTable"}},fe={name:"SuiTableCell",mixins:[L],props:{negative:Boolean,positive:Boolean,selected:Boolean,textAlign:_(["left","right","center"]),warning:Boolean,singleLine:Boolean,collapsing:Boolean,disabled:Boolean,selectable:Boolean,width:_.Number(),state:_.State(),verticalAlign:_.VerticalAlign()},render:function(){var e=arguments[0],t=this.getElementType("td");return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes(this.textAlign&&"".concat(this.textAlign," aligned"),this.verticalAlign&&"".concat(this.verticalAlign," aligned"),this.negative&&"negative",this.positive&&"positive",this.warning&&"warning",this.singleLine&&"single line",this.collapsing&&"collapsing",this.disabled&&"disabled",this.selectable&&"selectable",this.width&&"".concat(this.num(this.width)," wide"),this.state)}]),[this.$slots.default])},meta:{parent:"SuiTable"}},me={name:"SuiTableFooter",mixins:[L],props:{fullWidth:Boolean},render:function(){var e=arguments[0],t=this.getElementType("tfoot");return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes(this.fullWidth&&"full-width")}]),[this.$slots.default])},meta:{parent:"SuiTable"}},ge={name:"SuiTableHeader",mixins:[L],props:{fullWidth:Boolean},render:function(){var e=arguments[0],t=this.getElementType("thead");return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes(this.fullWidth&&"full-width")}]),[this.$slots.default])},meta:{parent:"SuiTable"}},be={name:"SuiTableHeaderCell",mixins:[L],props:{negative:Boolean,positive:Boolean,selected:Boolean,textAlign:_(["left","right","center"]),warning:Boolean,singleLine:Boolean,collapsing:Boolean,disabled:Boolean,selectable:Boolean,width:_.Number(),verticalAlign:_.VerticalAlign()},render:function(){var e=arguments[0],t=this.getElementType("th");return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes(this.textAlign&&"".concat(this.textAlign," aligned"),this.verticalAlign&&"".concat(this.verticalAlign," aligned"),this.negative&&"negative",this.positive&&"positive",this.warning&&"warning",this.singleLine&&"single line",this.collapsing&&"collapsing",this.disabled&&"disabled",this.selectable&&"selectable",this.width&&"".concat(this.num(this.width)," wide"))}]),[this.$slots.default])},meta:{parent:"SuiTable"}},ye={name:"SuiTableRow",mixins:[L],props:{active:{description:"A row can be active or selected by a user.",type:Boolean},disabled:{description:"A row can be disabled.",type:Boolean},error:{description:"A row may call attention to an error or a negative value.",type:Boolean},negative:{description:"A row may let a user know whether a value is bad.",type:Boolean},positive:{description:"A row may let a user know whether a value is good.",type:Boolean},selected:{description:"DEPRECATED A row can be active or selected by a user.",type:Boolean},state:_.State({description:"DEPRECATED"}),textAlign:_(["left","right","center"],{description:"A table row can adjust its text alignment."}),verticalAlign:_.VerticalAlign({description:"A row may warn a user."}),warning:{description:"A row may warn a user.",type:Boolean}},render:function(){var e=arguments[0],t=this.getElementType("tr");return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes(this.textAlign&&"".concat(this.textAlign," aligned"),this.verticalAlign&&"".concat(this.verticalAlign," aligned"),this.disabled&&"disabled",this.error&&"error",this.negative&&"negative",this.positive&&"positive",(this.selected||this.active)&&"active",this.warning&&"warning",this.state)}]),[this.$slots.default])},meta:{parent:"SuiTable"}};function ve(e,t){var i=t.arg;e.classList.remove("left"),e.classList.remove("right"),e.classList.remove("floated"),e.classList.add(i),e.classList.add("floated")}var Se={name:"SuiButton",description:"A button indicates a possible user action",mixins:[L],props:{active:{type:Boolean,description:"A button can show it is currently the active user selection."},animated:_(["fade","vertical"],{type:Boolean,description:"A button can animate to show hidden content."}),attached:_(["left","right","top","bottom"],{description:"A button can be attached to the top or bottom of other content."}),basic:{type:Boolean,description:"A basic button is less pronounced."},circular:{type:Boolean,description:"A button can be circular."},className:{type:String,description:"Additional classes."},color:_.Color(),compact:{type:Boolean,description:"A button can reduce its padding to fit into tighter spaces."},content:{type:String,description:"Shorthand for primary content."},disabled:{type:Boolean,description:"A button can show it is currently unable to be interacted with."},floated:_(["left","right"],{description:"A button can be aligned to the left or right of its container."}),fluid:{type:Boolean,description:"A button can take the width of its container."},icon:[Boolean,String],inverted:{type:Boolean,description:"A button can be formatted to appear on dark backgrounds."},labelPosition:_(["left","right"],{description:"A labeled button can format a Label or Icon to appear on the left or right."}),loading:{type:Boolean,description:"A button can show a loading indicator."},negative:{type:Boolean,description:"A button can hint towards a negative consequence."},positive:{type:Boolean,description:"A button can hint towards a positive consequence."},primary:{type:Boolean,description:"A button can be formatted to show different levels of emphasis."},secondary:{type:Boolean,description:"A button can be formatted to show different levels of emphasis."},size:_.Size(),tabIndex:{type:[Number,String],description:"A button can receive focus."},toggle:{type:Boolean,description:"A button can be formatted to toggle on and off."},social:_.Social()},meta:{events:{click:{description:"Click event passed to the button.",value:"Event"}},slots:{default:{description:"Primary content."}}},computed:{hasIconClass:function(){return!!this.icon&&("string"!=typeof this.icon||!(this.content||this.$slots.default))}},render:function(){var e=arguments[0],t=this.getElementType("button"),i=this.$slots.label,n=this.classes("ui",this.active&&"active",this.attached&&"".concat(this.attached," attached"),this.animated,this.animated&&"animated",this.basic&&"basic",this.circular&&"circular",this.className,this.color,this.compact&&"compact",this.disabled&&"disabled",this.floated&&"".concat(this.floated," floated"),this.fluid&&"fluid",this.hasIconClass&&"icon",!i&&this.icon&&this.labelPosition&&"icon",this.inverted&&"inverted",!i&&this.labelPosition&&this.labelPosition,!i&&this.labelPosition&&"labeled",this.loading&&"loading",this.toggle&&"toggle",this.negative&&"negative",this.positive&&"positive",this.primary&&"primary",this.secondary&&"secondary",this.social,this.size,"button"),r=e(t,l()([{},this.getChildPropsAndListeners(),{class:n,attrs:{role:"button"}}]),["string"==typeof this.icon&&e(Q,{attrs:{name:this.icon}}),this.content||this.$slots.default]);return i?e("div",{class:this.classes("ui",this.labelPosition,"labeled","button")},["left"===this.labelPosition&&i,r,"left"!==this.labelPosition&&i]):r}},we={name:"SuiButtonContent",mixins:[L],props:{visible:{type:Boolean},hidden:{type:Boolean}},render:function(){var e=arguments[0],t=this.getElementType("div"),i=this.classes(this.visible&&"visible",this.hidden&&"hidden","content");return e(t,l()([{},this.getChildPropsAndListeners(),{class:i}]),[this.content||this.$slots.default])},meta:{parent:"SuiButton"}},Ae={name:"SuiButtonGroup",mixins:[L],props:{attached:_(["top","bottom"]),widths:_.Number(),vertical:Boolean,labeled:Boolean,icons:Boolean,color:_.Color(),basic:Boolean,size:_.Size()},render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes("ui",this.size,this.color,this.attached,this.attached&&"attached",this.num(this.widths),this.vertical&&"vertical",this.labeled&&"labeled",this.icons&&"icon",this.basic&&"basic","buttons")}]),[this.$slots.default])},meta:{parent:"SuiButton"}};function Oe(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n)}return i}function xe(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?Oe(Object(i),!0).forEach((function(t){Pe(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):Oe(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}function Pe(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}var Be={name:"SuiButtonOr",mixins:[L],props:{text:String},render:function(){var e=arguments[0],t=this.getElementType(),i={};return this.text&&(i["data-text"]=this.text),e(t,l()([{},this.getChildPropsAndListeners(),{class:"or",attrs:xe({},i)}]))},meta:{parent:"SuiButton"}},Ce={name:"SuiContainer",mixins:[L],props:{fluid:{type:Boolean,description:"Container has no maximum width."},text:{type:Boolean,description:"Reduce maximum width to more naturally accommodate text."},textAlign:_.TextAlign({description:"Align container text."})},render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes("ui",I(this.textAlign),this.text&&"text",this.fluid&&"fluid","container")}]),[this.$slots.default])}},je={name:"SuiDivider",mixins:[L],props:{clearing:Boolean,fitted:Boolean,hidden:Boolean,horizontal:Boolean,inverted:Boolean,vertical:Boolean},render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes("ui",this.clearing&&"clearing",this.fitted&&"fitted",this.hidden&&"hidden",this.horizontal&&"horizontal",this.vertical&&"vertical",this.inverted&&"inverted","divider")}]),[this.$slots.default])}},Ee={name:"SuiFlag",mixins:[L],props:{name:String},render:function(){var e=arguments[0],t=this.getElementType("i");return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes("flag",this.name)}]))}},Te={name:"SuiHeader",mixins:[L],props:{color:_.Color(),content:String,dividing:Boolean,disabled:Boolean,floated:_(["left","right"]),icon:{type:[Boolean,String],default:!1},image:{type:String,description:"Add an image by img src or pass an Image."},size:_.Size(),sub:Boolean,textAlign:_(["left","right","center","justify"]),block:Boolean,attached:_(["top","bottom"],{type:Boolean}),inverted:Boolean},render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes("ui",this.floated&&"".concat(this.floated," floated"),I(this.textAlign),this.attached,this.attached&&"attached",this.color,this.size,this.icon&&"icon",this.block&&"block",this.dividing&&"dividing",this.image&&"image",this.sub&&"sub",this.disabled&&"disabled",this.inverted&&"inverted","header")}]),[this.icon!==!!this.icon&&e(Q,{attrs:{name:this.icon}}),this.image&&e("img",{attrs:{src:this.image},class:"ui image"}),this.$slots.default||this.content])}},$e={name:"SuiHeaderContent",mixins:[L],render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:"content"}]),[this.$slots.default])},meta:{parent:"SuiHeader"}},Le={name:"SuiHeaderSubheader",mixins:[L],render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:"sub header"}]),[this.$slots.default])},meta:{parent:"SuiHeader"}},ke={name:"SuiIconGroup",mixins:[L],props:{size:_.Size({description:"Icon group size."})},render:function(){var e=arguments[0],t=this.getElementType("i");return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes(this.size,"icons")}]),[this.$slots.default])},meta:{parent:"SuiIcon"}},De={name:"SuiImage",mixins:[L],props:{avatar:{type:Boolean,description:"An image may be formatted to appear inline with text as an avatar."},bordered:{type:Boolean,description:"An image may include a border to emphasize the edges of white or transparent content."},circular:{type:Boolean,description:"An image may appear circular."},rounded:{type:Boolean,description:"An image may appear rounded."},disabled:Boolean,hidden:Boolean,size:_.Size(),spaced:_(["left","right"],{type:Boolean}),shape:_(["rounded","circular"]),src:{type:String,required:!0},floated:_(["left","right"]),centered:Boolean,verticalAlign:_.VerticalAlign({description:"An image can specify its vertical alignment."}),wrapped:Boolean},render:function(){var e=arguments[0],t=this.getElementType("div"),i=this.classes("ui",this.avatar&&"avatar",this.size,this.shape,this.verticalAlign&&"".concat(this.verticalAlign," aligned"),this.floated&&"".concat(this.floated," floated"),this.centered&&"centered",this.bordered&&"bordered",this.rounded&&"rounded",this.circular&&"circular",this.spaced,this.spaced&&"spaced",this.hidden&&"hidden",this.disabled&&"disabled","image");return this.wrapped||this.$slots.corner||this.$slots.label?e(t,{class:i},[this.$slots.corner,e("img",{attrs:{src:this.src}}),this.$slots.label]):e("img",{class:i,attrs:{src:this.src}})}},Ie={name:"SuiImageGroup",mixins:[L],props:{size:_.Size()},render:function(){var e=arguments[0],t=this.getElementType("div");return e(t,{class:this.classes("ui",this.size,"images")},[this.$slots.default])},meta:{parent:"SuiImage"}};function Me(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n)}return i}function Fe(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?Me(Object(i),!0).forEach((function(t){ze(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):Me(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}function ze(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}var Re={name:"SuiInput",components:{SuiButton:Se,SuiIcon:Q},mixins:[L],props:{action:String,disabled:Boolean,error:Boolean,focus:Boolean,fluid:Boolean,icon:String,iconPosition:_(["left","right"]),inverted:Boolean,inputClass:String,loading:Boolean,size:_(["mini","small","large","big","huge","massive"]),transparent:Boolean,type:{description:"The HTML input type.",default:"text",type:String},value:[String,Number]},events:{input:{custom:!0},blur:{custom:!0}},methods:{handleChange:function(e){var t=e.target.value,i="number"===this.type?Number(t):t;this.$emit("input",i)}},render:function(){var e,t=this,i=arguments[0],n=this.getElementType();return(this.loading||this.icon)&&(e=i(Q,{attrs:{name:this.loading?"loading":this.icon}})),i(n,l()([{},this.getChildPropsAndListeners(),{class:this.classes("ui",this.action&&"action",this.disabled&&"disabled",this.error&&"error",this.focus&&"focus",this.transparent&&"transparent",this.inverted&&"inverted",this.loading&&"loading",this.fluid&&"fluid","left"===this.iconPosition&&"left",(this.loading||this.icon)&&"icon",Boolean(this.size)&&this.size,"input")}]),[i("input",{class:this.inputClass,domProps:{value:this.value},on:{input:this.handleChange,focus:function(e){return t.$emit("focus",e)},blur:function(e){return t.$emit("blur",e)}},ref:"input",attrs:Fe({type:this.type},this.$attrs)}),e,this.action&&i(Se,{attrs:{content:this.action}})])}},Ne={name:"SuiLabel",mixins:[L],description:"A label displays content classification.",props:{attached:_(["top","bottom","top right","top left","bottom left","bottom right"],{description:"A label can attach to a content segment."}),basic:{type:Boolean,description:"A label can reduce its complexity."},circular:{type:Boolean,description:"A label can be circular."},color:_.Color(),corner:_(["left","right"],{description:"A label can position itself in the corner of an element."}),empty:{type:Boolean,description:"Formats the label as a dot."},floating:{type:Boolean,description:"Float above another element in the upper right corner."},image:Boolean,pointing:_(["left","right","above","below"],{description:"A label can point to content next to it.",type:Boolean}),icon:String,ribbon:_(["left","right"],{description:"A label can appear as a ribbon attaching itself to an element.",type:Boolean}),size:_.Size({description:"A label can have different sizes."}),tag:_.Color({description:"A label can appear as a tag.",type:Boolean})},computed:{pointingClass:function(){if(!this.pointing)return"";var e="";return["left","right"].includes(this.pointing)&&(e+="".concat(this.pointing," ")),e+="pointing",["above","below"].includes(this.pointing)&&(e+=" ".concat(this.pointing)),e}},render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes("ui",this.pointingClass,this.color,this.size,this.circular&&"circular",this.empty&&"empty",this.floating&&"floating",this.basic&&"basic",this.image&&"image",this.attached&&"".concat(this.attached," attached"),this.ribbon&&"".concat(this.ribbon," ribbon"),this.corner&&"".concat(this.corner," corner"),this.tag&&"".concat(this.tag," tag"),"label")}]),[this.icon&&e(Q,{attrs:{name:this.icon}}),this.$slots.default])}},He={name:"SuiLabelDetail",mixins:[L],render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:"detail"}]),[this.$slots.default])},meta:{parent:"SuiLabel"}};function Ve(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n)}return i}function qe(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}var Ge=function(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?Ve(Object(i),!0).forEach((function(t){qe(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):Ve(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}({},Q,{name:"SuiListIcon",mixins:[L],meta:{parent:"SuiList"}}),_e={name:"SuiListContent",mixins:[L],render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:"content"}]),[this.$slots.default])},meta:{parent:"SuiList"}},Ue={name:"SuiListItem",components:{SuiListContent:_e,SuiListIcon:Ge},mixins:[L],props:{active:{type:Boolean,description:"A list item can be active."},content:String,icon:String},render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes("item",this.active&&"active"),attrs:{role:"listitem"}}]),[this.icon&&e(Ge,{attrs:{name:this.icon}}),this.content?e(_e,[this.content]):this.$slots.default])},meta:{parent:"SuiList"}},We={name:"SuiList",mixins:[L],props:{bulleted:{type:Boolean,description:"A list can mark items with a bullet."},divided:Boolean,horizontal:Boolean,items:Array,link:Boolean,relaxed:Boolean,inverted:{type:Boolean,description:"A list can be inverted to appear on a dark background."},ordered:{type:Boolean,description:"A list can be ordered numerically."},size:_.Size()},render:function(){var e,t=arguments[0],i=this.getElementType();return e=this.items?this.items.map((function(e){return t(Ue,[e])})):this.$slots.default,t(i,l()([{},this.getChildPropsAndListeners(),{class:this.classes("ui",this.size,this.bulleted&&"bulleted",this.divided&&"divided",this.ordered&&"ordered",this.horizontal&&"horizontal",this.link&&"link",this.relaxed&&"relaxed",this.inverted&&"inverted","list"),attrs:{role:"list"}}]),[e])}},Ye={name:"SuiListDescription",mixins:[L],render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:"description"}]),[this.$slots.default])},meta:{parent:"SuiList"}},Ke={name:"SuiListHeader",mixins:[L],render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:"header"}]),[this.$slots.default])},meta:{parent:"SuiList"}},Xe={name:"SuiListList",mixins:[L],render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:"list"}]),[this.$slots.default])},meta:{parent:"SuiList"}},Je={name:"SuiLoader",mixins:[L],props:{active:Boolean,content:String,indeterminate:Boolean,disabled:Boolean,inline:Boolean,centered:Boolean,size:_.Size({type:String}),inverted:Boolean},render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes("ui",this.indeterminate&&"indeterminate",this.active&&"active",this.disabled&&"disabled",this.inline&&"inline",this.centered&&"centered",this.inverted&&"inverted",this.size,(this.content||this.$slots.default)&&"text","loader")}]),[this.content||this.$slots.default])}},Ze={name:"SuiRail",mixins:[L],props:{attached:Boolean,dividing:Boolean,internal:Boolean,position:_(["left","right"])},render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes("ui",this.dividing&&"dividing",this.attached&&"attached",this.internal&&"internal",this.position,"rail")}]),[this.$slots.default])}},Qe={name:"SuiReveal",mixins:[L],props:{active:{type:Boolean,description:"An active reveal displays its hidden content."},animated:_(["fade","small fade","move","move right","move up","move down","rotate","rotate left"]),disabled:{type:Boolean,description:"A disabled reveal will not animate when hovered."},instant:{type:Boolean,description:"An element can show its content without delay."}},render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes("ui",this.animated,this.disabled&&"disabled",this.instant&&"instant",this.active&&"active","reveal")}]),[this.$slots.default])}},et={name:"SuiRevealContent",mixins:[L],props:{visible:Boolean,hidden:Boolean},render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes("ui",this.hidden&&"hidden",this.visible&&"visible","content")}]),[this.$slots.default])},meta:{parent:"SuiReveal"}},tt={name:"SuiSegment",mixins:[L],props:{attached:_.Attached({type:Boolean,description:"Attach segment to other content, like a header."}),basic:Boolean,clearing:{type:Boolean,description:"A segment can clear floated content."},inverted:Boolean,padded:_.Padded({type:Boolean,description:"A segment can increase its padding"}),piled:Boolean,raised:Boolean,stacked:_(["tall"],{type:Boolean}),vertical:Boolean,disabled:Boolean,loading:Boolean,compact:Boolean,color:_.Color({type:String}),emphasis:_.Emphasis({type:String}),circular:Boolean,floated:_.Floated({type:String}),aligned:_.TextAlign({type:String})},render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes("ui",this.attached,this.attached&&"attached",this.basic&&"basic",this.clearing&&"clearing",this.padded,this.padded&&"padded",this.inverted&&"inverted",this.stacked,this.stacked&&"stacked",this.piled&&"piled",this.raised&&"raised",this.vertical&&"vertical",this.disabled&&"disabled",this.loading&&"loading",this.compact&&"compact",this.color,this.emphasis,this.circular&&"circular",this.floated,this.floated&&"floated",this.aligned,this.aligned&&"aligned","segment")}]),[this.$slots.default])}},it={name:"SuiSegments",mixins:[L],props:{piled:Boolean,raised:Boolean,stacked:Boolean,horizontal:Boolean,vertical:Boolean},meta:{parent:"SuiSegment"},render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes("ui",this.piled&&"piled",this.raised&&"raised",this.stacked&&"stacked",this.horizontal&&"horizontal",this.vertical&&"vertical","segments")}]),[this.$slots.default])}},nt={name:"SuiStepDescription",mixins:[L],render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:"description"}]),[this.$slots.default])},meta:{parent:"SuiStep"}},rt={name:"SuiStepTitle",mixins:[L],render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:"title"}]),[this.$slots.default])},meta:{parent:"SuiStep"}},st={name:"SuiStepContent",components:{SuiStepDescription:nt,SuiStepTitle:rt},mixins:[L],props:{description:String,title:String},render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:"content"}]),[this.title&&e(rt,[this.title]),this.description&&e(nt,[this.description]),this.$slots.default])},meta:{parent:"SuiStep"}},ot={name:"SuiStep",components:{SuiIcon:Q,SuiStepContent:st,SuiStepTitle:rt,SuiStepDescription:nt},mixins:[L],props:{active:Boolean,completed:Boolean,description:String,disabled:Boolean,icon:String,title:String,link:Boolean},render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes("ui",this.active&&"active",this.completed&&"completed",this.disabled&&"disabled",this.link&&"link","step")}]),[this.icon&&e(Q,{attrs:{name:this.icon}}),this.title||this.description?e(st,[this.title&&e(rt,[this.title]),this.description&&e(nt,[this.description])]):this.$slots.default])}};function at(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n)}return i}function ct(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?at(Object(i),!0).forEach((function(t){lt(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):at(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}function lt(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}var dt={name:"SuiStepGroup",components:{SuiStep:ot},mixins:[L],props:{ordered:Boolean,steps:Array,vertical:Boolean,stackable:Boolean,unstackable:Boolean,fluid:Boolean,attached:_.Attached({type:Boolean}),stepNumber:_.Number({type:String,description:"Defined number of steps"}),size:_.Size({type:String})},render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes("ui",this.stepNumber&&this.num(this.stepNumber),this.ordered&&"ordered",this.vertical&&"vertical",this.fluid&&"fluid",this.stackable&&"tablet stackable",this.unstackable&&"unstackable",this.attached,this.attached&&"attached",this.size,"steps")}]),[this.steps?this.steps.map((function(t){return e(ot,{props:ct({},t)})})):this.$slots.default])},meta:{parent:"SuiStep"}};function ut(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n)}return i}function ht(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}var pt={name:"SuiAccordion",mixins:[L],props:{activeIndex:[Number,Array],exclusive:Boolean,fluid:Boolean,inverted:Boolean,panels:Array,styled:Boolean},data:function(){return{active:this.exclusive?Array.isArray(this.activeIndex)?this.activeIndex[0]:this.activeIndex:Array.isArray(this.activeIndex)?this.activeIndex:[this.activeIndex],panelElms:[]}},methods:{register:function(e){var t,i=this,n=-1;!function r(s){s.some((function(s){return"SuiAccordion"!==s.$options.name&&("SuiAccordionTitle"===s.$options.name&&(n+=1),s===e?(i.panelElms[n]=function(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?ut(Object(i),!0).forEach((function(t){ht(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):ut(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}({},i.panelElms[n]||{},ht({},s.$options.name,s)),t=!0,!0):(r(s.$children),t))}))}(this.$children)},toggleEl:function(e){var t=this;this.panelElms.some((function(i,n){return(i.SuiAccordionTitle===e||i.SuiAccordionContent===e)&&(t.toggle(n),!0)}))},toggle:function(e){this.exclusive?this.active===e?this.active=null:this.active=e:this.active.includes(e)?this.active=this.active.filter((function(t){return t!==e})):this.active=this.active.concat([e]),this.panelElms&&this.toggleChildren()},toggleChildren:function(){var e=this;this.panelElms.forEach((function(t,i){var n=e.isPanelActive(i);t.SuiAccordionTitle&&t.SuiAccordionTitle.setActive(n),t.SuiAccordionContent&&t.SuiAccordionContent.setActive(n)}))},isPanelActive:function(e){return Array.isArray(this.active)?this.active.includes(e):this.active===e}},render:function(){var e=this,t=arguments[0],i=this.getElementType();return t(i,l()([{},this.getChildPropsAndListeners(),{class:this.classes("ui",this.inverted&&"inverted",this.fluid&&"fluid",this.styled&&"styled","accordion")}]),[this.panels?this.panels.map((function(i,n){var r=i.title,s=i.content;return t("template",[t("div",{class:e.classes("title",e.isPanelActive(n)&&"active"),on:{click:function(){return e.toggle(n)}}},[r]),t("div",{class:e.classes("content",e.isPanelActive(n)&&"active")},[s])])})):this.$slots.default])}},ft={props:{active:Boolean},data:function(){return{dataActive:this.active,currentIndex:null,accordion:null}},methods:{setActive:function(e){this.dataActive=e},toggle:function(){this.accordion.toggleEl(this)}},mounted:function(){for(var e=this.$parent;e&&!this.accordion;)"SuiAccordion"===e.$options.name&&(this.accordion=e),e=e.$parent;if(!this.accordion)throw new Error("".concat(this.$options.name," must be place as a child of a SuiAccordion"));this.accordion.register(this)},watch:{active:function(e){this.dataActive=e}},meta:{parent:"SuiAccordion"}};function mt(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n)}return i}function gt(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}var bt=function(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?mt(Object(i),!0).forEach((function(t){gt(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):mt(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}({name:"SuiAccordionContent",mixins:[L]},ft,{render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes("content",this.dataActive&&"active")}]),[this.$slots.default])}});function yt(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n)}return i}function vt(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}var St=function(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?yt(Object(i),!0).forEach((function(t){vt(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):yt(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}({name:"SuiAccordionTitle",mixins:[L]},ft,{render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes("title",this.dataActive&&"active"),on:{click:this.toggle}}]),[this.$slots.default])}}),wt={name:"SuiCheckbox",model:{prop:"inputValue",event:"change"},mixins:[L],props:{disabled:{type:Boolean,description:"Disables checkbox interactions"},inputValue:[Array,Boolean,Number,String,Object],label:{type:String,description:"Adds label next to the checkbox"},radio:{type:Boolean,description:"Changes checkbox to radio button"},toggle:{type:Boolean,description:"Make checkbox looks like a on/off toggle"},name:{type:String,description:"Naming input field"},value:[String,Object],required:{type:Boolean,description:'Adds "required" to checkbox input'},slider:{type:Boolean,description:"Make checkbox looks like a two-positional slider"}},events:{change:{custom:!0}},computed:{isArray:function(){return Array.isArray(this.inputValue)},isChecked:function(){return this.radio&&this.value?this.inputValue===this.value:this.isArray?this.inputValue.includes(this.value):!!this.inputValue}},methods:{setValue:function(e){var t=this,i=e.target.checked;this.radio&&this.value?this.$emit("change",this.value):this.isArray?i?this.$emit("change",this.inputValue.concat([this.value])):this.$emit("change",this.inputValue.filter((function(e){return e!==t.value}))):this.$emit("change",i)}},render:function(){var e=this,t=arguments[0],i=this.getElementType();return t(i,l()([{},this.getChildPropsAndListeners(),{class:this.classes("ui",!(this.label||this.$slots.default)&&"fitted",this.radio&&"radio",this.toggle&&"toggle",this.slider&&"slider",this.disabled&&"disabled","checkbox")}]),[t("input",{ref:"input",class:"hidden",attrs:{readonly:"",tabindex:"0",name:this.name,type:this.radio?"radio":"checkbox",disabled:this.disabled,required:this.required},domProps:{checked:this.isChecked},on:{change:this.setValue}}),t("label",{on:{click:function(){return e.$refs.input.click()}},attrs:{for:this.name}},[this.label||this.$slots.default])])}},At={name:"SuiDimmer",mixins:[L],props:{active:Boolean,inverted:Boolean},render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes("ui",this.active&&"active",this.inverted&&"inverted","dimmer")}]),[e("div",{class:"content"},[e("div",{class:"center"},[this.$slots.default])])])}},Ot={name:"SuiDimmerDimmable",mixins:[L],props:{},render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes("dimmable")}]),[this.$slots.default])},meta:{parent:"SuiDimmer"}};function xt(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n)}return i}function Pt(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?xt(Object(i),!0).forEach((function(t){Bt(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):xt(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}function Bt(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}var Ct={name:"SuiDropdownItem",mixins:[L],props:{flag:{type:String,description:"Shorthand for sui-flag."},image:{type:Object,description:"Shorthand for sui-image."},icon:{type:String,description:"Shorthand for sui-icon."},label:{type:Object,description:"Shorthand for sui-label"},text:{type:String,description:"Display text."},value:{type:null,description:"Stored value."},active:{type:Boolean,default:!1,description:"Style as the currently chosen item."},selected:{type:Boolean,default:!1,description:"Is item selected"},disabled:{type:Boolean,default:!1,description:"A dropdown item can be disabled."}},events:{select:{custom:!0}},methods:{select:function(){this.$emit("select",this.value)}},render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{attrs:{role:"option"},class:this.classes(this.disabled&&"disabled",this.active&&"active",this.selected&&"selected","item"),on:{click:this.select}}]),[this.icon&&e(Q,{attrs:{name:this.icon}}),this.image&&e(De,{props:Pt({},this.image)}),this.flag&&e(Ee,{attrs:{name:this.flag}}),this.label&&e(Ne,{props:Pt({},this.label)}),this.text||this.$slots.default])},meta:{parent:"SuiDropdown"}},jt="closed",Et="opening",Tt="open",$t="closing",Lt={name:"SuiDropdownMenu",mixins:[L],data:function(){return{open:!1,visualState:jt}},computed:{animation:function(){var e=this.$parent.animation;switch(this.visualState){case Et:return"animating ".concat(e," in visible");case $t:return"animating ".concat(e," out visible");default:return""}}},watch:{open:function(e){this.visualState=e?Et:$t}},mounted:function(){for(var e=this.$parent;e&&!this.accordion;)/^SuiDropdown(WithRequired)?$/.test(e.$options.name)&&(this.dropdown=e),e=e.$parent;if(!this.dropdown)throw new Error("SuiDropdownMenu must be place as a child of a SuiDropdown");this.dropdown.register(this),this.$el.addEventListener(D(),this.onAnimationEnded,!1)},methods:{onAnimationEnded:function(){this.visualState=this.open?Tt:jt},setOpen:function(e){this.open=e}},render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{attrs:{tabindex:"-1"}},this.getChildPropsAndListeners(),{class:this.classes("menu",this.open&&"visible active","transition",this.animation)}]),[this.$slots.default])},meta:{parent:"SuiDropdown"}};function kt(e){return(kt="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function Dt(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n)}return i}function It(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?Dt(Object(i),!0).forEach((function(t){Mt(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):Dt(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}function Mt(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}var Ft={auto:"auto",autoUpward:"auto-upward",upward:"upward",downward:"downward"},zt="slide",Rt="down",Nt="up";var Ht,Vt={name:"SuiDropdown",mixins:[L],props:{allowAdditions:{type:Boolean,description:"A dropdown can allow user additions."},button:{type:Boolean,description:"A dropdown button style."},icon:{type:String,description:"Change default button to other button."},item:{type:Boolean,description:"A dropdown can be formatted as a Menu item."},floating:{type:Boolean,description:"A dropdown menu can appear to be floating below an element."},fluid:{type:Boolean,description:"A dropdown can take the full width of its parent."},labeled:{type:Boolean,description:"A dropdown can be labeled."},multiple:{type:Boolean,description:"A selection dropdown can allow multiple selections."},loading:{type:Boolean,description:"A dropdown can show that it is currently loading data."},maxSelections:{type:Number,default:1/0,description:"Maximum possible selections when using multiple selection"},options:{type:Array,default:function(){return[]},description:"Array of SuiDropdownItem props e.g. `{ text: '', value: '' }`"},placeholder:{type:String,description:"Placeholder text."},pointing:{type:String,description:"A dropdown can be formatted so that its menu is pointing."},search:{type:Boolean,description:"A dropdown can have a search field to filter options."},searchInMenu:{type:Object,description:"A dropdown can have a search input in dropdown menu. Should be passed an Object with SuiInput props."},selection:{type:Boolean,description:"A dropdown can be used to select between choices in a form."},simple:{type:Boolean,description:"A dropdown that works without JavaScript",default:!1},text:{type:String,description:"Text of dropdown"},value:{type:[Array,String,Number],description:"Value of the dropdown."},direction:_(Object.values(Ft),{default:Ft.auto,description:"A dropdown can have a direction to open"}),openOnFocus:{type:Boolean,default:!0,description:"Whether or not the menu should open when the dropdown is focused."},closeOnBlur:{type:Boolean,default:!0,description:"Whether or not the menu should close when the dropdown is blurred."},noResultsMessage:{type:String,default:"No results found",description:"Message to display when there are no results."},maxSelectionsMessage:{type:String,default:"Max {selections} selections",description:"Message to display when the maximum amount of selections is reached."},disabled:{type:Boolean,default:!1,description:"Whether or not the dropdown is disabled"}},events:{input:{custom:!0}},data:function(){return{filter:"",menu:null,open:!1,menuDirection:null,focused:!1,isMouseDown:!1,selectedIndex:-1}},computed:{maximumValuesSelected:function(){return this.multipleValue.length>=this.maxSelections},downward:function(){return this.direction!==Ft.auto&&this.direction!==Ft.autoUpward?this.direction===Ft.downward:(this.calculateMenuDirection(),null===this.menuDirection||(this.menuDirection.below&&this.menuDirection.above||!this.menuDirection.below&&!this.menuDirection.above?this.direction===Ft.auto:!!this.menuDirection.below))},animation:function(){return"".concat(zt," ").concat(this.downward?Rt:Nt)},filteredOptions:function(){var e=this;if(!this.search&&!this.multiple&&!this.searchInMenu)return this.options;var t=new RegExp(this.filter.replace(/[-/\\^$*+?.()|[\]{}]/g,"\\$&"),"i");return this.options.filter((function(i){return!(e.filter&&!t.test(i.text))&&(!e.multiple||!(e.maximumValuesSelected||e.multipleValue.indexOf(i.value)>-1))}))},message:function(){if(0===this.filteredOptions.length){if(this.multiple&&this.maximumValuesSelected)return this.maxSelectionsMessage.replace("{selections}",this.maxSelections);if(this.filter&&!this.allowAdditions)return this.noResultsMessage}return""},menuNode:function(){var e=this,t=this.$createElement;return t(Lt,[[this.searchInMenu&&[t(Re,l()([{},{props:this.searchInMenu,ref:"searchInMenu"},{on:{input:this.updateFilter,keydown:this.handleSearchKeyDown},attrs:{value:this.filter}}])),t(je)],this.message?t("div",{class:"message"},[this.message]):this.filteredOptions.map((function(i,n){return t(Ct,{props:It({},i),attrs:{active:e.multiple?-1!==e.multipleValue.indexOf(i.value):e.value===i.value,selected:e.selectedIndex===n},class:i.class,on:{select:e.selectItem}})}))]])},multipleValue:function(){return Array.isArray(this.value)?this.value:[]},searchNode:function(){var e=this.$createElement;return this.search&&e("input",{attrs:{type:"text","aria-autocomplete":"list",autoComplete:"off",tabindex:"0"},class:"search",on:{input:this.updateFilter,keydown:this.handleSearchKeyDown},ref:"search",domProps:{value:this.filter}})},selectedNodes:function(){var e=this,t=this.$createElement;return this.multiple?this.multipleValue.map((function(i){var n=e.findOption(i),r=e.allowAdditions&&!n?{text:i}:n;return r?t(Ne,{nativeOn:{click:e.handleClickOnSelectedNode}},[r.icon&&t(Q,{attrs:{name:r.icon}}),r.image&&t(De,{props:It({},r.image)}),r.flag&&t(Ee,{attrs:{name:r.flag}}),r.text,t(Q,{attrs:{name:"delete"},nativeOn:{click:function(){return e.deselectItem(i)}}})]):null})).filter((function(e){return null!=e})):null},textNode:function(){var e=this.$createElement,t=this.text||this.placeholder,i=this.multiple&&this.value&&this.value.length||!this.multiple&&-1===[null,void 0].indexOf(this.value),n=!this.multiple&&this.open&&void 0!==this.filteredOptions[this.selectedIndex]&&this.filteredOptions[this.selectedIndex].value===this.value,r=i?this.findOption(this.value):t;if(!r)return null;var s=this.classes(this.placeholder&&!i&&"default",!this.searchInMenu&&this.filter&&!n&&"filtered","text"),o="object"===kt(r)?r:{text:r};return e("div",{ref:"text",class:s,attrs:{role:"alert","aria-live":"polite"}},[o.icon&&e(Q,{attrs:{name:o.icon}}),o.image&&e(De,{props:It({},o.image)}),o.flag&&e(Ee,{attrs:{name:o.flag}}),o.label&&e(Ne,{props:It({},o.label)}),o.text])}},watch:{filteredOptions:function(){this.updateSelectedIndex()},filter:function(e){this.$emit("filtered",e),this.search&&this.resizeInput()}},mounted:function(){document.body.addEventListener("click",this.closeMenu)},destroyed:function(){document.body.removeEventListener("click",this.closeMenu)},methods:{setOpen:function(){var e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];this.open=e,this.search&&this.filteredOptions.length>=0&&(this.selectedIndex=0),this.menu&&this.menu.setOpen&&this.menu.setOpen(e)},closeMenu:function(){this.closeOnBlur&&this.setOpen(!1)},deselectItem:function(e){this.$emit("input",this.multipleValue.filter((function(t){return t!==e})))},findOption:function(e){return this.options.find((function(t){return t.value===e}))},handleMouseDown:function(){var e=this;this.isMouseDown=!0,document.body.addEventListener("mouseup",(function(){e.isMouseDown=!1}),{capture:!0,once:!0})},handleClick:function(e){var t=this;if(e.stopPropagation(),this.open){if(this.search&&e.target===this.$refs.search)return;var i=e.path||e.composedPath&&e.composedPath();if(i||this.addEventPath(),this.searchInMenu&&e.target===this.$refs.searchInMenu.$refs.input)return;if(this.multiple&&-1!==i.indexOf(this.menu.$el))return void this.$nextTick((function(){return t.focusSearch()}))}this.focusSearch(),this.setOpen(!this.open)},addEventPath:function(){"path"in Event.prototype||Object.defineProperty(Event.prototype,"path",{get:function(){for(var e=[],t=this.target;t;)e.push(t),t=t.parentElement;return-1===e.indexOf(window)&&-1===e.indexOf(document)&&e.push(document),-1===e.indexOf(window)&&e.push(window),e}})},handleFocus:function(){this.focused||(this.focused=!0,!this.isMouseDown&&this.openOnFocus&&this.setOpen(!0))},handleBlur:function(e){this.isMouseDown||e.relatedTarget===this.$refs.search||(this.focused=!1,this.open&&this.closeOnBlur&&this.setOpen(!1))},handleClickOnSelectedNode:function(e){e.stopPropagation()},toggleFilteredText:function(e,t){this.searchInMenu||this.multiple||e.classList.contains("filtered")||""===t.trim()||e.classList.add("filtered"),this.multiple||""!==t.trim()||e.classList.remove("filtered")},handleKeyDown:function(e){this.$refs.text&&this.toggleFilteredText(this.$refs.text,this.filter);var t=13,i=27,n=38,r=40;if(this.open){var s=1;switch(e.keyCode){case t:var o=this.filter;if(this.multiple||-1===this.selectedIndex||(this.filter=""),this.allowAdditions&&-1===this.selectedIndex&&""!==o.trim())e.preventDefault(),this.selectItem(o);else if(this.selection||this.searchInMenu||this.search){if(-1===this.selectedIndex)return;e.preventDefault(),this.multiple?this.selectItem(this.filteredOptions[this.selectedIndex].value):(this.setOpen(!1),this.$refs.text.classList.remove("filtered"))}return;case i:return void(this.open&&this.setOpen(!1));case n:s=-1;break;case r:break;default:return}if(e.preventDefault(),0!==this.filteredOptions.length){var a=this.selectedIndex+s;this.filteredOptions.length<=a?this.selectedIndex=0:this.selectedIndex=a<0?this.filteredOptions.length-1:a,(this.selection||this.searchInMenu||this.search)&&!this.multiple&&this.$emit("input",this.filteredOptions[this.selectedIndex].value)}}else e.keyCode!==t&&(this.setOpen(!0),e.preventDefault())},register:function(e){this.menu=e},selectItem:function(e){if(!this.multiple||!this.maximumValuesSelected){var t=this.multiple?this.multipleValue.filter((function(t){return t!==e})).concat(e):e;this.$emit("input",t),this.filter="",this.multiple||this.$nextTick(this.updateSelectedIndex)}},updateSelectedIndex:function(){var e=this;this.multiple?this.selectedIndex=this.filteredOptions.length>this.selectedIndex?this.selectedIndex:this.selectedIndex-1:this.selectedIndex=this.filteredOptions.findIndex((function(t){return t.value===e.value}))},resizeInput:function(){var e=this.$refs.sizer;e.innerText=this.filter;var t=e.offsetWidth;e.style.display="",e.style.padding="",this.$refs.search.style.minWidth="".concat(Math.ceil(t+1),"px")},updateFilter:function(e){this.filter="string"==typeof e?e:e.target.value},focusSearch:function(){this.search&&this.$refs.search.focus()},handleSearchKeyDown:function(e){this.multiple&&8===e.keyCode&&""===this.filter&&(this.multipleValue.pop(),this.$emit("input",this.multipleValue))},calculateMenuDirection:function(){if("undefined"!=typeof window&&this.menu&&this.menu.$el&&this.open){this.menu.$el.classList.add("loading"),this.$el.classList.remove("upward");var e,t,i,n,r={offset:{top:0,left:0},scrollTop:document.body.scrollTop,height:document.body.offsetHeight},s={offset:(e=this.menu.$el,t=e.getBoundingClientRect(),i=window.pageXOffset||document.documentElement.scrollLeft,n=window.pageYOffset||document.documentElement.scrollTop,{top:t.top+n,left:t.left+i}),height:this.menu.$el.offsetHeight};this.menu.$el.classList.remove("loading"),this.menuDirection={above:s.offset.top-s.height-this.$el.clientHeight>=0,below:s.offset.top+s.height<r.height}}}},render:function(){var e=arguments[0],t=this.getElementType("div"),i="string"==typeof t&&!t.includes("-"),n=Mt({},i?"on":"nativeOn",{"!mousedown":this.handleMouseDown,click:this.handleClick,"!focus":this.handleFocus,"!blur":this.handleBlur,"!keydown":this.handleKeyDown});return e(t,l()([{attrs:{role:"listbox","aria-expanded":this.open,tabindex:"0"}},this.getChildPropsAndListeners(),{class:this.classes("ui",this.button&&"button",this.item&&"item",this.floating&&"floating",this.fluid&&"fluid",this.pointing&&"pointing ".concat(this.pointing),this.loading&&"loading",this.labeled&&"labeled",this.multiple&&"multiple",this.selection&&"selection",this.search&&"search",this.open&&"active visible",this.disabled&&"disabled",this.simple&&"simple",!this.downward&&Ft.upward,"dropdown")},n]),[this.selectedNodes,this.searchNode,this.textNode,null!==this.icon&&e("i",{ref:"icon",attrs:{"aria-hidden":"true"},class:"".concat(this.icon||"dropdown"," icon")}),e("span",{class:"sizer",ref:"sizer"}),this.$slots.default||this.menuNode])}},qt={name:"SuiDropdownDivider",mixins:[L],render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{attrs:{role:"option"},class:this.classes("divider")}]))},meta:{parent:"SuiDropdown"}},Gt={name:"SuiDropdownHeader",mixins:[L],props:{content:{type:String,description:"Shorthand for primary content."},icon:{type:String,description:"Shorthand for `sui-icon`."}},render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes("header")}]),[this.icon&&e(Q,{attrs:{name:this.icon}}),this.content||this.$slots.default])},meta:{parent:"SuiDropdown"}},_t={name:"SuiEmbed",mixins:[L],props:{active:{type:Boolean,description:"An embed can be active"},aspectRatio:_(["4:3","16:9","21:9"],{description:"An embed can specify an alternative aspect ratio (4:3 | 16:9 | 21:9)"}),icon:{type:String,description:"Specifies an icon to use with placeholder content",default:"video play"},placeholder:{type:String,description:"A placeholder image for embed"},source:_(["youtube","vimeo"],{description:"Specifies a source to use. Cannot be used together with url"}),url:{type:String,description:"Specifies a url to use for embed. Cannot be used together with source"},autoplay:{type:Boolean,description:"Setting to true or false will force autoplay",default:!0},brandedUI:{type:Boolean,description:"Whether to show networks branded UI like title cards, or after video calls to action"},color:{type:String,description:"Specifies what default chrome color with Vimeo or YouTube",default:"#444444"},hd:{type:Boolean,description:"Specifies whether to display YouTuber/Vimeo video in high-definition",default:!0},id:{type:String,description:"Specifies an id for source"},iframe:{type:Object,description:"Shorthand for HTML iframe"}},data:function(){return{isActive:!1}},computed:{isActiveState:function(){return this.active||this.isActive}},methods:{setActive:function(){this.isActive=!0}},render:function(){var e=arguments[0],t=this;function i(){var e=!t.url&&t.source,i=!t.source&&t.url,n=e&&t.autoplay,r=e&&t.brandedUI,s=e&&t.color,o=e&&t.hd,a=e&&t.id;return"youtube"===e?["//www.youtube.com/embed/".concat(a),"?autohide=true","&amp;autoplay=".concat(n),"&amp;color=".concat(encodeURIComponent(s)),"&amp;hq=".concat(o),"&amp;jsapi=false","&amp;modestbranding=".concat(r)].join(""):"vimeo"===e?["//player.vimeo.com/video/".concat(a),"?api=false","&amp;autoplay=".concat(n),"&amp;byline=false","&amp;color=".concat(encodeURIComponent(s)),"&amp;portrait=false","&amp;title=false"].join(""):i}function n(e){return Object.entries(e).reduce((function(e,t){return"".concat(e).concat(t[0],":").concat(t[1],";")}),"")}function r(){if(!t.isActiveState)return null;if(t.$slots.default)return t.$slots.default;var r=t.iframe||{},s=i(),o=r.style?n(r.style):"";return e("div",{class:"embed"},[e("iframe",{attrs:{src:r.src||s,allowFullScreen:r.allowFullScreen||!1,frameBorder:r.frameBorder||0,width:r.width||"100%",height:r.height||"100%",scrolling:r.scrolling||"no",title:r.title||"Embedded content from ".concat(t.source||"custom host")},style:o})])}var s=this.getElementType();return e(s,l()([{on:{click:this.setActive}},this.getChildPropsAndListeners(),{class:this.classes("ui",this.aspectRatio,this.isActiveState&&"active","embed")}]),[this.icon&&e(Q,{attrs:{name:this.icon}}),this.placeholder&&e("img",{class:"placeholder",attrs:{src:this.placeholder}}),r()])}};function Ut(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}function Wt(e){return function(e){if(Array.isArray(e)){for(var t=0,i=new Array(e.length);t<e.length;t++)i[t]=e[t];return i}}(e)||function(e){if(Symbol.iterator in Object(e)||"[object Arguments]"===Object.prototype.toString.call(e))return Array.from(e)}(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance")}()}var Yt={closed:"closed",opening:"opening",open:"open",closing:"closing"};function Kt(e){return["".concat(e," up"),"".concat(e," down"),"".concat(e," left"),"".concat(e," right")]}var Xt=["scale","drop","horizontal flip","vertical flip","fade"].concat(Wt(Kt("fade")),Wt(Kt("fly")),Wt(Kt("swing")));function Jt(e,t){return"animating ".concat(e," ").concat(t?"in":"out")}function Zt(e,t){switch(e){case Yt.opening:return Jt(t,!0);case Yt.open:return"visible active";case Yt.closing:return"visible active ".concat(Jt(t,!1));case Yt.close:return"hidden";default:return""}}var Qt={name:"SuiModal",model:{prop:"open",event:"changed"},mixins:[L],props:{animation:_(Xt,{default:Xt[0]}),animationDuration:{type:Number,default:500},aligned:_(["top"]),closeIcon:{type:Boolean,default:!1},dimmer:_(["inverted"]),image:{type:Boolean,default:!1},open:{type:Boolean,default:!1},size:_(["standard","fullscreen","small","large","mini","tiny"],{default:"standard"}),basic:{type:Boolean},closable:{type:Boolean,default:!0}},events:(Ht={displayChanged:{custom:!0}},Ut(Ht,"changed",{custom:!0}),Ut(Ht,"clickAwayModal",{custom:!0}),Ht),data:function(){return{visualState:this.open?Yt.open:Yt.closed}},computed:{dimmerClass:function(){return Zt(this.visualState,"fade")},modalClass:function(){return Zt(this.visualState,this.animation)},visible:function(){return this.visualState!==Yt.closed},dimmerStyle:function(){return{display:this.visible?"flex !important":"none !important",animationDuration:"".concat(this.animationDuration,"ms")}},modalStyle:function(){return{display:this.visible?"block !important":"none !important",animationDuration:"".concat(this.animationDuration,"ms")}}},watch:{open:function(e){this.visualState=e?Yt.opening:Yt.closing},visualState:function(e){this.$emit("displayChanged",e)}},mounted:function(){this.$el.addEventListener(D(),this.onAnimationEnd,!0)},beforeDestroy:function(){this.$el.removeEventListener(D(),this.onAnimationEnd,!0)},methods:{close:function(){this.$emit("changed",!1)},dimmerClick:function(e){this.closable&&e.target===e.currentTarget&&this.visualState===Yt.open&&(this.$emit("clickAwayModal"),this.close())},onAnimationEnd:function(){this.visualState=this.open?Yt.open:Yt.closed}},render:function(){var e=this,t=arguments[0];return t("div",{ref:"dimmer",class:this.classes("ui",this.dimmer,"dimmer modals page transition",this.dimmerClass),style:this.dimmerStyle,on:{click:this.dimmerClick}},[t("div",{ref:"modal",style:this.modalStyle,class:this.classes("ui",this.size,this.basic&&"basic",this.aligned&&"".concat(this.aligned," aligned"),"modal","transition",this.modalClass)},[this.closeIcon&&t(Q,{attrs:{name:"close"},nativeOn:{click:function(){return e.close()}}}),this.$slots.default])])}},ei={name:"SuiModalActions",mixins:[L],render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes("actions")}]),[this.$slots.default])},meta:{parent:"SuiModal"}},ti={name:"SuiModalContent",mixins:[L],props:{image:Boolean,scrolling:{type:Boolean,default:!1,description:"A modal can use the entire size of the screen."}},render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes("content",this.image&&"image",this.scrolling&&"scrolling")}]),[this.$slots.default])},meta:{parent:"SuiModal"}},ii={name:"SuiModalDescription",mixins:[L],props:{},render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes("description")}]),[this.$slots.default])},meta:{parent:"SuiModal"}},ni={name:"SuiModalHeader",mixins:[L],props:{},render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes("header")}]),[this.$slots.default])},meta:{parent:"SuiModal"}};function ri(e){return function(e){if(Array.isArray(e)){for(var t=0,i=new Array(e.length);t<e.length;t++)i[t]=e[t];return i}}(e)||function(e){if(Symbol.iterator in Object(e)||"[object Arguments]"===Object.prototype.toString.call(e))return Array.from(e)}(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance")}()}function si(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n)}return i}function oi(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}var ai={name:"SuiRating",mixins:[L],binding:{prop:"rating",event:"changed"},props:{icon:String,maxRating:Number,rating:Number},events:{rate:{custom:!0}},data:function(){return{selected:0}},methods:{getCurrentValue:function(e){return Number(e.target.getAttribute("aria-posinset"))},onRate:function(e){var t=this.getCurrentValue(e);this.$emit("rate",e,function(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?si(Object(i),!0).forEach((function(t){oi(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):si(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}({},this.$props,{rating:t}))},onMouseleave:function(){this.selected=0},onMouseover:function(e){this.selected=this.getCurrentValue(e)}},render:function(){var e=this,t=arguments[0],i=this.getElementType();return t(i,l()([{},this.getChildPropsAndListeners(),{class:this.classes("ui",this.icon,"rating"),attrs:{role:"radiogroup"}}]),[ri(new Array(this.maxRating)).map((function(i,n){var r=n+1,s=e.rating>n,o=e.selected>n;return t("i",{attrs:{"aria-checked":s.toString(),"aria-posinset":r,"aria-setsize":e.maxRating,tabindex:"0",role:"radio"},class:e.classes(s&&"active",o&&"selected","icon"),on:{click:e.onRate,mouseover:e.onMouseover,mouseleave:e.onMouseleave}})}))])}},ci={name:"SuiSearchSimpleResults",functional:!0,props:{results:Array},render:function(e,t){var i=t.props,n=t.scopedSlots;return i.results.map((function(e){return n.default({result:e})}))}},li={name:"SuiSearchCategoryResults",functional:!0,props:{results:Object},render:function(e,t){var i=t.props,n=t.scopedSlots,r=arguments[0],s=Object.keys(i.results);return s.map((function(e){return r("div",{class:"category",key:e},[r("div",{class:"name"},[i.results[e].name]),r("div",{class:"results"},[r(ci,l()([{attrs:{results:i.results[e].results}},{scopedSlots:{default:n.default}}]))])])}))}},di={name:"SuiSearchResult",functional:!0,props:{title:{type:String,description:"Display title."},description:{type:String,description:"Additional text with less emphasis."},url:{type:String,description:"Link to open on click."}},render:function(e,t){var i=t.props,n=t.listeners,r=arguments[0],s=i.title,o=i.description,a=i.url,c=a?{url:a}:{};return r("div",l()([{},c,{on:{click:function(){return n.select(i)}},class:"result"}]),[r("div",{class:"content"},[s&&r("div",{class:"title"},[s]),o&&r("div",{class:"description"},[o])])])}};function ui(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n)}return i}function hi(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?ui(Object(i),!0).forEach((function(t){pi(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):ui(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}function pi(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}function fi(e){return(fi="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}var mi={name:"SuiSearchResults",mixins:[L],props:{category:Boolean,duration:Number,searchFocused:Boolean,loading:Boolean,value:String,results:[Array,Object]},data:function(){return{animationTimeout:null}},computed:{open:function(){return!(!this.value||!this.searchFocused||this.loading||!this.results)},empty:function(){return!(this.results&&"object"===fi(this.results)&&(this.results.length||Object.keys(this.results).length))}},watch:{open:function(){var e=this;this.animationTimeout=setTimeout((function(){e.animationTimeout=null}),this.duration)}},methods:{handleSelect:function(e){this.$emit("select",e)}},render:function(){var e=this,t=arguments[0],i=this.category?li:ci;return this.empty?null:t("div",{class:this.classes("results","transition",this.category&&"category",this.animationTimeout&&"visible animating scale ".concat(this.open?"in":"out"),!this.animationTimeout&&(this.open?"visible":"hidden"))},[t(i,l()([{attrs:{results:this.results}},{scopedSlots:{default:function(i){var n=i.result;return t(di,{props:hi({},n),on:{select:e.handleSelect}})}}}]))])}};function gi(e){return(gi="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}var bi={name:"SuiSearch",mixins:[L],props:{action:{type:String,description:"API action to use",default:function(){return"search"}},aligned:_.Floated({description:"A search can have its results aligned to its left or right container edge."}),disabled:{type:Boolean,description:"A search can show it is currently unable to be interacted with."},duration:{type:Number,description:"Duration of animation events.",default:function(){return 300}},fluid:{type:Boolean,description:"A search can have its results take up the width of its container."},fullTextSearch:_(["exact"],{type:[Boolean],default:function(){return!0}}),loading:{type:Boolean,description:"A search can show a loading indicator."},maxResults:{type:Number,default:function(){return 7}},placeholder:{type:String,description:"Input's placeholder."},searchDelay:{type:Number,default:function(){return 1e3},description:"Delay before querying results on inputchange"},searchFields:{type:Array,default:function(){return["title","description"]},description:"Specify object properties inside local source object which will be searched."},source:{type:Array,description:"One of:\n- array of results e.g. `{ title: '', description: '' }` or\n- object of categories e.g. `{ name: '', results: [{ title: '', description: '' }] }`"},value:{type:String,description:"Current value of the search input."}},meta:{slots:{input:{description:"Custom input.",scope:{class:{type:String,description:"CSS class to give to the input. Do not use with sui-input, use `props` instead."},props:{type:Object,description:"Props to pass to sui-input."},handlers:{type:Object,description:"Handlers to pass to the input."}}},result:{description:"Render the result.",scope:{result:{type:Object,description:"Object in the result prop matching the search term."}}}}},data:function(){return{animationTimeout:null,searchFocused:!1,request:null,filteredResults:null,valueState:null,loadingState:!1}},computed:{category:function(){return this.filteredResults&&"object"===gi(this.filteredResults)&&!Array.isArray(this.filteredResults)},internalLoading:function(){return this.loading||this.loadingState},internalValue:function(){return void 0===this.value?this.valueState:this.value}},watch:{internalValue:function(){this.internalValue?(this.loadingState=!0,this.search(this.internalValue)):(this.loadingState=!1,this.filteredResults=null)}},created:function(){var e,t,i,n;this.source||(this.search=(e=this.search,t=this.searchDelay,function(){var r=this,s=arguments,o=function(){n=null,i||e.apply(r,s)},a=i&&!n;clearTimeout(n),n=setTimeout(o,t),a&&e.apply(r,s)}))},methods:{handleInput:function(e){this.valueState="string"==typeof e?e:e.target.value,this.$emit("input",this.valueState)},handleSelect:function(e){this.$emit("select",e),this.handleInput(e.title)},handleFocus:function(){this.searchFocused=!0},handleBlur:function(){this.searchFocused=!1},search:function(e){var t,i,n,r,s,o,a,c,l,d,u=this;this.source?(this.filteredResults=(t=this.internalValue,i=this.source,n=this.searchFields,r=this.fullTextSearch,s=[],o=[],a=[],c=t.toString().replace(/[-[]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g,"\\$&"),l=new RegExp("(?:s|^)"+c,"i"),d=function(e,t){var i=!s.includes(t),n=!a.includes(t),r=!o.includes(t);i&&n&&r&&e.push(t)},void 0===i||!1===i?[]:(n.forEach((function(e){i.forEach((function(i){var n,c;"string"==typeof i[e]&&(-1!==i[e].search(l)?d(s,i):"exact"===r&&(n=t,c=i[e],n=n.toLowerCase(),(c=c.toLowerCase()).indexOf(n)>-1)?d(o,i):r&&function(e,t){var i=t.length,n=e.length;if("string"!=typeof e)return!1;if(e=e.toLowerCase(),t=t.toLowerCase(),n>i)return!1;if(n===i)return e===t;e:for(var r=0,s=0;r<n;r++){for(var o=e.charCodeAt(r);s<i;)if(t.charCodeAt(s++)===o)continue e;return!1}return!0}(t,i[e])&&d(a,i))}))})),[].concat(s,o,a))).slice(0,this.maxResults),this.loadingState=!1):this.executeAction(this.getEndpoint(this.action,{value:e})).then((function(t){u.internalValue===e&&(u.loadingState=!1,u.filteredResults=t)}))}},render:function(){var e=arguments[0],t=this.getElementType(),i="prompt";return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes("ui",this.category&&"category",this.disabled&&"disabled",this.fluid&&"fluid",this.aligned,this.aligned&&"aligned",this.internalLoading&&"loading","search")}]),[this.$scopedSlots.input?this.$scopedSlots.input({class:i,props:{inputClass:i,value:this.internalValue},handlers:{blur:this.handleBlur,input:this.handleInput,focus:this.handleFocus}}):e("input",{class:"prompt",attrs:{placeholder:this.placeholder,type:"text"},domProps:{value:this.internalValue},on:{blur:this.handleBlur,focus:this.handleFocus,input:this.handleInput}}),e(mi,{attrs:{animationTimeout:this.animationTimeout,category:this.category,duration:this.duration,loading:this.internalLoading,results:this.filteredResults,searchFocused:this.searchFocused,value:this.internalValue},on:{select:this.handleSelect}})])}},yi={name:"SuiSidebar",mixins:[L],props:{animation:_(["overlay","push","scale down","uncover","slide out","slide along"]),direction:_(["top","right","bottom","left"],{default:"left"}),visible:Boolean,width:_(["very thin","thin","wide","very wide"])},data:function(){return{animating:!1}},watch:{visible:function(){var e=this;this.animating=!0,setTimeout((function(){e.animating=!1}),500)}},render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:"ui sidebar ".concat(this.direction," ").concat(this.width," ").concat(this.animation||"").concat(this.visible?" visible":"").concat(this.animating?" animating":"")}]),[this.$slots.default])}},vi={name:"SuiSidebarPushable",mixins:[L],render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:"pushable"}]),[this.$slots.default])},meta:{parent:"SuiSidebar"}},Si={name:"SuiSidebarPusher",mixins:[L],props:{dimmed:Boolean},render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes("pusher",this.dimmed&&"dimmed")}]),[this.$slots.default])},meta:{parent:"SuiSidebar"}},wi={inserted:function(e){var t=document.createDocumentFragment(),i=Array.from(e.childNodes),n=e.parentNode,r=document.createComment("fragment tail");t.appendChild(r),i.forEach((function(e){return t.appendChild(e)})),n.insertBefore(t,e),n.removeChild(e),i.forEach((function(t){return Ai(t,e)})),e.__hooks__={appendChild:e.appendChild,insertBefore:e.insertBefore,removeChild:e.removeChild},e.appendChild=function(t){var i=n.insertBefore(t,r);return t.parentNode!==e&&Ai(t,e),i},e.insertBefore=function(t,i){var r=n.insertBefore(t,i);return t.parentNode!==e&&Ai(t,e),r},e.removeChild=function(e){return Oi(e),n.removeChild(e)}},unbind:function(e){e.__hooks__&&(Object.keys(e.__hooks__).forEach((function(t){e[t]=e.__hooks__[t]})),delete e.__hooks__)}},Ai=function(e,t){Object.defineProperty(e,"parentNode",{configurable:!0,writable:!1,value:t})},Oi=function(e){Object.defineProperty(e,"parentNode",{configurable:!0,writable:!0,value:null})},xi={abstract:!0,directives:{fragment:wi},render:function(e){return e("div",{attrs:{class:"v-fragment"},directives:[{name:"fragment"}]},[this.$slots.default])}},Pi=["top left","top right","bottom right","bottom left","right center","left center","top center","bottom center"],Bi={name:"SuiPrivatePopupContainer",mixins:[L],props:{popupClass:String,triggerCoords:p?[window.DOMRect,Object]:Object,position:String},data:function(){return{mountedPosition:this.position,mountedStyle:null}},mounted:function(){var e=this;this.$nextTick((function(){e.popupCoords=e.$refs.container.getBoundingClientRect(),e.setPopupStyle()}))},methods:{computePopupStyle:function(e){var t={position:"absolute"};if(!p)return t;var i=this.offset,n=window,r=n.pageYOffset,s=n.pageXOffset,o=document.documentElement,a=o.clientWidth,c=o.clientHeight;if(e.includes("right"))t.right=Math.round(a-(this.triggerCoords.right+s)),t.left="auto";else if(e.includes("left"))t.left=Math.round(this.triggerCoords.left+s),t.right="auto";else{var l=(this.triggerCoords.width-this.popupCoords.width)/2;t.left=Math.round(this.triggerCoords.left+l+s),t.right="auto"}if(e.includes("top"))t.bottom=Math.round(c-(this.triggerCoords.top+r)),t.top="auto";else if(e.includes("bottom"))t.top=Math.round(this.triggerCoords.bottom+r),t.bottom="auto";else{var d=(this.triggerCoords.height+this.popupCoords.height)/2;t.top=Math.round(this.triggerCoords.bottom+r-d),t.bottom="auto";var u=this.popupCoords.width+8;e.includes("right")?t.right-=u:t.left-=u}return i&&("number"==typeof t.right?t.right-=i:t.left-=i),t},isStyleInViewport:function(e){var t=window,i=t.pageYOffset,n=t.pageXOffset,r=document.documentElement,s=r.clientWidth,o=r.clientHeight,a={top:e.top,left:e.left,width:this.popupCoords.width,height:this.popupCoords.height};return"number"==typeof e.right&&(a.left=s-e.right-a.width),"number"==typeof e.bottom&&(a.top=o-e.bottom-a.height),!(a.top<i)&&(!(a.top+a.height>i+o)&&(!(a.left<n)&&!(a.left+a.width>n+s)))},setPopupStyle:function(){if(this.triggerCoords&&this.popupCoords){for(var e,t,i,n,r=this.position,s=this.computePopupStyle(r),o=(e=Pi,t=r,e.filter((function(e){return e!==t}))).concat([r]),a=0;!this.isStyleInViewport(s)&&a<o.length;a+=1)s=this.computePopupStyle(o[a]),r=o[a];i=s,n=function(e){return"number"==typeof e?"".concat(e,"px"):e},s=Object.keys(i).reduce((function(e,t){return e[t]=n(i[t]),e}),{}),this.mountedStyle=s,this.mountedPosition=r}}},render:function(){var e=this,t=arguments[0],i=this.classes("ui",this.mountedPosition,this.popupClass,"popup","transition visible");return t("portal",{attrs:{to:"semantic-ui-vue"}},[t("div",{ref:"container",class:i,style:this.mountedStyle,on:{mouseover:function(){return e.$emit("mouseover")},mouseleave:function(){return e.$emit("mouseleave")}}},[this.$slots.default])])}},Ci={name:"SuiPopupHeader",mixins:[L],render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:"header"}]),[this.$slots.default])},meta:{parent:"SuiPopup"}},ji={name:"SuiPopupContent",mixins:[L],render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:"content"}]),[this.$slots.default])},meta:{parent:"SuiPopup"}},Ei={name:"SuiPopup",description:"A popup displays additional information on top of a page.",mixins:[L],props:{basic:{type:Boolean,description:"Display the popup without the pointing arrow."},content:{type:String,description:"Simple text content for the popover."},flowing:{type:Boolean,description:"A flowing Popup has no maximum width and continues to flow to fit its content."},header:{type:String,description:"Header displayed above the content in bold."},hoverable:{type:Boolean,description:"Whether the popup should not close on hover."},inverted:{type:Boolean,description:"Invert the colors of the Popup."},position:_(Pi,{description:"Position for the popover.",default:"top left"}),size:_(["mini","tiny","small","large","huge"],{description:"Popup size."}),wide:_(["very"],{type:Boolean,description:"Popup width."})},data:function(){return{coords:null,open:!1}},mounted:function(){this.$slots.trigger[0].elm.addEventListener("mouseenter",this.handleOpen),this.$slots.trigger[0].elm.addEventListener("mouseleave",this.handleBlur)},methods:{handleOpen:function(){this.coords=this.$slots.trigger[0].elm.getBoundingClientRect(),this.open=!0,this.$emit("open")},handleBlur:function(){this.hoverable?this.blurTimeout=setTimeout(this.close,300):this.close()},handleContainerHover:function(){this.hoverable&&this.blurTimeout&&clearTimeout(this.blurTimeout)},close:function(){this.open=!1,this.$emit("close")}},render:function(){var e=arguments[0];return e(xi,[this.$slots.trigger,this.open&&e(Bi,{on:{mouseover:this.handleContainerHover,mouseleave:this.handleBlur},attrs:{popupClass:this.classes(this.basic&&"basic",this.flowing&&"flowing",this.inverted&&"inverted",this.size,this.wide,this.wide&&"wide"),triggerCoords:this.coords,position:this.position,content:this.content}},[this.header&&e(Ci,[this.header]),this.content&&e(ji,[this.content]),this.$slots.default])])}},Ti={name:"SuiProgress",mixins:[L],props:{label:String,content:String,top:Boolean,bottom:Boolean,attached:Boolean,inverted:Boolean,progress:Boolean,indicating:Boolean,indeterminate:Boolean,size:_.Size(),color:_.Color(),state:_.State(),percent:{type:[Number,String],default:50,validator:function(e){return e>=0&&e<=100}}},computed:{percentString:function(){return"".concat(this.percent,"%")}},render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes("ui","progress",this.state,this.color,this.size,this.top&&"top",this.bottom&&"bottom",this.inverted&&"inverted",this.attached&&"attached",this.indicating&&"indicating",this.indeterminate&&"indeterminate"),attrs:{"data-percent":this.percent}}]),[e("div",{class:"bar",style:{width:this.percentString,"transition-duration":"300ms"}},[this.progress&&e("div",{class:"progress"},[" ",this.percentString," "])]),this.label&&e("div",{class:"label"},[this.label])])}};function $i(e){return function(e){if(Array.isArray(e)){for(var t=0,i=new Array(e.length);t<e.length;t++)i[t]=e[t];return i}}(e)||function(e){if(Symbol.iterator in Object(e)||"[object Arguments]"===Object.prototype.toString.call(e))return Array.from(e)}(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance")}()}function Li(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n)}return i}function ki(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?Li(Object(i),!0).forEach((function(t){Di(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):Li(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}function Di(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}var Ii={name:"SuiTab",props:{menu:{type:Object,default:function(){return{attached:!0,tabular:!0}}},menuPosition:_(["left","right"],{description:"Menu Position"}),activeIndex:{type:[String,Number],default:0}},data:function(){return{tabs:[],activeTab:null}},computed:{tabMenu:function(){var e=this,t=this.$createElement;return t("sui-menu",{props:ki({},this.menu)},[this.tabs.map((function(i){return t("a",{class:["item",{active:i.active,disabled:i.disabled}],on:{click:function(t){return e.openTab(t,i)}}},[i.icon&&t("sui-icon",{attrs:{name:i.icon}}),t("span",[i.title]),i.label&&t("sui-label",[i.label])])}))])}},watch:{activeIndex:function(e){this.openTab(null,this.tabs[+e])}},mounted:function(){if(!this.tabs.length)throw new Error("tab used without tab-pane");var e=this.tabs[this.activeIndex]||this.tabs[0];e.open(),this.activeTab=e},methods:{addTab:function(e){this.tabs.push(e)},openTab:function(e,t){if(!t.disabled){this.activeTab.close(),t.open();var i=this.tabs.indexOf(t);this.$emit("change",e,t,i),this.$emit("update:activeIndex",i),this.activeTab=t}}},render:function(){var e=arguments[0],t=this.$slots.default,i=[this.tabMenu,t];return"bottom"===this.menu.attached&&i.reverse(),this.menu.vertical&&(i=[e("sui-grid-column",{attrs:{width:4}},[this.tabMenu]),e("sui-grid-column",{attrs:{width:12},class:"stretched"},[t])],"right"!==this.menu.tabular&&"right"!==this.menuPosition||i.reverse(),i=e("sui-grid",[e("sui-grid-row",[i])])),e("div",[Array.isArray(i)?$i(i):i])}},Mi={name:"SuiTabPane",meta:{parent:"SuiTab"},props:{title:{type:String,required:!0},icon:{type:String},label:{type:String},attached:{type:[Boolean,String],default:!0},loading:{type:Boolean,default:!1},disabled:{type:Boolean,default:!1}},data:function(){return{active:!1}},computed:{classList:function(){var e=["ui","tab","segment",{loading:this.active&&this.loading},{attached:this.attached},{active:this.active}];return"string"==typeof this.attached&&e.push(this.attached),e}},mounted:function(){try{this.findParent().addTab(this)}catch(e){throw new Error("tab-pane was placed outside of tab component")}},methods:{findParent:function(){for(var e=this.$parent,t=Ii.name;e.$options.name!==t;)e=e.$parent;return e},open:function(){this.active=!0},close:function(){this.active=!1}},render:function(){var e=arguments[0];return this.active&&e("div",{class:this.classList},[this.$slots.default])}},Fi={name:"SuiCard",mixins:[L],props:{},render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes("ui","card")}]),[this.$slots.default])}},zi={name:"SuiCardContent",mixins:[L],props:{extra:Boolean},render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes(this.extra&&"extra","content")}]),[this.$slots.default,this.$slots.right&&e("div",{class:"right floated"},[this.$slots.right])])},meta:{parent:"SuiCard"}},Ri={name:"SuiCardDescription",mixins:[L],render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes("description")}]),[this.$slots.default])},meta:{parent:"SuiCard"}},Ni={name:"SuiCardGroup",mixins:[L],props:{itemsPerRow:_.Number(),stackable:Boolean},render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes("ui",this.num(this.itemsPerRow),this.stackable&&"stackable","cards")}]),[this.$slots.default])},meta:{parent:"SuiCard"}},Hi={name:"SuiCardHeader",mixins:[L],render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes("header")}]),[this.$slots.default])},meta:{parent:"SuiCard"}},Vi={name:"SuiCardMeta",mixins:[L],render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes("meta")}]),[this.$slots.default])},meta:{parent:"SuiCard"}},qi={name:"SuiComment",mixins:[L],render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes("ui","comment")}]),[this.$slots.default])}},Gi={name:"SuiCommentAction",mixins:[L],render:function(){var e=arguments[0],t=this.getElementType("a");return e(t,l()([{},this.getChildPropsAndListeners()]),[this.$slots.default])},meta:{parent:"SuiComment"}},_i={name:"SuiCommentActions",mixins:[L],render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes("actions")}]),[this.$slots.default])},meta:{parent:"SuiComment"}},Ui={name:"SuiCommentAuthor",mixins:[L],render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes("author")}]),[this.$slots.default])},meta:{parent:"SuiComment"}},Wi={name:"SuiCommentAvatar",mixins:[L],props:{src:String},render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes("avatar")}]),[e("img",{attrs:{src:this.src}})])},meta:{parent:"SuiComment"}},Yi={name:"SuiCommentContent",mixins:[L],render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes("content")}]),[this.$slots.default])},meta:{parent:"SuiComment"}},Ki={name:"SuiCommentGroup",mixins:[L,k],props:{threaded:{type:Boolean,description:"A comment list can be threaded to showing the relationship between conversations",default:!1},minimal:{type:Boolean,description:"Comments can hide extra information unless a user shows intent to interact with a comment",default:!1},collapsed:{type:Boolean,description:"Comments can be collapsed, or hidden from view",default:!1},size:_.Size()},render:function(){var e=arguments[0],t=this.getElementType(),i=["comments",this.threaded&&"threaded",this.minimal&&"minimal",this.collapsed&&"collapsed",this.size],n=this.getParentName();return"SuiComment"!==n&&i.push("ui"),e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes.apply(this,i)}]),[this.$slots.default])},meta:{parent:"SuiComment"}},Xi={name:"SuiCommentMetadata",mixins:[L],render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes("metadata")}]),[this.$slots.default])},meta:{parent:"SuiComment"}},Ji={name:"SuiCommentText",mixins:[L],render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes("text")}]),[this.$slots.default])},meta:{parent:"SuiComment"}},Zi={name:"SuiFeedEvent",mixins:[L],description:"A feed contains an event",props:{content:{type:String,description:"Shorthand for SuiFeedContent"},image:{type:String,description:"An event can contain image label"},icon:{type:String,description:"An event can contain icon label"},date:{type:String,description:"Shorthand for SuiFeedDate"},summary:{type:String,description:"Shorthand for SuiFeedSummary"},extraImages:{type:Array,description:"Shorthand for SuiFeedExtra with images"},extraText:{type:String,description:"Shorthand for SuiFeedExtra with text"},meta:{type:String,description:"Shorthand for SuiFeedMeta"}},render:function(){var e=arguments[0],t=this.getElementType(),i=this.content||this.date||this.summary||this.extraImages||this.extraText||this.meta;return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes("event")}]),[this.image&&e(an,{attrs:{image:this.image}}),this.icon&&e(an,{attrs:{icon:this.icon}}),i&&e(rn,{attrs:{content:this.content,date:this.date,summary:this.summary,extraImages:this.extraImages,extraText:this.extraText,meta:this.meta}}),this.$slots.default])},meta:{parent:"SuiFeed"}};function Qi(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n)}return i}function en(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?Qi(Object(i),!0).forEach((function(t){tn(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):Qi(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}function tn(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}var nn={name:"SuiFeed",mixins:[L],description:"A feed presents user activity chronologically",props:{size:_(["small","large"],{description:"A feed can have different sizes (small | large)"}),events:{type:Array,description:"Shorthand array of props for FeedEvent"}},render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes("ui",this.size,"feed")}]),[this.$slots.default||this.events&&this.events.map((function(t){return e(Zi,{props:en({},t)})}))])}},rn={name:"SuiFeedContent",mixins:[L],props:{content:{type:String,description:"Shorthand for primary content"},date:{type:String,description:"Shorthand for SuiFeedDate"},summary:{type:String,description:"Shorthand for SuiFeedSummary"},extraImages:{type:Array,description:"Shorthand for SuiFeedExtra with images"},extraText:{type:String,description:"Shorthand for SuiFeedExtra with text"},meta:{type:String,description:"Shorthand for SuiFeedMeta"}},render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes("content")}]),[this.$slots.default||[this.date&&e(sn,{attrs:{content:this.date}}),this.content,this.summary&&e(dn,{attrs:{content:this.summary}}),this.extraText&&e(on,{attrs:{text:!0,content:this.extraText}}),this.extraImages&&e(on,{attrs:{images:this.extraImages}}),this.meta&&e(ln,{attrs:{content:this.meta}})]])},meta:{parent:"SuiFeed"}},sn={name:"SuiFeedDate",mixins:[L],description:"An event or an event summary can contain a date",props:{content:{type:String,description:"Shorthand for primary content"}},render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes("date")}]),[this.$slots.default||this.content])},meta:{parent:"SuiFeed"}},on={name:"SuiFeedExtra",mixins:[L],description:"A feed can contain an extra content",props:{content:{type:String,description:"Shorthand for primary content"},images:{type:[Array,Boolean],description:"An event can contain additional information like a set of images"},text:{type:Boolean,description:"An event can contain additional text information"}},render:function(){var e=arguments[0],t=this.getElementType(),i=Array.isArray(this.images)&&this.images.map((function(t){return e(De,{attrs:{src:t}})})),n=[this.content,i];return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes(this.images&&"images",(this.text||this.content)&&"text","extra")}]),[this.$slots.default||n])},meta:{parent:"SuiFeed"}},an={name:"SuiFeedLabel",mixins:[L],description:"An event can contain an image or icon label",props:{content:{type:String,description:"Shorthand for primary content"},image:{type:String,description:"An event can contain image label"},icon:{type:String,description:"An event can contain icon label"}},render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes("label")}]),[this.$slots.default||[this.content,this.icon&&e(Q,{attrs:{name:this.icon}}),this.image&&e(De,{attrs:{src:this.image}})]])},meta:{parent:"SuiFeed"}},cn={name:"SuiFeedLike",mixins:[L],description:"A feed can contain a like element",props:{content:{type:String,description:"Shorthand for primary content"},icon:{type:String,description:"Shorthand for icon. Mutually exclusive with children"}},render:function(){var e=arguments[0],t=this.getElementType("a");return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes("like")}]),[this.$slots.default||[this.icon&&e(Q,{attrs:{name:this.icon}}),this.content]])},meta:{parent:"SuiFeed"}},ln={name:"SuiFeedMeta",mixins:[L],description:"A feed can contain a meta",props:{content:{type:String,description:"Shorthand for primary content"},like:{type:String,description:"Shorthand for SuiFeedLike"}},render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes("meta")}]),[this.$slots.default||[this.like&&e(cn,{attrs:{content:this.like}}),this.content]])},meta:{parent:"SuiFeed"}},dn={name:"SuiFeedSummary",mixins:[L],description:"A feed can contain a summary",props:{content:{type:String,description:"Shorthand for primary content"},date:{type:String,description:"Shorthand for SuiFeedDate"},user:{type:String,description:"Shorthand for SuiFeedUser"}},render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes("summary")}]),[this.$slots.default||[this.user&&e(un,{attrs:{content:this.user}}),this.content,this.date&&e(sn,{attrs:{content:this.date}})]])},meta:{parent:"SuiFeed"}},un={name:"SuiFeedUser",mixins:[L],description:"A feed can contain a user element",props:{content:{type:String,description:"Shorthand for primary content"}},render:function(){var e=arguments[0],t=this.getElementType("a");return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes("user")}]),[this.$slots.default||this.content])},meta:{parent:"SuiFeed"}},hn={name:"SuiItem",mixins:[L],description:"An item view presents large collections of site content for display",props:{href:{type:String,description:'Specifies a linked document, resource, or location. Only useful if the ItemGroup contains the "link" class.'}},render:function(){var e=arguments[0],t=this.href?"a":this.getElementType();return e(t,{attrs:{href:this.href},class:this.classes("item")},[this.$slots.default])}},pn={name:"SuiItemGroup",mixins:[L],description:"A group of items",props:{unstackable:{type:Boolean,description:"A table can specify how it stacks items responsively"},divided:{type:Boolean,description:"Items can be divided to better distinguish between grouped content"},relaxed:_(["very"],{type:Boolean,description:"A group of items can relax its padding to provide more negative space"}),link:{type:Boolean,description:"An item can be formatted so that the entire contents link to another page"}},render:function(){var e=arguments[0],t=this.getElementType();return e(t,{class:this.classes("ui",this.unstackable&&"unstackable",this.divided&&"divided",this.relaxed,this.relaxed&&"relaxed",this.link&&"link","items")},[this.$slots.default])},meta:{parent:"SuiItem"}},fn={name:"SuiItemContent",mixins:[L],description:"An item can contain content",props:{verticalAlign:_.VerticalAlign({description:"Content can specify its vertical alignment"})},render:function(){var e=arguments[0],t=this.getElementType();return e(t,{class:this.classes(this.verticalAlign&&"".concat(this.verticalAlign," aligned"),"content")},[this.$slots.default])},meta:{parent:"SuiItem"}},mn={name:"SuiItemImage",mixins:[L],description:"An item can contain an image",props:{src:{type:String,required:!0,description:"Specifies the URL of the image"},size:_(["mini","tiny","small","medium","large","big","huge","massive"],{type:String,description:"An image may appear at different sizes (mini, tiny, small, medium, large, big, huge, massive)"}),href:{type:String,description:"Specifies a linked document, resource, or location"}},render:function(){var e=arguments[0],t=this.href?"a":this.getElementType();return e(t,{attrs:{href:this.href},class:this.classes(this.size&&"ui ".concat(this.size),"image")},[e("img",{attrs:{src:this.src}})])},meta:{parent:"SuiItem"}},gn={name:"SuiItemHeader",mixins:[L],description:"An item can contain a header",props:{href:{type:String,description:"Specifies a linked document, resource, or location"}},render:function(){var e=arguments[0],t=this.href?"a":this.getElementType();return e(t,{attrs:{href:this.href},class:this.classes("header")},[this.$slots.default])},meta:{parent:"SuiItem"}},bn={name:"SuiItemMeta",mixins:[L],description:"An item can contain content metadata",props:{},render:function(){var e=arguments[0],t=this.getElementType();return e(t,{class:this.classes("meta")},[this.$slots.default])},meta:{parent:"SuiItem"}},yn={name:"SuiItemDescription",mixins:[L],description:"An item can contain a description with a single or multiple paragraphs",render:function(){var e=arguments[0],t=this.getElementType();return e(t,{class:this.classes("description")},[this.$slots.default])},meta:{parent:"SuiItem"}},vn={name:"SuiItemExtra",mixins:[L],description:"An item can contain extra content meant to be formatted separately from the main content",props:{},render:function(){var e=arguments[0],t=this.getElementType();return e(t,{class:this.classes("extra")},[this.$slots.default])},meta:{parent:"SuiItem"}},Sn={name:"SuiStatistic",mixins:[k,L],props:{horizontal:{type:Boolean,description:"Present measurement horizontally"},color:_.Color(),size:_.Size(),floated:_(["left","right"]),inverted:{type:Boolean,description:"Should the colors be inverted"}},render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes(this.getUIClass(),"statistic",this.color,this.size,this.floated&&"".concat(this.floated," floated"),this.inverted&&"inverted",this.horizontal&&"horizontal")}]),[this.$slots.default])}},wn={name:"SuiStatisticValue",mixins:[L],props:{text:Boolean},render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes(this.text&&"text","value")}]),[this.$slots.default])},meta:{parent:"SuiStatistic"}},An={name:"SuiStatisticLabel",mixins:[L],render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes("label")}]),[this.$slots.default])},meta:{parent:"SuiStatistic"}},On={name:"SuiStatisticsGroup",mixins:[L],props:{horizontal:Boolean,columns:_.Number()},render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes(this.num(this.columns),"ui","statistics",this.horizontal&&"horizontal")}]),[this.$slots.default])},meta:{parent:"SuiStatistic"}},xn={name:"SuiAdvertisement",description:"An advertisement view presents thrif-party promotional content",mixins:[L],props:{centered:{type:Boolean,description:"Center the advertisement",default:!1},test:{type:[String,Number],description:"Text to be displayed on the advertisement."},unit:_(["medium rectangle","large rectangle","small rectangle","vertical rectangle","leaderboard","half page","mobile leaderboard","mobile banner","button","square button","small button","skyscraper","wide skyscraper","banner","vertical banner","top banner","half banner","leaderboard","large leaderboard","billboard","panorama","netboard"],{description:"Define the size of the advertisement",type:String,required:!0})},render:function(){var e=arguments[0],t=this.getElementType();return e(t,l()([{},this.getChildPropsAndListeners(),{class:this.classes("ui",this.centered?"centered":null,this.unit,this.test?"test":null,"ad"),attrs:{"data-text":this.test}}]),[this.$slots.default])}};function Pn(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n)}return i}function Bn(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}i.d(t,"Breadcrumb",(function(){return U})),i.d(t,"BreadcrumbDivider",(function(){return N})),i.d(t,"BreadcrumbSection",(function(){return R})),i.d(t,"Form",(function(){return W})),i.d(t,"FormField",(function(){return Y})),i.d(t,"FormFields",(function(){return K})),i.d(t,"Grid",(function(){return X})),i.d(t,"GridColumn",(function(){return J})),i.d(t,"GridRow",(function(){return Z})),i.d(t,"Menu",(function(){return re})),i.d(t,"MenuHeader",(function(){return se})),i.d(t,"MenuItem",(function(){return ee})),i.d(t,"MenuMenu",(function(){return oe})),i.d(t,"Message",(function(){return ue})),i.d(t,"MessageContent",(function(){return ae})),i.d(t,"MessageHeader",(function(){return ce})),i.d(t,"MessageItem",(function(){return le})),i.d(t,"MessageList",(function(){return de})),i.d(t,"Table",(function(){return he})),i.d(t,"TableBody",(function(){return pe})),i.d(t,"TableCell",(function(){return fe})),i.d(t,"TableFooter",(function(){return me})),i.d(t,"TableHeader",(function(){return ge})),i.d(t,"TableHeaderCell",(function(){return be})),i.d(t,"TableRow",(function(){return ye})),i.d(t,"floated",(function(){return ve})),i.d(t,"Button",(function(){return Se})),i.d(t,"ButtonContent",(function(){return we})),i.d(t,"ButtonGroup",(function(){return Ae})),i.d(t,"ButtonOr",(function(){return Be})),i.d(t,"Container",(function(){return Ce})),i.d(t,"Divider",(function(){return je})),i.d(t,"Flag",(function(){return Ee})),i.d(t,"Header",(function(){return Te})),i.d(t,"HeaderContent",(function(){return $e})),i.d(t,"HeaderSubheader",(function(){return Le})),i.d(t,"Icon",(function(){return Q})),i.d(t,"IconGroup",(function(){return ke})),i.d(t,"Image",(function(){return De})),i.d(t,"ImageGroup",(function(){return Ie})),i.d(t,"Input",(function(){return Re})),i.d(t,"Label",(function(){return Ne})),i.d(t,"LabelDetail",(function(){return He})),i.d(t,"List",(function(){return We})),i.d(t,"ListContent",(function(){return _e})),i.d(t,"ListDescription",(function(){return Ye})),i.d(t,"ListHeader",(function(){return Ke})),i.d(t,"ListIcon",(function(){return Ge})),i.d(t,"ListItem",(function(){return Ue})),i.d(t,"ListList",(function(){return Xe})),i.d(t,"Loader",(function(){return Je})),i.d(t,"Rail",(function(){return Ze})),i.d(t,"Reveal",(function(){return Qe})),i.d(t,"RevealContent",(function(){return et})),i.d(t,"Segment",(function(){return tt})),i.d(t,"Segments",(function(){return it})),i.d(t,"Step",(function(){return ot})),i.d(t,"StepContent",(function(){return st})),i.d(t,"StepDescription",(function(){return nt})),i.d(t,"StepGroup",(function(){return dt})),i.d(t,"StepTitle",(function(){return rt})),i.d(t,"Accordion",(function(){return pt})),i.d(t,"AccordionContent",(function(){return bt})),i.d(t,"AccordionTitle",(function(){return St})),i.d(t,"Checkbox",(function(){return wt})),i.d(t,"Dimmer",(function(){return At})),i.d(t,"DimmerDimmable",(function(){return Ot})),i.d(t,"Dropdown",(function(){return Vt})),i.d(t,"DropdownDivider",(function(){return qt})),i.d(t,"DropdownHeader",(function(){return Gt})),i.d(t,"DropdownItem",(function(){return Ct})),i.d(t,"DropdownMenu",(function(){return Lt})),i.d(t,"Embed",(function(){return _t})),i.d(t,"Modal",(function(){return Qt})),i.d(t,"ModalActions",(function(){return ei})),i.d(t,"ModalContent",(function(){return ti})),i.d(t,"ModalDescription",(function(){return ii})),i.d(t,"ModalHeader",(function(){return ni})),i.d(t,"Rating",(function(){return ai})),i.d(t,"Search",(function(){return bi})),i.d(t,"Sidebar",(function(){return yi})),i.d(t,"SidebarPushable",(function(){return vi})),i.d(t,"SidebarPusher",(function(){return Si})),i.d(t,"Popup",(function(){return Ei})),i.d(t,"PopupContent",(function(){return ji})),i.d(t,"PopupHeader",(function(){return Ci})),i.d(t,"Progress",(function(){return Ti})),i.d(t,"TabPane",(function(){return Mi})),i.d(t,"Tab",(function(){return Ii})),i.d(t,"Card",(function(){return Fi})),i.d(t,"CardContent",(function(){return zi})),i.d(t,"CardDescription",(function(){return Ri})),i.d(t,"CardGroup",(function(){return Ni})),i.d(t,"CardHeader",(function(){return Hi})),i.d(t,"CardMeta",(function(){return Vi})),i.d(t,"Comment",(function(){return qi})),i.d(t,"CommentAction",(function(){return Gi})),i.d(t,"CommentActions",(function(){return _i})),i.d(t,"CommentAuthor",(function(){return Ui})),i.d(t,"CommentAvatar",(function(){return Wi})),i.d(t,"CommentContent",(function(){return Yi})),i.d(t,"CommentGroup",(function(){return Ki})),i.d(t,"CommentMetadata",(function(){return Xi})),i.d(t,"CommentText",(function(){return Ji})),i.d(t,"Feed",(function(){return nn})),i.d(t,"FeedContent",(function(){return rn})),i.d(t,"FeedDate",(function(){return sn})),i.d(t,"FeedEvent",(function(){return Zi})),i.d(t,"FeedExtra",(function(){return on})),i.d(t,"FeedLabel",(function(){return an})),i.d(t,"FeedLike",(function(){return cn})),i.d(t,"FeedMeta",(function(){return ln})),i.d(t,"FeedSummary",(function(){return dn})),i.d(t,"FeedUser",(function(){return un})),i.d(t,"Item",(function(){return hn})),i.d(t,"ItemGroup",(function(){return pn})),i.d(t,"ItemContent",(function(){return fn})),i.d(t,"ItemImage",(function(){return mn})),i.d(t,"ItemHeader",(function(){return gn})),i.d(t,"ItemMeta",(function(){return bn})),i.d(t,"ItemDescription",(function(){return yn})),i.d(t,"ItemExtra",(function(){return vn})),i.d(t,"Statistic",(function(){return Sn})),i.d(t,"StatisticValue",(function(){return wn})),i.d(t,"StatisticLabel",(function(){return An})),i.d(t,"StatisticGroup",(function(){return On})),i.d(t,"Advertisement",(function(){return xn}));var Cn=function(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?Pn(Object(i),!0).forEach((function(t){Bn(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):Pn(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}({},n,{},s,{},o,{},a);t.default=function(e){Object.values(Cn).forEach((function(t){return e.component(t.name,t)})),Object.values(r).forEach((function(t){return e.directive(t.name,t)}))}}]);

/***/ }),

/***/ "./node_modules/vue-loader/dist/exportHelper.js":
/*!******************************************************!*\
  !*** ./node_modules/vue-loader/dist/exportHelper.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
// runtime helper for setting properties on components
// in a tree-shakable way
exports["default"] = (sfc, props) => {
    const target = sfc.__vccOpts || sfc;
    for (const [key, val] of props) {
        target[key] = val;
    }
    return target;
};


/***/ }),

/***/ "./src/Resources/private/js/App.vue":
/*!******************************************!*\
  !*** ./src/Resources/private/js/App.vue ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _App_vue_vue_type_template_id_43325c2c_scoped_true__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./App.vue?vue&type=template&id=43325c2c&scoped=true */ "./src/Resources/private/js/App.vue?vue&type=template&id=43325c2c&scoped=true");
/* harmony import */ var _App_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./App.vue?vue&type=script&lang=js */ "./src/Resources/private/js/App.vue?vue&type=script&lang=js");
/* harmony import */ var _App_vue_vue_type_style_index_0_id_43325c2c_scoped_true_lang_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./App.vue?vue&type=style&index=0&id=43325c2c&scoped=true&lang=css */ "./src/Resources/private/js/App.vue?vue&type=style&index=0&id=43325c2c&scoped=true&lang=css");
/* harmony import */ var _home_bdacruz_Documents_retailer_SyliusStandard_vendor_asdoria_sylius_retailer_plugin_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./node_modules/vue-loader/dist/exportHelper.js */ "./node_modules/vue-loader/dist/exportHelper.js");




;


const __exports__ = /*#__PURE__*/(0,_home_bdacruz_Documents_retailer_SyliusStandard_vendor_asdoria_sylius_retailer_plugin_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_3__["default"])(_App_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__["default"], [['render',_App_vue_vue_type_template_id_43325c2c_scoped_true__WEBPACK_IMPORTED_MODULE_0__.render],['__scopeId',"data-v-43325c2c"],['__file',"src/Resources/private/js/App.vue"]])
/* hot reload */
if (false) {}


/* harmony default export */ __webpack_exports__["default"] = (__exports__);

/***/ }),

/***/ "./src/Resources/private/js/components/RetailerMapIcon.vue":
/*!*****************************************************************!*\
  !*** ./src/Resources/private/js/components/RetailerMapIcon.vue ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _RetailerMapIcon_vue_vue_type_template_id_58261f73_scoped_true__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RetailerMapIcon.vue?vue&type=template&id=58261f73&scoped=true */ "./src/Resources/private/js/components/RetailerMapIcon.vue?vue&type=template&id=58261f73&scoped=true");
/* harmony import */ var _RetailerMapIcon_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RetailerMapIcon.vue?vue&type=script&lang=js */ "./src/Resources/private/js/components/RetailerMapIcon.vue?vue&type=script&lang=js");
/* harmony import */ var _RetailerMapIcon_vue_vue_type_style_index_0_id_58261f73_scoped_true_lang_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./RetailerMapIcon.vue?vue&type=style&index=0&id=58261f73&scoped=true&lang=css */ "./src/Resources/private/js/components/RetailerMapIcon.vue?vue&type=style&index=0&id=58261f73&scoped=true&lang=css");
/* harmony import */ var _home_bdacruz_Documents_retailer_SyliusStandard_vendor_asdoria_sylius_retailer_plugin_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./node_modules/vue-loader/dist/exportHelper.js */ "./node_modules/vue-loader/dist/exportHelper.js");




;


const __exports__ = /*#__PURE__*/(0,_home_bdacruz_Documents_retailer_SyliusStandard_vendor_asdoria_sylius_retailer_plugin_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_3__["default"])(_RetailerMapIcon_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__["default"], [['render',_RetailerMapIcon_vue_vue_type_template_id_58261f73_scoped_true__WEBPACK_IMPORTED_MODULE_0__.render],['__scopeId',"data-v-58261f73"],['__file',"src/Resources/private/js/components/RetailerMapIcon.vue"]])
/* hot reload */
if (false) {}


/* harmony default export */ __webpack_exports__["default"] = (__exports__);

/***/ }),

/***/ "./src/Resources/private/js/components/TheMap.vue":
/*!********************************************************!*\
  !*** ./src/Resources/private/js/components/TheMap.vue ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _TheMap_vue_vue_type_template_id_fbd115e6_scoped_true__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TheMap.vue?vue&type=template&id=fbd115e6&scoped=true */ "./src/Resources/private/js/components/TheMap.vue?vue&type=template&id=fbd115e6&scoped=true");
/* harmony import */ var _TheMap_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TheMap.vue?vue&type=script&lang=js */ "./src/Resources/private/js/components/TheMap.vue?vue&type=script&lang=js");
/* harmony import */ var _TheMap_vue_vue_type_style_index_0_id_fbd115e6_scoped_true_lang_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TheMap.vue?vue&type=style&index=0&id=fbd115e6&scoped=true&lang=css */ "./src/Resources/private/js/components/TheMap.vue?vue&type=style&index=0&id=fbd115e6&scoped=true&lang=css");
/* harmony import */ var _home_bdacruz_Documents_retailer_SyliusStandard_vendor_asdoria_sylius_retailer_plugin_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./node_modules/vue-loader/dist/exportHelper.js */ "./node_modules/vue-loader/dist/exportHelper.js");




;


const __exports__ = /*#__PURE__*/(0,_home_bdacruz_Documents_retailer_SyliusStandard_vendor_asdoria_sylius_retailer_plugin_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_3__["default"])(_TheMap_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__["default"], [['render',_TheMap_vue_vue_type_template_id_fbd115e6_scoped_true__WEBPACK_IMPORTED_MODULE_0__.render],['__scopeId',"data-v-fbd115e6"],['__file',"src/Resources/private/js/components/TheMap.vue"]])
/* hot reload */
if (false) {}


/* harmony default export */ __webpack_exports__["default"] = (__exports__);

/***/ }),

/***/ "./src/Resources/private/js/components/TheRetailer.vue":
/*!*************************************************************!*\
  !*** ./src/Resources/private/js/components/TheRetailer.vue ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _TheRetailer_vue_vue_type_template_id_abbd3fe2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TheRetailer.vue?vue&type=template&id=abbd3fe2 */ "./src/Resources/private/js/components/TheRetailer.vue?vue&type=template&id=abbd3fe2");
/* harmony import */ var _TheRetailer_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TheRetailer.vue?vue&type=script&lang=js */ "./src/Resources/private/js/components/TheRetailer.vue?vue&type=script&lang=js");
/* harmony import */ var _home_bdacruz_Documents_retailer_SyliusStandard_vendor_asdoria_sylius_retailer_plugin_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/vue-loader/dist/exportHelper.js */ "./node_modules/vue-loader/dist/exportHelper.js");




;
const __exports__ = /*#__PURE__*/(0,_home_bdacruz_Documents_retailer_SyliusStandard_vendor_asdoria_sylius_retailer_plugin_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__["default"])(_TheRetailer_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__["default"], [['render',_TheRetailer_vue_vue_type_template_id_abbd3fe2__WEBPACK_IMPORTED_MODULE_0__.render],['__file',"src/Resources/private/js/components/TheRetailer.vue"]])
/* hot reload */
if (false) {}


/* harmony default export */ __webpack_exports__["default"] = (__exports__);

/***/ }),

/***/ "./src/Resources/private/js/components/TheSearch.vue":
/*!***********************************************************!*\
  !*** ./src/Resources/private/js/components/TheSearch.vue ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _TheSearch_vue_vue_type_template_id_6f7752f2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TheSearch.vue?vue&type=template&id=6f7752f2 */ "./src/Resources/private/js/components/TheSearch.vue?vue&type=template&id=6f7752f2");
/* harmony import */ var _TheSearch_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TheSearch.vue?vue&type=script&lang=js */ "./src/Resources/private/js/components/TheSearch.vue?vue&type=script&lang=js");
/* harmony import */ var _home_bdacruz_Documents_retailer_SyliusStandard_vendor_asdoria_sylius_retailer_plugin_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/vue-loader/dist/exportHelper.js */ "./node_modules/vue-loader/dist/exportHelper.js");




;
const __exports__ = /*#__PURE__*/(0,_home_bdacruz_Documents_retailer_SyliusStandard_vendor_asdoria_sylius_retailer_plugin_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__["default"])(_TheSearch_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__["default"], [['render',_TheSearch_vue_vue_type_template_id_6f7752f2__WEBPACK_IMPORTED_MODULE_0__.render],['__file',"src/Resources/private/js/components/TheSearch.vue"]])
/* hot reload */
if (false) {}


/* harmony default export */ __webpack_exports__["default"] = (__exports__);

/***/ }),

/***/ "./src/Resources/private/js/App.vue?vue&type=script&lang=js":
/*!******************************************************************!*\
  !*** ./src/Resources/private/js/App.vue?vue&type=script&lang=js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_0_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_App_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__["default"]; }
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_0_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_App_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./App.vue?vue&type=script&lang=js */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/Resources/private/js/App.vue?vue&type=script&lang=js");
 

/***/ }),

/***/ "./src/Resources/private/js/components/RetailerMapIcon.vue?vue&type=script&lang=js":
/*!*****************************************************************************************!*\
  !*** ./src/Resources/private/js/components/RetailerMapIcon.vue?vue&type=script&lang=js ***!
  \*****************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_0_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_RetailerMapIcon_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__["default"]; }
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_0_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_RetailerMapIcon_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!../../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./RetailerMapIcon.vue?vue&type=script&lang=js */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/Resources/private/js/components/RetailerMapIcon.vue?vue&type=script&lang=js");
 

/***/ }),

/***/ "./src/Resources/private/js/components/TheMap.vue?vue&type=script&lang=js":
/*!********************************************************************************!*\
  !*** ./src/Resources/private/js/components/TheMap.vue?vue&type=script&lang=js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_0_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_TheMap_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__["default"]; }
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_0_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_TheMap_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!../../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./TheMap.vue?vue&type=script&lang=js */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/Resources/private/js/components/TheMap.vue?vue&type=script&lang=js");
 

/***/ }),

/***/ "./src/Resources/private/js/components/TheRetailer.vue?vue&type=script&lang=js":
/*!*************************************************************************************!*\
  !*** ./src/Resources/private/js/components/TheRetailer.vue?vue&type=script&lang=js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_0_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_TheRetailer_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__["default"]; }
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_0_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_TheRetailer_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!../../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./TheRetailer.vue?vue&type=script&lang=js */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/Resources/private/js/components/TheRetailer.vue?vue&type=script&lang=js");
 

/***/ }),

/***/ "./src/Resources/private/js/components/TheSearch.vue?vue&type=script&lang=js":
/*!***********************************************************************************!*\
  !*** ./src/Resources/private/js/components/TheSearch.vue?vue&type=script&lang=js ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_0_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_TheSearch_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__["default"]; }
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_0_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_TheSearch_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!../../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./TheSearch.vue?vue&type=script&lang=js */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/Resources/private/js/components/TheSearch.vue?vue&type=script&lang=js");
 

/***/ }),

/***/ "./src/Resources/private/js/App.vue?vue&type=template&id=43325c2c&scoped=true":
/*!************************************************************************************!*\
  !*** ./src/Resources/private/js/App.vue?vue&type=template&id=43325c2c&scoped=true ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": function() { return /* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_0_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_App_vue_vue_type_template_id_43325c2c_scoped_true__WEBPACK_IMPORTED_MODULE_0__.render; }
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_0_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_App_vue_vue_type_template_id_43325c2c_scoped_true__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!../../../../node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./App.vue?vue&type=template&id=43325c2c&scoped=true */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/Resources/private/js/App.vue?vue&type=template&id=43325c2c&scoped=true");


/***/ }),

/***/ "./src/Resources/private/js/components/RetailerMapIcon.vue?vue&type=template&id=58261f73&scoped=true":
/*!***********************************************************************************************************!*\
  !*** ./src/Resources/private/js/components/RetailerMapIcon.vue?vue&type=template&id=58261f73&scoped=true ***!
  \***********************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": function() { return /* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_0_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_RetailerMapIcon_vue_vue_type_template_id_58261f73_scoped_true__WEBPACK_IMPORTED_MODULE_0__.render; }
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_0_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_RetailerMapIcon_vue_vue_type_template_id_58261f73_scoped_true__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!../../../../../node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!../../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./RetailerMapIcon.vue?vue&type=template&id=58261f73&scoped=true */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/Resources/private/js/components/RetailerMapIcon.vue?vue&type=template&id=58261f73&scoped=true");


/***/ }),

/***/ "./src/Resources/private/js/components/TheMap.vue?vue&type=template&id=fbd115e6&scoped=true":
/*!**************************************************************************************************!*\
  !*** ./src/Resources/private/js/components/TheMap.vue?vue&type=template&id=fbd115e6&scoped=true ***!
  \**************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": function() { return /* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_0_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_TheMap_vue_vue_type_template_id_fbd115e6_scoped_true__WEBPACK_IMPORTED_MODULE_0__.render; }
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_0_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_TheMap_vue_vue_type_template_id_fbd115e6_scoped_true__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!../../../../../node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!../../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./TheMap.vue?vue&type=template&id=fbd115e6&scoped=true */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/Resources/private/js/components/TheMap.vue?vue&type=template&id=fbd115e6&scoped=true");


/***/ }),

/***/ "./src/Resources/private/js/components/TheRetailer.vue?vue&type=template&id=abbd3fe2":
/*!*******************************************************************************************!*\
  !*** ./src/Resources/private/js/components/TheRetailer.vue?vue&type=template&id=abbd3fe2 ***!
  \*******************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": function() { return /* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_0_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_TheRetailer_vue_vue_type_template_id_abbd3fe2__WEBPACK_IMPORTED_MODULE_0__.render; }
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_0_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_TheRetailer_vue_vue_type_template_id_abbd3fe2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!../../../../../node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!../../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./TheRetailer.vue?vue&type=template&id=abbd3fe2 */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/Resources/private/js/components/TheRetailer.vue?vue&type=template&id=abbd3fe2");


/***/ }),

/***/ "./src/Resources/private/js/components/TheSearch.vue?vue&type=template&id=6f7752f2":
/*!*****************************************************************************************!*\
  !*** ./src/Resources/private/js/components/TheSearch.vue?vue&type=template&id=6f7752f2 ***!
  \*****************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": function() { return /* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_0_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_TheSearch_vue_vue_type_template_id_6f7752f2__WEBPACK_IMPORTED_MODULE_0__.render; }
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_0_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_TheSearch_vue_vue_type_template_id_6f7752f2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!../../../../../node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!../../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./TheSearch.vue?vue&type=template&id=6f7752f2 */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/Resources/private/js/components/TheSearch.vue?vue&type=template&id=6f7752f2");


/***/ }),

/***/ "./src/Resources/private/js/App.vue?vue&type=style&index=0&id=43325c2c&scoped=true&lang=css":
/*!**************************************************************************************************!*\
  !*** ./src/Resources/private/js/App.vue?vue&type=style&index=0&id=43325c2c&scoped=true&lang=css ***!
  \**************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_clonedRuleSet_4_use_0_node_modules_css_loader_dist_cjs_js_clonedRuleSet_4_use_1_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_4_use_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_App_vue_vue_type_style_index_0_id_43325c2c_scoped_true_lang_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/mini-css-extract-plugin/dist/loader.js??clonedRuleSet-4.use[0]!../../../../node_modules/css-loader/dist/cjs.js??clonedRuleSet-4.use[1]!../../../../node_modules/vue-loader/dist/stylePostLoader.js!../../../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-4.use[2]!../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./App.vue?vue&type=style&index=0&id=43325c2c&scoped=true&lang=css */ "./node_modules/mini-css-extract-plugin/dist/loader.js??clonedRuleSet-4.use[0]!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-4.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-4.use[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/Resources/private/js/App.vue?vue&type=style&index=0&id=43325c2c&scoped=true&lang=css");


/***/ }),

/***/ "./src/Resources/private/js/components/RetailerMapIcon.vue?vue&type=style&index=0&id=58261f73&scoped=true&lang=css":
/*!*************************************************************************************************************************!*\
  !*** ./src/Resources/private/js/components/RetailerMapIcon.vue?vue&type=style&index=0&id=58261f73&scoped=true&lang=css ***!
  \*************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_clonedRuleSet_4_use_0_node_modules_css_loader_dist_cjs_js_clonedRuleSet_4_use_1_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_4_use_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_RetailerMapIcon_vue_vue_type_style_index_0_id_58261f73_scoped_true_lang_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../../node_modules/mini-css-extract-plugin/dist/loader.js??clonedRuleSet-4.use[0]!../../../../../node_modules/css-loader/dist/cjs.js??clonedRuleSet-4.use[1]!../../../../../node_modules/vue-loader/dist/stylePostLoader.js!../../../../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-4.use[2]!../../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./RetailerMapIcon.vue?vue&type=style&index=0&id=58261f73&scoped=true&lang=css */ "./node_modules/mini-css-extract-plugin/dist/loader.js??clonedRuleSet-4.use[0]!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-4.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-4.use[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/Resources/private/js/components/RetailerMapIcon.vue?vue&type=style&index=0&id=58261f73&scoped=true&lang=css");


/***/ }),

/***/ "./src/Resources/private/js/components/TheMap.vue?vue&type=style&index=0&id=fbd115e6&scoped=true&lang=css":
/*!****************************************************************************************************************!*\
  !*** ./src/Resources/private/js/components/TheMap.vue?vue&type=style&index=0&id=fbd115e6&scoped=true&lang=css ***!
  \****************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_clonedRuleSet_4_use_0_node_modules_css_loader_dist_cjs_js_clonedRuleSet_4_use_1_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_4_use_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_TheMap_vue_vue_type_style_index_0_id_fbd115e6_scoped_true_lang_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../../node_modules/mini-css-extract-plugin/dist/loader.js??clonedRuleSet-4.use[0]!../../../../../node_modules/css-loader/dist/cjs.js??clonedRuleSet-4.use[1]!../../../../../node_modules/vue-loader/dist/stylePostLoader.js!../../../../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-4.use[2]!../../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./TheMap.vue?vue&type=style&index=0&id=fbd115e6&scoped=true&lang=css */ "./node_modules/mini-css-extract-plugin/dist/loader.js??clonedRuleSet-4.use[0]!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-4.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-4.use[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/Resources/private/js/components/TheMap.vue?vue&type=style&index=0&id=fbd115e6&scoped=true&lang=css");


/***/ }),

/***/ "./node_modules/vue/dist/vue.esm-bundler.js":
/*!**************************************************!*\
  !*** ./node_modules/vue/dist/vue.esm-bundler.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseTransition": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.BaseTransition; },
/* harmony export */   "Comment": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Comment; },
/* harmony export */   "EffectScope": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.EffectScope; },
/* harmony export */   "Fragment": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Fragment; },
/* harmony export */   "KeepAlive": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.KeepAlive; },
/* harmony export */   "ReactiveEffect": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ReactiveEffect; },
/* harmony export */   "Static": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Static; },
/* harmony export */   "Suspense": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Suspense; },
/* harmony export */   "Teleport": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Teleport; },
/* harmony export */   "Text": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Text; },
/* harmony export */   "Transition": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Transition; },
/* harmony export */   "TransitionGroup": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.TransitionGroup; },
/* harmony export */   "VueElement": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.VueElement; },
/* harmony export */   "callWithAsyncErrorHandling": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.callWithAsyncErrorHandling; },
/* harmony export */   "callWithErrorHandling": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.callWithErrorHandling; },
/* harmony export */   "camelize": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.camelize; },
/* harmony export */   "capitalize": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.capitalize; },
/* harmony export */   "cloneVNode": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.cloneVNode; },
/* harmony export */   "compatUtils": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.compatUtils; },
/* harmony export */   "compile": function() { return /* binding */ compileToFunction; },
/* harmony export */   "computed": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.computed; },
/* harmony export */   "createApp": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createApp; },
/* harmony export */   "createBlock": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createBlock; },
/* harmony export */   "createCommentVNode": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode; },
/* harmony export */   "createElementBlock": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createElementBlock; },
/* harmony export */   "createElementVNode": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createElementVNode; },
/* harmony export */   "createHydrationRenderer": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createHydrationRenderer; },
/* harmony export */   "createPropsRestProxy": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createPropsRestProxy; },
/* harmony export */   "createRenderer": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createRenderer; },
/* harmony export */   "createSSRApp": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createSSRApp; },
/* harmony export */   "createSlots": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createSlots; },
/* harmony export */   "createStaticVNode": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createStaticVNode; },
/* harmony export */   "createTextVNode": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createTextVNode; },
/* harmony export */   "createVNode": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createVNode; },
/* harmony export */   "customRef": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.customRef; },
/* harmony export */   "defineAsyncComponent": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineAsyncComponent; },
/* harmony export */   "defineComponent": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineComponent; },
/* harmony export */   "defineCustomElement": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineCustomElement; },
/* harmony export */   "defineEmits": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineEmits; },
/* harmony export */   "defineExpose": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineExpose; },
/* harmony export */   "defineProps": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineProps; },
/* harmony export */   "defineSSRCustomElement": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineSSRCustomElement; },
/* harmony export */   "devtools": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.devtools; },
/* harmony export */   "effect": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.effect; },
/* harmony export */   "effectScope": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.effectScope; },
/* harmony export */   "getCurrentInstance": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance; },
/* harmony export */   "getCurrentScope": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.getCurrentScope; },
/* harmony export */   "getTransitionRawChildren": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.getTransitionRawChildren; },
/* harmony export */   "guardReactiveProps": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.guardReactiveProps; },
/* harmony export */   "h": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.h; },
/* harmony export */   "handleError": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.handleError; },
/* harmony export */   "hydrate": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.hydrate; },
/* harmony export */   "initCustomFormatter": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.initCustomFormatter; },
/* harmony export */   "initDirectivesForSSR": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.initDirectivesForSSR; },
/* harmony export */   "inject": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.inject; },
/* harmony export */   "isMemoSame": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isMemoSame; },
/* harmony export */   "isProxy": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isProxy; },
/* harmony export */   "isReactive": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isReactive; },
/* harmony export */   "isReadonly": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isReadonly; },
/* harmony export */   "isRef": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isRef; },
/* harmony export */   "isRuntimeOnly": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isRuntimeOnly; },
/* harmony export */   "isShallow": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isShallow; },
/* harmony export */   "isVNode": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isVNode; },
/* harmony export */   "markRaw": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.markRaw; },
/* harmony export */   "mergeDefaults": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.mergeDefaults; },
/* harmony export */   "mergeProps": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.mergeProps; },
/* harmony export */   "nextTick": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.nextTick; },
/* harmony export */   "normalizeClass": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.normalizeClass; },
/* harmony export */   "normalizeProps": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.normalizeProps; },
/* harmony export */   "normalizeStyle": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.normalizeStyle; },
/* harmony export */   "onActivated": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onActivated; },
/* harmony export */   "onBeforeMount": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onBeforeMount; },
/* harmony export */   "onBeforeUnmount": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount; },
/* harmony export */   "onBeforeUpdate": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onBeforeUpdate; },
/* harmony export */   "onDeactivated": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onDeactivated; },
/* harmony export */   "onErrorCaptured": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onErrorCaptured; },
/* harmony export */   "onMounted": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onMounted; },
/* harmony export */   "onRenderTracked": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onRenderTracked; },
/* harmony export */   "onRenderTriggered": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onRenderTriggered; },
/* harmony export */   "onScopeDispose": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onScopeDispose; },
/* harmony export */   "onServerPrefetch": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onServerPrefetch; },
/* harmony export */   "onUnmounted": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onUnmounted; },
/* harmony export */   "onUpdated": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onUpdated; },
/* harmony export */   "openBlock": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.openBlock; },
/* harmony export */   "popScopeId": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.popScopeId; },
/* harmony export */   "provide": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.provide; },
/* harmony export */   "proxyRefs": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.proxyRefs; },
/* harmony export */   "pushScopeId": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.pushScopeId; },
/* harmony export */   "queuePostFlushCb": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.queuePostFlushCb; },
/* harmony export */   "reactive": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.reactive; },
/* harmony export */   "readonly": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.readonly; },
/* harmony export */   "ref": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ref; },
/* harmony export */   "registerRuntimeCompiler": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.registerRuntimeCompiler; },
/* harmony export */   "render": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.render; },
/* harmony export */   "renderList": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.renderList; },
/* harmony export */   "renderSlot": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.renderSlot; },
/* harmony export */   "resolveComponent": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveComponent; },
/* harmony export */   "resolveDirective": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveDirective; },
/* harmony export */   "resolveDynamicComponent": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveDynamicComponent; },
/* harmony export */   "resolveFilter": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveFilter; },
/* harmony export */   "resolveTransitionHooks": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks; },
/* harmony export */   "setBlockTracking": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.setBlockTracking; },
/* harmony export */   "setDevtoolsHook": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.setDevtoolsHook; },
/* harmony export */   "setTransitionHooks": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks; },
/* harmony export */   "shallowReactive": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.shallowReactive; },
/* harmony export */   "shallowReadonly": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly; },
/* harmony export */   "shallowRef": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.shallowRef; },
/* harmony export */   "ssrContextKey": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ssrContextKey; },
/* harmony export */   "ssrUtils": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ssrUtils; },
/* harmony export */   "stop": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.stop; },
/* harmony export */   "toDisplayString": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toDisplayString; },
/* harmony export */   "toHandlerKey": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toHandlerKey; },
/* harmony export */   "toHandlers": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toHandlers; },
/* harmony export */   "toRaw": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toRaw; },
/* harmony export */   "toRef": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toRef; },
/* harmony export */   "toRefs": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toRefs; },
/* harmony export */   "transformVNodeArgs": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.transformVNodeArgs; },
/* harmony export */   "triggerRef": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.triggerRef; },
/* harmony export */   "unref": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.unref; },
/* harmony export */   "useAttrs": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useAttrs; },
/* harmony export */   "useCssModule": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useCssModule; },
/* harmony export */   "useCssVars": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useCssVars; },
/* harmony export */   "useSSRContext": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useSSRContext; },
/* harmony export */   "useSlots": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useSlots; },
/* harmony export */   "useTransitionState": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useTransitionState; },
/* harmony export */   "vModelCheckbox": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelCheckbox; },
/* harmony export */   "vModelDynamic": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelDynamic; },
/* harmony export */   "vModelRadio": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelRadio; },
/* harmony export */   "vModelSelect": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelSelect; },
/* harmony export */   "vModelText": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelText; },
/* harmony export */   "vShow": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vShow; },
/* harmony export */   "version": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.version; },
/* harmony export */   "warn": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.warn; },
/* harmony export */   "watch": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.watch; },
/* harmony export */   "watchEffect": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.watchEffect; },
/* harmony export */   "watchPostEffect": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.watchPostEffect; },
/* harmony export */   "watchSyncEffect": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.watchSyncEffect; },
/* harmony export */   "withAsyncContext": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withAsyncContext; },
/* harmony export */   "withCtx": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withCtx; },
/* harmony export */   "withDefaults": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withDefaults; },
/* harmony export */   "withDirectives": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withDirectives; },
/* harmony export */   "withKeys": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withKeys; },
/* harmony export */   "withMemo": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withMemo; },
/* harmony export */   "withModifiers": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withModifiers; },
/* harmony export */   "withScopeId": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withScopeId; }
/* harmony export */ });
/* harmony import */ var _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/runtime-dom */ "./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js");
/* harmony import */ var _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/runtime-dom */ "./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js");
/* harmony import */ var _vue_compiler_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @vue/compiler-dom */ "./node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js");
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");






function initDev() {
    {
        (0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_1__.initCustomFormatter)();
    }
}

// This entry is the "full-build" that includes both the runtime
if ((true)) {
    initDev();
}
const compileCache = Object.create(null);
function compileToFunction(template, options) {
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isString)(template)) {
        if (template.nodeType) {
            template = template.innerHTML;
        }
        else {
            ( true) && (0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_1__.warn)(`invalid template option: `, template);
            return _vue_shared__WEBPACK_IMPORTED_MODULE_2__.NOOP;
        }
    }
    const key = template;
    const cached = compileCache[key];
    if (cached) {
        return cached;
    }
    if (template[0] === '#') {
        const el = document.querySelector(template);
        if (( true) && !el) {
            (0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_1__.warn)(`Template element not found or is empty: ${template}`);
        }
        // __UNSAFE__
        // Reason: potential execution of JS expressions in in-DOM template.
        // The user must make sure the in-DOM template is trusted. If it's rendered
        // by the server, the template should not contain any user data.
        template = el ? el.innerHTML : ``;
    }
    const { code } = (0,_vue_compiler_dom__WEBPACK_IMPORTED_MODULE_3__.compile)(template, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.extend)({
        hoistStatic: true,
        onError: ( true) ? onError : 0,
        onWarn: ( true) ? e => onError(e, true) : 0
    }, options));
    function onError(err, asWarning = false) {
        const message = asWarning
            ? err.message
            : `Template compilation error: ${err.message}`;
        const codeFrame = err.loc &&
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.generateCodeFrame)(template, err.loc.start.offset, err.loc.end.offset);
        (0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_1__.warn)(codeFrame ? `${message}\n${codeFrame}` : message);
    }
    // The wildcard import results in a huge object with every export
    // with keys that cannot be mangled, and can be quite heavy size-wise.
    // In the global build we know `Vue` is available globally so we can avoid
    // the wildcard object.
    const render = (new Function('Vue', code)(_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__));
    render._rc = true;
    return (compileCache[key] = render);
}
(0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_1__.registerRuntimeCompiler)(compileToFunction);




/***/ }),

/***/ "./node_modules/vuex/dist/vuex.esm-bundler.js":
/*!****************************************************!*\
  !*** ./node_modules/vuex/dist/vuex.esm-bundler.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Store": function() { return /* binding */ Store; },
/* harmony export */   "createLogger": function() { return /* binding */ createLogger; },
/* harmony export */   "createNamespacedHelpers": function() { return /* binding */ createNamespacedHelpers; },
/* harmony export */   "createStore": function() { return /* binding */ createStore; },
/* harmony export */   "mapActions": function() { return /* binding */ mapActions; },
/* harmony export */   "mapGetters": function() { return /* binding */ mapGetters; },
/* harmony export */   "mapMutations": function() { return /* binding */ mapMutations; },
/* harmony export */   "mapState": function() { return /* binding */ mapState; },
/* harmony export */   "storeKey": function() { return /* binding */ storeKey; },
/* harmony export */   "useStore": function() { return /* binding */ useStore; }
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm-bundler.js");
/* harmony import */ var _vue_devtools_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/devtools-api */ "./node_modules/@vue/devtools-api/lib/esm/index.js");
/*!
 * vuex v4.0.2
 * (c) 2021 Evan You
 * @license MIT
 */



var storeKey = 'store';

function useStore (key) {
  if ( key === void 0 ) key = null;

  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(key !== null ? key : storeKey)
}

/**
 * Get the first item that pass the test
 * by second argument function
 *
 * @param {Array} list
 * @param {Function} f
 * @return {*}
 */
function find (list, f) {
  return list.filter(f)[0]
}

/**
 * Deep copy the given object considering circular structure.
 * This function caches all nested objects and its copies.
 * If it detects circular structure, use cached copy to avoid infinite loop.
 *
 * @param {*} obj
 * @param {Array<Object>} cache
 * @return {*}
 */
function deepCopy (obj, cache) {
  if ( cache === void 0 ) cache = [];

  // just return if obj is immutable value
  if (obj === null || typeof obj !== 'object') {
    return obj
  }

  // if obj is hit, it is in circular structure
  var hit = find(cache, function (c) { return c.original === obj; });
  if (hit) {
    return hit.copy
  }

  var copy = Array.isArray(obj) ? [] : {};
  // put the copy into cache at first
  // because we want to refer it in recursive deepCopy
  cache.push({
    original: obj,
    copy: copy
  });

  Object.keys(obj).forEach(function (key) {
    copy[key] = deepCopy(obj[key], cache);
  });

  return copy
}

/**
 * forEach for object
 */
function forEachValue (obj, fn) {
  Object.keys(obj).forEach(function (key) { return fn(obj[key], key); });
}

function isObject (obj) {
  return obj !== null && typeof obj === 'object'
}

function isPromise (val) {
  return val && typeof val.then === 'function'
}

function assert (condition, msg) {
  if (!condition) { throw new Error(("[vuex] " + msg)) }
}

function partial (fn, arg) {
  return function () {
    return fn(arg)
  }
}

function genericSubscribe (fn, subs, options) {
  if (subs.indexOf(fn) < 0) {
    options && options.prepend
      ? subs.unshift(fn)
      : subs.push(fn);
  }
  return function () {
    var i = subs.indexOf(fn);
    if (i > -1) {
      subs.splice(i, 1);
    }
  }
}

function resetStore (store, hot) {
  store._actions = Object.create(null);
  store._mutations = Object.create(null);
  store._wrappedGetters = Object.create(null);
  store._modulesNamespaceMap = Object.create(null);
  var state = store.state;
  // init all modules
  installModule(store, state, [], store._modules.root, true);
  // reset state
  resetStoreState(store, state, hot);
}

function resetStoreState (store, state, hot) {
  var oldState = store._state;

  // bind store public getters
  store.getters = {};
  // reset local getters cache
  store._makeLocalGettersCache = Object.create(null);
  var wrappedGetters = store._wrappedGetters;
  var computedObj = {};
  forEachValue(wrappedGetters, function (fn, key) {
    // use computed to leverage its lazy-caching mechanism
    // direct inline function use will lead to closure preserving oldState.
    // using partial to return function with only arguments preserved in closure environment.
    computedObj[key] = partial(fn, store);
    Object.defineProperty(store.getters, key, {
      // TODO: use `computed` when it's possible. at the moment we can't due to
      // https://github.com/vuejs/vuex/pull/1883
      get: function () { return computedObj[key](); },
      enumerable: true // for local getters
    });
  });

  store._state = (0,vue__WEBPACK_IMPORTED_MODULE_0__.reactive)({
    data: state
  });

  // enable strict mode for new state
  if (store.strict) {
    enableStrictMode(store);
  }

  if (oldState) {
    if (hot) {
      // dispatch changes in all subscribed watchers
      // to force getter re-evaluation for hot reloading.
      store._withCommit(function () {
        oldState.data = null;
      });
    }
  }
}

function installModule (store, rootState, path, module, hot) {
  var isRoot = !path.length;
  var namespace = store._modules.getNamespace(path);

  // register in namespace map
  if (module.namespaced) {
    if (store._modulesNamespaceMap[namespace] && ("development" !== 'production')) {
      console.error(("[vuex] duplicate namespace " + namespace + " for the namespaced module " + (path.join('/'))));
    }
    store._modulesNamespaceMap[namespace] = module;
  }

  // set state
  if (!isRoot && !hot) {
    var parentState = getNestedState(rootState, path.slice(0, -1));
    var moduleName = path[path.length - 1];
    store._withCommit(function () {
      if ((true)) {
        if (moduleName in parentState) {
          console.warn(
            ("[vuex] state field \"" + moduleName + "\" was overridden by a module with the same name at \"" + (path.join('.')) + "\"")
          );
        }
      }
      parentState[moduleName] = module.state;
    });
  }

  var local = module.context = makeLocalContext(store, namespace, path);

  module.forEachMutation(function (mutation, key) {
    var namespacedType = namespace + key;
    registerMutation(store, namespacedType, mutation, local);
  });

  module.forEachAction(function (action, key) {
    var type = action.root ? key : namespace + key;
    var handler = action.handler || action;
    registerAction(store, type, handler, local);
  });

  module.forEachGetter(function (getter, key) {
    var namespacedType = namespace + key;
    registerGetter(store, namespacedType, getter, local);
  });

  module.forEachChild(function (child, key) {
    installModule(store, rootState, path.concat(key), child, hot);
  });
}

/**
 * make localized dispatch, commit, getters and state
 * if there is no namespace, just use root ones
 */
function makeLocalContext (store, namespace, path) {
  var noNamespace = namespace === '';

  var local = {
    dispatch: noNamespace ? store.dispatch : function (_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type = args.type;

      if (!options || !options.root) {
        type = namespace + type;
        if (( true) && !store._actions[type]) {
          console.error(("[vuex] unknown local action type: " + (args.type) + ", global type: " + type));
          return
        }
      }

      return store.dispatch(type, payload)
    },

    commit: noNamespace ? store.commit : function (_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type = args.type;

      if (!options || !options.root) {
        type = namespace + type;
        if (( true) && !store._mutations[type]) {
          console.error(("[vuex] unknown local mutation type: " + (args.type) + ", global type: " + type));
          return
        }
      }

      store.commit(type, payload, options);
    }
  };

  // getters and state object must be gotten lazily
  // because they will be changed by state update
  Object.defineProperties(local, {
    getters: {
      get: noNamespace
        ? function () { return store.getters; }
        : function () { return makeLocalGetters(store, namespace); }
    },
    state: {
      get: function () { return getNestedState(store.state, path); }
    }
  });

  return local
}

function makeLocalGetters (store, namespace) {
  if (!store._makeLocalGettersCache[namespace]) {
    var gettersProxy = {};
    var splitPos = namespace.length;
    Object.keys(store.getters).forEach(function (type) {
      // skip if the target getter is not match this namespace
      if (type.slice(0, splitPos) !== namespace) { return }

      // extract local getter type
      var localType = type.slice(splitPos);

      // Add a port to the getters proxy.
      // Define as getter property because
      // we do not want to evaluate the getters in this time.
      Object.defineProperty(gettersProxy, localType, {
        get: function () { return store.getters[type]; },
        enumerable: true
      });
    });
    store._makeLocalGettersCache[namespace] = gettersProxy;
  }

  return store._makeLocalGettersCache[namespace]
}

function registerMutation (store, type, handler, local) {
  var entry = store._mutations[type] || (store._mutations[type] = []);
  entry.push(function wrappedMutationHandler (payload) {
    handler.call(store, local.state, payload);
  });
}

function registerAction (store, type, handler, local) {
  var entry = store._actions[type] || (store._actions[type] = []);
  entry.push(function wrappedActionHandler (payload) {
    var res = handler.call(store, {
      dispatch: local.dispatch,
      commit: local.commit,
      getters: local.getters,
      state: local.state,
      rootGetters: store.getters,
      rootState: store.state
    }, payload);
    if (!isPromise(res)) {
      res = Promise.resolve(res);
    }
    if (store._devtoolHook) {
      return res.catch(function (err) {
        store._devtoolHook.emit('vuex:error', err);
        throw err
      })
    } else {
      return res
    }
  });
}

function registerGetter (store, type, rawGetter, local) {
  if (store._wrappedGetters[type]) {
    if ((true)) {
      console.error(("[vuex] duplicate getter key: " + type));
    }
    return
  }
  store._wrappedGetters[type] = function wrappedGetter (store) {
    return rawGetter(
      local.state, // local state
      local.getters, // local getters
      store.state, // root state
      store.getters // root getters
    )
  };
}

function enableStrictMode (store) {
  (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(function () { return store._state.data; }, function () {
    if ((true)) {
      assert(store._committing, "do not mutate vuex store state outside mutation handlers.");
    }
  }, { deep: true, flush: 'sync' });
}

function getNestedState (state, path) {
  return path.reduce(function (state, key) { return state[key]; }, state)
}

function unifyObjectStyle (type, payload, options) {
  if (isObject(type) && type.type) {
    options = payload;
    payload = type;
    type = type.type;
  }

  if ((true)) {
    assert(typeof type === 'string', ("expects string as the type, but found " + (typeof type) + "."));
  }

  return { type: type, payload: payload, options: options }
}

var LABEL_VUEX_BINDINGS = 'vuex bindings';
var MUTATIONS_LAYER_ID = 'vuex:mutations';
var ACTIONS_LAYER_ID = 'vuex:actions';
var INSPECTOR_ID = 'vuex';

var actionId = 0;

function addDevtools (app, store) {
  (0,_vue_devtools_api__WEBPACK_IMPORTED_MODULE_1__.setupDevtoolsPlugin)(
    {
      id: 'org.vuejs.vuex',
      app: app,
      label: 'Vuex',
      homepage: 'https://next.vuex.vuejs.org/',
      logo: 'https://vuejs.org/images/icons/favicon-96x96.png',
      packageName: 'vuex',
      componentStateTypes: [LABEL_VUEX_BINDINGS]
    },
    function (api) {
      api.addTimelineLayer({
        id: MUTATIONS_LAYER_ID,
        label: 'Vuex Mutations',
        color: COLOR_LIME_500
      });

      api.addTimelineLayer({
        id: ACTIONS_LAYER_ID,
        label: 'Vuex Actions',
        color: COLOR_LIME_500
      });

      api.addInspector({
        id: INSPECTOR_ID,
        label: 'Vuex',
        icon: 'storage',
        treeFilterPlaceholder: 'Filter stores...'
      });

      api.on.getInspectorTree(function (payload) {
        if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
          if (payload.filter) {
            var nodes = [];
            flattenStoreForInspectorTree(nodes, store._modules.root, payload.filter, '');
            payload.rootNodes = nodes;
          } else {
            payload.rootNodes = [
              formatStoreForInspectorTree(store._modules.root, '')
            ];
          }
        }
      });

      api.on.getInspectorState(function (payload) {
        if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
          var modulePath = payload.nodeId;
          makeLocalGetters(store, modulePath);
          payload.state = formatStoreForInspectorState(
            getStoreModule(store._modules, modulePath),
            modulePath === 'root' ? store.getters : store._makeLocalGettersCache,
            modulePath
          );
        }
      });

      api.on.editInspectorState(function (payload) {
        if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
          var modulePath = payload.nodeId;
          var path = payload.path;
          if (modulePath !== 'root') {
            path = modulePath.split('/').filter(Boolean).concat( path);
          }
          store._withCommit(function () {
            payload.set(store._state.data, path, payload.state.value);
          });
        }
      });

      store.subscribe(function (mutation, state) {
        var data = {};

        if (mutation.payload) {
          data.payload = mutation.payload;
        }

        data.state = state;

        api.notifyComponentUpdate();
        api.sendInspectorTree(INSPECTOR_ID);
        api.sendInspectorState(INSPECTOR_ID);

        api.addTimelineEvent({
          layerId: MUTATIONS_LAYER_ID,
          event: {
            time: Date.now(),
            title: mutation.type,
            data: data
          }
        });
      });

      store.subscribeAction({
        before: function (action, state) {
          var data = {};
          if (action.payload) {
            data.payload = action.payload;
          }
          action._id = actionId++;
          action._time = Date.now();
          data.state = state;

          api.addTimelineEvent({
            layerId: ACTIONS_LAYER_ID,
            event: {
              time: action._time,
              title: action.type,
              groupId: action._id,
              subtitle: 'start',
              data: data
            }
          });
        },
        after: function (action, state) {
          var data = {};
          var duration = Date.now() - action._time;
          data.duration = {
            _custom: {
              type: 'duration',
              display: (duration + "ms"),
              tooltip: 'Action duration',
              value: duration
            }
          };
          if (action.payload) {
            data.payload = action.payload;
          }
          data.state = state;

          api.addTimelineEvent({
            layerId: ACTIONS_LAYER_ID,
            event: {
              time: Date.now(),
              title: action.type,
              groupId: action._id,
              subtitle: 'end',
              data: data
            }
          });
        }
      });
    }
  );
}

// extracted from tailwind palette
var COLOR_LIME_500 = 0x84cc16;
var COLOR_DARK = 0x666666;
var COLOR_WHITE = 0xffffff;

var TAG_NAMESPACED = {
  label: 'namespaced',
  textColor: COLOR_WHITE,
  backgroundColor: COLOR_DARK
};

/**
 * @param {string} path
 */
function extractNameFromPath (path) {
  return path && path !== 'root' ? path.split('/').slice(-2, -1)[0] : 'Root'
}

/**
 * @param {*} module
 * @return {import('@vue/devtools-api').CustomInspectorNode}
 */
function formatStoreForInspectorTree (module, path) {
  return {
    id: path || 'root',
    // all modules end with a `/`, we want the last segment only
    // cart/ -> cart
    // nested/cart/ -> cart
    label: extractNameFromPath(path),
    tags: module.namespaced ? [TAG_NAMESPACED] : [],
    children: Object.keys(module._children).map(function (moduleName) { return formatStoreForInspectorTree(
        module._children[moduleName],
        path + moduleName + '/'
      ); }
    )
  }
}

/**
 * @param {import('@vue/devtools-api').CustomInspectorNode[]} result
 * @param {*} module
 * @param {string} filter
 * @param {string} path
 */
function flattenStoreForInspectorTree (result, module, filter, path) {
  if (path.includes(filter)) {
    result.push({
      id: path || 'root',
      label: path.endsWith('/') ? path.slice(0, path.length - 1) : path || 'Root',
      tags: module.namespaced ? [TAG_NAMESPACED] : []
    });
  }
  Object.keys(module._children).forEach(function (moduleName) {
    flattenStoreForInspectorTree(result, module._children[moduleName], filter, path + moduleName + '/');
  });
}

/**
 * @param {*} module
 * @return {import('@vue/devtools-api').CustomInspectorState}
 */
function formatStoreForInspectorState (module, getters, path) {
  getters = path === 'root' ? getters : getters[path];
  var gettersKeys = Object.keys(getters);
  var storeState = {
    state: Object.keys(module.state).map(function (key) { return ({
      key: key,
      editable: true,
      value: module.state[key]
    }); })
  };

  if (gettersKeys.length) {
    var tree = transformPathsToObjectTree(getters);
    storeState.getters = Object.keys(tree).map(function (key) { return ({
      key: key.endsWith('/') ? extractNameFromPath(key) : key,
      editable: false,
      value: canThrow(function () { return tree[key]; })
    }); });
  }

  return storeState
}

function transformPathsToObjectTree (getters) {
  var result = {};
  Object.keys(getters).forEach(function (key) {
    var path = key.split('/');
    if (path.length > 1) {
      var target = result;
      var leafKey = path.pop();
      path.forEach(function (p) {
        if (!target[p]) {
          target[p] = {
            _custom: {
              value: {},
              display: p,
              tooltip: 'Module',
              abstract: true
            }
          };
        }
        target = target[p]._custom.value;
      });
      target[leafKey] = canThrow(function () { return getters[key]; });
    } else {
      result[key] = canThrow(function () { return getters[key]; });
    }
  });
  return result
}

function getStoreModule (moduleMap, path) {
  var names = path.split('/').filter(function (n) { return n; });
  return names.reduce(
    function (module, moduleName, i) {
      var child = module[moduleName];
      if (!child) {
        throw new Error(("Missing module \"" + moduleName + "\" for path \"" + path + "\"."))
      }
      return i === names.length - 1 ? child : child._children
    },
    path === 'root' ? moduleMap : moduleMap.root._children
  )
}

function canThrow (cb) {
  try {
    return cb()
  } catch (e) {
    return e
  }
}

// Base data struct for store's module, package with some attribute and method
var Module = function Module (rawModule, runtime) {
  this.runtime = runtime;
  // Store some children item
  this._children = Object.create(null);
  // Store the origin module object which passed by programmer
  this._rawModule = rawModule;
  var rawState = rawModule.state;

  // Store the origin module's state
  this.state = (typeof rawState === 'function' ? rawState() : rawState) || {};
};

var prototypeAccessors$1 = { namespaced: { configurable: true } };

prototypeAccessors$1.namespaced.get = function () {
  return !!this._rawModule.namespaced
};

Module.prototype.addChild = function addChild (key, module) {
  this._children[key] = module;
};

Module.prototype.removeChild = function removeChild (key) {
  delete this._children[key];
};

Module.prototype.getChild = function getChild (key) {
  return this._children[key]
};

Module.prototype.hasChild = function hasChild (key) {
  return key in this._children
};

Module.prototype.update = function update (rawModule) {
  this._rawModule.namespaced = rawModule.namespaced;
  if (rawModule.actions) {
    this._rawModule.actions = rawModule.actions;
  }
  if (rawModule.mutations) {
    this._rawModule.mutations = rawModule.mutations;
  }
  if (rawModule.getters) {
    this._rawModule.getters = rawModule.getters;
  }
};

Module.prototype.forEachChild = function forEachChild (fn) {
  forEachValue(this._children, fn);
};

Module.prototype.forEachGetter = function forEachGetter (fn) {
  if (this._rawModule.getters) {
    forEachValue(this._rawModule.getters, fn);
  }
};

Module.prototype.forEachAction = function forEachAction (fn) {
  if (this._rawModule.actions) {
    forEachValue(this._rawModule.actions, fn);
  }
};

Module.prototype.forEachMutation = function forEachMutation (fn) {
  if (this._rawModule.mutations) {
    forEachValue(this._rawModule.mutations, fn);
  }
};

Object.defineProperties( Module.prototype, prototypeAccessors$1 );

var ModuleCollection = function ModuleCollection (rawRootModule) {
  // register root module (Vuex.Store options)
  this.register([], rawRootModule, false);
};

ModuleCollection.prototype.get = function get (path) {
  return path.reduce(function (module, key) {
    return module.getChild(key)
  }, this.root)
};

ModuleCollection.prototype.getNamespace = function getNamespace (path) {
  var module = this.root;
  return path.reduce(function (namespace, key) {
    module = module.getChild(key);
    return namespace + (module.namespaced ? key + '/' : '')
  }, '')
};

ModuleCollection.prototype.update = function update$1 (rawRootModule) {
  update([], this.root, rawRootModule);
};

ModuleCollection.prototype.register = function register (path, rawModule, runtime) {
    var this$1$1 = this;
    if ( runtime === void 0 ) runtime = true;

  if ((true)) {
    assertRawModule(path, rawModule);
  }

  var newModule = new Module(rawModule, runtime);
  if (path.length === 0) {
    this.root = newModule;
  } else {
    var parent = this.get(path.slice(0, -1));
    parent.addChild(path[path.length - 1], newModule);
  }

  // register nested modules
  if (rawModule.modules) {
    forEachValue(rawModule.modules, function (rawChildModule, key) {
      this$1$1.register(path.concat(key), rawChildModule, runtime);
    });
  }
};

ModuleCollection.prototype.unregister = function unregister (path) {
  var parent = this.get(path.slice(0, -1));
  var key = path[path.length - 1];
  var child = parent.getChild(key);

  if (!child) {
    if ((true)) {
      console.warn(
        "[vuex] trying to unregister module '" + key + "', which is " +
        "not registered"
      );
    }
    return
  }

  if (!child.runtime) {
    return
  }

  parent.removeChild(key);
};

ModuleCollection.prototype.isRegistered = function isRegistered (path) {
  var parent = this.get(path.slice(0, -1));
  var key = path[path.length - 1];

  if (parent) {
    return parent.hasChild(key)
  }

  return false
};

function update (path, targetModule, newModule) {
  if ((true)) {
    assertRawModule(path, newModule);
  }

  // update target module
  targetModule.update(newModule);

  // update nested modules
  if (newModule.modules) {
    for (var key in newModule.modules) {
      if (!targetModule.getChild(key)) {
        if ((true)) {
          console.warn(
            "[vuex] trying to add a new module '" + key + "' on hot reloading, " +
            'manual reload is needed'
          );
        }
        return
      }
      update(
        path.concat(key),
        targetModule.getChild(key),
        newModule.modules[key]
      );
    }
  }
}

var functionAssert = {
  assert: function (value) { return typeof value === 'function'; },
  expected: 'function'
};

var objectAssert = {
  assert: function (value) { return typeof value === 'function' ||
    (typeof value === 'object' && typeof value.handler === 'function'); },
  expected: 'function or object with "handler" function'
};

var assertTypes = {
  getters: functionAssert,
  mutations: functionAssert,
  actions: objectAssert
};

function assertRawModule (path, rawModule) {
  Object.keys(assertTypes).forEach(function (key) {
    if (!rawModule[key]) { return }

    var assertOptions = assertTypes[key];

    forEachValue(rawModule[key], function (value, type) {
      assert(
        assertOptions.assert(value),
        makeAssertionMessage(path, key, type, value, assertOptions.expected)
      );
    });
  });
}

function makeAssertionMessage (path, key, type, value, expected) {
  var buf = key + " should be " + expected + " but \"" + key + "." + type + "\"";
  if (path.length > 0) {
    buf += " in module \"" + (path.join('.')) + "\"";
  }
  buf += " is " + (JSON.stringify(value)) + ".";
  return buf
}

function createStore (options) {
  return new Store(options)
}

var Store = function Store (options) {
  var this$1$1 = this;
  if ( options === void 0 ) options = {};

  if ((true)) {
    assert(typeof Promise !== 'undefined', "vuex requires a Promise polyfill in this browser.");
    assert(this instanceof Store, "store must be called with the new operator.");
  }

  var plugins = options.plugins; if ( plugins === void 0 ) plugins = [];
  var strict = options.strict; if ( strict === void 0 ) strict = false;
  var devtools = options.devtools;

  // store internal state
  this._committing = false;
  this._actions = Object.create(null);
  this._actionSubscribers = [];
  this._mutations = Object.create(null);
  this._wrappedGetters = Object.create(null);
  this._modules = new ModuleCollection(options);
  this._modulesNamespaceMap = Object.create(null);
  this._subscribers = [];
  this._makeLocalGettersCache = Object.create(null);
  this._devtools = devtools;

  // bind commit and dispatch to self
  var store = this;
  var ref = this;
  var dispatch = ref.dispatch;
  var commit = ref.commit;
  this.dispatch = function boundDispatch (type, payload) {
    return dispatch.call(store, type, payload)
  };
  this.commit = function boundCommit (type, payload, options) {
    return commit.call(store, type, payload, options)
  };

  // strict mode
  this.strict = strict;

  var state = this._modules.root.state;

  // init root module.
  // this also recursively registers all sub-modules
  // and collects all module getters inside this._wrappedGetters
  installModule(this, state, [], this._modules.root);

  // initialize the store state, which is responsible for the reactivity
  // (also registers _wrappedGetters as computed properties)
  resetStoreState(this, state);

  // apply plugins
  plugins.forEach(function (plugin) { return plugin(this$1$1); });
};

var prototypeAccessors = { state: { configurable: true } };

Store.prototype.install = function install (app, injectKey) {
  app.provide(injectKey || storeKey, this);
  app.config.globalProperties.$store = this;

  var useDevtools = this._devtools !== undefined
    ? this._devtools
    : ( true) || 0;

  if (useDevtools) {
    addDevtools(app, this);
  }
};

prototypeAccessors.state.get = function () {
  return this._state.data
};

prototypeAccessors.state.set = function (v) {
  if ((true)) {
    assert(false, "use store.replaceState() to explicit replace store state.");
  }
};

Store.prototype.commit = function commit (_type, _payload, _options) {
    var this$1$1 = this;

  // check object-style commit
  var ref = unifyObjectStyle(_type, _payload, _options);
    var type = ref.type;
    var payload = ref.payload;
    var options = ref.options;

  var mutation = { type: type, payload: payload };
  var entry = this._mutations[type];
  if (!entry) {
    if ((true)) {
      console.error(("[vuex] unknown mutation type: " + type));
    }
    return
  }
  this._withCommit(function () {
    entry.forEach(function commitIterator (handler) {
      handler(payload);
    });
  });

  this._subscribers
    .slice() // shallow copy to prevent iterator invalidation if subscriber synchronously calls unsubscribe
    .forEach(function (sub) { return sub(mutation, this$1$1.state); });

  if (
    ( true) &&
    options && options.silent
  ) {
    console.warn(
      "[vuex] mutation type: " + type + ". Silent option has been removed. " +
      'Use the filter functionality in the vue-devtools'
    );
  }
};

Store.prototype.dispatch = function dispatch (_type, _payload) {
    var this$1$1 = this;

  // check object-style dispatch
  var ref = unifyObjectStyle(_type, _payload);
    var type = ref.type;
    var payload = ref.payload;

  var action = { type: type, payload: payload };
  var entry = this._actions[type];
  if (!entry) {
    if ((true)) {
      console.error(("[vuex] unknown action type: " + type));
    }
    return
  }

  try {
    this._actionSubscribers
      .slice() // shallow copy to prevent iterator invalidation if subscriber synchronously calls unsubscribe
      .filter(function (sub) { return sub.before; })
      .forEach(function (sub) { return sub.before(action, this$1$1.state); });
  } catch (e) {
    if ((true)) {
      console.warn("[vuex] error in before action subscribers: ");
      console.error(e);
    }
  }

  var result = entry.length > 1
    ? Promise.all(entry.map(function (handler) { return handler(payload); }))
    : entry[0](payload);

  return new Promise(function (resolve, reject) {
    result.then(function (res) {
      try {
        this$1$1._actionSubscribers
          .filter(function (sub) { return sub.after; })
          .forEach(function (sub) { return sub.after(action, this$1$1.state); });
      } catch (e) {
        if ((true)) {
          console.warn("[vuex] error in after action subscribers: ");
          console.error(e);
        }
      }
      resolve(res);
    }, function (error) {
      try {
        this$1$1._actionSubscribers
          .filter(function (sub) { return sub.error; })
          .forEach(function (sub) { return sub.error(action, this$1$1.state, error); });
      } catch (e) {
        if ((true)) {
          console.warn("[vuex] error in error action subscribers: ");
          console.error(e);
        }
      }
      reject(error);
    });
  })
};

Store.prototype.subscribe = function subscribe (fn, options) {
  return genericSubscribe(fn, this._subscribers, options)
};

Store.prototype.subscribeAction = function subscribeAction (fn, options) {
  var subs = typeof fn === 'function' ? { before: fn } : fn;
  return genericSubscribe(subs, this._actionSubscribers, options)
};

Store.prototype.watch = function watch$1 (getter, cb, options) {
    var this$1$1 = this;

  if ((true)) {
    assert(typeof getter === 'function', "store.watch only accepts a function.");
  }
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(function () { return getter(this$1$1.state, this$1$1.getters); }, cb, Object.assign({}, options))
};

Store.prototype.replaceState = function replaceState (state) {
    var this$1$1 = this;

  this._withCommit(function () {
    this$1$1._state.data = state;
  });
};

Store.prototype.registerModule = function registerModule (path, rawModule, options) {
    if ( options === void 0 ) options = {};

  if (typeof path === 'string') { path = [path]; }

  if ((true)) {
    assert(Array.isArray(path), "module path must be a string or an Array.");
    assert(path.length > 0, 'cannot register the root module by using registerModule.');
  }

  this._modules.register(path, rawModule);
  installModule(this, this.state, path, this._modules.get(path), options.preserveState);
  // reset store to update getters...
  resetStoreState(this, this.state);
};

Store.prototype.unregisterModule = function unregisterModule (path) {
    var this$1$1 = this;

  if (typeof path === 'string') { path = [path]; }

  if ((true)) {
    assert(Array.isArray(path), "module path must be a string or an Array.");
  }

  this._modules.unregister(path);
  this._withCommit(function () {
    var parentState = getNestedState(this$1$1.state, path.slice(0, -1));
    delete parentState[path[path.length - 1]];
  });
  resetStore(this);
};

Store.prototype.hasModule = function hasModule (path) {
  if (typeof path === 'string') { path = [path]; }

  if ((true)) {
    assert(Array.isArray(path), "module path must be a string or an Array.");
  }

  return this._modules.isRegistered(path)
};

Store.prototype.hotUpdate = function hotUpdate (newOptions) {
  this._modules.update(newOptions);
  resetStore(this, true);
};

Store.prototype._withCommit = function _withCommit (fn) {
  var committing = this._committing;
  this._committing = true;
  fn();
  this._committing = committing;
};

Object.defineProperties( Store.prototype, prototypeAccessors );

/**
 * Reduce the code which written in Vue.js for getting the state.
 * @param {String} [namespace] - Module's namespace
 * @param {Object|Array} states # Object's item can be a function which accept state and getters for param, you can do something for state and getters in it.
 * @param {Object}
 */
var mapState = normalizeNamespace(function (namespace, states) {
  var res = {};
  if (( true) && !isValidMap(states)) {
    console.error('[vuex] mapState: mapper parameter must be either an Array or an Object');
  }
  normalizeMap(states).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    res[key] = function mappedState () {
      var state = this.$store.state;
      var getters = this.$store.getters;
      if (namespace) {
        var module = getModuleByNamespace(this.$store, 'mapState', namespace);
        if (!module) {
          return
        }
        state = module.context.state;
        getters = module.context.getters;
      }
      return typeof val === 'function'
        ? val.call(this, state, getters)
        : state[val]
    };
    // mark vuex getter for devtools
    res[key].vuex = true;
  });
  return res
});

/**
 * Reduce the code which written in Vue.js for committing the mutation
 * @param {String} [namespace] - Module's namespace
 * @param {Object|Array} mutations # Object's item can be a function which accept `commit` function as the first param, it can accept another params. You can commit mutation and do any other things in this function. specially, You need to pass anthor params from the mapped function.
 * @return {Object}
 */
var mapMutations = normalizeNamespace(function (namespace, mutations) {
  var res = {};
  if (( true) && !isValidMap(mutations)) {
    console.error('[vuex] mapMutations: mapper parameter must be either an Array or an Object');
  }
  normalizeMap(mutations).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    res[key] = function mappedMutation () {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      // Get the commit method from store
      var commit = this.$store.commit;
      if (namespace) {
        var module = getModuleByNamespace(this.$store, 'mapMutations', namespace);
        if (!module) {
          return
        }
        commit = module.context.commit;
      }
      return typeof val === 'function'
        ? val.apply(this, [commit].concat(args))
        : commit.apply(this.$store, [val].concat(args))
    };
  });
  return res
});

/**
 * Reduce the code which written in Vue.js for getting the getters
 * @param {String} [namespace] - Module's namespace
 * @param {Object|Array} getters
 * @return {Object}
 */
var mapGetters = normalizeNamespace(function (namespace, getters) {
  var res = {};
  if (( true) && !isValidMap(getters)) {
    console.error('[vuex] mapGetters: mapper parameter must be either an Array or an Object');
  }
  normalizeMap(getters).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    // The namespace has been mutated by normalizeNamespace
    val = namespace + val;
    res[key] = function mappedGetter () {
      if (namespace && !getModuleByNamespace(this.$store, 'mapGetters', namespace)) {
        return
      }
      if (( true) && !(val in this.$store.getters)) {
        console.error(("[vuex] unknown getter: " + val));
        return
      }
      return this.$store.getters[val]
    };
    // mark vuex getter for devtools
    res[key].vuex = true;
  });
  return res
});

/**
 * Reduce the code which written in Vue.js for dispatch the action
 * @param {String} [namespace] - Module's namespace
 * @param {Object|Array} actions # Object's item can be a function which accept `dispatch` function as the first param, it can accept anthor params. You can dispatch action and do any other things in this function. specially, You need to pass anthor params from the mapped function.
 * @return {Object}
 */
var mapActions = normalizeNamespace(function (namespace, actions) {
  var res = {};
  if (( true) && !isValidMap(actions)) {
    console.error('[vuex] mapActions: mapper parameter must be either an Array or an Object');
  }
  normalizeMap(actions).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    res[key] = function mappedAction () {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      // get dispatch function from store
      var dispatch = this.$store.dispatch;
      if (namespace) {
        var module = getModuleByNamespace(this.$store, 'mapActions', namespace);
        if (!module) {
          return
        }
        dispatch = module.context.dispatch;
      }
      return typeof val === 'function'
        ? val.apply(this, [dispatch].concat(args))
        : dispatch.apply(this.$store, [val].concat(args))
    };
  });
  return res
});

/**
 * Rebinding namespace param for mapXXX function in special scoped, and return them by simple object
 * @param {String} namespace
 * @return {Object}
 */
var createNamespacedHelpers = function (namespace) { return ({
  mapState: mapState.bind(null, namespace),
  mapGetters: mapGetters.bind(null, namespace),
  mapMutations: mapMutations.bind(null, namespace),
  mapActions: mapActions.bind(null, namespace)
}); };

/**
 * Normalize the map
 * normalizeMap([1, 2, 3]) => [ { key: 1, val: 1 }, { key: 2, val: 2 }, { key: 3, val: 3 } ]
 * normalizeMap({a: 1, b: 2, c: 3}) => [ { key: 'a', val: 1 }, { key: 'b', val: 2 }, { key: 'c', val: 3 } ]
 * @param {Array|Object} map
 * @return {Object}
 */
function normalizeMap (map) {
  if (!isValidMap(map)) {
    return []
  }
  return Array.isArray(map)
    ? map.map(function (key) { return ({ key: key, val: key }); })
    : Object.keys(map).map(function (key) { return ({ key: key, val: map[key] }); })
}

/**
 * Validate whether given map is valid or not
 * @param {*} map
 * @return {Boolean}
 */
function isValidMap (map) {
  return Array.isArray(map) || isObject(map)
}

/**
 * Return a function expect two param contains namespace and map. it will normalize the namespace and then the param's function will handle the new namespace and the map.
 * @param {Function} fn
 * @return {Function}
 */
function normalizeNamespace (fn) {
  return function (namespace, map) {
    if (typeof namespace !== 'string') {
      map = namespace;
      namespace = '';
    } else if (namespace.charAt(namespace.length - 1) !== '/') {
      namespace += '/';
    }
    return fn(namespace, map)
  }
}

/**
 * Search a special module from store by namespace. if module not exist, print error message.
 * @param {Object} store
 * @param {String} helper
 * @param {String} namespace
 * @return {Object}
 */
function getModuleByNamespace (store, helper, namespace) {
  var module = store._modulesNamespaceMap[namespace];
  if (( true) && !module) {
    console.error(("[vuex] module namespace not found in " + helper + "(): " + namespace));
  }
  return module
}

// Credits: borrowed code from fcomb/redux-logger

function createLogger (ref) {
  if ( ref === void 0 ) ref = {};
  var collapsed = ref.collapsed; if ( collapsed === void 0 ) collapsed = true;
  var filter = ref.filter; if ( filter === void 0 ) filter = function (mutation, stateBefore, stateAfter) { return true; };
  var transformer = ref.transformer; if ( transformer === void 0 ) transformer = function (state) { return state; };
  var mutationTransformer = ref.mutationTransformer; if ( mutationTransformer === void 0 ) mutationTransformer = function (mut) { return mut; };
  var actionFilter = ref.actionFilter; if ( actionFilter === void 0 ) actionFilter = function (action, state) { return true; };
  var actionTransformer = ref.actionTransformer; if ( actionTransformer === void 0 ) actionTransformer = function (act) { return act; };
  var logMutations = ref.logMutations; if ( logMutations === void 0 ) logMutations = true;
  var logActions = ref.logActions; if ( logActions === void 0 ) logActions = true;
  var logger = ref.logger; if ( logger === void 0 ) logger = console;

  return function (store) {
    var prevState = deepCopy(store.state);

    if (typeof logger === 'undefined') {
      return
    }

    if (logMutations) {
      store.subscribe(function (mutation, state) {
        var nextState = deepCopy(state);

        if (filter(mutation, prevState, nextState)) {
          var formattedTime = getFormattedTime();
          var formattedMutation = mutationTransformer(mutation);
          var message = "mutation " + (mutation.type) + formattedTime;

          startMessage(logger, message, collapsed);
          logger.log('%c prev state', 'color: #9E9E9E; font-weight: bold', transformer(prevState));
          logger.log('%c mutation', 'color: #03A9F4; font-weight: bold', formattedMutation);
          logger.log('%c next state', 'color: #4CAF50; font-weight: bold', transformer(nextState));
          endMessage(logger);
        }

        prevState = nextState;
      });
    }

    if (logActions) {
      store.subscribeAction(function (action, state) {
        if (actionFilter(action, state)) {
          var formattedTime = getFormattedTime();
          var formattedAction = actionTransformer(action);
          var message = "action " + (action.type) + formattedTime;

          startMessage(logger, message, collapsed);
          logger.log('%c action', 'color: #03A9F4; font-weight: bold', formattedAction);
          endMessage(logger);
        }
      });
    }
  }
}

function startMessage (logger, message, collapsed) {
  var startMessage = collapsed
    ? logger.groupCollapsed
    : logger.group;

  // render
  try {
    startMessage.call(logger, message);
  } catch (e) {
    logger.log(message);
  }
}

function endMessage (logger) {
  try {
    logger.groupEnd();
  } catch (e) {
    logger.log('—— log end ——');
  }
}

function getFormattedTime () {
  var time = new Date();
  return (" @ " + (pad(time.getHours(), 2)) + ":" + (pad(time.getMinutes(), 2)) + ":" + (pad(time.getSeconds(), 2)) + "." + (pad(time.getMilliseconds(), 3)))
}

function repeat (str, times) {
  return (new Array(times + 1)).join(str)
}

function pad (num, maxLength) {
  return repeat('0', maxLength - num.toString().length) + num
}

var index = {
  version: '4.0.2',
  Store: Store,
  storeKey: storeKey,
  createStore: createStore,
  useStore: useStore,
  mapState: mapState,
  mapMutations: mapMutations,
  mapGetters: mapGetters,
  mapActions: mapActions,
  createNamespacedHelpers: createNamespacedHelpers,
  createLogger: createLogger
};

/* harmony default export */ __webpack_exports__["default"] = (index);



/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/create fake namespace object */
/******/ 	!function() {
/******/ 		var getProto = Object.getPrototypeOf ? function(obj) { return Object.getPrototypeOf(obj); } : function(obj) { return obj.__proto__; };
/******/ 		var leafPrototypes;
/******/ 		// create a fake namespace object
/******/ 		// mode & 1: value is a module id, require it
/******/ 		// mode & 2: merge all properties of value into the ns
/******/ 		// mode & 4: return value when already ns object
/******/ 		// mode & 16: return value when it's Promise-like
/******/ 		// mode & 8|1: behave like require
/******/ 		__webpack_require__.t = function(value, mode) {
/******/ 			if(mode & 1) value = this(value);
/******/ 			if(mode & 8) return value;
/******/ 			if(typeof value === 'object' && value) {
/******/ 				if((mode & 4) && value.__esModule) return value;
/******/ 				if((mode & 16) && typeof value.then === 'function') return value;
/******/ 			}
/******/ 			var ns = Object.create(null);
/******/ 			__webpack_require__.r(ns);
/******/ 			var def = {};
/******/ 			leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
/******/ 			for(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {
/******/ 				Object.getOwnPropertyNames(current).forEach(function(key) { def[key] = function() { return value[key]; }; });
/******/ 			}
/******/ 			def['default'] = function() { return value; };
/******/ 			__webpack_require__.d(ns, def);
/******/ 			return ns;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	!function() {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = function(chunkId) {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	!function() {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = function(chunkId) {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".min.js";
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/get mini-css chunk filename */
/******/ 	!function() {
/******/ 		// This function allow to reference all chunks
/******/ 		__webpack_require__.miniCssF = function(chunkId) {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".min.css";
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	!function() {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	!function() {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "retailer-bundle:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = function(url, done, key, chunkId) {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = function(prev, event) {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach(function(fn) { return fn(event); });
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			;
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	!function() {
/******/ 		__webpack_require__.p = "/bundles/asdoriasyliusretailerplugin/";
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	!function() {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"shop-retailer": 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.f.j = function(chunkId, promises) {
/******/ 				// JSONP chunk loading for javascript
/******/ 				var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 				if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 		
/******/ 					// a Promise means "currently loading".
/******/ 					if(installedChunkData) {
/******/ 						promises.push(installedChunkData[2]);
/******/ 					} else {
/******/ 						if(true) { // all chunks have JS
/******/ 							// setup Promise in chunk cache
/******/ 							var promise = new Promise(function(resolve, reject) { installedChunkData = installedChunks[chunkId] = [resolve, reject]; });
/******/ 							promises.push(installedChunkData[2] = promise);
/******/ 		
/******/ 							// start chunk loading
/******/ 							var url = __webpack_require__.p + __webpack_require__.u(chunkId);
/******/ 							// create error before stack unwound to get useful stacktrace later
/******/ 							var error = new Error();
/******/ 							var loadingEnded = function(event) {
/******/ 								if(__webpack_require__.o(installedChunks, chunkId)) {
/******/ 									installedChunkData = installedChunks[chunkId];
/******/ 									if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
/******/ 									if(installedChunkData) {
/******/ 										var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 										var realSrc = event && event.target && event.target.src;
/******/ 										error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 										error.name = 'ChunkLoadError';
/******/ 										error.type = errorType;
/******/ 										error.request = realSrc;
/******/ 										installedChunkData[1](error);
/******/ 									}
/******/ 								}
/******/ 							};
/******/ 							__webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
/******/ 						} else installedChunks[chunkId] = 0;
/******/ 					}
/******/ 				}
/******/ 		};
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = function(parentChunkLoadingFunction, data) {
/******/ 			var chunkIds = data[0];
/******/ 			var moreModules = data[1];
/******/ 			var runtime = data[2];
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some(function(id) { return installedChunks[id] !== 0; })) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 		
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkretailer_bundle"] = self["webpackChunkretailer_bundle"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	}();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
!function() {
"use strict";
var __webpack_exports__ = {};
/*!******************************************!*\
  !*** ./src/Resources/private/js/shop.js ***!
  \******************************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm-bundler.js");
/* harmony import */ var vuex__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vuex */ "./node_modules/vuex/dist/vuex.esm-bundler.js");
/* harmony import */ var _App_vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./App.vue */ "./src/Resources/private/js/App.vue");
/* harmony import */ var semantic_ui_vue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! semantic-ui-vue */ "./node_modules/semantic-ui-vue/dist/commonjs/semantic-ui-vue.js");
/* harmony import */ var semantic_ui_vue__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(semantic_ui_vue__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var semantic_ui_css_semantic_min_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! semantic-ui-css/semantic.min.css */ "./node_modules/semantic-ui-css/semantic.min.css");





const el = document.querySelector('#app');
const store = (0,vuex__WEBPACK_IMPORTED_MODULE_4__.createStore)({
  state() {
    return {
      retailers: [],
      defaultValues: el.dataset.default,
      searchResultsLength: 0,
      centerByClick: 0
    };
  },

  getters: {
    getRetailer(state) {
      return state.retailer;
    }

  }
});
const app = (0,vue__WEBPACK_IMPORTED_MODULE_0__.createApp)(_App_vue__WEBPACK_IMPORTED_MODULE_1__["default"], { ...el.dataset
});
app.use(store);
app.use((semantic_ui_vue__WEBPACK_IMPORTED_MODULE_2___default()));
app.mount(el);
}();
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
!function() {
"use strict";
/*!**********************************************!*\
  !*** ./src/Resources/private/scss/shop.scss ***!
  \**********************************************/
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin

}();
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxVQUFVLCtDQUErQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUosc0JBQXNCLDJDQUFNOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQyxLQUFLO0FBQ0w7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QyxLQUFLO0FBQ0w7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQyxLQUFLO0FBQ0w7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQyxLQUFLO0FBQ0w7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQyxLQUFLO0FBQ0w7QUFDQSxrQ0FBa0MsVUFBVTtBQUM1QyxLQUFLO0FBQ0w7QUFDQSxrQ0FBa0MsV0FBVztBQUM3QyxLQUFLO0FBQ0w7QUFDQSxrQ0FBa0MsWUFBWTtBQUM5QyxLQUFL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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFEQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFFQUFxRSxzREFBUztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLEtBQXFDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvREFBTztBQUNuQiw0QkFBNEIsaUJBQWlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxvREFBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxtREFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEtBQXFDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsS0FBcUM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsdUNBQXVDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsaURBQUk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGtDQUFrQyxjQUFjLFFBQVE7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFxQztBQUMxQyxJQUFJLDBEQUFhO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUksbURBQU07QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDhNQUE4TTtBQUMxTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9EQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELEtBQUs7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsdURBQVUsY0FBYyxxQ0FBcUM7QUFDeEU7O0FBRUE7QUFDQTtBQUNBLFFBQVEsdURBQVU7QUFDbEIsbUJBQW1CO0FBQ25CO0FBQ0EsWUFBWTtBQUNaLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLEtBQXFDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsS0FBcUMsY0FBYyxxREFBUSxXQUFXLHVEQUFVO0FBQ3pHLGdGQUFnRixLQUFLO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLDJCQUEyQixvREFBRztBQUM5QiwwQkFBMEIsb0RBQUc7QUFDN0IsNEJBQTRCLG9EQUFHO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRixRQUFRO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGlDQUFpQyxTQUFTLGlDQUFpQyxVQUFVO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLElBQWdFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixZQUFZLHNDQUFzQyxvQkFBb0I7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJEQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsZ0JBQWdCLElBQWdFO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyREFBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsZ0JBQWdCLElBQWdFO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxVQUFVLDJCQUEyQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLElBQXFDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9EQUFPO0FBQ2Y7QUFDQTtBQUNBLGFBQWEscURBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG1EQUFNO0FBQ2QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsOERBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDhEQUFhO0FBQzdCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLElBQXFDO0FBQ25ELHdCQUF3Qix5REFBWTtBQUNwQyxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsK0RBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsS0FBcUM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0MsMENBQTBDLGtEQUFTO0FBQ25ELFlBQVksdURBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksOERBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw4REFBYTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHFEQUFRO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMscURBQVE7QUFDekMsaUNBQWlDLHVEQUFVLENBQUMscURBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQXFDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGtCQUFrQixJQUFJLEtBQUssRUFBRSxNQUFNO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLGNBQWMsSUFBcUM7QUFDbkQsdUJBQXVCLHVEQUFVLHFCQUFxQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIscURBQVE7QUFDN0IscUJBQXFCLHVEQUFVLENBQUMscURBQVE7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvREFBTyxZQUFZLHFEQUFRO0FBQ25DO0FBQ0EsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQXFDO0FBQ2xELG9FQUFvRSxPQUFPO0FBQzNFO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxhQUFhLHFEQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQSxZQUFZLG9EQUFPO0FBQ25CLDRCQUE0QixpQkFBaUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsTUFBTTtBQUN2RTtBQUNBO0FBQ0EsU0FBUyxLQUFxQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHNCQUFzQixLQUFLLEdBQUc7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxLQUFxQyxNQUFNLHFEQUFRO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5REFBWTtBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtREFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsS0FBcUMsSUFBSSxnRUFBZSxZQUFZLENBQU87QUFDOUYsbUJBQW1CLEtBQXFDLElBQUksZ0VBQWUsWUFBWSxDQUFPO0FBQzlGLG1CQUFtQixLQUFxQyxJQUFJLGdFQUFlLFlBQVksQ0FBTztBQUM5RixrQkFBa0IsS0FBcUMsSUFBSSxnRUFBZSxXQUFXLENBQU07QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLDZDQUFJO0FBQ3BFLENBQUM7QUFDRDtBQUNBO0FBQ0EsVUFBVSxhQUFhO0FBQ3ZCLGdCQUFnQiw4REFBOEQ7QUFDOUU7QUFDQSxhQUFhLEtBQXFDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBcUM7QUFDbEQsMkJBQTJCLGtEQUFTO0FBQ3BDO0FBQ0EsWUFBWSxtREFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msa0RBQVMsSUFBSSxtREFBTTtBQUN2RDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0RBQVMsSUFBSSxtREFBTTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtREFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsa0RBQVMsSUFBSSxtREFBTTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0RBQUs7QUFDckIsaUJBQWlCLEtBQXFDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixrREFBUyxJQUFJLG1EQUFNO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtREFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixLQUFxQztBQUN2RDtBQUNBLGNBQWMscURBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGtEQUFTLGdDQUFnQyxtREFBTTtBQUN4RSxpQ0FBaUMscUJBQXFCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxxQkFBcUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFVBQVUsYUFBYTtBQUN2QixnQkFBZ0Isd0JBQXdCO0FBQ3hDLDJCQUEyQixrREFBUyxJQUFJLG1EQUFNO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixrREFBUyxJQUFJLG1EQUFNO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtREFBTTtBQUN2QixhQUFhLEtBQXFDO0FBQ2xELG1EQUFtRCxJQUFJO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBcUM7QUFDbEQsOERBQThELElBQUk7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsS0FBcUM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFVBQVUsS0FBSyxnRUFBZ0U7QUFDL0U7QUFDQTtBQUNBLHNCQUFzQixrREFBUyxJQUFJLG1EQUFNO0FBQ3pDLDRCQUE0QixrREFBUyxJQUFJLG1EQUFNO0FBQy9DLG9EQUFvRCxtREFBTTtBQUMxRCxZQUFZLG1EQUFNO0FBQ2xCLFlBQVksbURBQU07QUFDbEIsWUFBWSxtREFBTTtBQUNsQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtREFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFpRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsbURBQU0sR0FBRztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx1Q0FBdUMsa0VBQXFCO0FBQzVELGFBQWEsS0FBcUM7QUFDbEQsNkJBQTZCLHFCQUFxQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDZDQUFJO0FBQ3JCLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9DQUFvQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNkNBQUk7QUFDekIsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0JBQWtCO0FBQzlCLGdCQUFnQixzREFBSztBQUNyQjtBQUNBO0FBQ0EsZ0RBQWdELHFCQUFxQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw2Q0FBSTtBQUN6QixhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsTUFBTSxZQUFZLElBQUksMEJBQTBCLFdBQVc7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QyxzQ0FBc0MsS0FBcUMsK0JBQStCLENBQUk7QUFDOUcsU0FBUyxJQUFxQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVEQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixJQUFxQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EscUJBQXFCLEVBRUo7QUFDakIscUJBQXFCLElBQXFDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixJQUFxQztBQUMzRCxnQ0FBZ0MsSUFBSSxjQUFjLHFCQUFxQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFxQyxNQUFNLHVEQUFVO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFxQyxLQUFLLHNEQUFTO0FBQ2hFLDJFQUEyRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHFEQUFRO0FBQ3JCLGFBQWEsS0FBcUM7QUFDbEQ7QUFDQTtBQUNBLDRCQUE0Qix5REFBUTtBQUNwQyxpQkFBaUIsSUFBcUM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyw2Q0FBSTtBQUNyQyx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdURBQVU7QUFDbEM7QUFDQSxrQkFBa0IsdURBQVU7QUFDNUI7QUFDQSxzQkFBc0IsNkNBQUk7QUFDMUIsaUJBQWlCLEtBQXFDLGFBQWEsNkNBQUk7QUFDdkUsMkNBQTJDLElBQUk7QUFDL0M7QUFDQSx5QkFBeUIsdURBQVUsU0FBUyx1REFBVTtBQUN0RDtBQUNBLG1CQUFtQixLQUFxQztBQUN4RDtBQUNBLDJFQUEyRSxJQUFJO0FBQy9FO0FBQ0Esc0JBQXNCLENBQUk7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsaUJBQWlCLElBQXFDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVEQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9EQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0RBQU87QUFDZjtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsNkNBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSw2Q0FBSTtBQUM5RSxRQUFRLG9EQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscURBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNEQUFLO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxxQkFBcUIsSUFBcUM7QUFDMUQsK0NBQStDLElBQUk7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsSUFBcUM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixvREFBTztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEscURBQVE7QUFDaEI7QUFDQSxZQUFZLHVEQUFVO0FBQ3RCO0FBQ0E7QUFDQSxrQkFBa0IsSUFBcUM7QUFDdkQsNERBQTRELElBQUk7QUFDaEU7QUFDQTtBQUNBLGFBQWEsdURBQVU7QUFDdkI7QUFDQTtBQUNBLGFBQWEscURBQVE7QUFDckIsWUFBWSxvREFBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsdURBQVU7QUFDdEM7QUFDQTtBQUNBLGdCQUFnQix1REFBVTtBQUMxQjtBQUNBO0FBQ0Esc0JBQXNCLElBQXFDO0FBQzNELGdFQUFnRSxZQUFZO0FBQzVFO0FBQ0E7QUFDQTtBQUNBLGNBQWMsSUFBcUM7QUFDbkQsdUNBQXVDLElBQUk7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQ0FBa0M7QUFDOUMsWUFBWSxxREFBcUQsMEJBQTBCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0NBQWtDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQXFDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1EQUFNLEVBQUUsdURBQVUsaUNBQWlDLHVEQUFVO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0RBQU87QUFDZjtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbURBQU0sQ0FBQyxtREFBTTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbURBQU07QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0RBQUc7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQXFDO0FBQzlDLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZ0VBQWU7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksdUJBQXVCLGNBQWM7QUFDakQsNEJBQTRCLHNEQUFLO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sS0FBcUM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwwQkFBMEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbURBQU07QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHFEQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbURBQU07QUFDeEI7QUFDQTtBQUNBLGlDQUFpQyxzREFBUyxtQkFBbUIsbURBQU07QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbURBQU07QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx3REFBTztBQUNmO0FBQ0EsU0FBUyxJQUFxQztBQUM5QyxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDJEQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixtREFBTSxzQkFBc0IscURBQVE7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxzREFBSztBQUNyQyw0Q0FBNEMsa0RBQVM7QUFDckQsd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBLHFHQUFxRyxtREFBTTtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixtREFBTTtBQUNqQztBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsdURBQVU7QUFDbkQsd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxzREFBUztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHVEQUFVO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLFlBQVksbURBQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrREFBUztBQUNqQyxlQUFlLGtEQUFTO0FBQ3hCO0FBQ0EsUUFBUSxvREFBTztBQUNmLHdCQUF3QixnQkFBZ0I7QUFDeEMsaUJBQWlCLEtBQXFDLE1BQU0scURBQVE7QUFDcEU7QUFDQTtBQUNBLGtDQUFrQyxxREFBUTtBQUMxQztBQUNBLDRDQUE0QyxrREFBUztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBcUMsTUFBTSxxREFBUTtBQUNoRTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MscURBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9EQUFPLFNBQVMsdURBQVUsVUFBVSxZQUFZO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLG1EQUFNO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLElBQXFDO0FBQ25ELG9DQUFvQyxJQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvREFBTztBQUNmO0FBQ0E7QUFDQSxhQUFhLHVEQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsc0RBQUs7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxtREFBTSxvQkFBb0IsbURBQU0sV0FBVyxzREFBUztBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDRCQUE0QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0RBQU87QUFDN0I7QUFDQTtBQUNBLHdCQUF3Qiw4QkFBOEI7QUFDdEQsb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxvREFBTztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscURBQVE7QUFDeEI7QUFDQTtBQUNBLGdCQUFnQixvREFBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxLQUFLO0FBQ3BFLHFCQUFxQixrQkFBa0IsbURBQVUsY0FBYztBQUMvRDtBQUNBLHlCQUF5QixzREFBUztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsY0FBYztBQUNoRDtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQSxpQ0FBaUMsY0FBYztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE1BQU07QUFDekI7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQSxrQkFBa0IsTUFBTTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0Msb0RBQU87QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBcUM7QUFDbEQsMEJBQTBCLElBQUk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1REFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsSUFDUztBQUN6QixpRUFBaUUsSUFBSTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxLQUFxQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHNEQUFLO0FBQ2xDO0FBQ0EsWUFBWSxnREFBRztBQUNmO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0RBQUc7QUFDUDtBQUNBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCO0FBQ0EsbUNBQW1DLGtEQUFTO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLEtBQXFDO0FBQ3REO0FBQ0E7QUFDQSxnQkFBZ0IsbURBQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1EQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwyQ0FBRTtBQUMzQjtBQUNBLGdDQUFnQztBQUNoQyxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHVEQUFVO0FBQ3ZCLDRDQUE0QztBQUM1QztBQUNBLGtDQUFrQyxxREFBUTtBQUMxQyxhQUFhLEtBQXFDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHFCQUFxQixJQUFxQztBQUMxRDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxxQkFBcUIsS0FBcUM7QUFDMUQ7QUFDQSxtQ0FBbUMsdURBQVU7QUFDN0M7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVEQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixJQUFxQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLElBQXFDO0FBQ25FO0FBQ0EsK0NBQStDLFdBQVc7QUFDMUQ7QUFDQTtBQUNBLDBCQUEwQixJQUFxQztBQUMvRDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxxQkFBcUIsSUFBcUM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixLQUFxQztBQUMxRCx1Q0FBdUMsS0FBSztBQUM1QztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxxQkFBcUIsSUFBcUM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixLQUFxQztBQUMxRCx1Q0FBdUMsS0FBSztBQUM1QztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLEtBQXFDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixJQUFxQztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixJQUFnRTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLElBQXFDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLElBQWdFO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsSUFBcUM7QUFDL0Q7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHFCQUFxQixLQUFxQztBQUMxRCxvRUFBb0UsWUFBWTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0RBQU87QUFDZix5REFBeUQsb0RBQU87QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CLFNBQVMsS0FBcUM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrREFBUyxtQkFBbUI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxREFBUTtBQUNwQjtBQUNBLGdCQUFnQixtREFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsc0RBQUs7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBVTtBQUNsQjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIscURBQVE7QUFDbEMsdUJBQXVCLHNEQUFLO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0RBQU8sY0FBYyxtREFBTTtBQUNuRDtBQUNBO0FBQ0EsNkJBQTZCLG9EQUFPO0FBQ3BDO0FBQ0E7QUFDQSxvQ0FBb0MsbURBQU07QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbURBQU07QUFDOUI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHNEQUFLO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLElBQXFDO0FBQy9ELGdFQUFnRSxXQUFXO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLElBQXFDO0FBQ3ZELHdEQUF3RCxXQUFXO0FBQ25FO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1DQUFtQyxrRkFBa0Y7QUFDakk7QUFDQTtBQUNBLGFBQWEsS0FBcUM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQ0FBa0M7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixLQUFxQztBQUM5RDtBQUNBLCtDQUErQywwQkFBMEI7QUFDekUsK0NBQStDLCtCQUErQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHVCQUF1QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixJQUFxQztBQUMvRCw4REFBOEQsWUFBWTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMENBQTBDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLElBQThFO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGlEQUFJLFVBQVUsMkRBQWM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLEtBQXFDO0FBQzlELGdFQUFnRSxXQUFXO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixLQUFxQztBQUMxRCxvRUFBb0UsV0FBVztBQUMvRSx5Q0FBeUMsZUFBZTtBQUN4RCx5Q0FBeUMsZUFBZTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixLQUFxQztBQUMxRCw0REFBNEQsZ0NBQWdDO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFDQUFxQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEtBQXFDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsS0FBSyxHQUFHLGFBQWE7QUFDOUM7QUFDQSxRQUFRLElBQWdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsS0FBSyxHQUFHLGFBQWE7QUFDckQ7QUFDQTtBQUNBLHlCQUF5Qiw2Q0FBNkMsSUFBSSxLQUFLO0FBQy9FO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBZ0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEtBQXFDO0FBQzlDLFFBQVEsMERBQWE7QUFDckI7QUFDQTtBQUNBLFNBQVMsS0FBcUM7QUFDOUMsUUFBUSwwREFBYTtBQUNyQjtBQUNBLFNBQVMsS0FBcUM7QUFDOUM7QUFDQSxvQ0FBb0Msa0JBQWtCLEVBQUUscUJBQXFCLEVBQUUsc0JBQXNCO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0I7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDBEQUFhO0FBQ2hDO0FBQ0EsUUFBUSxJQUFnRTtBQUN4RTtBQUNBO0FBQ0EsWUFBWSxtVEFBbVQsNkNBQUksMkVBQTJFO0FBQzlZLDJFQUEyRTtBQUMzRTtBQUNBLHFKQUFxSixLQUFxQztBQUMxTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1QkFBdUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixJQUFxQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixJQUFxQztBQUMvRCwwREFBMEQsWUFBWTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixZQUFZO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsWUFBWTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNEQUFzRDtBQUN0RSxZQUFZLEtBR2dCLGdCQUFnQixFQU1uQztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDJEQUFjO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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LHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQSx5QkFBeUIsU0FBUztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsU0FBUztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtEQUFTO0FBQzNCO0FBQ0E7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0Q0FBNEM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQ0FBZ0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDBFQUEwRTtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDenFQbitCO0FBQzNWO0FBQ3VQOztBQUV6UjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsS0FBSztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsUUFBUTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IscURBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIscURBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvREFBTztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHNEQUFTO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFEQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdURBQVU7QUFDckIsb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpRUFBb0I7QUFDOUMsNENBQTRDLCtEQUFrQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BELG9CQUFvQiwrREFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsSUFBcUM7QUFDbEQsWUFBWSx1REFBSSx5QkFBeUIsSUFBSSxRQUFRLHlCQUF5QjtBQUM5RSx5QkFBeUIsT0FBTztBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzREFBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw2RUFBMEI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9EQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpREFBSTtBQUNqQjtBQUNBLGFBQWEsNERBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCx1REFBVTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDO0FBQzdDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7Ozs7Ozs7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V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLGlDQUFpQyxtQ0FBbUM7V0FDcEU7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLE1BQU0scUJBQXFCO1dBQzNCO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTs7V0FFQTs7V0FFQTtXQUNBO1dBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2RkE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBLE1BQU0wQixFQUFFLEdBQUcvRyxRQUFRLENBQUNnSCxhQUFULENBQXVCLE1BQXZCLENBQVg7QUFFQSxNQUFNbkgsS0FBSyxHQUFHK0csaURBQVcsQ0FBQztFQUN4QjdELEtBQUssR0FBRztJQUNOLE9BQU87TUFDTEQsU0FBUyxFQUFFLEVBRE47TUFFTHhELGFBQWEsRUFBRXlILEVBQUUsQ0FBQ0UsT0FBSCxDQUFXMUgsT0FGckI7TUFHTHlGLG1CQUFtQixFQUFFLENBSGhCO01BSUxoQyxhQUFhLEVBQUU7SUFKVixDQUFQO0VBTUQsQ0FSdUI7O0VBU3hCa0UsT0FBTyxFQUFFO0lBQ1BDLFdBQVcsQ0FBQ3BFLEtBQUQsRUFBUTtNQUNqQixPQUFPQSxLQUFLLENBQUN5QixRQUFiO0lBQ0Q7O0VBSE07QUFUZSxDQUFELENBQXpCO0FBaUJBLE1BQU00QyxHQUFHLEdBQUdULDhDQUFTLENBQUNFLGdEQUFELEVBQU0sRUFDekIsR0FBR0UsRUFBRSxDQUFDRTtBQURtQixDQUFOLENBQXJCO0FBSUFHLEdBQUcsQ0FBQ0MsR0FBSixDQUFReEgsS0FBUjtBQUNBdUgsR0FBRyxDQUFDQyxHQUFKLENBQVFQLHdEQUFSO0FBQ0FNLEdBQUcsQ0FBQ0UsS0FBSixDQUFVUCxFQUFWLEU7Ozs7Ozs7OztBQ2pDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JldGFpbGVyLWJ1bmRsZS8uL25vZGVfbW9kdWxlcy9AdnVlLWxlYWZsZXQvdnVlLWxlYWZsZXQvZGlzdC92dWUtbGVhZmxldC5lc20uanMiLCJ3ZWJwYWNrOi8vcmV0YWlsZXItYnVuZGxlLy4vbm9kZV9tb2R1bGVzL0B2dWUvY29tcGlsZXItY29yZS9kaXN0L2NvbXBpbGVyLWNvcmUuZXNtLWJ1bmRsZXIuanMiLCJ3ZWJwYWNrOi8vcmV0YWlsZXItYnVuZGxlLy4vbm9kZV9tb2R1bGVzL0B2dWUvY29tcGlsZXItZG9tL2Rpc3QvY29tcGlsZXItZG9tLmVzbS1idW5kbGVyLmpzIiwid2VicGFjazovL3JldGFpbGVyLWJ1bmRsZS8uL25vZGVfbW9kdWxlcy9AdnVlL2RldnRvb2xzLWFwaS9saWIvZXNtL2NvbnN0LmpzIiwid2VicGFjazovL3JldGFpbGVyLWJ1bmRsZS8uL25vZGVfbW9kdWxlcy9AdnVlL2RldnRvb2xzLWFwaS9saWIvZXNtL2Vudi5qcyIsIndlYnBhY2s6Ly9yZXRhaWxlci1idW5kbGUvLi9ub2RlX21vZHVsZXMvQHZ1ZS9kZXZ0b29scy1hcGkvbGliL2VzbS9pbmRleC5qcyIsIndlYnBhY2s6Ly9yZXRhaWxlci1idW5kbGUvLi9ub2RlX21vZHVsZXMvQHZ1ZS9kZXZ0b29scy1hcGkvbGliL2VzbS9wcm94eS5qcyIsIndlYnBhY2s6Ly9yZXRhaWxlci1idW5kbGUvLi9ub2RlX21vZHVsZXMvQHZ1ZS9kZXZ0b29scy1hcGkvbGliL2VzbS90aW1lLmpzIiwid2VicGFjazovL3JldGFpbGVyLWJ1bmRsZS8uL25vZGVfbW9kdWxlcy9AdnVlL3JlYWN0aXZpdHkvZGlzdC9yZWFjdGl2aXR5LmVzbS1idW5kbGVyLmpzIiwid2VicGFjazovL3JldGFpbGVyLWJ1bmRsZS8uL25vZGVfbW9kdWxlcy9AdnVlL3J1bnRpbWUtY29yZS9kaXN0L3J1bnRpbWUtY29yZS5lc20tYnVuZGxlci5qcyIsIndlYnBhY2s6Ly9yZXRhaWxlci1idW5kbGUvLi9ub2RlX21vZHVsZXMvQHZ1ZS9ydW50aW1lLWRvbS9kaXN0L3J1bnRpbWUtZG9tLmVzbS1idW5kbGVyLmpzIiwid2VicGFjazovL3JldGFpbGVyLWJ1bmRsZS8uL25vZGVfbW9kdWxlcy9AdnVlL3NoYXJlZC9kaXN0L3NoYXJlZC5lc20tYnVuZGxlci5qcyIsIndlYnBhY2s6Ly9yZXRhaWxlci1idW5kbGUvLi9ub2RlX21vZHVsZXMvYXhpb3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcmV0YWlsZXItYnVuZGxlLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9hZGFwdGVycy94aHIuanMiLCJ3ZWJwYWNrOi8vcmV0YWlsZXItYnVuZGxlLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9heGlvcy5qcyIsIndlYnBhY2s6Ly9yZXRhaWxlci1idW5kbGUvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWxUb2tlbi5qcyIsIndlYnBhY2s6Ly9yZXRhaWxlci1idW5kbGUvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWxlZEVycm9yLmpzIiwid2VicGFjazovL3JldGFpbGVyLWJ1bmRsZS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL2lzQ2FuY2VsLmpzIiwid2VicGFjazovL3JldGFpbGVyLWJ1bmRsZS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9BeGlvcy5qcyIsIndlYnBhY2s6Ly9yZXRhaWxlci1idW5kbGUvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvQXhpb3NFcnJvci5qcyIsIndlYnBhY2s6Ly9yZXRhaWxlci1idW5kbGUvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvSW50ZXJjZXB0b3JNYW5hZ2VyLmpzIiwid2VicGFjazovL3JldGFpbGVyLWJ1bmRsZS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9idWlsZEZ1bGxQYXRoLmpzIiwid2VicGFjazovL3JldGFpbGVyLWJ1bmRsZS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9kaXNwYXRjaFJlcXVlc3QuanMiLCJ3ZWJwYWNrOi8vcmV0YWlsZXItYnVuZGxlLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL21lcmdlQ29uZmlnLmpzIiwid2VicGFjazovL3JldGFpbGVyLWJ1bmRsZS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9zZXR0bGUuanMiLCJ3ZWJwYWNrOi8vcmV0YWlsZXItYnVuZGxlLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL3RyYW5zZm9ybURhdGEuanMiLCJ3ZWJwYWNrOi8vcmV0YWlsZXItYnVuZGxlLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9kZWZhdWx0cy9pbmRleC5qcyIsIndlYnBhY2s6Ly9yZXRhaWxlci1idW5kbGUvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2RlZmF1bHRzL3RyYW5zaXRpb25hbC5qcyIsIndlYnBhY2s6Ly9yZXRhaWxlci1idW5kbGUvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2Vudi9kYXRhLmpzIiwid2VicGFjazovL3JldGFpbGVyLWJ1bmRsZS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9iaW5kLmpzIiwid2VicGFjazovL3JldGFpbGVyLWJ1bmRsZS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9idWlsZFVSTC5qcyIsIndlYnBhY2s6Ly9yZXRhaWxlci1idW5kbGUvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29tYmluZVVSTHMuanMiLCJ3ZWJwYWNrOi8vcmV0YWlsZXItYnVuZGxlLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2Nvb2tpZXMuanMiLCJ3ZWJwYWNrOi8vcmV0YWlsZXItYnVuZGxlLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzQWJzb2x1dGVVUkwuanMiLCJ3ZWJwYWNrOi8vcmV0YWlsZXItYnVuZGxlLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzQXhpb3NFcnJvci5qcyIsIndlYnBhY2s6Ly9yZXRhaWxlci1idW5kbGUvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNVUkxTYW1lT3JpZ2luLmpzIiwid2VicGFjazovL3JldGFpbGVyLWJ1bmRsZS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9ub3JtYWxpemVIZWFkZXJOYW1lLmpzIiwid2VicGFjazovL3JldGFpbGVyLWJ1bmRsZS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9udWxsLmpzIiwid2VicGFjazovL3JldGFpbGVyLWJ1bmRsZS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9wYXJzZUhlYWRlcnMuanMiLCJ3ZWJwYWNrOi8vcmV0YWlsZXItYnVuZGxlLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3BhcnNlUHJvdG9jb2wuanMiLCJ3ZWJwYWNrOi8vcmV0YWlsZXItYnVuZGxlLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3NwcmVhZC5qcyIsIndlYnBhY2s6Ly9yZXRhaWxlci1idW5kbGUvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvdG9Gb3JtRGF0YS5qcyIsIndlYnBhY2s6Ly9yZXRhaWxlci1idW5kbGUvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvdmFsaWRhdG9yLmpzIiwid2VicGFjazovL3JldGFpbGVyLWJ1bmRsZS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vcmV0YWlsZXItYnVuZGxlLy4vc3JjL1Jlc291cmNlcy9wcml2YXRlL2pzL0FwcC52dWUiLCJ3ZWJwYWNrOi8vcmV0YWlsZXItYnVuZGxlLy4vc3JjL1Jlc291cmNlcy9wcml2YXRlL2pzL2NvbXBvbmVudHMvUmV0YWlsZXJNYXBJY29uLnZ1ZSIsIndlYnBhY2s6Ly9yZXRhaWxlci1idW5kbGUvLi9zcmMvUmVzb3VyY2VzL3ByaXZhdGUvanMvY29tcG9uZW50cy9UaGVNYXAudnVlIiwid2VicGFjazovL3JldGFpbGVyLWJ1bmRsZS8uL3NyYy9SZXNvdXJjZXMvcHJpdmF0ZS9qcy9jb21wb25lbnRzL1RoZVJldGFpbGVyLnZ1ZSIsIndlYnBhY2s6Ly9yZXRhaWxlci1idW5kbGUvLi9zcmMvUmVzb3VyY2VzL3ByaXZhdGUvanMvY29tcG9uZW50cy9UaGVTZWFyY2gudnVlIiwid2VicGFjazovL3JldGFpbGVyLWJ1bmRsZS8uL25vZGVfbW9kdWxlcy9sZWFmbGV0L2Rpc3QvbGVhZmxldC5jc3MiLCJ3ZWJwYWNrOi8vcmV0YWlsZXItYnVuZGxlLy4vbm9kZV9tb2R1bGVzL3NlbWFudGljLXVpLWNzcy9zZW1hbnRpYy5taW4uY3NzIiwid2VicGFjazovL3JldGFpbGVyLWJ1bmRsZS8uL3NyYy9SZXNvdXJjZXMvcHJpdmF0ZS9qcy9BcHAudnVlPzFjZTgiLCJ3ZWJwYWNrOi8vcmV0YWlsZXItYnVuZGxlLy4vc3JjL1Jlc291cmNlcy9wcml2YXRlL2pzL2NvbXBvbmVudHMvUmV0YWlsZXJNYXBJY29uLnZ1ZT85NDEzIiwid2VicGFjazovL3JldGFpbGVyLWJ1bmRsZS8uL3NyYy9SZXNvdXJjZXMvcHJpdmF0ZS9qcy9jb21wb25lbnRzL1RoZU1hcC52dWU/MjI3MiIsIndlYnBhY2s6Ly9yZXRhaWxlci1idW5kbGUvLi9ub2RlX21vZHVsZXMvc2VtYW50aWMtdWktdnVlL2Rpc3QvY29tbW9uanMvc2VtYW50aWMtdWktdnVlLmpzIiwid2VicGFjazovL3JldGFpbGVyLWJ1bmRsZS8uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvZXhwb3J0SGVscGVyLmpzIiwid2VicGFjazovL3JldGFpbGVyLWJ1bmRsZS8uL3NyYy9SZXNvdXJjZXMvcHJpdmF0ZS9qcy9BcHAudnVlP2ViNTAiLCJ3ZWJwYWNrOi8vcmV0YWlsZXItYnVuZGxlLy4vc3JjL1Jlc291cmNlcy9wcml2YXRlL2pzL2NvbXBvbmVudHMvUmV0YWlsZXJNYXBJY29uLnZ1ZT85MjVhIiwid2VicGFjazovL3JldGFpbGVyLWJ1bmRsZS8uL3NyYy9SZXNvdXJjZXMvcHJpdmF0ZS9qcy9jb21wb25lbnRzL1RoZU1hcC52dWU/NDljNyIsIndlYnBhY2s6Ly9yZXRhaWxlci1idW5kbGUvLi9zcmMvUmVzb3VyY2VzL3ByaXZhdGUvanMvY29tcG9uZW50cy9UaGVSZXRhaWxlci52dWU/ZTNjYSIsIndlYnBhY2s6Ly9yZXRhaWxlci1idW5kbGUvLi9zcmMvUmVzb3VyY2VzL3ByaXZhdGUvanMvY29tcG9uZW50cy9UaGVTZWFyY2gudnVlPzgzNGQiLCJ3ZWJwYWNrOi8vcmV0YWlsZXItYnVuZGxlLy4vc3JjL1Jlc291cmNlcy9wcml2YXRlL2pzL0FwcC52dWU/MzI2OSIsIndlYnBhY2s6Ly9yZXRhaWxlci1idW5kbGUvLi9zcmMvUmVzb3VyY2VzL3ByaXZhdGUvanMvY29tcG9uZW50cy9SZXRhaWxlck1hcEljb24udnVlP2RkM2MiLCJ3ZWJwYWNrOi8vcmV0YWlsZXItYnVuZGxlLy4vc3JjL1Jlc291cmNlcy9wcml2YXRlL2pzL2NvbXBvbmVudHMvVGhlTWFwLnZ1ZT9mNTk0Iiwid2VicGFjazovL3JldGFpbGVyLWJ1bmRsZS8uL3NyYy9SZXNvdXJjZXMvcHJpdmF0ZS9qcy9jb21wb25lbnRzL1RoZVJldGFpbGVyLnZ1ZT82NGNiIiwid2VicGFjazovL3JldGFpbGVyLWJ1bmRsZS8uL3NyYy9SZXNvdXJjZXMvcHJpdmF0ZS9qcy9jb21wb25lbnRzL1RoZVNlYXJjaC52dWU/N2ZiOSIsIndlYnBhY2s6Ly9yZXRhaWxlci1idW5kbGUvLi9ub2RlX21vZHVsZXMvdnVlL2Rpc3QvdnVlLmVzbS1idW5kbGVyLmpzIiwid2VicGFjazovL3JldGFpbGVyLWJ1bmRsZS8uL25vZGVfbW9kdWxlcy92dWV4L2Rpc3QvdnVleC5lc20tYnVuZGxlci5qcyIsIndlYnBhY2s6Ly9yZXRhaWxlci1idW5kbGUvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vcmV0YWlsZXItYnVuZGxlL3dlYnBhY2svcnVudGltZS9jb21wYXQgZ2V0IGRlZmF1bHQgZXhwb3J0Iiwid2VicGFjazovL3JldGFpbGVyLWJ1bmRsZS93ZWJwYWNrL3J1bnRpbWUvY3JlYXRlIGZha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9yZXRhaWxlci1idW5kbGUvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL3JldGFpbGVyLWJ1bmRsZS93ZWJwYWNrL3J1bnRpbWUvZW5zdXJlIGNodW5rIiwid2VicGFjazovL3JldGFpbGVyLWJ1bmRsZS93ZWJwYWNrL3J1bnRpbWUvZ2V0IGphdmFzY3JpcHQgY2h1bmsgZmlsZW5hbWUiLCJ3ZWJwYWNrOi8vcmV0YWlsZXItYnVuZGxlL3dlYnBhY2svcnVudGltZS9nZXQgbWluaS1jc3MgY2h1bmsgZmlsZW5hbWUiLCJ3ZWJwYWNrOi8vcmV0YWlsZXItYnVuZGxlL3dlYnBhY2svcnVudGltZS9nbG9iYWwiLCJ3ZWJwYWNrOi8vcmV0YWlsZXItYnVuZGxlL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vcmV0YWlsZXItYnVuZGxlL3dlYnBhY2svcnVudGltZS9sb2FkIHNjcmlwdCIsIndlYnBhY2s6Ly9yZXRhaWxlci1idW5kbGUvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9yZXRhaWxlci1idW5kbGUvd2VicGFjay9ydW50aW1lL3B1YmxpY1BhdGgiLCJ3ZWJwYWNrOi8vcmV0YWlsZXItYnVuZGxlL3dlYnBhY2svcnVudGltZS9qc29ucCBjaHVuayBsb2FkaW5nIiwid2VicGFjazovL3JldGFpbGVyLWJ1bmRsZS8uL3NyYy9SZXNvdXJjZXMvcHJpdmF0ZS9qcy9zaG9wLmpzIiwid2VicGFjazovL3JldGFpbGVyLWJ1bmRsZS8uL3NyYy9SZXNvdXJjZXMvcHJpdmF0ZS9zY3NzL3Nob3Auc2NzcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB3YXRjaCwgcmVmLCBwcm92aWRlLCBoLCBpbmplY3QsIG9uVW5tb3VudGVkLCBvbkJlZm9yZVVubW91bnQsIG9uTW91bnRlZCwgbmV4dFRpY2ssIHJlbmRlciBhcyByZW5kZXIkMywgcmVhY3RpdmUsIGNvbXB1dGVkIH0gZnJvbSAndnVlJztcblxuY29uc3QgZGVib3VuY2UgPSAoZm4sIHRpbWUpID0+IHtcbiAgbGV0IHRpbWVvdXQ7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXM7XG4gICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICB9XG4gICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgZm4uYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICB9LCB0aW1lKTtcbiAgfTtcbn07XG5cbmNvbnN0IGNhcGl0YWxpemVGaXJzdExldHRlciA9IChzdHJpbmcpID0+IHtcbiAgaWYgKCFzdHJpbmcgfHwgdHlwZW9mIHN0cmluZy5jaGFyQXQgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBzdHJpbmc7XG4gIH1cbiAgcmV0dXJuIHN0cmluZy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0cmluZy5zbGljZSgxKTtcbn07XG5cbmNvbnN0IHByb3BzQmluZGVyID0gKG1ldGhvZHMsIGxlYWZsZXRFbGVtZW50LCBwcm9wcykgPT4ge1xuICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wcykge1xuICAgIGNvbnN0IHNldE1ldGhvZE5hbWUgPSBcInNldFwiICsgY2FwaXRhbGl6ZUZpcnN0TGV0dGVyKGtleSk7XG4gICAgaWYgKG1ldGhvZHNbc2V0TWV0aG9kTmFtZV0pIHtcbiAgICAgIHdhdGNoKFxuICAgICAgICAoKSA9PiBwcm9wc1trZXldLFxuICAgICAgICAobmV3VmFsLCBvbGRWYWwpID0+IHtcbiAgICAgICAgICBtZXRob2RzW3NldE1ldGhvZE5hbWVdKG5ld1ZhbCwgb2xkVmFsKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGxlYWZsZXRFbGVtZW50W3NldE1ldGhvZE5hbWVdKSB7XG4gICAgICB3YXRjaChcbiAgICAgICAgKCkgPT4gcHJvcHNba2V5XSxcbiAgICAgICAgKG5ld1ZhbCkgPT4ge1xuICAgICAgICAgIGxlYWZsZXRFbGVtZW50W3NldE1ldGhvZE5hbWVdKG5ld1ZhbCk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuICB9XG59O1xuXG5jb25zdCByZW1hcEV2ZW50cyA9IChjb250ZXh0QXR0cnMpID0+IHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGZvciAoY29uc3QgYXR0ck5hbWUgaW4gY29udGV4dEF0dHJzKSB7XG4gICAgaWYgKFxuICAgICAgYXR0ck5hbWUuc3RhcnRzV2l0aChcIm9uXCIpICYmXG4gICAgICAhYXR0ck5hbWUuc3RhcnRzV2l0aChcIm9uVXBkYXRlXCIpICYmXG4gICAgICBhdHRyTmFtZSAhPT0gXCJvblJlYWR5XCJcbiAgICApIHtcbiAgICAgIGNvbnN0IGV2ZW50TmFtZSA9IGF0dHJOYW1lLnNsaWNlKDIpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICByZXN1bHRbZXZlbnROYW1lXSA9IGNvbnRleHRBdHRyc1thdHRyTmFtZV07XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5jb25zdCByZXNldFdlYnBhY2tJY29uID0gYXN5bmMgKEljb24pID0+IHtcbiAgY29uc3QgbW9kdWxlcyA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICBpbXBvcnQoJ2xlYWZsZXQvZGlzdC9pbWFnZXMvbWFya2VyLWljb24tMngucG5nJyksXG4gICAgaW1wb3J0KCdsZWFmbGV0L2Rpc3QvaW1hZ2VzL21hcmtlci1pY29uLnBuZycpLFxuICAgIGltcG9ydCgnbGVhZmxldC9kaXN0L2ltYWdlcy9tYXJrZXItc2hhZG93LnBuZycpLFxuICBdKTtcblxuICBkZWxldGUgSWNvbi5EZWZhdWx0LnByb3RvdHlwZS5fZ2V0SWNvblVybDtcblxuICBJY29uLkRlZmF1bHQubWVyZ2VPcHRpb25zKHtcbiAgICBpY29uUmV0aW5hVXJsOiBtb2R1bGVzWzBdLmRlZmF1bHQsXG4gICAgaWNvblVybDogbW9kdWxlc1sxXS5kZWZhdWx0LFxuICAgIHNoYWRvd1VybDogbW9kdWxlc1syXS5kZWZhdWx0LFxuICB9KTtcbn07XG5cbi8qKlxuICogV3JhcHMgYSBwbGFjZWhvbGRlciBmdW5jdGlvbiBhbmQgcHJvdmlkZXMgaXQgd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cbiAqIFRoZSB3cmFwcGVyIGNhbiBsYXRlciBiZSB1cGRhdGVkIHdpdGgge0BsaW5rIHVwZGF0ZUxlYWZsZXRXcmFwcGVyfVxuICogdG8gcHJvdmlkZSBhIGRpZmZlcmVudCBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kTmFtZSBLZXkgdXNlZCB0byBwcm92aWRlIHRoZSB3cmFwcGVyIGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHByb3ZpZGVMZWFmbGV0V3JhcHBlciA9IChtZXRob2ROYW1lKSA9PiB7XG4gIGNvbnN0IHdyYXBwZWQgPSByZWYoKCkgPT5cbiAgICBjb25zb2xlLndhcm4oYE1ldGhvZCAke21ldGhvZE5hbWV9IGhhcyBiZWVuIGludm9rZWQgd2l0aG91dCBiZWluZyByZXBsYWNlZGApXG4gICk7XG4gIGNvbnN0IHdyYXBwZXIgPSAoLi4uYXJncykgPT4gd3JhcHBlZC52YWx1ZSguLi5hcmdzKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHZ1ZS9uby1yZWYtYXMtb3BlcmFuZFxuICB3cmFwcGVyLndyYXBwZWQgPSB3cmFwcGVkO1xuICBwcm92aWRlKG1ldGhvZE5hbWUsIHdyYXBwZXIpO1xuXG4gIHJldHVybiB3cmFwcGVyO1xufTtcblxuLyoqXG4gKiBDaGFuZ2UgdGhlIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIGFuIGluamVjdGVkIExlYWZsZXQgd3JhcHBlclxuICogaXMgaW52b2tlZC5cbiAqXG4gKiBAcGFyYW0geyp9IHdyYXBwZXIgUHJvdmlkZWQgd3JhcHBlciB3aG9zZSB3cmFwcGVkIGZ1bmN0aW9uIGlzIHRvIGJlIHVwZGF0ZWRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGxlYWZsZXRNZXRob2QgTmV3IG1ldGhvZCB0byBiZSB3cmFwcGVkIGJ5IHRoZSB3cmFwcGVyXG4gKi9cbmNvbnN0IHVwZGF0ZUxlYWZsZXRXcmFwcGVyID0gKHdyYXBwZXIsIGxlYWZsZXRNZXRob2QpID0+XG4gICh3cmFwcGVyLndyYXBwZWQudmFsdWUgPSBsZWFmbGV0TWV0aG9kKTtcblxuY29uc3QgV0lORE9XX09SX0dMT0JBTCA9XG4gICh0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiAmJiBzZWxmLnNlbGYgPT09IHNlbGYgJiYgc2VsZikgfHxcbiAgKHR5cGVvZiBnbG9iYWwgPT09IFwib2JqZWN0XCIgJiYgZ2xvYmFsLmdsb2JhbCA9PT0gZ2xvYmFsICYmIGdsb2JhbCkgfHxcbiAgdW5kZWZpbmVkO1xuXG5jb25zdCBHTE9CQUxfTEVBRkxFVF9PUFQgPSBcInVzZUdsb2JhbExlYWZsZXRcIjtcblxuY29uc3QgcHJvcHMgPSB7XG4gIG9wdGlvbnM6IHtcbiAgICB0eXBlOiBPYmplY3QsXG4gICAgZGVmYXVsdDogKCkgPT4gKHt9KSxcbiAgfSxcbn07XG5cbmNvbnN0IHNldHVwID0gKHByb3BzKSA9PiB7XG4gIHJldHVybiB7IG9wdGlvbnM6IHByb3BzLm9wdGlvbnMsIG1ldGhvZHM6IHt9IH07XG59O1xuXG5jb25zdCBwcm9wcyQxID0ge1xuICAuLi5wcm9wcyxcbiAgcGFuZToge1xuICAgIHR5cGU6IFN0cmluZyxcbiAgICBkZWZhdWx0OiBcIm92ZXJsYXlQYW5lXCIsXG4gIH0sXG4gIGF0dHJpYnV0aW9uOiB7XG4gICAgdHlwZTogU3RyaW5nLFxuICAgIGRlZmF1bHQ6IG51bGwsXG4gIH0sXG4gIG5hbWU6IHtcbiAgICB0eXBlOiBTdHJpbmcsXG4gICAgY3VzdG9tOiB0cnVlLFxuICAgIGRlZmF1bHQ6IHVuZGVmaW5lZCxcbiAgfSxcbiAgbGF5ZXJUeXBlOiB7XG4gICAgdHlwZTogU3RyaW5nLFxuICAgIGN1c3RvbTogdHJ1ZSxcbiAgICBkZWZhdWx0OiB1bmRlZmluZWQsXG4gIH0sXG4gIHZpc2libGU6IHtcbiAgICB0eXBlOiBCb29sZWFuLFxuICAgIGN1c3RvbTogdHJ1ZSxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICB9LFxufTtcblxuY29uc3Qgc2V0dXAkMSA9IChwcm9wcywgbGVhZmxldFJlZiwgY29udGV4dCkgPT4ge1xuICBjb25zdCBhZGRMYXllciA9IGluamVjdChcImFkZExheWVyXCIpO1xuICBjb25zdCByZW1vdmVMYXllciA9IGluamVjdChcInJlbW92ZUxheWVyXCIpO1xuICBjb25zdCB7XG4gICAgb3B0aW9uczogY29tcG9uZW50T3B0aW9ucyxcbiAgICBtZXRob2RzOiBjb21wb25lbnRNZXRob2RzLFxuICB9ID0gc2V0dXAocHJvcHMpO1xuXG4gIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgLi4uY29tcG9uZW50T3B0aW9ucyxcbiAgICBhdHRyaWJ1dGlvbjogcHJvcHMuYXR0cmlidXRpb24sXG4gICAgcGFuZTogcHJvcHMucGFuZSxcbiAgfTtcblxuICBjb25zdCBhZGRUaGlzTGF5ZXIgPSAoKSA9PiBhZGRMYXllcih7IGxlYWZsZXRPYmplY3Q6IGxlYWZsZXRSZWYudmFsdWUgfSk7XG4gIGNvbnN0IHJlbW92ZVRoaXNMYXllciA9ICgpID0+XG4gICAgcmVtb3ZlTGF5ZXIoeyBsZWFmbGV0T2JqZWN0OiBsZWFmbGV0UmVmLnZhbHVlIH0pO1xuXG4gIGNvbnN0IG1ldGhvZHMgPSB7XG4gICAgLi4uY29tcG9uZW50TWV0aG9kcyxcbiAgICBzZXRBdHRyaWJ1dGlvbih2YWwsIG9sZCkge1xuICAgICAgY29uc3QgYXR0cmlidXRpb25Db250cm9sID0gdGhpcy4kcGFyZW50LmxlYWZsZXRPYmplY3QuYXR0cmlidXRpb25Db250cm9sO1xuICAgICAgYXR0cmlidXRpb25Db250cm9sLnJlbW92ZUF0dHJpYnV0aW9uKG9sZCkuYWRkQXR0cmlidXRpb24odmFsKTtcbiAgICB9LFxuICAgIHNldE5hbWUoKSB7XG4gICAgICByZW1vdmVUaGlzTGF5ZXIoKTtcbiAgICAgIGlmIChwcm9wcy52aXNpYmxlKSB7XG4gICAgICAgIGFkZFRoaXNMYXllcigpO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2V0TGF5ZXJUeXBlKCkge1xuICAgICAgcmVtb3ZlVGhpc0xheWVyKCk7XG4gICAgICBpZiAocHJvcHMudmlzaWJsZSkge1xuICAgICAgICBhZGRUaGlzTGF5ZXIoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNldFZpc2libGUoaXNWaXNpYmxlKSB7XG4gICAgICBpZiAobGVhZmxldFJlZi52YWx1ZSkge1xuICAgICAgICBpZiAoaXNWaXNpYmxlKSB7XG4gICAgICAgICAgYWRkVGhpc0xheWVyKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVtb3ZlVGhpc0xheWVyKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGJpbmRQb3B1cCh7IGxlYWZsZXRPYmplY3QgfSkge1xuICAgICAgbGVhZmxldFJlZi52YWx1ZS5iaW5kUG9wdXAobGVhZmxldE9iamVjdCk7XG4gICAgfSxcbiAgICBiaW5kVG9vbHRpcCh7IGxlYWZsZXRPYmplY3QgfSkge1xuICAgICAgbGVhZmxldFJlZi52YWx1ZS5iaW5kVG9vbHRpcChsZWFmbGV0T2JqZWN0KTtcbiAgICB9LFxuICAgIHVuYmluZFRvb2x0aXAoKSB7XG4gICAgICBjb25zdCB0b29sdGlwID0gbGVhZmxldFJlZi52YWx1ZSA/IGxlYWZsZXRSZWYudmFsdWUuZ2V0VG9vbHRpcCgpIDogbnVsbDtcbiAgICAgIGlmICh0b29sdGlwKSB7XG4gICAgICAgIHRvb2x0aXAudW5iaW5kVG9vbHRpcCgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdW5iaW5kUG9wdXAoKSB7XG4gICAgICBjb25zdCBwb3B1cCA9IGxlYWZsZXRSZWYudmFsdWUgPyBsZWFmbGV0UmVmLnZhbHVlLmdldFBvcHVwKCkgOiBudWxsO1xuICAgICAgaWYgKHBvcHVwKSB7XG4gICAgICAgIHBvcHVwLnVuYmluZFBvcHVwKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICB1cGRhdGVWaXNpYmxlUHJvcCh2YWx1ZSkge1xuICAgICAgLyoqXG4gICAgICAgKiBUcmlnZ2VycyB3aGVuIHRoZSB2aXNpYmxlIHByb3AgbmVlZHMgdG8gYmUgdXBkYXRlZFxuICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHZhbHVlIC0gdmFsdWUgb2YgdGhlIHZpc2libGUgcHJvcGVydHlcbiAgICAgICAqL1xuICAgICAgY29udGV4dC5lbWl0KFwidXBkYXRlOnZpc2libGVcIiwgdmFsdWUpO1xuICAgIH0sXG4gIH07XG5cbiAgcHJvdmlkZShcImJpbmRQb3B1cFwiLCBtZXRob2RzLmJpbmRQb3B1cCk7XG4gIHByb3ZpZGUoXCJiaW5kVG9vbHRpcFwiLCBtZXRob2RzLmJpbmRUb29sdGlwKTtcbiAgcHJvdmlkZShcInVuYmluZFRvb2x0aXBcIiwgbWV0aG9kcy51bmJpbmRUb29sdGlwKTtcbiAgcHJvdmlkZShcInVuYmluZFBvcHVwXCIsIG1ldGhvZHMudW5iaW5kUG9wdXApO1xuXG4gIG9uVW5tb3VudGVkKCgpID0+IHtcbiAgICBtZXRob2RzLnVuYmluZFBvcHVwKCk7XG4gICAgbWV0aG9kcy51bmJpbmRUb29sdGlwKCk7XG4gICAgcmVtb3ZlVGhpc0xheWVyKCk7XG4gIH0pO1xuXG4gIHJldHVybiB7IG9wdGlvbnMsIG1ldGhvZHMgfTtcbn07XG5cbmNvbnN0IHJlbmRlciA9IChyZWFkeSwgc2xvdHMpID0+IHtcbiAgaWYgKHJlYWR5ICYmIHNsb3RzLmRlZmF1bHQpIHtcbiAgICByZXR1cm4gaChcImRpdlwiLCB7IHN0eWxlOiB7IGRpc3BsYXk6IFwibm9uZVwiIH0gfSwgc2xvdHMuZGVmYXVsdCgpKTtcbiAgfVxufTtcblxuY29uc3QgcHJvcHMkMiA9IHtcbiAgLi4ucHJvcHMsXG4gIGludGVyYWN0aXZlOiB7XG4gICAgdHlwZTogQm9vbGVhbixcbiAgICBkZWZhdWx0OiB0cnVlLFxuICB9LFxuICBidWJibGluZ01vdXNlRXZlbnRzOiB7XG4gICAgdHlwZTogQm9vbGVhbixcbiAgICBkZWZhdWx0OiB0cnVlLFxuICB9LFxufTtcblxuY29uc3Qgc2V0dXAkMiA9IChwcm9wcykgPT4ge1xuICBjb25zdCB7IG9wdGlvbnM6IGNvbXBvbmVudE9wdGlvbnMsIG1ldGhvZHMgfSA9IHNldHVwKHByb3BzKTtcbiAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAuLi5jb21wb25lbnRPcHRpb25zLFxuICAgIGludGVyYWN0aXZlOiBwcm9wcy5pbnRlcmFjdGl2ZSxcbiAgICBidWJibGluZ01vdXNlRXZlbnRzOiBwcm9wcy5idWJibGluZ01vdXNlRXZlbnRzLFxuICB9O1xuXG4gIHJldHVybiB7IG9wdGlvbnMsIG1ldGhvZHMgfTtcbn07XG5cbmNvbnN0IHByb3BzJDMgPSB7XG4gIC4uLnByb3BzJDEsXG4gIC4uLnByb3BzJDIsXG4gIHN0cm9rZToge1xuICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgY3VzdG9tOiB0cnVlLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gIH0sXG4gIGNvbG9yOiB7XG4gICAgdHlwZTogU3RyaW5nLFxuICAgIGN1c3RvbTogdHJ1ZSxcbiAgICBkZWZhdWx0OiBcIiMzMzg4ZmZcIixcbiAgfSxcbiAgd2VpZ2h0OiB7XG4gICAgdHlwZTogTnVtYmVyLFxuICAgIGN1c3RvbTogdHJ1ZSxcbiAgICBkZWZhdWx0OiAzLFxuICB9LFxuICBvcGFjaXR5OiB7XG4gICAgdHlwZTogTnVtYmVyLFxuICAgIGN1c3RvbTogdHJ1ZSxcbiAgICBkZWZhdWx0OiAxLjAsXG4gIH0sXG4gIGxpbmVDYXA6IHtcbiAgICB0eXBlOiBTdHJpbmcsXG4gICAgY3VzdG9tOiB0cnVlLFxuICAgIGRlZmF1bHQ6IFwicm91bmRcIixcbiAgfSxcbiAgbGluZUpvaW46IHtcbiAgICB0eXBlOiBTdHJpbmcsXG4gICAgY3VzdG9tOiB0cnVlLFxuICAgIGRlZmF1bHQ6IFwicm91bmRcIixcbiAgfSxcbiAgZGFzaEFycmF5OiB7XG4gICAgdHlwZTogU3RyaW5nLFxuICAgIGN1c3RvbTogdHJ1ZSxcbiAgICBkZWZhdWx0OiBudWxsLFxuICB9LFxuICBkYXNoT2Zmc2V0OiB7XG4gICAgdHlwZTogU3RyaW5nLFxuICAgIGN1c3RvbTogdHJ1ZSxcbiAgICBkZWZhdWx0OiBudWxsLFxuICB9LFxuICBmaWxsOiB7XG4gICAgdHlwZTogQm9vbGVhbixcbiAgICBjdXN0b206IHRydWUsXG4gICAgZGVmYXVsdDogZmFsc2UsXG4gIH0sXG4gIGZpbGxDb2xvcjoge1xuICAgIHR5cGU6IFN0cmluZyxcbiAgICBjdXN0b206IHRydWUsXG4gICAgZGVmYXVsdDogXCIjMzM4OGZmXCIsXG4gIH0sXG4gIGZpbGxPcGFjaXR5OiB7XG4gICAgdHlwZTogTnVtYmVyLFxuICAgIGN1c3RvbTogdHJ1ZSxcbiAgICBkZWZhdWx0OiAwLjIsXG4gIH0sXG4gIGZpbGxSdWxlOiB7XG4gICAgdHlwZTogU3RyaW5nLFxuICAgIGN1c3RvbTogdHJ1ZSxcbiAgICBkZWZhdWx0OiBcImV2ZW5vZGRcIixcbiAgfSxcbiAgY2xhc3NOYW1lOiB7XG4gICAgdHlwZTogU3RyaW5nLFxuICAgIGN1c3RvbTogdHJ1ZSxcbiAgICBkZWZhdWx0OiBudWxsLFxuICB9LFxufTtcblxuY29uc3Qgc2V0dXAkMyA9IChwcm9wcywgbGVhZmxldFJlZiwgY29udGV4dCkgPT4ge1xuICBjb25zdCB7IG9wdGlvbnM6IGxheWVyT3B0aW9ucywgbWV0aG9kczogbGF5ZXJNZXRob2RzIH0gPSBzZXR1cCQxKFxuICAgIHByb3BzLFxuICAgIGxlYWZsZXRSZWYsXG4gICAgY29udGV4dFxuICApO1xuICBjb25zdCB7XG4gICAgb3B0aW9uczogaW50ZXJhY3RpdmVMYXllck9wdGlvbnMsXG4gICAgbWV0aG9kczogaW50ZXJhY3RpdmVMYXllck1ldGhvZHMsXG4gIH0gPSBzZXR1cCQyKHByb3BzKTtcblxuICBjb25zdCByZW1vdmVMYXllciA9IGluamVjdChcInJlbW92ZUxheWVyXCIpO1xuXG4gIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgLi4ubGF5ZXJPcHRpb25zLFxuICAgIC4uLmludGVyYWN0aXZlTGF5ZXJPcHRpb25zLFxuICAgIHN0cm9rZTogcHJvcHMuc3Ryb2tlLFxuICAgIGNvbG9yOiBwcm9wcy5jb2xvcixcbiAgICB3ZWlnaHQ6IHByb3BzLndlaWdodCxcbiAgICBvcGFjaXR5OiBwcm9wcy5vcGFjaXR5LFxuICAgIGxpbmVDYXA6IHByb3BzLmxpbmVDYXAsXG4gICAgbGluZUpvaW46IHByb3BzLmxpbmVKb2luLFxuICAgIGRhc2hBcnJheTogcHJvcHMuZGFzaEFycmF5LFxuICAgIGRhc2hPZmZzZXQ6IHByb3BzLmRhc2hPZmZzZXQsXG4gICAgZmlsbDogcHJvcHMuZmlsbCxcbiAgICBmaWxsQ29sb3I6IHByb3BzLmZpbGxDb2xvcixcbiAgICBmaWxsT3BhY2l0eTogcHJvcHMuZmlsbE9wYWNpdHksXG4gICAgZmlsbFJ1bGU6IHByb3BzLmZpbGxSdWxlLFxuICAgIGNsYXNzTmFtZTogcHJvcHMuY2xhc3NOYW1lLFxuICB9O1xuICBjb25zdCBtZXRob2RzID0ge1xuICAgIC4uLmxheWVyTWV0aG9kcyxcbiAgICAuLi5pbnRlcmFjdGl2ZUxheWVyTWV0aG9kcyxcbiAgICBzZXRTdHJva2Uoc3Ryb2tlKSB7XG4gICAgICBsZWFmbGV0UmVmLnZhbHVlLnNldFN0eWxlKHsgc3Ryb2tlIH0pO1xuICAgIH0sXG4gICAgc2V0Q29sb3IoY29sb3IpIHtcbiAgICAgIGxlYWZsZXRSZWYudmFsdWUuc2V0U3R5bGUoeyBjb2xvciB9KTtcbiAgICB9LFxuICAgIHNldFdlaWdodCh3ZWlnaHQpIHtcbiAgICAgIGxlYWZsZXRSZWYudmFsdWUuc2V0U3R5bGUoeyB3ZWlnaHQgfSk7XG4gICAgfSxcbiAgICBzZXRPcGFjaXR5KG9wYWNpdHkpIHtcbiAgICAgIGxlYWZsZXRSZWYudmFsdWUuc2V0U3R5bGUoeyBvcGFjaXR5IH0pO1xuICAgIH0sXG4gICAgc2V0TGluZUNhcChsaW5lQ2FwKSB7XG4gICAgICBsZWFmbGV0UmVmLnZhbHVlLnNldFN0eWxlKHsgbGluZUNhcCB9KTtcbiAgICB9LFxuICAgIHNldExpbmVKb2luKGxpbmVKb2luKSB7XG4gICAgICBsZWFmbGV0UmVmLnZhbHVlLnNldFN0eWxlKHsgbGluZUpvaW4gfSk7XG4gICAgfSxcbiAgICBzZXREYXNoQXJyYXkoZGFzaEFycmF5KSB7XG4gICAgICBsZWFmbGV0UmVmLnZhbHVlLnNldFN0eWxlKHsgZGFzaEFycmF5IH0pO1xuICAgIH0sXG4gICAgc2V0RGFzaE9mZnNldChkYXNoT2Zmc2V0KSB7XG4gICAgICBsZWFmbGV0UmVmLnZhbHVlLnNldFN0eWxlKHsgZGFzaE9mZnNldCB9KTtcbiAgICB9LFxuICAgIHNldEZpbGwoZmlsbCkge1xuICAgICAgbGVhZmxldFJlZi52YWx1ZS5zZXRTdHlsZSh7IGZpbGwgfSk7XG4gICAgfSxcbiAgICBzZXRGaWxsQ29sb3IoZmlsbENvbG9yKSB7XG4gICAgICBsZWFmbGV0UmVmLnZhbHVlLnNldFN0eWxlKHsgZmlsbENvbG9yIH0pO1xuICAgIH0sXG4gICAgc2V0RmlsbE9wYWNpdHkoZmlsbE9wYWNpdHkpIHtcbiAgICAgIGxlYWZsZXRSZWYudmFsdWUuc2V0U3R5bGUoeyBmaWxsT3BhY2l0eSB9KTtcbiAgICB9LFxuICAgIHNldEZpbGxSdWxlKGZpbGxSdWxlKSB7XG4gICAgICBsZWFmbGV0UmVmLnZhbHVlLnNldFN0eWxlKHsgZmlsbFJ1bGUgfSk7XG4gICAgfSxcbiAgICBzZXRDbGFzc05hbWUoY2xhc3NOYW1lKSB7XG4gICAgICBsZWFmbGV0UmVmLnZhbHVlLnNldFN0eWxlKHsgY2xhc3NOYW1lIH0pO1xuICAgIH0sXG4gIH07XG5cbiAgb25CZWZvcmVVbm1vdW50KCgpID0+IHtcbiAgICByZW1vdmVMYXllcih7IGxlYWZsZXRPYmplY3Q6IGxlYWZsZXRSZWYudmFsdWUgfSk7XG4gIH0pO1xuXG4gIHJldHVybiB7IG9wdGlvbnMsIG1ldGhvZHMgfTtcbn07XG5cbmNvbnN0IHByb3BzJDQgPSB7XG4gIC4uLnByb3BzJDMsXG4gIGxhdExuZzoge1xuICAgIHR5cGU6IFtPYmplY3QsIEFycmF5XSxcbiAgICBjdXN0b206IHRydWUsXG4gICAgZGVmYXVsdDogbnVsbCxcbiAgfSxcbiAgLyoqXG4gICAqIFJhZGl1cyBvZiB0aGUgbWFya2VyIGluIHBpeGVscy5cbiAgICovXG4gIHJhZGl1czoge1xuICAgIHR5cGU6IE51bWJlcixcbiAgICBkZWZhdWx0OiBudWxsLFxuICB9LFxufTtcblxuY29uc3Qgc2V0dXAkNCA9IChwcm9wcywgbGVhZmxldFJlZiwgY29udGV4dCkgPT4ge1xuICBjb25zdCB7IG9wdGlvbnM6IHBhdGhPcHRpb25zLCBtZXRob2RzOiBwYXRoTWV0aG9kcyB9ID0gc2V0dXAkMyhcbiAgICBwcm9wcyxcbiAgICBsZWFmbGV0UmVmLFxuICAgIGNvbnRleHRcbiAgKTtcbiAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAuLi5wYXRoT3B0aW9ucyxcbiAgICAuLi5wcm9wcyxcbiAgfTtcbiAgY29uc3QgbWV0aG9kcyA9IHtcbiAgICAuLi5wYXRoTWV0aG9kcyxcbiAgICBzZXRSYWRpdXMocmFkaXVzKSB7XG4gICAgICBsZWFmbGV0UmVmLnZhbHVlLnNldFJhZGl1cyhyYWRpdXMpO1xuICAgIH0sXG4gICAgc2V0TGF0TG5nKGxhdExuZykge1xuICAgICAgbGVhZmxldFJlZi52YWx1ZS5zZXRMYXRMbmcobGF0TG5nKTtcbiAgICB9LFxuICB9O1xuXG4gIHJldHVybiB7IG9wdGlvbnMsIG1ldGhvZHMgfTtcbn07XG5cbmNvbnN0IHByb3BzJDUgPSB7XG4gIC4uLnByb3BzJDQsXG4gIC8qKlxuICAgKiBSYWRpdXMgb2YgdGhlIGNpcmNsZSBpbiBtZXRlcnMuXG4gICAqL1xuICByYWRpdXM6IHtcbiAgICB0eXBlOiBOdW1iZXIsXG4gICAgZGVmYXVsdDogbnVsbCxcbiAgfSxcbn07XG5cbmNvbnN0IHNldHVwJDUgPSAocHJvcHMsIGxlYWZsZXRSZWYsIGNvbnRleHQpID0+IHtcbiAgY29uc3Qge1xuICAgIG9wdGlvbnM6IGNpcmNsZU1hcmtlck9wdGlvbnMsXG4gICAgbWV0aG9kczogY2lyY2xlTWFya2VyTWV0aG9kcyxcbiAgfSA9IHNldHVwJDQocHJvcHMsIGxlYWZsZXRSZWYsIGNvbnRleHQpO1xuXG4gIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgLi4uY2lyY2xlTWFya2VyT3B0aW9ucyxcbiAgICAuLi5wcm9wcyxcbiAgfTtcblxuICBjb25zdCBtZXRob2RzID0ge1xuICAgIC4uLmNpcmNsZU1hcmtlck1ldGhvZHMsXG4gIH07XG5cbiAgcmV0dXJuIHsgb3B0aW9ucywgbWV0aG9kcyB9O1xufTtcblxuLyoqXG4gKiBDaXJjbGUgY29tcG9uZW50LCBsZXRzIHlvdSBhZGQgYW5kIHBlcnNvbmFsaXplIGNpcmNsZXMgb24gdGhlIG1hcFxuICovXG52YXIgc2NyaXB0ID0ge1xuICBuYW1lOiBcIkxDaXJjbGVcIixcbiAgcHJvcHM6IHByb3BzJDUsXG4gIHNldHVwKHByb3BzLCBjb250ZXh0KSB7XG4gICAgY29uc3QgbGVhZmxldFJlZiA9IHJlZih7fSk7XG4gICAgY29uc3QgcmVhZHkgPSByZWYoZmFsc2UpO1xuXG4gICAgY29uc3QgdXNlR2xvYmFsTGVhZmxldCA9IGluamVjdChHTE9CQUxfTEVBRkxFVF9PUFQpO1xuICAgIGNvbnN0IGFkZExheWVyID0gaW5qZWN0KFwiYWRkTGF5ZXJcIik7XG5cbiAgICBjb25zdCB7IG9wdGlvbnMsIG1ldGhvZHMgfSA9IHNldHVwJDUocHJvcHMsIGxlYWZsZXRSZWYsIGNvbnRleHQpO1xuXG4gICAgb25Nb3VudGVkKGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHsgY2lyY2xlLCBEb21FdmVudCB9ID0gdXNlR2xvYmFsTGVhZmxldFxuICAgICAgICA/IFdJTkRPV19PUl9HTE9CQUwuTFxuICAgICAgICA6IGF3YWl0IGltcG9ydCgnbGVhZmxldC9kaXN0L2xlYWZsZXQtc3JjLmVzbScpO1xuXG4gICAgICBsZWFmbGV0UmVmLnZhbHVlID0gY2lyY2xlKHByb3BzLmxhdExuZywgb3B0aW9ucyk7XG5cbiAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHJlbWFwRXZlbnRzKGNvbnRleHQuYXR0cnMpO1xuICAgICAgRG9tRXZlbnQub24obGVhZmxldFJlZi52YWx1ZSwgbGlzdGVuZXJzKTtcblxuICAgICAgcHJvcHNCaW5kZXIobWV0aG9kcywgbGVhZmxldFJlZi52YWx1ZSwgcHJvcHMpO1xuXG4gICAgICBhZGRMYXllcih7XG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICAuLi5tZXRob2RzLFxuICAgICAgICBsZWFmbGV0T2JqZWN0OiBsZWFmbGV0UmVmLnZhbHVlLFxuICAgICAgfSk7XG4gICAgICByZWFkeS52YWx1ZSA9IHRydWU7XG4gICAgICBuZXh0VGljaygoKSA9PiBjb250ZXh0LmVtaXQoXCJyZWFkeVwiLCBsZWFmbGV0UmVmLnZhbHVlKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHsgcmVhZHksIGxlYWZsZXRPYmplY3Q6IGxlYWZsZXRSZWYgfTtcbiAgfSxcbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiByZW5kZXIodGhpcy5yZWFkeSwgdGhpcy4kc2xvdHMpO1xuICB9LFxufTtcblxuc2NyaXB0Ll9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvTENpcmNsZS52dWVcIjtcblxuLyoqXG4gKiBDaXJjbGUgTWFya2VyIGNvbXBvbmVudCwgbGV0cyB5b3UgYWRkIGFuZCBwZXJzb25hbGl6ZSBjaXJjbGUgbWFya2VycyBvbiB0aGUgbWFwXG4gKi9cbnZhciBzY3JpcHQkMSA9IHtcbiAgbmFtZTogXCJMQ2lyY2xlTWFya2VyXCIsXG4gIHByb3BzOiBwcm9wcyQ0LFxuICBzZXR1cChwcm9wcywgY29udGV4dCkge1xuICAgIGNvbnN0IGxlYWZsZXRSZWYgPSByZWYoe30pO1xuICAgIGNvbnN0IHJlYWR5ID0gcmVmKGZhbHNlKTtcblxuICAgIGNvbnN0IHVzZUdsb2JhbExlYWZsZXQgPSBpbmplY3QoR0xPQkFMX0xFQUZMRVRfT1BUKTtcbiAgICBjb25zdCBhZGRMYXllciA9IGluamVjdChcImFkZExheWVyXCIpO1xuXG4gICAgY29uc3QgeyBvcHRpb25zLCBtZXRob2RzIH0gPSBzZXR1cCQ0KHByb3BzLCBsZWFmbGV0UmVmLCBjb250ZXh0KTtcblxuICAgIG9uTW91bnRlZChhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IGNpcmNsZU1hcmtlciwgRG9tRXZlbnQgfSA9IHVzZUdsb2JhbExlYWZsZXRcbiAgICAgICAgPyBXSU5ET1dfT1JfR0xPQkFMLkxcbiAgICAgICAgOiBhd2FpdCBpbXBvcnQoJ2xlYWZsZXQvZGlzdC9sZWFmbGV0LXNyYy5lc20nKTtcblxuICAgICAgbGVhZmxldFJlZi52YWx1ZSA9IGNpcmNsZU1hcmtlcihwcm9wcy5sYXRMbmcsIG9wdGlvbnMpO1xuXG4gICAgICBjb25zdCBsaXN0ZW5lcnMgPSByZW1hcEV2ZW50cyhjb250ZXh0LmF0dHJzKTtcbiAgICAgIERvbUV2ZW50Lm9uKGxlYWZsZXRSZWYudmFsdWUsIGxpc3RlbmVycyk7XG5cbiAgICAgIHByb3BzQmluZGVyKG1ldGhvZHMsIGxlYWZsZXRSZWYudmFsdWUsIHByb3BzKTtcblxuICAgICAgYWRkTGF5ZXIoe1xuICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgLi4ubWV0aG9kcyxcbiAgICAgICAgbGVhZmxldE9iamVjdDogbGVhZmxldFJlZi52YWx1ZSxcbiAgICAgIH0pO1xuICAgICAgcmVhZHkudmFsdWUgPSB0cnVlO1xuICAgICAgbmV4dFRpY2soKCkgPT4gY29udGV4dC5lbWl0KFwicmVhZHlcIiwgbGVhZmxldFJlZi52YWx1ZSkpO1xuICAgIH0pO1xuICAgIHJldHVybiB7IHJlYWR5LCBsZWFmbGV0T2JqZWN0OiBsZWFmbGV0UmVmIH07XG4gIH0sXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gcmVuZGVyKHRoaXMucmVhZHksIHRoaXMuJHNsb3RzKTtcbiAgfSxcbn07XG5cbnNjcmlwdCQxLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvTENpcmNsZU1hcmtlci52dWVcIjtcblxuY29uc3QgcHJvcHMkNiA9IHtcbiAgLi4ucHJvcHMsXG4gIHBvc2l0aW9uOiB7XG4gICAgdHlwZTogU3RyaW5nLFxuICAgIGRlZmF1bHQ6IFwidG9wcmlnaHRcIixcbiAgfSxcbn07XG5cbmNvbnN0IHNldHVwJDYgPSAocHJvcHMsIGxlYWZsZXRSZWYpID0+IHtcbiAgY29uc3Qge1xuICAgIG9wdGlvbnM6IGNvbXBvbmVudE9wdGlvbnMsXG4gICAgbWV0aG9kczogY29tcG9uZW50TWV0aG9kcyxcbiAgfSA9IHNldHVwKHByb3BzKTtcbiAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAuLi5jb21wb25lbnRPcHRpb25zLFxuICAgIHBvc2l0aW9uOiBwcm9wcy5wb3NpdGlvbixcbiAgfTtcblxuICBjb25zdCBtZXRob2RzID0ge1xuICAgIC4uLmNvbXBvbmVudE1ldGhvZHMsXG4gICAgc2V0UG9zaXRpb24ocG9zaXRpb24pIHtcbiAgICAgIGlmIChsZWFmbGV0UmVmLnZhbHVlKSB7XG4gICAgICAgIGxlYWZsZXRSZWYudmFsdWUuc2V0UG9zaXRpb24ocG9zaXRpb24pO1xuICAgICAgfVxuICAgIH0sXG4gIH07XG5cbiAgb25Vbm1vdW50ZWQoKCkgPT4ge1xuICAgIGlmIChsZWFmbGV0UmVmLnZhbHVlKSB7XG4gICAgICBsZWFmbGV0UmVmLnZhbHVlLnJlbW92ZSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHsgb3B0aW9ucywgbWV0aG9kcyB9O1xufTtcblxuY29uc3QgcmVuZGVyJDEgPSAoc2xvdHMpID0+IHtcbiAgaWYgKHNsb3RzLmRlZmF1bHQpIHtcbiAgICByZXR1cm4gaChcImRpdlwiLCB7IHJlZjogXCJyb290XCIgfSwgc2xvdHMuZGVmYXVsdCgpKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbnZhciBzY3JpcHQkMiA9IHtcbiAgbmFtZTogXCJMQ29udHJvbFwiLFxuICBwcm9wczoge1xuICAgIC4uLnByb3BzJDYsXG4gICAgZGlzYWJsZUNsaWNrUHJvcGFnYXRpb246IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBjdXN0b206IHRydWUsXG4gICAgICBkZWZhdWx0OiB0cnVlLFxuICAgIH0sXG4gICAgZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgY3VzdG9tOiB0cnVlLFxuICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgfSxcbiAgfSxcbiAgc2V0dXAocHJvcHMsIGNvbnRleHQpIHtcbiAgICBjb25zdCBsZWFmbGV0UmVmID0gcmVmKHt9KTtcbiAgICBjb25zdCByb290ID0gcmVmKG51bGwpO1xuXG4gICAgY29uc3QgdXNlR2xvYmFsTGVhZmxldCA9IGluamVjdChHTE9CQUxfTEVBRkxFVF9PUFQpO1xuICAgIGNvbnN0IHJlZ2lzdGVyQ29udHJvbCA9IGluamVjdChcInJlZ2lzdGVyQ29udHJvbFwiKTtcblxuICAgIGNvbnN0IHsgb3B0aW9ucywgbWV0aG9kcyB9ID0gc2V0dXAkNihwcm9wcywgbGVhZmxldFJlZik7XG5cbiAgICBvbk1vdW50ZWQoYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgeyBDb250cm9sLCBEb21FdmVudCB9ID0gdXNlR2xvYmFsTGVhZmxldFxuICAgICAgICA/IFdJTkRPV19PUl9HTE9CQUwuTFxuICAgICAgICA6IGF3YWl0IGltcG9ydCgnbGVhZmxldC9kaXN0L2xlYWZsZXQtc3JjLmVzbScpO1xuXG4gICAgICBjb25zdCBMQ29udHJvbCA9IENvbnRyb2wuZXh0ZW5kKHtcbiAgICAgICAgb25BZGQoKSB7XG4gICAgICAgICAgcmV0dXJuIHJvb3QudmFsdWU7XG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgbGVhZmxldFJlZi52YWx1ZSA9IG5ldyBMQ29udHJvbChvcHRpb25zKTtcbiAgICAgIHByb3BzQmluZGVyKG1ldGhvZHMsIGxlYWZsZXRSZWYudmFsdWUsIHByb3BzKTtcbiAgICAgIHJlZ2lzdGVyQ29udHJvbCh7IGxlYWZsZXRPYmplY3Q6IGxlYWZsZXRSZWYudmFsdWUgfSk7XG5cbiAgICAgIGlmIChwcm9wcy5kaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbikge1xuICAgICAgICBEb21FdmVudC5kaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbihyb290LnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcy5kaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24pIHtcbiAgICAgICAgRG9tRXZlbnQuZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uKHJvb3QudmFsdWUpO1xuICAgICAgfVxuICAgICAgbmV4dFRpY2soKCkgPT4gY29udGV4dC5lbWl0KFwicmVhZHlcIiwgbGVhZmxldFJlZi52YWx1ZSkpO1xuICAgIH0pO1xuICAgIHJldHVybiB7IHJvb3QsIGxlYWZsZXRPYmplY3Q6IGxlYWZsZXRSZWYgfTtcbiAgfSxcbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiByZW5kZXIkMSh0aGlzLiRzbG90cyk7XG4gIH0sXG59O1xuXG5zY3JpcHQkMi5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL0xDb250cm9sLnZ1ZVwiO1xuXG5jb25zdCBwcm9wcyQ3ID0ge1xuICAuLi5wcm9wcyQ2LFxuICBwcmVmaXg6IHtcbiAgICB0eXBlOiBTdHJpbmcsXG4gICAgZGVmYXVsdDogXCJWdWUtTGVhZmxldFwiLFxuICAgIGN1c3RvbTogdHJ1ZSxcbiAgfSxcbn07XG5cbmNvbnN0IHNldHVwJDcgPSAocHJvcHMsIGxlYWZsZXRSZWYpID0+IHtcbiAgY29uc3QgeyBvcHRpb25zOiBjb250cm9sT3B0aW9ucywgbWV0aG9kczogY29udHJvbE1ldGhvZHMgfSA9IHNldHVwJDYoXG4gICAgcHJvcHMsXG4gICAgbGVhZmxldFJlZlxuICApO1xuICBjb25zdCBvcHRpb25zID0ge1xuICAgIC4uLmNvbnRyb2xPcHRpb25zLFxuICAgIHByZWZpeDogcHJvcHMucHJlZml4LFxuICB9O1xuXG4gIGNvbnN0IG1ldGhvZHMgPSB7XG4gICAgLi4uY29udHJvbE1ldGhvZHMsXG4gICAgc2V0UHJlZml4KHByZWZpeCkge1xuICAgICAgbGVhZmxldFJlZi52YWx1ZS5zZXRQcmVmaXgocHJlZml4KTtcbiAgICB9LFxuICB9O1xuXG4gIHJldHVybiB7IG9wdGlvbnMsIG1ldGhvZHMgfTtcbn07XG5cbnZhciBzY3JpcHQkMyA9IHtcbiAgbmFtZTogXCJMQ29udHJvbEF0dHJpYnV0aW9uXCIsXG4gIHByb3BzOiBwcm9wcyQ3LFxuICBzZXR1cChwcm9wcywgY29udGV4dCkge1xuICAgIGNvbnN0IGxlYWZsZXRSZWYgPSByZWYoe30pO1xuXG4gICAgY29uc3QgdXNlR2xvYmFsTGVhZmxldCA9IGluamVjdChHTE9CQUxfTEVBRkxFVF9PUFQpO1xuICAgIGNvbnN0IHJlZ2lzdGVyQ29udHJvbCA9IGluamVjdChcInJlZ2lzdGVyQ29udHJvbFwiKTtcblxuICAgIGNvbnN0IHsgb3B0aW9ucywgbWV0aG9kcyB9ID0gc2V0dXAkNyhwcm9wcywgbGVhZmxldFJlZik7XG5cbiAgICBvbk1vdW50ZWQoYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgeyBjb250cm9sIH0gPSB1c2VHbG9iYWxMZWFmbGV0XG4gICAgICAgID8gV0lORE9XX09SX0dMT0JBTC5MXG4gICAgICAgIDogYXdhaXQgaW1wb3J0KCdsZWFmbGV0L2Rpc3QvbGVhZmxldC1zcmMuZXNtJyk7XG5cbiAgICAgIGxlYWZsZXRSZWYudmFsdWUgPSBjb250cm9sLmF0dHJpYnV0aW9uKG9wdGlvbnMpO1xuICAgICAgcHJvcHNCaW5kZXIobWV0aG9kcywgbGVhZmxldFJlZi52YWx1ZSwgcHJvcHMpO1xuICAgICAgcmVnaXN0ZXJDb250cm9sKHsgbGVhZmxldE9iamVjdDogbGVhZmxldFJlZi52YWx1ZSB9KTtcbiAgICAgIG5leHRUaWNrKCgpID0+IGNvbnRleHQuZW1pdChcInJlYWR5XCIsIGxlYWZsZXRSZWYudmFsdWUpKTtcbiAgICB9KTtcbiAgICByZXR1cm4geyBsZWFmbGV0T2JqZWN0OiBsZWFmbGV0UmVmLnZhbHVlIH07XG4gIH0sXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcbn07XG5cbnNjcmlwdCQzLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvTENvbnRyb2xBdHRyaWJ1dGlvbi52dWVcIjtcblxuY29uc3QgcHJvcHMkOCA9IHtcbiAgLi4ucHJvcHMkNixcbiAgY29sbGFwc2VkOiB7XG4gICAgdHlwZTogQm9vbGVhbixcbiAgICBkZWZhdWx0OiB0cnVlLFxuICB9LFxuICBhdXRvWkluZGV4OiB7XG4gICAgdHlwZTogQm9vbGVhbixcbiAgICBkZWZhdWx0OiB0cnVlLFxuICB9LFxuICBoaWRlU2luZ2xlQmFzZToge1xuICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgZGVmYXVsdDogZmFsc2UsXG4gIH0sXG4gIHNvcnRMYXllcnM6IHtcbiAgICB0eXBlOiBCb29sZWFuLFxuICAgIGRlZmF1bHQ6IGZhbHNlLFxuICB9LFxuICBzb3J0RnVuY3Rpb246IHtcbiAgICB0eXBlOiBGdW5jdGlvbixcbiAgICBkZWZhdWx0OiB1bmRlZmluZWQsXG4gIH0sXG59O1xuXG5jb25zdCBzZXR1cCQ4ID0gKHByb3BzLCBsZWFmbGV0UmVmKSA9PiB7XG4gIGNvbnN0IHsgb3B0aW9uczogY29udHJvbE9wdGlvbnMgfSA9IHNldHVwJDYocHJvcHMsIGxlYWZsZXRSZWYpO1xuICBjb25zdCBvcHRpb25zID0ge1xuICAgIC4uLmNvbnRyb2xPcHRpb25zLFxuICAgIGNvbGxhcHNlZDogcHJvcHMuY29sbGFwc2VkLFxuICAgIGF1dG9aSW5kZXg6IHByb3BzLmF1dG9aSW5kZXgsXG4gICAgaGlkZVNpbmdsZUJhc2U6IHByb3BzLmhpZGVTaW5nbGVCYXNlLFxuICAgIHNvcnRMYXllcnM6IHByb3BzLnNvcnRMYXllcnMsXG4gICAgc29ydEZ1bmN0aW9uOiBwcm9wcy5zb3J0RnVuY3Rpb24sXG4gIH07XG5cbiAgY29uc3QgbWV0aG9kcyA9IHtcbiAgICBhZGRMYXllcihsYXllcikge1xuICAgICAgaWYgKGxheWVyLmxheWVyVHlwZSA9PT0gXCJiYXNlXCIpIHtcbiAgICAgICAgbGVhZmxldFJlZi52YWx1ZS5hZGRCYXNlTGF5ZXIobGF5ZXIubGVhZmxldE9iamVjdCwgbGF5ZXIubmFtZSk7XG4gICAgICB9IGVsc2UgaWYgKGxheWVyLmxheWVyVHlwZSA9PT0gXCJvdmVybGF5XCIpIHtcbiAgICAgICAgbGVhZmxldFJlZi52YWx1ZS5hZGRPdmVybGF5KGxheWVyLmxlYWZsZXRPYmplY3QsIGxheWVyLm5hbWUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVtb3ZlTGF5ZXIobGF5ZXIpIHtcbiAgICAgIGxlYWZsZXRSZWYudmFsdWUucmVtb3ZlTGF5ZXIobGF5ZXIubGVhZmxldE9iamVjdCk7XG4gICAgfSxcbiAgfTtcbiAgcmV0dXJuIHsgb3B0aW9ucywgbWV0aG9kcyB9O1xufTtcblxudmFyIHNjcmlwdCQ0ID0ge1xuICBuYW1lOiBcIkxDb250cm9sTGF5ZXJzXCIsXG4gIHByb3BzOiBwcm9wcyQ4LFxuICBzZXR1cChwcm9wcywgY29udGV4dCkge1xuICAgIGNvbnN0IGxlYWZsZXRSZWYgPSByZWYoe30pO1xuXG4gICAgY29uc3QgdXNlR2xvYmFsTGVhZmxldCA9IGluamVjdChHTE9CQUxfTEVBRkxFVF9PUFQpO1xuICAgIGNvbnN0IHJlZ2lzdGVyTGF5ZXJDb250cm9sID0gaW5qZWN0KFwicmVnaXN0ZXJMYXllckNvbnRyb2xcIik7XG5cbiAgICBjb25zdCB7IG9wdGlvbnMsIG1ldGhvZHMgfSA9IHNldHVwJDgocHJvcHMsIGxlYWZsZXRSZWYpO1xuXG4gICAgb25Nb3VudGVkKGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHsgY29udHJvbCB9ID0gdXNlR2xvYmFsTGVhZmxldFxuICAgICAgICA/IFdJTkRPV19PUl9HTE9CQUwuTFxuICAgICAgICA6IGF3YWl0IGltcG9ydCgnbGVhZmxldC9kaXN0L2xlYWZsZXQtc3JjLmVzbScpO1xuXG4gICAgICBsZWFmbGV0UmVmLnZhbHVlID0gY29udHJvbC5sYXllcnMobnVsbCwgbnVsbCwgb3B0aW9ucyk7XG5cbiAgICAgIHByb3BzQmluZGVyKG1ldGhvZHMsIGxlYWZsZXRSZWYudmFsdWUsIHByb3BzKTtcblxuICAgICAgcmVnaXN0ZXJMYXllckNvbnRyb2woe1xuICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgLi4ubWV0aG9kcyxcbiAgICAgICAgbGVhZmxldE9iamVjdDogbGVhZmxldFJlZi52YWx1ZSxcbiAgICAgIH0pO1xuICAgICAgbmV4dFRpY2soKCkgPT4gY29udGV4dC5lbWl0KFwicmVhZHlcIiwgbGVhZmxldFJlZi52YWx1ZSkpO1xuICAgIH0pO1xuICAgIHJldHVybiB7IGxlYWZsZXRPYmplY3Q6IGxlYWZsZXRSZWYudmFsdWUgfTtcbiAgfSxcbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9LFxufTtcblxuc2NyaXB0JDQuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9MQ29udHJvbExheWVycy52dWVcIjtcblxuY29uc3QgcHJvcHMkOSA9IHtcbiAgLi4ucHJvcHMkNixcbiAgbWF4V2lkdGg6IHtcbiAgICB0eXBlOiBOdW1iZXIsXG4gICAgZGVmYXVsdDogMTAwLFxuICB9LFxuICBtZXRyaWM6IHtcbiAgICB0eXBlOiBCb29sZWFuLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gIH0sXG4gIGltcGVyaWFsOiB7XG4gICAgdHlwZTogQm9vbGVhbixcbiAgICBkZWZhdWx0OiB0cnVlLFxuICB9LFxuICB1cGRhdGVXaGVuSWRsZToge1xuICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgZGVmYXVsdDogZmFsc2UsXG4gIH0sXG59O1xuXG5jb25zdCBzZXR1cCQ5ID0gKHByb3BzLCBsZWFmbGV0UmVmKSA9PiB7XG4gIGNvbnN0IHsgb3B0aW9uczogY29udHJvbE9wdGlvbnMsIG1ldGhvZHM6IGNvbnRyb2xNZXRob2RzIH0gPSBzZXR1cCQ2KFxuICAgIHByb3BzLFxuICAgIGxlYWZsZXRSZWZcbiAgKTtcbiAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAuLi5jb250cm9sT3B0aW9ucyxcbiAgICBtYXhXaWR0aDogcHJvcHMubWF4V2lkdGgsXG4gICAgbWV0cmljOiBwcm9wcy5tZXRyaWMsXG4gICAgaW1wZXJpYWw6IHByb3BzLmltcGVyaWFsLFxuICAgIHVwZGF0ZVdoZW5JZGxlOiBwcm9wcy51cGRhdGVXaGVuSWRsZSxcbiAgfTtcblxuICByZXR1cm4geyBvcHRpb25zLCBtZXRob2RzOiBjb250cm9sTWV0aG9kcyB9O1xufTtcblxudmFyIHNjcmlwdCQ1ID0ge1xuICBuYW1lOiBcIkxDb250cm9sU2NhbGVcIixcbiAgcHJvcHM6IHByb3BzJDksXG4gIHNldHVwKHByb3BzLCBjb250ZXh0KSB7XG4gICAgY29uc3QgbGVhZmxldFJlZiA9IHJlZih7fSk7XG5cbiAgICBjb25zdCB1c2VHbG9iYWxMZWFmbGV0ID0gaW5qZWN0KEdMT0JBTF9MRUFGTEVUX09QVCk7XG4gICAgY29uc3QgcmVnaXN0ZXJDb250cm9sID0gaW5qZWN0KFwicmVnaXN0ZXJDb250cm9sXCIpO1xuXG4gICAgY29uc3QgeyBvcHRpb25zLCBtZXRob2RzIH0gPSBzZXR1cCQ5KHByb3BzLCBsZWFmbGV0UmVmKTtcblxuICAgIG9uTW91bnRlZChhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IGNvbnRyb2wgfSA9IHVzZUdsb2JhbExlYWZsZXRcbiAgICAgICAgPyBXSU5ET1dfT1JfR0xPQkFMLkxcbiAgICAgICAgOiBhd2FpdCBpbXBvcnQoJ2xlYWZsZXQvZGlzdC9sZWFmbGV0LXNyYy5lc20nKTtcblxuICAgICAgbGVhZmxldFJlZi52YWx1ZSA9IGNvbnRyb2wuc2NhbGUob3B0aW9ucyk7XG4gICAgICBwcm9wc0JpbmRlcihtZXRob2RzLCBsZWFmbGV0UmVmLnZhbHVlLCBwcm9wcyk7XG4gICAgICByZWdpc3RlckNvbnRyb2woeyBsZWFmbGV0T2JqZWN0OiBsZWFmbGV0UmVmLnZhbHVlIH0pO1xuICAgICAgbmV4dFRpY2soKCkgPT4gY29udGV4dC5lbWl0KFwicmVhZHlcIiwgbGVhZmxldFJlZi52YWx1ZSkpO1xuICAgIH0pO1xuICAgIHJldHVybiB7IGxlYWZsZXRPYmplY3Q6IGxlYWZsZXRSZWYudmFsdWUgfTtcbiAgfSxcbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9LFxufTtcblxuc2NyaXB0JDUuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9MQ29udHJvbFNjYWxlLnZ1ZVwiO1xuXG5jb25zdCBwcm9wcyRhID0ge1xuICAuLi5wcm9wcyQ2LFxuICB6b29tSW5UZXh0OiB7XG4gICAgdHlwZTogU3RyaW5nLFxuICAgIGRlZmF1bHQ6IFwiK1wiLFxuICB9LFxuICB6b29tSW5UaXRsZToge1xuICAgIHR5cGU6IFN0cmluZyxcbiAgICBkZWZhdWx0OiBcIlpvb20gaW5cIixcbiAgfSxcbiAgem9vbU91dFRleHQ6IHtcbiAgICB0eXBlOiBTdHJpbmcsXG4gICAgZGVmYXVsdDogXCItXCIsXG4gIH0sXG4gIHpvb21PdXRUaXRsZToge1xuICAgIHR5cGU6IFN0cmluZyxcbiAgICBkZWZhdWx0OiBcIlpvb20gb3V0XCIsXG4gIH0sXG59O1xuXG5jb25zdCBzZXR1cCRhID0gKHByb3BzLCBsZWFmbGV0UmVmKSA9PiB7XG4gIGNvbnN0IHsgb3B0aW9uczogY29udHJvbE9wdGlvbnMsIG1ldGhvZHM6IGNvbnRyb2xNZXRob2RzIH0gPSBzZXR1cCQ2KFxuICAgIHByb3BzLFxuICAgIGxlYWZsZXRSZWZcbiAgKTtcbiAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAuLi5jb250cm9sT3B0aW9ucyxcbiAgICB6b29tSW5UZXh0OiBwcm9wcy56b29tSW5UZXh0LFxuICAgIHpvb21JblRpdGxlOiBwcm9wcy56b29tSW5UaXRsZSxcbiAgICB6b29tT3V0VGV4dDogcHJvcHMuem9vbU91dFRleHQsXG4gICAgem9vbU91dFRpdGxlOiBwcm9wcy56b29tT3V0VGl0bGUsXG4gIH07XG5cbiAgcmV0dXJuIHsgb3B0aW9ucywgbWV0aG9kczogY29udHJvbE1ldGhvZHMgfTtcbn07XG5cbnZhciBzY3JpcHQkNiA9IHtcbiAgbmFtZTogXCJMQ29udHJvbFpvb21cIixcbiAgcHJvcHM6IHByb3BzJGEsXG4gIHNldHVwKHByb3BzLCBjb250ZXh0KSB7XG4gICAgY29uc3QgbGVhZmxldFJlZiA9IHJlZih7fSk7XG5cbiAgICBjb25zdCB1c2VHbG9iYWxMZWFmbGV0ID0gaW5qZWN0KEdMT0JBTF9MRUFGTEVUX09QVCk7XG4gICAgY29uc3QgcmVnaXN0ZXJDb250cm9sID0gaW5qZWN0KFwicmVnaXN0ZXJDb250cm9sXCIpO1xuXG4gICAgY29uc3QgeyBvcHRpb25zLCBtZXRob2RzIH0gPSBzZXR1cCRhKHByb3BzLCBsZWFmbGV0UmVmKTtcblxuICAgIG9uTW91bnRlZChhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IGNvbnRyb2wgfSA9IHVzZUdsb2JhbExlYWZsZXRcbiAgICAgICAgPyBXSU5ET1dfT1JfR0xPQkFMLkxcbiAgICAgICAgOiBhd2FpdCBpbXBvcnQoJ2xlYWZsZXQvZGlzdC9sZWFmbGV0LXNyYy5lc20nKTtcblxuICAgICAgbGVhZmxldFJlZi52YWx1ZSA9IGNvbnRyb2wuem9vbShvcHRpb25zKTtcbiAgICAgIHByb3BzQmluZGVyKG1ldGhvZHMsIGxlYWZsZXRSZWYudmFsdWUsIHByb3BzKTtcbiAgICAgIHJlZ2lzdGVyQ29udHJvbCh7IGxlYWZsZXRPYmplY3Q6IGxlYWZsZXRSZWYudmFsdWUgfSk7XG4gICAgICBuZXh0VGljaygoKSA9PiBjb250ZXh0LmVtaXQoXCJyZWFkeVwiLCBsZWFmbGV0UmVmLnZhbHVlKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHsgbGVhZmxldE9iamVjdDogbGVhZmxldFJlZi52YWx1ZSB9O1xuICB9LFxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG59O1xuXG5zY3JpcHQkNi5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL0xDb250cm9sWm9vbS52dWVcIjtcblxuY29uc3QgcHJvcHMkYiA9IHtcbiAgLi4ucHJvcHMkMSxcbn07XG5cbmNvbnN0IHNldHVwJGIgPSAocHJvcHMsIGxlYWZsZXRSZWYsIGNvbnRleHQpID0+IHtcbiAgY29uc3QgeyBvcHRpb25zOiBsYXllck9wdGlvbnMsIG1ldGhvZHM6IGxheWVyTWV0aG9kcyB9ID0gc2V0dXAkMShcbiAgICBwcm9wcyxcbiAgICBsZWFmbGV0UmVmLFxuICAgIGNvbnRleHRcbiAgKTtcblxuICBjb25zdCBvcHRpb25zID0ge1xuICAgIC4uLmxheWVyT3B0aW9ucyxcbiAgfTtcblxuICBjb25zdCBtZXRob2RzID0ge1xuICAgIC4uLmxheWVyTWV0aG9kcyxcbiAgICBhZGRMYXllcihsYXllcikge1xuICAgICAgbGVhZmxldFJlZi52YWx1ZS5hZGRMYXllcihsYXllci5sZWFmbGV0T2JqZWN0KTtcbiAgICB9LFxuICAgIHJlbW92ZUxheWVyKGxheWVyKSB7XG4gICAgICBsZWFmbGV0UmVmLnZhbHVlLnJlbW92ZUxheWVyKGxheWVyLmxlYWZsZXRPYmplY3QpO1xuICAgIH0sXG4gIH07XG5cbiAgcHJvdmlkZShcImFkZExheWVyXCIsIG1ldGhvZHMuYWRkTGF5ZXIpO1xuICBwcm92aWRlKFwicmVtb3ZlTGF5ZXJcIiwgbWV0aG9kcy5yZW1vdmVMYXllcik7XG5cbiAgcmV0dXJuIHsgb3B0aW9ucywgbWV0aG9kcyB9O1xufTtcblxuY29uc3QgcHJvcHMkYyA9IHtcbiAgLi4ucHJvcHMkYixcbn07XG5cbmNvbnN0IHNldHVwJGMgPSAocHJvcHMsIGxlYWZsZXRSZWYpID0+IHtcbiAgY29uc3QgeyBvcHRpb25zOiBsYXllck9wdGlvbnMsIG1ldGhvZHM6IGxheWVyR3JvdXBNZXRob2RzIH0gPSBzZXR1cCRiKFxuICAgIHByb3BzLFxuICAgIGxlYWZsZXRSZWZcbiAgKTtcblxuICBjb25zdCBvcHRpb25zID0ge1xuICAgIC4uLmxheWVyT3B0aW9ucyxcbiAgICAuLi5wcm9wcyxcbiAgfTtcblxuICBjb25zdCBtZXRob2RzID0ge1xuICAgIC4uLmxheWVyR3JvdXBNZXRob2RzLFxuICB9O1xuXG4gIHJldHVybiB7IG9wdGlvbnMsIG1ldGhvZHMgfTtcbn07XG5cbnZhciBzY3JpcHQkNyA9IHtcbiAgcHJvcHM6IHByb3BzJGMsXG4gIHNldHVwKHByb3BzLCBjb250ZXh0KSB7XG4gICAgY29uc3QgbGVhZmxldFJlZiA9IHJlZih7fSk7XG4gICAgY29uc3QgcmVhZHkgPSByZWYoZmFsc2UpO1xuXG4gICAgY29uc3QgdXNlR2xvYmFsTGVhZmxldCA9IGluamVjdChHTE9CQUxfTEVBRkxFVF9PUFQpO1xuICAgIGNvbnN0IGFkZExheWVyID0gaW5qZWN0KFwiYWRkTGF5ZXJcIik7XG5cbiAgICBjb25zdCB7IG1ldGhvZHMsIG9wdGlvbnMgfSA9IHNldHVwJGMocHJvcHMsIGxlYWZsZXRSZWYpO1xuXG4gICAgb25Nb3VudGVkKGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHsgZmVhdHVyZUdyb3VwLCBEb21FdmVudCB9ID0gdXNlR2xvYmFsTGVhZmxldFxuICAgICAgICA/IFdJTkRPV19PUl9HTE9CQUwuTFxuICAgICAgICA6IGF3YWl0IGltcG9ydCgnbGVhZmxldC9kaXN0L2xlYWZsZXQtc3JjLmVzbScpO1xuXG4gICAgICBsZWFmbGV0UmVmLnZhbHVlID0gZmVhdHVyZUdyb3VwKG9wdGlvbnMpO1xuXG4gICAgICBjb25zdCBsaXN0ZW5lcnMgPSByZW1hcEV2ZW50cyhjb250ZXh0LmF0dHJzKTtcbiAgICAgIERvbUV2ZW50Lm9uKGxlYWZsZXRSZWYudmFsdWUsIGxpc3RlbmVycyk7XG5cbiAgICAgIHByb3BzQmluZGVyKG1ldGhvZHMsIGxlYWZsZXRSZWYudmFsdWUsIHByb3BzKTtcbiAgICAgIGFkZExheWVyKHtcbiAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgIC4uLm1ldGhvZHMsXG4gICAgICAgIGxlYWZsZXRPYmplY3Q6IGxlYWZsZXRSZWYudmFsdWUsXG4gICAgICB9KTtcbiAgICAgIHJlYWR5LnZhbHVlID0gdHJ1ZTtcbiAgICAgIG5leHRUaWNrKCgpID0+IGNvbnRleHQuZW1pdChcInJlYWR5XCIsIGxlYWZsZXRSZWYudmFsdWUpKTtcbiAgICB9KTtcbiAgICByZXR1cm4geyByZWFkeSwgbGVhZmxldE9iamVjdDogbGVhZmxldFJlZiB9O1xuICB9LFxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHJlbmRlcih0aGlzLnJlYWR5LCB0aGlzLiRzbG90cyk7XG4gIH0sXG59O1xuXG5zY3JpcHQkNy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL0xGZWF0dXJlR3JvdXAudnVlXCI7XG5cbmNvbnN0IHByb3BzJGQgPSB7XG4gIC4uLnByb3BzJGIsXG4gIGdlb2pzb246IHtcbiAgICB0eXBlOiBbT2JqZWN0LCBBcnJheV0sXG4gICAgZGVmYXVsdDogKCkgPT4gKHt9KSxcbiAgfSxcbn07XG5cbmNvbnN0IHNldHVwJGQgPSAocHJvcHMsIGxlYWZsZXRSZWYpID0+IHtcbiAgY29uc3QgeyBvcHRpb25zOiBsYXllck9wdGlvbnMsIG1ldGhvZHM6IGxheWVyR3JvdXBNZXRob2RzIH0gPSBzZXR1cCRiKFxuICAgIHByb3BzLFxuICAgIGxlYWZsZXRSZWZcbiAgKTtcblxuICBjb25zdCBvcHRpb25zID0ge1xuICAgIC4uLmxheWVyT3B0aW9ucyxcbiAgICAuLi5wcm9wcyxcbiAgfTtcblxuICBjb25zdCBtZXRob2RzID0ge1xuICAgIC4uLmxheWVyR3JvdXBNZXRob2RzLFxuICAgIHNldEdlb2pzb24obmV3VmFsKSB7XG4gICAgICBsZWFmbGV0UmVmLnZhbHVlLmNsZWFyTGF5ZXJzKCk7XG4gICAgICBsZWFmbGV0UmVmLnZhbHVlLmFkZERhdGEobmV3VmFsKTtcbiAgICB9LFxuICAgIGdldEdlb0pTT05EYXRhKCkge1xuICAgICAgcmV0dXJuIGxlYWZsZXRSZWYudmFsdWUudG9HZW9KU09OKCk7XG4gICAgfSxcbiAgICBnZXRCb3VuZHMoKSB7XG4gICAgICByZXR1cm4gbGVhZmxldFJlZi52YWx1ZS5nZXRCb3VuZHMoKTtcbiAgICB9LFxuICB9O1xuXG4gIHJldHVybiB7IG9wdGlvbnMsIG1ldGhvZHMgfTtcbn07XG5cbnZhciBzY3JpcHQkOCA9IHtcbiAgcHJvcHM6IHByb3BzJGQsXG4gIHNldHVwKHByb3BzLCBjb250ZXh0KSB7XG4gICAgY29uc3QgbGVhZmxldFJlZiA9IHJlZih7fSk7XG4gICAgY29uc3QgcmVhZHkgPSByZWYoZmFsc2UpO1xuXG4gICAgY29uc3QgdXNlR2xvYmFsTGVhZmxldCA9IGluamVjdChHTE9CQUxfTEVBRkxFVF9PUFQpO1xuICAgIGNvbnN0IGFkZExheWVyID0gaW5qZWN0KFwiYWRkTGF5ZXJcIik7XG5cbiAgICBjb25zdCB7IG1ldGhvZHMsIG9wdGlvbnMgfSA9IHNldHVwJGQocHJvcHMsIGxlYWZsZXRSZWYpO1xuXG4gICAgb25Nb3VudGVkKGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHsgZ2VvSlNPTiwgRG9tRXZlbnQgfSA9IHVzZUdsb2JhbExlYWZsZXRcbiAgICAgICAgPyBXSU5ET1dfT1JfR0xPQkFMLkxcbiAgICAgICAgOiBhd2FpdCBpbXBvcnQoJ2xlYWZsZXQvZGlzdC9sZWFmbGV0LXNyYy5lc20nKTtcblxuICAgICAgbGVhZmxldFJlZi52YWx1ZSA9IGdlb0pTT04ocHJvcHMuZ2VvanNvbiwgb3B0aW9ucyk7XG5cbiAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHJlbWFwRXZlbnRzKGNvbnRleHQuYXR0cnMpO1xuICAgICAgRG9tRXZlbnQub24obGVhZmxldFJlZi52YWx1ZSwgbGlzdGVuZXJzKTtcblxuICAgICAgcHJvcHNCaW5kZXIobWV0aG9kcywgbGVhZmxldFJlZi52YWx1ZSwgcHJvcHMpO1xuICAgICAgYWRkTGF5ZXIoe1xuICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgLi4ubWV0aG9kcyxcbiAgICAgICAgbGVhZmxldE9iamVjdDogbGVhZmxldFJlZi52YWx1ZSxcbiAgICAgIH0pO1xuICAgICAgcmVhZHkudmFsdWUgPSB0cnVlO1xuICAgICAgbmV4dFRpY2soKCkgPT4gY29udGV4dC5lbWl0KFwicmVhZHlcIiwgbGVhZmxldFJlZi52YWx1ZSkpO1xuICAgIH0pO1xuICAgIHJldHVybiB7IHJlYWR5LCBsZWFmbGV0T2JqZWN0OiBsZWFmbGV0UmVmIH07XG4gIH0sXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gcmVuZGVyKHRoaXMucmVhZHksIHRoaXMuJHNsb3RzKTtcbiAgfSxcbn07XG5cbnNjcmlwdCQ4Ll9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvTEdlb0pzb24udnVlXCI7XG5cbmNvbnN0IHByb3BzJGUgPSB7XG4gIC4uLnByb3BzJDEsXG4gIHBhbmU6IHtcbiAgICB0eXBlOiBTdHJpbmcsXG4gICAgZGVmYXVsdDogXCJ0aWxlUGFuZVwiLFxuICB9LFxuICBvcGFjaXR5OiB7XG4gICAgdHlwZTogTnVtYmVyLFxuICAgIGN1c3RvbTogZmFsc2UsXG4gICAgZGVmYXVsdDogMS4wLFxuICB9LFxuICB6SW5kZXg6IHtcbiAgICB0eXBlOiBOdW1iZXIsXG4gICAgZGVmYXVsdDogMSxcbiAgfSxcbiAgdGlsZVNpemU6IHtcbiAgICB0eXBlOiBOdW1iZXIsXG4gICAgZGVmYXVsdDogMjU2LFxuICB9LFxuICBub1dyYXA6IHtcbiAgICB0eXBlOiBCb29sZWFuLFxuICAgIGRlZmF1bHQ6IGZhbHNlLFxuICB9LFxuICBtaW5ab29tOiB7XG4gICAgdHlwZTogTnVtYmVyLFxuICAgIGRlZmF1bHQ6IDAsXG4gIH0sXG4gIG1heFpvb206IHtcbiAgICB0eXBlOiBOdW1iZXIsXG4gICAgZGVmYXVsdDogdW5kZWZpbmVkLFxuICB9LFxufTtcblxuY29uc3Qgc2V0dXAkZSA9IChwcm9wcywgbGVhZmxldFJlZiwgY29udGV4dCkgPT4ge1xuICBjb25zdCB7IG9wdGlvbnM6IGxheWVyT3B0aW9ucywgbWV0aG9kczogbGF5ZXJNZXRob2RzIH0gPSBzZXR1cCQxKFxuICAgIHByb3BzLFxuICAgIGxlYWZsZXRSZWYsXG4gICAgY29udGV4dFxuICApO1xuICBjb25zdCBvcHRpb25zID0ge1xuICAgIC4uLmxheWVyT3B0aW9ucyxcbiAgICBwYW5lOiBwcm9wcy5wYW5lLFxuICAgIG9wYWNpdHk6IHByb3BzLm9wYWNpdHksXG4gICAgekluZGV4OiBwcm9wcy56SW5kZXgsXG4gICAgdGlsZVNpemU6IHByb3BzLnRpbGVTaXplLFxuICAgIG5vV3JhcDogcHJvcHMubm9XcmFwLFxuICAgIG1pblpvb206IHByb3BzLm1pblpvb20sXG4gICAgbWF4Wm9vbTogcHJvcHMubWF4Wm9vbSxcbiAgfTtcbiAgcmV0dXJuIHsgb3B0aW9ucywgbWV0aG9kczogeyAuLi5sYXllck1ldGhvZHMgfSB9O1xufTtcblxudmFyIHNjcmlwdCQ5ID0ge1xuICBwcm9wczoge1xuICAgIC4uLnByb3BzJGUsXG4gICAgY2hpbGRSZW5kZXI6IHtcbiAgICAgIHR5cGU6IEZ1bmN0aW9uLFxuICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgfSxcbiAgfSxcbiAgc2V0dXAocHJvcHMsIGNvbnRleHQpIHtcbiAgICBjb25zdCBsZWFmbGV0UmVmID0gcmVmKHt9KTtcbiAgICBjb25zdCB0aWxlQ29tcG9uZW50cyA9IHJlZih7fSk7XG4gICAgY29uc3Qgcm9vdCA9IHJlZihudWxsKTtcbiAgICBjb25zdCByZWFkeSA9IHJlZihmYWxzZSk7XG5cbiAgICBjb25zdCB1c2VHbG9iYWxMZWFmbGV0ID0gaW5qZWN0KEdMT0JBTF9MRUFGTEVUX09QVCk7XG4gICAgY29uc3QgYWRkTGF5ZXIgPSBpbmplY3QoXCJhZGRMYXllclwiKTtcblxuICAgIGNvbnN0IHsgb3B0aW9ucywgbWV0aG9kcyB9ID0gc2V0dXAkZShwcm9wcywgbGVhZmxldFJlZiwgY29udGV4dCk7XG5cbiAgICBvbk1vdW50ZWQoYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgeyBHcmlkTGF5ZXIsIERvbUV2ZW50LCBEb21VdGlsIH0gPSB1c2VHbG9iYWxMZWFmbGV0XG4gICAgICAgID8gV0lORE9XX09SX0dMT0JBTC5MXG4gICAgICAgIDogYXdhaXQgaW1wb3J0KCdsZWFmbGV0L2Rpc3QvbGVhZmxldC1zcmMuZXNtJyk7XG5cbiAgICAgIG1ldGhvZHMub25VbmxvYWQgPSAoZSkgPT4ge1xuICAgICAgICBjb25zdCBrZXkgPSBsZWFmbGV0UmVmLnZhbHVlLl90aWxlQ29vcmRzVG9LZXkoZS5jb29yZHMpO1xuICAgICAgICBpZiAodGlsZUNvbXBvbmVudHNba2V5XSkge1xuICAgICAgICAgIHRpbGVDb21wb25lbnRzW2tleV0uaW5uZXJIVE1MID0gXCJcIjtcbiAgICAgICAgICB0aWxlQ29tcG9uZW50c1trZXldID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBtZXRob2RzLnNldFRpbGVDb21wb25lbnQgPSAoKSA9PiB7XG4gICAgICAgIGxlYWZsZXRSZWYudmFsdWUucmVkcmF3KCk7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBHTGF5ZXIgPSBHcmlkTGF5ZXIuZXh0ZW5kKHtcbiAgICAgICAgY3JlYXRlVGlsZShjb29yZHMpIHtcbiAgICAgICAgICBjb25zdCBrZXkgPSBsZWFmbGV0UmVmLnZhbHVlLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzKTtcbiAgICAgICAgICB0aWxlQ29tcG9uZW50c1trZXldID0gRG9tVXRpbC5jcmVhdGUoXCJkaXZcIik7XG5cbiAgICAgICAgICBsZXQgdk5vZGUgPSBoKFxuICAgICAgICAgICAgeyBzZXR1cDogcHJvcHMuY2hpbGRSZW5kZXIsIHByb3BzOiBbXCJjb29yZHNcIl0gfSxcbiAgICAgICAgICAgIHsgY29vcmRzIH1cbiAgICAgICAgICApO1xuICAgICAgICAgIHJlbmRlciQzKHZOb2RlLCB0aWxlQ29tcG9uZW50c1trZXldKTtcblxuICAgICAgICAgIHJldHVybiB0aWxlQ29tcG9uZW50c1trZXldO1xuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIGxlYWZsZXRSZWYudmFsdWUgPSBuZXcgR0xheWVyKG9wdGlvbnMpO1xuXG4gICAgICBjb25zdCBsaXN0ZW5lcnMgPSByZW1hcEV2ZW50cyhjb250ZXh0LmF0dHJzKTtcbiAgICAgIERvbUV2ZW50Lm9uKGxlYWZsZXRSZWYudmFsdWUsIGxpc3RlbmVycyk7XG5cbiAgICAgIGxlYWZsZXRSZWYudmFsdWUub24oXCJ0aWxldW5sb2FkXCIsIG1ldGhvZHMub25VbmxvYWQpO1xuXG4gICAgICBwcm9wc0JpbmRlcihtZXRob2RzLCBsZWFmbGV0UmVmLnZhbHVlLCBwcm9wcyk7XG4gICAgICBhZGRMYXllcih7XG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICAuLi5tZXRob2RzLFxuICAgICAgICBsZWFmbGV0T2JqZWN0OiBsZWFmbGV0UmVmLnZhbHVlLFxuICAgICAgfSk7XG4gICAgICByZWFkeS52YWx1ZSA9IHRydWU7XG4gICAgICBuZXh0VGljaygoKSA9PiBjb250ZXh0LmVtaXQoXCJyZWFkeVwiLCBsZWFmbGV0UmVmLnZhbHVlKSk7XG4gICAgfSk7XG5cbiAgICBvblVubW91bnRlZCgoKSA9PiB7XG4gICAgICBsZWFmbGV0UmVmLnZhbHVlLm9mZihcInRpbGV1bmxvYWRcIiwgbWV0aG9kcy51bkxvYWQpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHsgcm9vdCwgcmVhZHksIGxlYWZsZXRPYmplY3Q6IGxlYWZsZXRSZWYgfTtcbiAgfSxcbiAgcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLnJlYWR5KSB7XG4gICAgICByZXR1cm4gaChcImRpdlwiLCB7IHN0eWxlOiB7IGRpc3BsYXk6IFwibm9uZVwiIH0sIHJlZjogXCJyb290XCIgfSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9LFxufTtcblxuc2NyaXB0JDkuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9MR3JpZExheWVyLnZ1ZVwiO1xuXG5jb25zdCBwcm9wcyRmID0ge1xuICBpY29uVXJsOiB7XG4gICAgdHlwZTogU3RyaW5nLFxuICAgIGN1c3RvbTogdHJ1ZSxcbiAgICBkZWZhdWx0OiBudWxsLFxuICB9LFxuICBpY29uUmV0aW5hVXJsOiB7XG4gICAgdHlwZTogU3RyaW5nLFxuICAgIGN1c3RvbTogdHJ1ZSxcbiAgICBkZWZhdWx0OiBudWxsLFxuICB9LFxuICBpY29uU2l6ZToge1xuICAgIHR5cGU6IFtPYmplY3QsIEFycmF5XSxcbiAgICBjdXN0b206IHRydWUsXG4gICAgZGVmYXVsdDogbnVsbCxcbiAgfSxcbiAgaWNvbkFuY2hvcjoge1xuICAgIHR5cGU6IFtPYmplY3QsIEFycmF5XSxcbiAgICBjdXN0b206IHRydWUsXG4gICAgZGVmYXVsdDogbnVsbCxcbiAgfSxcbiAgcG9wdXBBbmNob3I6IHtcbiAgICB0eXBlOiBbT2JqZWN0LCBBcnJheV0sXG4gICAgY3VzdG9tOiB0cnVlLFxuICAgIGRlZmF1bHQ6ICgpID0+IFswLCAwXSxcbiAgfSxcbiAgdG9vbHRpcEFuY2hvcjoge1xuICAgIHR5cGU6IFtPYmplY3QsIEFycmF5XSxcbiAgICBjdXN0b206IHRydWUsXG4gICAgZGVmYXVsdDogKCkgPT4gWzAsIDBdLFxuICB9LFxuICBzaGFkb3dVcmw6IHtcbiAgICB0eXBlOiBTdHJpbmcsXG4gICAgY3VzdG9tOiB0cnVlLFxuICAgIGRlZmF1bHQ6IG51bGwsXG4gIH0sXG4gIHNoYWRvd1JldGluYVVybDoge1xuICAgIHR5cGU6IFN0cmluZyxcbiAgICBjdXN0b206IHRydWUsXG4gICAgZGVmYXVsdDogbnVsbCxcbiAgfSxcbiAgc2hhZG93U2l6ZToge1xuICAgIHR5cGU6IFtPYmplY3QsIEFycmF5XSxcbiAgICBjdXN0b206IHRydWUsXG4gICAgZGVmYXVsdDogbnVsbCxcbiAgfSxcbiAgc2hhZG93QW5jaG9yOiB7XG4gICAgdHlwZTogW09iamVjdCwgQXJyYXldLFxuICAgIGN1c3RvbTogdHJ1ZSxcbiAgICBkZWZhdWx0OiBudWxsLFxuICB9LFxuICBiZ1Bvczoge1xuICAgIHR5cGU6IFtPYmplY3QsIEFycmF5XSxcbiAgICBjdXN0b206IHRydWUsXG4gICAgZGVmYXVsdDogKCkgPT4gWzAsIDBdLFxuICB9LFxuICBjbGFzc05hbWU6IHtcbiAgICB0eXBlOiBTdHJpbmcsXG4gICAgY3VzdG9tOiB0cnVlLFxuICAgIGRlZmF1bHQ6IFwiXCIsXG4gIH0sXG4gIG9wdGlvbnM6IHtcbiAgICB0eXBlOiBPYmplY3QsXG4gICAgY3VzdG9tOiB0cnVlLFxuICAgIGRlZmF1bHQ6ICgpID0+ICh7fSksXG4gIH0sXG59O1xuXG4vKipcbiAqIEljb24gY29tcG9uZW50LCBsZXRzIHlvdSBhZGQgYW5kIGN1c3RvbSBpY29ucyB0byB0aGUgbWFwXG4gKi9cbnZhciBzY3JpcHQkYSA9IHtcbiAgbmFtZTogXCJMSWNvblwiLFxuICBwcm9wczoge1xuICAgIC4uLnByb3BzJGYsXG4gICAgLi4ucHJvcHMsXG4gIH0sXG4gIHNldHVwKHByb3BzLCBjb250ZXh0KSB7XG4gICAgY29uc3Qgcm9vdCA9IHJlZihudWxsKTtcblxuICAgIGNvbnN0IHVzZUdsb2JhbExlYWZsZXQgPSBpbmplY3QoR0xPQkFMX0xFQUZMRVRfT1BUKTtcbiAgICBjb25zdCBjYW5TZXRQYXJlbnRIdG1sID0gaW5qZWN0KFwiY2FuU2V0UGFyZW50SHRtbFwiKTtcbiAgICBjb25zdCBzZXRQYXJlbnRIdG1sID0gaW5qZWN0KFwic2V0UGFyZW50SHRtbFwiKTtcbiAgICBjb25zdCBzZXRJY29uID0gaW5qZWN0KFwic2V0SWNvblwiKTtcblxuICAgIGxldCBvbkRvbUV2ZW50O1xuICAgIGxldCBvZmZEb21FdmVudDtcbiAgICBsZXQgZGl2SWNvbjtcbiAgICBsZXQgaWNvbjtcbiAgICBsZXQgaWNvbk9iamVjdCA9IHVuZGVmaW5lZDtcblxuICAgIGNvbnN0IGNyZWF0ZUljb24gPSAoZWwsIHJlY3JlYXRpb25OZWVkZWQsIGh0bWxTd2FwTmVlZGVkKSA9PiB7XG4gICAgICBjb25zdCBlbEh0bWwgPSBlbCAmJiBlbC5pbm5lckhUTUw7XG4gICAgICBpZiAoIXJlY3JlYXRpb25OZWVkZWQpIHtcbiAgICAgICAgaWYgKGh0bWxTd2FwTmVlZGVkICYmIGljb25PYmplY3QgJiYgY2FuU2V0UGFyZW50SHRtbCgpKSB7XG4gICAgICAgICAgc2V0UGFyZW50SHRtbChlbEh0bWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbGlzdGVuZXJzID0gcmVtYXBFdmVudHMoY29udGV4dC5hdHRycyk7XG4gICAgICBpZiAoaWNvbk9iamVjdCkge1xuICAgICAgICBvZmZEb21FdmVudChpY29uT2JqZWN0LCBsaXN0ZW5lcnMpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB7IG9wdGlvbnM6IGNvbXBvbmVudE9wdGlvbnMgfSA9IHNldHVwKHByb3BzKTtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIC4uLmNvbXBvbmVudE9wdGlvbnMsXG4gICAgICAgIGljb25Vcmw6IHByb3BzLmljb25VcmwsXG4gICAgICAgIGljb25SZXRpbmFVcmw6IHByb3BzLmljb25SZXRpbmFVcmwsXG4gICAgICAgIGljb25TaXplOiBwcm9wcy5pY29uU2l6ZSxcbiAgICAgICAgaWNvbkFuY2hvcjogcHJvcHMuaWNvbkFuY2hvcixcbiAgICAgICAgcG9wdXBBbmNob3I6IHByb3BzLnBvcHVwQW5jaG9yLFxuICAgICAgICB0b29sdGlwQW5jaG9yOiBwcm9wcy50b29sdGlwQW5jaG9yLFxuICAgICAgICBzaGFkb3dVcmw6IHByb3BzLnNoYWRvd1VybCxcbiAgICAgICAgc2hhZG93UmV0aW5hVXJsOiBwcm9wcy5zaGFkb3dSZXRpbmFVcmwsXG4gICAgICAgIHNoYWRvd1NpemU6IHByb3BzLnNoYWRvd1NpemUsXG4gICAgICAgIHNoYWRvd0FuY2hvcjogcHJvcHMuc2hhZG93QW5jaG9yLFxuICAgICAgICBiZ1BvczogcHJvcHMuYmdQb3MsXG4gICAgICAgIGNsYXNzTmFtZTogcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgICBodG1sOiBlbEh0bWwgfHwgcHJvcHMuaHRtbCxcbiAgICAgIH07XG5cbiAgICAgIGljb25PYmplY3QgPSBvcHRpb25zLmh0bWwgPyBkaXZJY29uKG9wdGlvbnMpIDogaWNvbihvcHRpb25zKTtcbiAgICAgIG9uRG9tRXZlbnQoaWNvbk9iamVjdCwgbGlzdGVuZXJzKTtcbiAgICAgIHNldEljb24oaWNvbk9iamVjdCk7XG4gICAgfTtcblxuICAgIGNvbnN0IHNjaGVkdWxlQ3JlYXRlSWNvbiA9ICgpID0+IHtcbiAgICAgIG5leHRUaWNrKCgpID0+IGNyZWF0ZUljb24ocm9vdC52YWx1ZSwgdHJ1ZSwgZmFsc2UpKTtcbiAgICB9O1xuXG4gICAgY29uc3Qgc2NoZWR1bGVIdG1sU3dhcCA9ICgpID0+IHtcbiAgICAgIG5leHRUaWNrKCgpID0+IGNyZWF0ZUljb24ocm9vdC52YWx1ZSwgZmFsc2UsIHRydWUpKTtcbiAgICB9O1xuXG4gICAgY29uc3QgbWV0aG9kcyA9IHtcbiAgICAgIHNldEljb25Vcmw6IHNjaGVkdWxlQ3JlYXRlSWNvbixcbiAgICAgIHNldEljb25SZXRpbmFVcmw6IHNjaGVkdWxlQ3JlYXRlSWNvbixcbiAgICAgIHNldEljb25TaXplOiBzY2hlZHVsZUNyZWF0ZUljb24sXG4gICAgICBzZXRJY29uQW5jaG9yOiBzY2hlZHVsZUNyZWF0ZUljb24sXG4gICAgICBzZXRQb3B1cEFuY2hvcjogc2NoZWR1bGVDcmVhdGVJY29uLFxuICAgICAgc2V0VG9vbHRpcEFuY2hvcjogc2NoZWR1bGVDcmVhdGVJY29uLFxuICAgICAgc2V0U2hhZG93VXJsOiBzY2hlZHVsZUNyZWF0ZUljb24sXG4gICAgICBzZXRTaGFkb3dSZXRpbmFVcmw6IHNjaGVkdWxlQ3JlYXRlSWNvbixcbiAgICAgIHNldFNoYWRvd0FuY2hvcjogc2NoZWR1bGVDcmVhdGVJY29uLFxuICAgICAgc2V0QmdQb3M6IHNjaGVkdWxlQ3JlYXRlSWNvbixcbiAgICAgIHNldENsYXNzTmFtZTogc2NoZWR1bGVDcmVhdGVJY29uLFxuICAgICAgc2V0SHRtbDogc2NoZWR1bGVDcmVhdGVJY29uLFxuICAgIH07XG5cbiAgICBvbk1vdW50ZWQoYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgeyBEb21FdmVudCwgZGl2SWNvbjogbERpdkljb24sIGljb246IGxJY29uIH0gPSB1c2VHbG9iYWxMZWFmbGV0XG4gICAgICAgID8gV0lORE9XX09SX0dMT0JBTC5MXG4gICAgICAgIDogYXdhaXQgaW1wb3J0KCdsZWFmbGV0L2Rpc3QvbGVhZmxldC1zcmMuZXNtJyk7XG5cbiAgICAgIG9uRG9tRXZlbnQgPSBEb21FdmVudC5vbjtcbiAgICAgIG9mZkRvbUV2ZW50ID0gRG9tRXZlbnQub2ZmO1xuICAgICAgZGl2SWNvbiA9IGxEaXZJY29uO1xuICAgICAgaWNvbiA9IGxJY29uO1xuXG4gICAgICBwcm9wc0JpbmRlcihtZXRob2RzLCB7fSwgcHJvcHMpO1xuXG4gICAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHNjaGVkdWxlSHRtbFN3YXApO1xuICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShyb290LnZhbHVlLCB7XG4gICAgICAgIGF0dHJpYnV0ZXM6IHRydWUsXG4gICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZSxcbiAgICAgICAgc3VidHJlZTogdHJ1ZSxcbiAgICAgIH0pO1xuICAgICAgc2NoZWR1bGVDcmVhdGVJY29uKCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4geyByb290IH07XG4gIH0sXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCBjb250ZW50ID0gdGhpcy4kc2xvdHMuZGVmYXVsdCA/IHRoaXMuJHNsb3RzLmRlZmF1bHQoKSA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gaChcImRpdlwiLCB7IHJlZjogXCJyb290XCIgfSwgY29udGVudCk7XG4gIH0sXG59O1xuXG5zY3JpcHQkYS5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL0xJY29uLnZ1ZVwiO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2xlYWZsZXQvZGlzdC9sZWFmbGV0LXNyYy5lc20uanMnKS5MYXRMbmdCb3VuZHN9IExhdExuZ0JvdW5kc1xuICovXG5cbmNvbnN0IHByb3BzJGcgPSB7XG4gIC4uLnByb3BzJDEsXG4gIHVybDoge1xuICAgIHR5cGU6IFN0cmluZyxcbiAgICByZXF1aXJlZDogdHJ1ZSxcbiAgfSxcbiAgYm91bmRzOiB7XG4gICAgdHlwZTogW0FycmF5LCBPYmplY3RdLFxuICAgIHJlcXVpcmVkOiB0cnVlLFxuICB9LFxuICBvcGFjaXR5OiB7XG4gICAgdHlwZTogTnVtYmVyLFxuICAgIGN1c3RvbTogdHJ1ZSxcbiAgICBkZWZhdWx0OiAxLjAsXG4gIH0sXG4gIGFsdDoge1xuICAgIHR5cGU6IFN0cmluZyxcbiAgICBkZWZhdWx0OiBcIlwiLFxuICB9LFxuICBpbnRlcmFjdGl2ZToge1xuICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgZGVmYXVsdDogZmFsc2UsXG4gIH0sXG4gIGNyb3NzT3JpZ2luOiB7XG4gICAgdHlwZTogQm9vbGVhbixcbiAgICBkZWZhdWx0OiBmYWxzZSxcbiAgfSxcbiAgZXJyb3JPdmVybGF5VXJsOiB7XG4gICAgdHlwZTogU3RyaW5nLFxuICAgIGN1c3RvbTogdHJ1ZSxcbiAgICBkZWZhdWx0OiBcIlwiLFxuICB9LFxuICB6SW5kZXg6IHtcbiAgICB0eXBlOiBOdW1iZXIsXG4gICAgY3VzdG9tOiB0cnVlLFxuICAgIGRlZmF1bHQ6IDEsXG4gIH0sXG4gIGNsYXNzTmFtZToge1xuICAgIHR5cGU6IFN0cmluZyxcbiAgICBkZWZhdWx0OiBcIlwiLFxuICB9LFxufTtcblxuY29uc3Qgc2V0dXAkZiA9IChzZXR1cFByb3BzLCBMZWFmbGV0UmVmLCBjb250ZXh0KSA9PiB7XG4gIGNvbnN0IHsgb3B0aW9uczogbGF5ZXJPcHRpb25zLCBtZXRob2RzOiBsYXllck1ldGhvZHMgfSA9IHNldHVwJDEoXG4gICAgc2V0dXBQcm9wcyxcbiAgICBMZWFmbGV0UmVmLFxuICAgIGNvbnRleHRcbiAgKTtcbiAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAuLi5sYXllck9wdGlvbnMsXG4gICAgLi4uc2V0dXBQcm9wcyxcbiAgfTtcblxuICBjb25zdCBtZXRob2RzID0ge1xuICAgIC4uLmxheWVyTWV0aG9kcyxcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBvcGFjaXR5IG9mIHRoZSBvdmVybGF5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcGFjaXR5XG4gICAgICovXG4gICAgc2V0T3BhY2l0eShvcGFjaXR5KSB7XG4gICAgICByZXR1cm4gTGVhZmxldFJlZi52YWx1ZS5zZXRPcGFjaXR5KG9wYWNpdHkpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgVVJMIG9mIHRoZSBpbWFnZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAgICovXG4gICAgc2V0VXJsKHVybCkge1xuICAgICAgcmV0dXJuIExlYWZsZXRSZWYudmFsdWUuc2V0VXJsKHVybCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIGJvdW5kcyB0aGF0IHRoaXMgSW1hZ2VPdmVybGF5IGNvdmVyc1xuICAgICAqIEBwYXJhbSB7TGF0TG5nQm91bmRzIHwgQXJyYXk8QXJyYXk8bnVtYmVyPj59IGJvdW5kc1xuICAgICAqL1xuICAgIHNldEJvdW5kcyhib3VuZHMpIHtcbiAgICAgIHJldHVybiBMZWFmbGV0UmVmLnZhbHVlLnNldEJvdW5kcyhib3VuZHMpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBib3VuZHMgdGhhdCB0aGlzIEltYWdlT3ZlcmxheSBjb3ZlcnNcbiAgICAgKiBAcmV0dXJucyB7TGF0TG5nQm91bmRzfVxuICAgICAqL1xuICAgIGdldEJvdW5kcygpIHtcbiAgICAgIHJldHVybiBMZWFmbGV0UmVmLnZhbHVlLmdldEJvdW5kcygpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaW5zdGFuY2Ugb2YgSFRNTEltYWdlRWxlbWVudCB1c2VkIGJ5IHRoaXMgb3ZlcmxheS5cbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XG4gICAgICovXG4gICAgZ2V0RWxlbWVudCgpIHtcbiAgICAgIHJldHVybiBMZWFmbGV0UmVmLnZhbHVlLmdldEVsZW1lbnQoKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEJyaW5ncyB0aGUgbGF5ZXIgdG8gdGhlIHRvcCBvZiBhbGwgb3ZlcmxheXMuXG4gICAgICovXG4gICAgYnJpbmdUb0Zyb250KCkge1xuICAgICAgcmV0dXJuIExlYWZsZXRSZWYudmFsdWUuYnJpbmdUb0Zyb250KCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBCcmluZ3MgdGhlIGxheWVyIHRvIHRoZSBib3R0b20gb2YgYWxsIG92ZXJsYXlzLlxuICAgICAqL1xuICAgIGJyaW5nVG9CYWNrKCkge1xuICAgICAgcmV0dXJuIExlYWZsZXRSZWYudmFsdWUuYnJpbmdUb0JhY2soKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIHpJbmRleCBvZiB0aGUgaW1hZ2Ugb3ZlcmxheS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gekluZGV4XG4gICAgICovXG4gICAgc2V0WkluZGV4KHpJbmRleCkge1xuICAgICAgcmV0dXJuIExlYWZsZXRSZWYudmFsdWUuc2V0WkluZGV4KHpJbmRleCk7XG4gICAgfSxcbiAgfTtcblxuICByZXR1cm4geyBvcHRpb25zLCBtZXRob2RzIH07XG59O1xuXG4vKipcbiAqIEltYWdlT3ZlcmxheSBjb21wb25lbnQsIHJlbmRlciBhIHBsYWluIGltYWdlIGluc3RlYWQgb2YgYSBnZW9zcGF0aWFsIG1hcC5cbiAqL1xudmFyIHNjcmlwdCRiID0ge1xuICBuYW1lOiBcIkxJbWFnZU92ZXJsYXlcIixcbiAgcHJvcHM6IHByb3BzJGcsXG4gIHNldHVwKHByb3BzLCBjb250ZXh0KSB7XG4gICAgY29uc3QgbGVhZmxldFJlZiA9IHJlZih7fSk7XG4gICAgY29uc3QgcmVhZHkgPSByZWYoZmFsc2UpO1xuXG4gICAgY29uc3QgdXNlR2xvYmFsTGVhZmxldCA9IGluamVjdChHTE9CQUxfTEVBRkxFVF9PUFQpO1xuICAgIGNvbnN0IGFkZExheWVyID0gaW5qZWN0KFwiYWRkTGF5ZXJcIik7XG5cbiAgICBjb25zdCB7IG9wdGlvbnMsIG1ldGhvZHMgfSA9IHNldHVwJGYocHJvcHMsIGxlYWZsZXRSZWYsIGNvbnRleHQpO1xuXG4gICAgb25Nb3VudGVkKGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHsgaW1hZ2VPdmVybGF5LCBEb21FdmVudCB9ID0gdXNlR2xvYmFsTGVhZmxldFxuICAgICAgICA/IFdJTkRPV19PUl9HTE9CQUwuTFxuICAgICAgICA6IGF3YWl0IGltcG9ydCgnbGVhZmxldC9kaXN0L2xlYWZsZXQtc3JjLmVzbScpO1xuICAgICAgbGVhZmxldFJlZi52YWx1ZSA9IGltYWdlT3ZlcmxheShwcm9wcy51cmwsIHByb3BzLmJvdW5kcywgb3B0aW9ucyk7XG5cbiAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHJlbWFwRXZlbnRzKGNvbnRleHQuYXR0cnMpO1xuICAgICAgRG9tRXZlbnQub24obGVhZmxldFJlZi52YWx1ZSwgbGlzdGVuZXJzKTtcbiAgICAgIHByb3BzQmluZGVyKG1ldGhvZHMsIGxlYWZsZXRSZWYudmFsdWUsIHByb3BzKTtcbiAgICAgIGFkZExheWVyKHtcbiAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgIC4uLm1ldGhvZHMsXG4gICAgICAgIGxlYWZsZXRPYmplY3Q6IGxlYWZsZXRSZWYudmFsdWUsXG4gICAgICB9KTtcbiAgICAgIHJlYWR5LnZhbHVlID0gdHJ1ZTtcbiAgICAgIG5leHRUaWNrKCgpID0+IGNvbnRleHQuZW1pdChcInJlYWR5XCIsIGxlYWZsZXRSZWYudmFsdWUpKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB7IHJlYWR5LCBsZWFmbGV0T2JqZWN0OiBsZWFmbGV0UmVmIH07XG4gIH0sXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gcmVuZGVyKHRoaXMucmVhZHksIHRoaXMuJHNsb3RzKTtcbiAgfSxcbn07XG5cbnNjcmlwdCRiLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvTEltYWdlT3ZlcmxheS52dWVcIjtcblxudmFyIHNjcmlwdCRjID0ge1xuICBwcm9wczogcHJvcHMkYixcbiAgc2V0dXAocHJvcHMsIGNvbnRleHQpIHtcbiAgICBjb25zdCBsZWFmbGV0UmVmID0gcmVmKHt9KTtcbiAgICBjb25zdCByZWFkeSA9IHJlZihmYWxzZSk7XG5cbiAgICBjb25zdCB1c2VHbG9iYWxMZWFmbGV0ID0gaW5qZWN0KEdMT0JBTF9MRUFGTEVUX09QVCk7XG4gICAgY29uc3QgYWRkTGF5ZXIgPSBpbmplY3QoXCJhZGRMYXllclwiKTtcblxuICAgIGNvbnN0IHsgbWV0aG9kcyB9ID0gc2V0dXAkYihwcm9wcywgbGVhZmxldFJlZiwgY29udGV4dCk7XG5cbiAgICBvbk1vdW50ZWQoYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgeyBsYXllckdyb3VwLCBEb21FdmVudCB9ID0gdXNlR2xvYmFsTGVhZmxldFxuICAgICAgICA/IFdJTkRPV19PUl9HTE9CQUwuTFxuICAgICAgICA6IGF3YWl0IGltcG9ydCgnbGVhZmxldC9kaXN0L2xlYWZsZXQtc3JjLmVzbScpO1xuICAgICAgbGVhZmxldFJlZi52YWx1ZSA9IGxheWVyR3JvdXAocHJvcHMub3B0aW9ucyk7XG5cbiAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHJlbWFwRXZlbnRzKGNvbnRleHQuYXR0cnMpO1xuICAgICAgRG9tRXZlbnQub24obGVhZmxldFJlZi52YWx1ZSwgbGlzdGVuZXJzKTtcblxuICAgICAgcHJvcHNCaW5kZXIobWV0aG9kcywgbGVhZmxldFJlZi52YWx1ZSwgcHJvcHMpO1xuICAgICAgYWRkTGF5ZXIoe1xuICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgLi4ubWV0aG9kcyxcbiAgICAgICAgbGVhZmxldE9iamVjdDogbGVhZmxldFJlZi52YWx1ZSxcbiAgICAgIH0pO1xuICAgICAgcmVhZHkudmFsdWUgPSB0cnVlO1xuICAgICAgbmV4dFRpY2soKCkgPT4gY29udGV4dC5lbWl0KFwicmVhZHlcIiwgbGVhZmxldFJlZi52YWx1ZSkpO1xuICAgIH0pO1xuICAgIHJldHVybiB7IHJlYWR5LCBsZWFmbGV0T2JqZWN0OiBsZWFmbGV0UmVmIH07XG4gIH0sXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gcmVuZGVyKHRoaXMucmVhZHksIHRoaXMuJHNsb3RzKTtcbiAgfSxcbn07XG5cbnNjcmlwdCRjLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvTExheWVyR3JvdXAudnVlXCI7XG5cbnZhciBzY3JpcHQkZCA9IHtcbiAgZW1pdHM6IFtcInJlYWR5XCIsIFwidXBkYXRlOnpvb21cIiwgXCJ1cGRhdGU6Y2VudGVyXCIsIFwidXBkYXRlOmJvdW5kc1wiXSxcbiAgcHJvcHM6IHtcbiAgICAuLi5wcm9wcyxcbiAgICAvKipcbiAgICAgKiBUaGUgY2VudGVyIG9mIHRoZSBtYXAsIHN1cHBvcnRzIC5zeW5jIG1vZGlmaWVyXG4gICAgICovXG4gICAgY2VudGVyOiB7XG4gICAgICB0eXBlOiBbT2JqZWN0LCBBcnJheV0sXG4gICAgICBkZWZhdWx0OiAoKSA9PiBbMCwgMF0sXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgYm91bmRzIG9mIHRoZSBtYXAsIHN1cHBvcnRzIC5zeW5jIG1vZGlmaWVyXG4gICAgICovXG4gICAgYm91bmRzOiB7XG4gICAgICB0eXBlOiBbQXJyYXksIE9iamVjdF0sXG4gICAgICBkZWZhdWx0OiB1bmRlZmluZWQsXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgbWF4IGJvdW5kcyBvZiB0aGUgbWFwXG4gICAgICovXG4gICAgbWF4Qm91bmRzOiB7XG4gICAgICB0eXBlOiBbQXJyYXksIE9iamVjdF0sXG4gICAgICBkZWZhdWx0OiB1bmRlZmluZWQsXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgem9vbSBvZiB0aGUgbWFwLCBzdXBwb3J0cyAuc3luYyBtb2RpZmllclxuICAgICAqL1xuICAgIHpvb206IHtcbiAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIGRlZmF1bHQ6IDAsXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgbWluWm9vbSBvZiB0aGUgbWFwXG4gICAgICovXG4gICAgbWluWm9vbToge1xuICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgZGVmYXVsdDogdW5kZWZpbmVkLFxuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIG1heFpvb20gb2YgdGhlIG1hcFxuICAgICAqL1xuICAgIG1heFpvb206IHtcbiAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZCxcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSBwYWRkaW5nQm90dG9tUmlnaHQgb2YgdGhlIG1hcFxuICAgICAqL1xuICAgIHBhZGRpbmdCb3R0b21SaWdodDoge1xuICAgICAgdHlwZTogQXJyYXksXG4gICAgICBkZWZhdWx0OiB1bmRlZmluZWQsXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgcGFkZGluZ1RvcExlZnQgb2YgdGhlIG1hcFxuICAgICAqL1xuICAgIHBhZGRpbmdUb3BMZWZ0OiB7XG4gICAgICB0eXBlOiBBcnJheSxcbiAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZCxcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSBwYWRkaW5nIG9mIHRoZSBtYXBcbiAgICAgKi9cbiAgICBwYWRkaW5nOiB7XG4gICAgICB0eXBlOiBBcnJheSxcbiAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZCxcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSB3b3JsZENvcHlKdW1wIG9wdGlvbiBmb3IgdGhlIG1hcFxuICAgICAqL1xuICAgIHdvcmxkQ29weUp1bXA6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSBDUlMgdG8gdXNlIGZvciB0aGUgbWFwLiBDYW4gYmUgYW4gb2JqZWN0IHRoYXQgZGVmaW5lcyBhIGNvb3JkaW5hdGUgcmVmZXJlbmNlXG4gICAgICogc3lzdGVtIGZvciBwcm9qZWN0aW5nIGdlb2dyYXBoaWNhbCBwb2ludHMgaW50byBzY3JlZW4gY29vcmRpbmF0ZXMgYW5kIGJhY2tcbiAgICAgKiAoc2VlIGh0dHBzOi8vbGVhZmxldGpzLmNvbS9yZWZlcmVuY2UtMS43LjEuaHRtbCNjcnMtbC1jcnMtYmFzZSksIG9yIGEgc3RyaW5nXG4gICAgICogbmFtZSBpZGVudGlmeWluZyBvbmUgb2YgTGVhZmxldCdzIGRlZmluZWQgQ1JTcywgc3VjaCBhcyBcIkVQU0c0MzI2XCIuXG4gICAgICovXG4gICAgY3JzOiB7XG4gICAgICB0eXBlOiBbU3RyaW5nLCBPYmplY3RdLFxuICAgICAgZGVmYXVsdDogXCJFUFNHMzg1N1wiLFxuICAgIH0sXG4gICAgbWF4Qm91bmRzVmlzY29zaXR5OiB7XG4gICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICBkZWZhdWx0OiB1bmRlZmluZWQsXG4gICAgfSxcbiAgICBpbmVydGlhOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogdW5kZWZpbmVkLFxuICAgIH0sXG4gICAgaW5lcnRpYURlY2VsZXJhdGlvbjoge1xuICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgZGVmYXVsdDogdW5kZWZpbmVkLFxuICAgIH0sXG4gICAgaW5lcnRpYU1heFNwZWVkOiB7XG4gICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICBkZWZhdWx0OiB1bmRlZmluZWQsXG4gICAgfSxcbiAgICBlYXNlTGluZWFyaXR5OiB7XG4gICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICBkZWZhdWx0OiB1bmRlZmluZWQsXG4gICAgfSxcbiAgICB6b29tQW5pbWF0aW9uOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogdW5kZWZpbmVkLFxuICAgIH0sXG4gICAgem9vbUFuaW1hdGlvblRocmVzaG9sZDoge1xuICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgZGVmYXVsdDogdW5kZWZpbmVkLFxuICAgIH0sXG4gICAgZmFkZUFuaW1hdGlvbjoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZCxcbiAgICB9LFxuICAgIG1hcmtlclpvb21BbmltYXRpb246IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiB1bmRlZmluZWQsXG4gICAgfSxcbiAgICBub0Jsb2NraW5nQW5pbWF0aW9uczoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgIH0sXG4gICAgdXNlR2xvYmFsTGVhZmxldDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgIH0sXG4gIH0sXG4gIHNldHVwKHByb3BzLCBjb250ZXh0KSB7XG4gICAgY29uc3Qgcm9vdCA9IHJlZihudWxsKTtcbiAgICBjb25zdCBibHVlcHJpbnQgPSByZWFjdGl2ZSh7XG4gICAgICByZWFkeTogZmFsc2UsXG4gICAgICBsZWFmbGV0UmVmOiB7fSxcbiAgICAgIGxheWVyc1RvQWRkOiBbXSxcbiAgICAgIGxheWVyc0luQ29udHJvbDogW10sXG4gICAgfSk7XG4gICAgY29uc3QgeyBvcHRpb25zOiBjb21wb25lbnRPcHRpb25zIH0gPSBzZXR1cChwcm9wcyk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIC4uLmNvbXBvbmVudE9wdGlvbnMsXG4gICAgICBtaW5ab29tOiBwcm9wcy5taW5ab29tLFxuICAgICAgbWF4Wm9vbTogcHJvcHMubWF4Wm9vbSxcbiAgICAgIG1heEJvdW5kczogcHJvcHMubWF4Qm91bmRzLFxuICAgICAgbWF4Qm91bmRzVmlzY29zaXR5OiBwcm9wcy5tYXhCb3VuZHNWaXNjb3NpdHksXG4gICAgICB3b3JsZENvcHlKdW1wOiBwcm9wcy53b3JsZENvcHlKdW1wLFxuICAgICAgY3JzOiBwcm9wcy5jcnMsXG4gICAgICBjZW50ZXI6IHByb3BzLmNlbnRlcixcbiAgICAgIHpvb206IHByb3BzLnpvb20sXG4gICAgICBpbmVydGlhOiBwcm9wcy5pbmVydGlhLFxuICAgICAgaW5lcnRpYURlY2VsZXJhdGlvbjogcHJvcHMuaW5lcnRpYURlY2VsZXJhdGlvbixcbiAgICAgIGluZXJ0aWFNYXhTcGVlZDogcHJvcHMuaW5lcnRpYU1heFNwZWVkLFxuICAgICAgZWFzZUxpbmVhcml0eTogcHJvcHMuZWFzZUxpbmVhcml0eSxcbiAgICAgIHpvb21BbmltYXRpb246IHByb3BzLnpvb21BbmltYXRpb24sXG4gICAgICB6b29tQW5pbWF0aW9uVGhyZXNob2xkOiBwcm9wcy56b29tQW5pbWF0aW9uVGhyZXNob2xkLFxuICAgICAgZmFkZUFuaW1hdGlvbjogcHJvcHMuZmFkZUFuaW1hdGlvbixcbiAgICAgIG1hcmtlclpvb21BbmltYXRpb246IHByb3BzLm1hcmtlclpvb21BbmltYXRpb24sXG4gICAgfTtcblxuICAgIGNvbnN0IGFkZExheWVyID0gcHJvdmlkZUxlYWZsZXRXcmFwcGVyKFwiYWRkTGF5ZXJcIik7XG4gICAgY29uc3QgcmVtb3ZlTGF5ZXIgPSBwcm92aWRlTGVhZmxldFdyYXBwZXIoXCJyZW1vdmVMYXllclwiKTtcbiAgICBjb25zdCByZWdpc3RlckNvbnRyb2wgPSBwcm92aWRlTGVhZmxldFdyYXBwZXIoXCJyZWdpc3RlckNvbnRyb2xcIik7XG4gICAgY29uc3QgcmVnaXN0ZXJMYXllckNvbnRyb2wgPSBwcm92aWRlTGVhZmxldFdyYXBwZXIoXCJyZWdpc3RlckxheWVyQ29udHJvbFwiKTtcbiAgICBwcm92aWRlKEdMT0JBTF9MRUFGTEVUX09QVCwgcHJvcHMudXNlR2xvYmFsTGVhZmxldCk7XG5cbiAgICBjb25zdCBldmVudEhhbmRsZXJzID0ge1xuICAgICAgbW92ZUVuZEhhbmRsZXIoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmlnZ2VycyB3aGVuIHpvb20gaXMgdXBkYXRlZFxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyLHN0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGNvbnRleHQuZW1pdChcInVwZGF0ZTp6b29tXCIsIGJsdWVwcmludC5sZWFmbGV0UmVmLmdldFpvb20oKSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmlnZ2VycyB3aGVuIGNlbnRlciBpcyB1cGRhdGVkXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3QsYXJyYXl9XG4gICAgICAgICAqL1xuICAgICAgICBjb250ZXh0LmVtaXQoXCJ1cGRhdGU6Y2VudGVyXCIsIGJsdWVwcmludC5sZWFmbGV0UmVmLmdldENlbnRlcigpKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVHJpZ2dlcnMgd2hlbiBib3VuZHMgYXJlIHVwZGF0ZWRcbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIGNvbnRleHQuZW1pdChcInVwZGF0ZTpib3VuZHNcIiwgYmx1ZXByaW50LmxlYWZsZXRSZWYuZ2V0Qm91bmRzKCkpO1xuICAgICAgfSxcbiAgICAgIG92ZXJsYXlBZGRIYW5kbGVyKGUpIHtcbiAgICAgICAgY29uc3QgbGF5ZXIgPSBibHVlcHJpbnQubGF5ZXJzSW5Db250cm9sLmZpbmQoKGwpID0+IGwubmFtZSA9PT0gZS5uYW1lKTtcbiAgICAgICAgaWYgKGxheWVyKSB7XG4gICAgICAgICAgbGF5ZXIudXBkYXRlVmlzaWJsZVByb3AodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvdmVybGF5UmVtb3ZlSGFuZGxlcihlKSB7XG4gICAgICAgIGNvbnN0IGxheWVyID0gYmx1ZXByaW50LmxheWVyc0luQ29udHJvbC5maW5kKChsKSA9PiBsLm5hbWUgPT09IGUubmFtZSk7XG4gICAgICAgIGlmIChsYXllcikge1xuICAgICAgICAgIGxheWVyLnVwZGF0ZVZpc2libGVQcm9wKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9O1xuXG4gICAgb25Nb3VudGVkKGFzeW5jICgpID0+IHtcbiAgICAgIGlmIChwcm9wcy51c2VHbG9iYWxMZWFmbGV0KSB7XG4gICAgICAgIFdJTkRPV19PUl9HTE9CQUwuTCA9IFdJTkRPV19PUl9HTE9CQUwuTCB8fCAoYXdhaXQgaW1wb3J0KCdsZWFmbGV0JykpO1xuICAgICAgfVxuICAgICAgY29uc3Qge1xuICAgICAgICBtYXAsXG4gICAgICAgIENSUyxcbiAgICAgICAgSWNvbixcbiAgICAgICAgbGF0TG5nQm91bmRzLFxuICAgICAgICBsYXRMbmcsXG4gICAgICAgIERvbUV2ZW50LFxuICAgICAgfSA9IHByb3BzLnVzZUdsb2JhbExlYWZsZXRcbiAgICAgICAgPyBXSU5ET1dfT1JfR0xPQkFMLkxcbiAgICAgICAgOiBhd2FpdCBpbXBvcnQoJ2xlYWZsZXQvZGlzdC9sZWFmbGV0LXNyYy5lc20nKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgb3B0aW9ucy5iZWZvcmVNYXBNb3VudCAmJiAoYXdhaXQgb3B0aW9ucy5iZWZvcmVNYXBNb3VudCgpKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgYFRoZSBmb2xsb3dpbmcgZXJyb3Igb2NjdXJyZWQgcnVubmluZyB0aGUgcHJvdmlkZWQgYmVmb3JlTWFwTW91bnQgaG9vayAke2Vycm9yLm1lc3NhZ2V9YFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBhd2FpdCByZXNldFdlYnBhY2tJY29uKEljb24pO1xuXG4gICAgICBjb25zdCBvcHRpb25zQ3JzID1cbiAgICAgICAgdHlwZW9mIG9wdGlvbnMuY3JzID09IFwic3RyaW5nXCIgPyBDUlNbb3B0aW9ucy5jcnNdIDogb3B0aW9ucy5jcnM7XG4gICAgICBvcHRpb25zLmNycyA9IG9wdGlvbnNDcnMgfHwgQ1JTLkVQU0czODU3O1xuXG4gICAgICBjb25zdCBtZXRob2RzID0ge1xuICAgICAgICBhZGRMYXllcihsYXllcikge1xuICAgICAgICAgIGlmIChsYXllci5sYXllclR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKGJsdWVwcmludC5sYXllckNvbnRyb2wgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBibHVlcHJpbnQubGF5ZXJzVG9BZGQucHVzaChsYXllcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zdCBleGlzdCA9IGJsdWVwcmludC5sYXllcnNJbkNvbnRyb2wuZmluZChcbiAgICAgICAgICAgICAgICAobCkgPT5cbiAgICAgICAgICAgICAgICAgIGwubGVhZmxldE9iamVjdC5fbGVhZmxldF9pZCA9PT1cbiAgICAgICAgICAgICAgICAgIGxheWVyLmxlYWZsZXRPYmplY3QuX2xlYWZsZXRfaWRcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgaWYgKCFleGlzdCkge1xuICAgICAgICAgICAgICAgIGJsdWVwcmludC5sYXllckNvbnRyb2wuYWRkTGF5ZXIobGF5ZXIpO1xuICAgICAgICAgICAgICAgIGJsdWVwcmludC5sYXllcnNJbkNvbnRyb2wucHVzaChsYXllcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxheWVyLnZpc2libGUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBibHVlcHJpbnQubGVhZmxldFJlZi5hZGRMYXllcihsYXllci5sZWFmbGV0T2JqZWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZUxheWVyKGxheWVyKSB7XG4gICAgICAgICAgaWYgKGxheWVyLmxheWVyVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoYmx1ZXByaW50LmxheWVyQ29udHJvbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGJsdWVwcmludC5sYXllcnNUb0FkZCA9IGJsdWVwcmludC5sYXllcnNUb0FkZC5maWx0ZXIoXG4gICAgICAgICAgICAgICAgKGwpID0+IGwubmFtZSAhPT0gbGF5ZXIubmFtZVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYmx1ZXByaW50LmxheWVyQ29udHJvbC5yZW1vdmVMYXllcihsYXllci5sZWFmbGV0T2JqZWN0KTtcbiAgICAgICAgICAgICAgYmx1ZXByaW50LmxheWVyc0luQ29udHJvbCA9IGJsdWVwcmludC5sYXllcnNJbkNvbnRyb2wuZmlsdGVyKFxuICAgICAgICAgICAgICAgIChsKSA9PlxuICAgICAgICAgICAgICAgICAgbC5sZWFmbGV0T2JqZWN0Ll9sZWFmbGV0X2lkICE9PVxuICAgICAgICAgICAgICAgICAgbGF5ZXIubGVhZmxldE9iamVjdC5fbGVhZmxldF9pZFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBibHVlcHJpbnQubGVhZmxldFJlZi5yZW1vdmVMYXllcihsYXllci5sZWFmbGV0T2JqZWN0KTtcbiAgICAgICAgfSxcblxuICAgICAgICByZWdpc3RlckxheWVyQ29udHJvbChsQ29udHJvbExheWVyKSB7XG4gICAgICAgICAgYmx1ZXByaW50LmxheWVyQ29udHJvbCA9IGxDb250cm9sTGF5ZXI7XG4gICAgICAgICAgYmx1ZXByaW50LmxheWVyc1RvQWRkLmZvckVhY2goKGxheWVyKSA9PiB7XG4gICAgICAgICAgICBibHVlcHJpbnQubGF5ZXJDb250cm9sLmFkZExheWVyKGxheWVyKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBibHVlcHJpbnQubGF5ZXJzVG9BZGQgPSBbXTtcblxuICAgICAgICAgIHJlZ2lzdGVyQ29udHJvbChsQ29udHJvbExheWVyKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZWdpc3RlckNvbnRyb2wobENvbnRyb2wpIHtcbiAgICAgICAgICBibHVlcHJpbnQubGVhZmxldFJlZi5hZGRDb250cm9sKGxDb250cm9sLmxlYWZsZXRPYmplY3QpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldFpvb20obmV3VmFsKSB7XG4gICAgICAgICAgY29uc3Qgem9vbSA9IGJsdWVwcmludC5sZWFmbGV0UmVmLmdldFpvb20oKTtcbiAgICAgICAgICBpZiAobmV3VmFsICE9PSB6b29tKSB7XG4gICAgICAgICAgICBibHVlcHJpbnQubGVhZmxldFJlZi5zZXRab29tKG5ld1ZhbCwge1xuICAgICAgICAgICAgICBhbmltYXRlOiBwcm9wcy5ub0Jsb2NraW5nQW5pbWF0aW9ucyA/IGZhbHNlIDogbnVsbCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBzZXRQYWRkaW5nQm90dG9tUmlnaHQobmV3VmFsKSB7XG4gICAgICAgICAgYmx1ZXByaW50LnBhZGRpbmdCb3R0b21SaWdodCA9IG5ld1ZhbDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0UGFkZGluZ1RvcExlZnQobmV3VmFsKSB7XG4gICAgICAgICAgYmx1ZXByaW50LnBhZGRpbmdUb3BMZWZ0ID0gbmV3VmFsO1xuICAgICAgICB9LFxuICAgICAgICBzZXRQYWRkaW5nKG5ld1ZhbCkge1xuICAgICAgICAgIGJsdWVwcmludC5wYWRkaW5nID0gbmV3VmFsO1xuICAgICAgICB9LFxuICAgICAgICBzZXRDcnMobmV3VmFsKSB7XG4gICAgICAgICAgY29uc3QgcHJldkJvdW5kcyA9IGJsdWVwcmludC5sZWFmbGV0UmVmLmdldEJvdW5kcygpO1xuICAgICAgICAgIGJsdWVwcmludC5sZWFmbGV0UmVmLm9wdGlvbnMuY3JzID0gbmV3VmFsO1xuICAgICAgICAgIGJsdWVwcmludC5sZWFmbGV0UmVmLmZpdEJvdW5kcyhwcmV2Qm91bmRzLCB7XG4gICAgICAgICAgICBhbmltYXRlOiBmYWxzZSxcbiAgICAgICAgICAgIHBhZGRpbmc6IFswLCAwXSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZml0Qm91bmRzKGJvdW5kcykge1xuICAgICAgICAgIGJsdWVwcmludC5sZWFmbGV0UmVmLmZpdEJvdW5kcyhib3VuZHMsIHtcbiAgICAgICAgICAgIGFuaW1hdGU6IHRoaXMubm9CbG9ja2luZ0FuaW1hdGlvbnMgPyBmYWxzZSA6IG51bGwsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldEJvdW5kcyhuZXdWYWwpIHtcbiAgICAgICAgICBpZiAoIW5ld1ZhbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBuZXdCb3VuZHMgPSBsYXRMbmdCb3VuZHMobmV3VmFsKTtcbiAgICAgICAgICBpZiAoIW5ld0JvdW5kcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgb2xkQm91bmRzID1cbiAgICAgICAgICAgIGJsdWVwcmludC5sYXN0U2V0Qm91bmRzIHx8IGJsdWVwcmludC5sZWFmbGV0UmVmLmdldEJvdW5kcygpO1xuICAgICAgICAgIGNvbnN0IGJvdW5kc0NoYW5nZWQgPSAhb2xkQm91bmRzLmVxdWFscyhuZXdCb3VuZHMsIDApOyAvLyBzZXQgbWF4TWFyZ2luIHRvIDAgLSBjaGVjayBleGFjdCBlcXVhbHNcbiAgICAgICAgICBpZiAoYm91bmRzQ2hhbmdlZCkge1xuICAgICAgICAgICAgYmx1ZXByaW50Lmxhc3RTZXRCb3VuZHMgPSBuZXdCb3VuZHM7XG4gICAgICAgICAgICBibHVlcHJpbnQubGVhZmxldFJlZi5maXRCb3VuZHMobmV3Qm91bmRzLCB0aGlzLmZpdEJvdW5kc09wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBzZXRDZW50ZXIobmV3VmFsKSB7XG4gICAgICAgICAgaWYgKG5ld1ZhbCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG5ld0NlbnRlciA9IGxhdExuZyhuZXdWYWwpO1xuICAgICAgICAgIGNvbnN0IG9sZENlbnRlciA9XG4gICAgICAgICAgICBibHVlcHJpbnQubGFzdFNldENlbnRlciB8fCBibHVlcHJpbnQubGVhZmxldFJlZi5nZXRDZW50ZXIoKTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBvbGRDZW50ZXIubGF0ICE9PSBuZXdDZW50ZXIubGF0IHx8XG4gICAgICAgICAgICBvbGRDZW50ZXIubG5nICE9PSBuZXdDZW50ZXIubG5nXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBibHVlcHJpbnQubGFzdFNldENlbnRlciA9IG5ld0NlbnRlcjtcbiAgICAgICAgICAgIGJsdWVwcmludC5sZWFmbGV0UmVmLnBhblRvKG5ld0NlbnRlciwge1xuICAgICAgICAgICAgICBhbmltYXRlOiB0aGlzLm5vQmxvY2tpbmdBbmltYXRpb25zID8gZmFsc2UgOiBudWxsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgfTtcblxuICAgICAgdXBkYXRlTGVhZmxldFdyYXBwZXIoYWRkTGF5ZXIsIG1ldGhvZHMuYWRkTGF5ZXIpO1xuICAgICAgdXBkYXRlTGVhZmxldFdyYXBwZXIocmVtb3ZlTGF5ZXIsIG1ldGhvZHMucmVtb3ZlTGF5ZXIpO1xuICAgICAgdXBkYXRlTGVhZmxldFdyYXBwZXIocmVnaXN0ZXJDb250cm9sLCBtZXRob2RzLnJlZ2lzdGVyQ29udHJvbCk7XG4gICAgICB1cGRhdGVMZWFmbGV0V3JhcHBlcihyZWdpc3RlckxheWVyQ29udHJvbCwgbWV0aG9kcy5yZWdpc3RlckxheWVyQ29udHJvbCk7XG5cbiAgICAgIGJsdWVwcmludC5sZWFmbGV0UmVmID0gbWFwKHJvb3QudmFsdWUsIG9wdGlvbnMpO1xuXG4gICAgICBwcm9wc0JpbmRlcihtZXRob2RzLCBibHVlcHJpbnQubGVhZmxldFJlZiwgcHJvcHMpO1xuICAgICAgY29uc3QgbGlzdGVuZXJzID0gcmVtYXBFdmVudHMoY29udGV4dC5hdHRycyk7XG5cbiAgICAgIGJsdWVwcmludC5sZWFmbGV0UmVmLm9uKFxuICAgICAgICBcIm1vdmVlbmRcIixcbiAgICAgICAgZGVib3VuY2UoZXZlbnRIYW5kbGVycy5tb3ZlRW5kSGFuZGxlciwgMTAwKVxuICAgICAgKTtcbiAgICAgIGJsdWVwcmludC5sZWFmbGV0UmVmLm9uKFwib3ZlcmxheWFkZFwiLCBldmVudEhhbmRsZXJzLm92ZXJsYXlBZGRIYW5kbGVyKTtcbiAgICAgIGJsdWVwcmludC5sZWFmbGV0UmVmLm9uKFxuICAgICAgICBcIm92ZXJsYXlyZW1vdmVcIixcbiAgICAgICAgZXZlbnRIYW5kbGVycy5vdmVybGF5UmVtb3ZlSGFuZGxlclxuICAgICAgKTtcbiAgICAgIERvbUV2ZW50Lm9uKGJsdWVwcmludC5sZWFmbGV0UmVmLCBsaXN0ZW5lcnMpO1xuICAgICAgYmx1ZXByaW50LnJlYWR5ID0gdHJ1ZTtcbiAgICAgIG5leHRUaWNrKCgpID0+IGNvbnRleHQuZW1pdChcInJlYWR5XCIsIGJsdWVwcmludC5sZWFmbGV0UmVmKSk7XG4gICAgfSk7XG5cbiAgICBvbkJlZm9yZVVubW91bnQoKCkgPT4ge1xuICAgICAgaWYgKGJsdWVwcmludC5sZWFmbGV0UmVmKSB7XG4gICAgICAgIGJsdWVwcmludC5sZWFmbGV0UmVmLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgbGVhZmxldE9iamVjdCA9IGNvbXB1dGVkKCgpID0+IGJsdWVwcmludC5sZWFmbGV0UmVmKTtcbiAgICBjb25zdCByZWFkeSA9IGNvbXB1dGVkKCgpID0+IGJsdWVwcmludC5yZWFkeSk7XG4gICAgcmV0dXJuIHsgcm9vdCwgcmVhZHksIGxlYWZsZXRPYmplY3QgfTtcbiAgfSxcbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiBoKFxuICAgICAgXCJkaXZcIixcbiAgICAgIHsgc3R5bGU6IHsgd2lkdGg6IFwiMTAwJVwiLCBoZWlnaHQ6IFwiMTAwJVwiIH0sIHJlZjogXCJyb290XCIgfSxcbiAgICAgIHRoaXMucmVhZHkgPyB0aGlzLiRzbG90cy5kZWZhdWx0KCkgOiB7fVxuICAgICk7XG4gIH0sXG59O1xuXG5zY3JpcHQkZC5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL0xNYXAudnVlXCI7XG5cbmNvbnN0IHByb3BzJGggPSB7XG4gIC4uLnByb3BzJDEsXG4gIHBhbmU6IHtcbiAgICB0eXBlOiBTdHJpbmcsXG4gICAgZGVmYXVsdDogXCJtYXJrZXJQYW5lXCIsXG4gIH0sXG4gIGRyYWdnYWJsZToge1xuICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgY3VzdG9tOiB0cnVlLFxuICAgIGRlZmF1bHQ6IGZhbHNlLFxuICB9LFxuICBsYXRMbmc6IHtcbiAgICB0eXBlOiBbT2JqZWN0LCBBcnJheV0sXG4gICAgY3VzdG9tOiB0cnVlLFxuICAgIGRlZmF1bHQ6IG51bGwsXG4gIH0sXG4gIGljb246IHtcbiAgICB0eXBlOiBbT2JqZWN0XSxcbiAgICBkZWZhdWx0OiAoKSA9PiB1bmRlZmluZWQsXG4gICAgY3VzdG9tOiBmYWxzZSxcbiAgfSxcbiAgekluZGV4T2Zmc2V0OiB7XG4gICAgdHlwZTogTnVtYmVyLFxuICAgIGN1c3RvbTogZmFsc2UsXG4gICAgZGVmYXVsdDogbnVsbCxcbiAgfSxcbn07XG5cbmNvbnN0IHNldHVwJGcgPSAocHJvcHMsIGxlYWZsZXRSZWYsIGNvbnRleHQpID0+IHtcbiAgY29uc3QgeyBvcHRpb25zOiBsYXllck9wdGlvbnMsIG1ldGhvZHM6IGxheWVyTWV0aG9kcyB9ID0gc2V0dXAkMShcbiAgICBwcm9wcyxcbiAgICBsZWFmbGV0UmVmLFxuICAgIGNvbnRleHRcbiAgKTtcbiAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAuLi5sYXllck9wdGlvbnMsXG4gICAgLi4ucHJvcHMsXG4gIH07XG5cbiAgY29uc3QgbWV0aG9kcyA9IHtcbiAgICAuLi5sYXllck1ldGhvZHMsXG4gICAgc2V0RHJhZ2dhYmxlKHZhbHVlKSB7XG4gICAgICBpZiAobGVhZmxldFJlZi52YWx1ZS5kcmFnZ2luZykge1xuICAgICAgICB2YWx1ZVxuICAgICAgICAgID8gbGVhZmxldFJlZi52YWx1ZS5kcmFnZ2luZy5lbmFibGUoKVxuICAgICAgICAgIDogbGVhZmxldFJlZi52YWx1ZS5kcmFnZ2luZy5kaXNhYmxlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBsYXRMbmdTeW5jKGV2ZW50KSB7XG4gICAgICBjb250ZXh0LmVtaXQoXCJ1cGRhdGU6bGF0TG5nXCIsIGV2ZW50LmxhdGxuZyk7XG4gICAgICBjb250ZXh0LmVtaXQoXCJ1cGRhdGU6bGF0LWxuZ1wiLCBldmVudC5sYXRsbmcpO1xuICAgIH0sXG4gICAgc2V0TGF0TG5nKG5ld1ZhbCkge1xuICAgICAgaWYgKG5ld1ZhbCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGxlYWZsZXRSZWYudmFsdWUpIHtcbiAgICAgICAgY29uc3Qgb2xkTGF0TG5nID0gbGVhZmxldFJlZi52YWx1ZS5nZXRMYXRMbmcoKTtcbiAgICAgICAgaWYgKCFvbGRMYXRMbmcgfHwgIW9sZExhdExuZy5lcXVhbHMobmV3VmFsKSkge1xuICAgICAgICAgIGxlYWZsZXRSZWYudmFsdWUuc2V0TGF0TG5nKG5ld1ZhbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICB9O1xuICByZXR1cm4geyBvcHRpb25zLCBtZXRob2RzIH07XG59O1xuXG4vKipcbiAqIE1hcmtlciBjb21wb25lbnQsIGxldHMgeW91IGFkZCBhbmQgcGVyc29uYWxpemUgbWFya2VycyBvbiB0aGUgbWFwXG4gKi9cbnZhciBzY3JpcHQkZSA9IHtcbiAgbmFtZTogXCJMTWFya2VyXCIsXG4gIHByb3BzOiBwcm9wcyRoLFxuICBzZXR1cChwcm9wcywgY29udGV4dCkge1xuICAgIGNvbnN0IGxlYWZsZXRSZWYgPSByZWYoe30pO1xuICAgIGNvbnN0IHJlYWR5ID0gcmVmKGZhbHNlKTtcblxuICAgIGNvbnN0IHVzZUdsb2JhbExlYWZsZXQgPSBpbmplY3QoR0xPQkFMX0xFQUZMRVRfT1BUKTtcbiAgICBjb25zdCBhZGRMYXllciA9IGluamVjdChcImFkZExheWVyXCIpO1xuXG4gICAgcHJvdmlkZShcImNhblNldFBhcmVudEh0bWxcIiwgKCkgPT4gISFsZWFmbGV0UmVmLnZhbHVlLmdldEVsZW1lbnQoKSk7XG4gICAgcHJvdmlkZShcbiAgICAgIFwic2V0UGFyZW50SHRtbFwiLFxuICAgICAgKGh0bWwpID0+IChsZWFmbGV0UmVmLnZhbHVlLmdldEVsZW1lbnQoKS5pbm5lckhUTUwgPSBodG1sKVxuICAgICk7XG4gICAgcHJvdmlkZShcbiAgICAgIFwic2V0SWNvblwiLFxuICAgICAgKG5ld0ljb24pID0+IGxlYWZsZXRSZWYudmFsdWUuc2V0SWNvbiAmJiBsZWFmbGV0UmVmLnZhbHVlLnNldEljb24obmV3SWNvbilcbiAgICApO1xuICAgIGNvbnN0IHsgb3B0aW9ucywgbWV0aG9kcyB9ID0gc2V0dXAkZyhwcm9wcywgbGVhZmxldFJlZiwgY29udGV4dCk7XG4gICAgaWYgKG9wdGlvbnMuaWNvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBJZiB0aGUgb3B0aW9ucyBvYmplY3Rpb24gaGFzIGEgcHJvcGVydHkgbmFtZWQgJ2ljb24nLCB0aGVuIExlYWZsZXQgd2lsbCBvdmVyd3JpdGVcbiAgICAgIC8vIHRoZSBkZWZhdWx0IGljb24gd2l0aCBpdCBmb3IgdGhlIG1hcmtlciwgX2V2ZW4gaWYgaXQgaXMgdW5kZWZpbmVkXy5cbiAgICAgIC8vIFRoaXMgbGVhZHMgdG8gdGhlIGlzc3VlIGRpc2N1c3NlZCBpbiBodHRwczovL2dpdGh1Yi5jb20vdnVlLWxlYWZsZXQvdnVlLWxlYWZsZXQvaXNzdWVzLzEzMFxuICAgICAgZGVsZXRlIG9wdGlvbnMuaWNvbjtcbiAgICB9XG5cbiAgICBvbk1vdW50ZWQoYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgeyBtYXJrZXIsIERvbUV2ZW50IH0gPSB1c2VHbG9iYWxMZWFmbGV0XG4gICAgICAgID8gV0lORE9XX09SX0dMT0JBTC5MXG4gICAgICAgIDogYXdhaXQgaW1wb3J0KCdsZWFmbGV0L2Rpc3QvbGVhZmxldC1zcmMuZXNtJyk7XG4gICAgICBsZWFmbGV0UmVmLnZhbHVlID0gbWFya2VyKHByb3BzLmxhdExuZywgb3B0aW9ucyk7XG5cbiAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHJlbWFwRXZlbnRzKGNvbnRleHQuYXR0cnMpO1xuICAgICAgRG9tRXZlbnQub24obGVhZmxldFJlZi52YWx1ZSwgbGlzdGVuZXJzKTtcblxuICAgICAgbGVhZmxldFJlZi52YWx1ZS5vbihcIm1vdmVcIiwgZGVib3VuY2UobWV0aG9kcy5sYXRMbmdTeW5jLCAxMDApKTtcbiAgICAgIHByb3BzQmluZGVyKG1ldGhvZHMsIGxlYWZsZXRSZWYudmFsdWUsIHByb3BzKTtcbiAgICAgIGFkZExheWVyKHtcbiAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgIC4uLm1ldGhvZHMsXG4gICAgICAgIGxlYWZsZXRPYmplY3Q6IGxlYWZsZXRSZWYudmFsdWUsXG4gICAgICB9KTtcbiAgICAgIHJlYWR5LnZhbHVlID0gdHJ1ZTtcbiAgICAgIG5leHRUaWNrKCgpID0+IGNvbnRleHQuZW1pdChcInJlYWR5XCIsIGxlYWZsZXRSZWYudmFsdWUpKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB7IHJlYWR5LCBsZWFmbGV0T2JqZWN0OiBsZWFmbGV0UmVmIH07XG4gIH0sXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gcmVuZGVyKHRoaXMucmVhZHksIHRoaXMuJHNsb3RzKTtcbiAgfSxcbn07XG5cbnNjcmlwdCRlLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvTE1hcmtlci52dWVcIjtcblxuY29uc3QgcHJvcHMkaSA9IHtcbiAgLi4ucHJvcHMkMyxcbiAgbGF0TG5nczoge1xuICAgIHR5cGU6IEFycmF5LFxuICAgIGRlZmF1bHQ6ICgpID0+IFtdLFxuICB9LFxuICBzbW9vdGhGYWN0b3I6IHtcbiAgICB0eXBlOiBOdW1iZXIsXG4gICAgY3VzdG9tOiB0cnVlLFxuICAgIGRlZmF1bHQ6IDEuMCxcbiAgfSxcbiAgbm9DbGlwOiB7XG4gICAgdHlwZTogQm9vbGVhbixcbiAgICBjdXN0b206IHRydWUsXG4gICAgZGVmYXVsdDogZmFsc2UsXG4gIH0sXG59O1xuXG5jb25zdCBzZXR1cCRoID0gKHByb3BzLCBsZWFmbGV0UmVmLCBjb250ZXh0KSA9PiB7XG4gIGNvbnN0IHsgb3B0aW9uczogcGF0aE9wdGlvbnMsIG1ldGhvZHM6IHBhdGhNZXRob2RzIH0gPSBzZXR1cCQzKFxuICAgIHByb3BzLFxuICAgIGxlYWZsZXRSZWYsXG4gICAgY29udGV4dFxuICApO1xuICBjb25zdCBvcHRpb25zID0ge1xuICAgIC4uLnBhdGhPcHRpb25zLFxuICAgIC4uLnByb3BzLFxuICB9O1xuXG4gIGNvbnN0IG1ldGhvZHMgPSB7XG4gICAgLi4ucGF0aE1ldGhvZHMsXG4gICAgc2V0U21vb3RoRmFjdG9yKHNtb290aEZhY3Rvcikge1xuICAgICAgbGVhZmxldFJlZi52YWx1ZS5zZXRTdHlsZSh7IHNtb290aEZhY3RvciB9KTtcbiAgICB9LFxuICAgIHNldE5vQ2xpcChub0NsaXApIHtcbiAgICAgIGxlYWZsZXRSZWYudmFsdWUuc2V0U3R5bGUoeyBub0NsaXAgfSk7XG4gICAgfSxcbiAgICBhZGRMYXRMbmcobGF0TG5nKSB7XG4gICAgICBsZWFmbGV0UmVmLnZhbHVlLmFkZExhdExuZyhsYXRMbmcpO1xuICAgIH0sXG4gIH07XG4gIHJldHVybiB7IG9wdGlvbnMsIG1ldGhvZHMgfTtcbn07XG5cbmNvbnN0IHByb3BzJGogPSB7XG4gIC4uLnByb3BzJGksXG59O1xuXG5jb25zdCBzZXR1cCRpID0gKHByb3BzLCBsZWFmbGV0UmVmLCBjb250ZXh0KSA9PiB7XG4gIGNvbnN0IHsgb3B0aW9uczogcG9seWxpbmVPcHRpb25zLCBtZXRob2RzOiBwb2x5bGluZU1ldGhvZHMgfSA9IHNldHVwJGgoXG4gICAgcHJvcHMsXG4gICAgbGVhZmxldFJlZixcbiAgICBjb250ZXh0XG4gICk7XG4gIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgLi4ucG9seWxpbmVPcHRpb25zLFxuICAgIC4uLnByb3BzLFxuICB9O1xuXG4gIGNvbnN0IG1ldGhvZHMgPSB7XG4gICAgLi4ucG9seWxpbmVNZXRob2RzLFxuICAgIHRvR2VvSlNPTihwcmVjaXNpb24pIHtcbiAgICAgIHJldHVybiBsZWFmbGV0UmVmLnZhbHVlLnRvR2VvSlNPTihwcmVjaXNpb24pO1xuICAgIH0sXG4gIH07XG5cbiAgcmV0dXJuIHsgb3B0aW9ucywgbWV0aG9kcyB9O1xufTtcblxuLyoqXG4gKiBQb2x5Z29uIGNvbXBvbmVudCwgbGV0cyB5b3UgYWRkIGFuZCBjdXN0b21pemUgcG9seWdvbiByZWdpb25zIG9uIHRoZSBtYXBcbiAqL1xudmFyIHNjcmlwdCRmID0ge1xuICBuYW1lOiBcIkxQb2x5Z29uXCIsXG4gIHByb3BzOiBwcm9wcyRqLFxuICBzZXR1cChwcm9wcywgY29udGV4dCkge1xuICAgIGNvbnN0IGxlYWZsZXRSZWYgPSByZWYoe30pO1xuICAgIGNvbnN0IHJlYWR5ID0gcmVmKGZhbHNlKTtcblxuICAgIGNvbnN0IHVzZUdsb2JhbExlYWZsZXQgPSBpbmplY3QoR0xPQkFMX0xFQUZMRVRfT1BUKTtcbiAgICBjb25zdCBhZGRMYXllciA9IGluamVjdChcImFkZExheWVyXCIpO1xuXG4gICAgY29uc3QgeyBvcHRpb25zLCBtZXRob2RzIH0gPSBzZXR1cCRpKHByb3BzLCBsZWFmbGV0UmVmLCBjb250ZXh0KTtcblxuICAgIG9uTW91bnRlZChhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IHBvbHlnb24sIERvbUV2ZW50IH0gPSB1c2VHbG9iYWxMZWFmbGV0XG4gICAgICAgID8gV0lORE9XX09SX0dMT0JBTC5MXG4gICAgICAgIDogYXdhaXQgaW1wb3J0KCdsZWFmbGV0L2Rpc3QvbGVhZmxldC1zcmMuZXNtJyk7XG5cbiAgICAgIGxlYWZsZXRSZWYudmFsdWUgPSBwb2x5Z29uKHByb3BzLmxhdExuZ3MsIG9wdGlvbnMpO1xuXG4gICAgICBjb25zdCBsaXN0ZW5lcnMgPSByZW1hcEV2ZW50cyhjb250ZXh0LmF0dHJzKTtcbiAgICAgIERvbUV2ZW50Lm9uKGxlYWZsZXRSZWYudmFsdWUsIGxpc3RlbmVycyk7XG5cbiAgICAgIHByb3BzQmluZGVyKG1ldGhvZHMsIGxlYWZsZXRSZWYudmFsdWUsIHByb3BzKTtcblxuICAgICAgYWRkTGF5ZXIoe1xuICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgLi4ubWV0aG9kcyxcbiAgICAgICAgbGVhZmxldE9iamVjdDogbGVhZmxldFJlZi52YWx1ZSxcbiAgICAgIH0pO1xuICAgICAgcmVhZHkudmFsdWUgPSB0cnVlO1xuICAgICAgbmV4dFRpY2soKCkgPT4gY29udGV4dC5lbWl0KFwicmVhZHlcIiwgbGVhZmxldFJlZi52YWx1ZSkpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHsgcmVhZHksIGxlYWZsZXRPYmplY3Q6IGxlYWZsZXRSZWYgfTtcbiAgfSxcbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiByZW5kZXIodGhpcy5yZWFkeSwgdGhpcy4kc2xvdHMpO1xuICB9LFxufTtcblxuc2NyaXB0JGYuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9MUG9seWdvbi52dWVcIjtcblxuLyoqXG4gKiBQb2x5bGluZSBjb21wb25lbnQsIGxldHMgeW91IGFkZCBhbmQgcGVyc29uYWxpemUgcG9seWxpbmVzIG9uIHRoZSBtYXBcbiAqL1xudmFyIHNjcmlwdCRnID0ge1xuICBuYW1lOiBcIkxQb2x5bGluZVwiLFxuICBwcm9wczogcHJvcHMkaSxcbiAgc2V0dXAocHJvcHMsIGNvbnRleHQpIHtcbiAgICBjb25zdCBsZWFmbGV0UmVmID0gcmVmKHt9KTtcbiAgICBjb25zdCByZWFkeSA9IHJlZihmYWxzZSk7XG5cbiAgICBjb25zdCB1c2VHbG9iYWxMZWFmbGV0ID0gaW5qZWN0KEdMT0JBTF9MRUFGTEVUX09QVCk7XG4gICAgY29uc3QgYWRkTGF5ZXIgPSBpbmplY3QoXCJhZGRMYXllclwiKTtcblxuICAgIGNvbnN0IHsgb3B0aW9ucywgbWV0aG9kcyB9ID0gc2V0dXAkaChwcm9wcywgbGVhZmxldFJlZiwgY29udGV4dCk7XG5cbiAgICBvbk1vdW50ZWQoYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgeyBwb2x5bGluZSwgRG9tRXZlbnQgfSA9IHVzZUdsb2JhbExlYWZsZXRcbiAgICAgICAgPyBXSU5ET1dfT1JfR0xPQkFMLkxcbiAgICAgICAgOiBhd2FpdCBpbXBvcnQoJ2xlYWZsZXQvZGlzdC9sZWFmbGV0LXNyYy5lc20nKTtcblxuICAgICAgbGVhZmxldFJlZi52YWx1ZSA9IHBvbHlsaW5lKHByb3BzLmxhdExuZ3MsIG9wdGlvbnMpO1xuXG4gICAgICBjb25zdCBsaXN0ZW5lcnMgPSByZW1hcEV2ZW50cyhjb250ZXh0LmF0dHJzKTtcbiAgICAgIERvbUV2ZW50Lm9uKGxlYWZsZXRSZWYudmFsdWUsIGxpc3RlbmVycyk7XG5cbiAgICAgIHByb3BzQmluZGVyKG1ldGhvZHMsIGxlYWZsZXRSZWYudmFsdWUsIHByb3BzKTtcblxuICAgICAgYWRkTGF5ZXIoe1xuICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgLi4ubWV0aG9kcyxcbiAgICAgICAgbGVhZmxldE9iamVjdDogbGVhZmxldFJlZi52YWx1ZSxcbiAgICAgIH0pO1xuICAgICAgcmVhZHkudmFsdWUgPSB0cnVlO1xuICAgICAgbmV4dFRpY2soKCkgPT4gY29udGV4dC5lbWl0KFwicmVhZHlcIiwgbGVhZmxldFJlZi52YWx1ZSkpO1xuICAgIH0pO1xuICAgIHJldHVybiB7IHJlYWR5LCBsZWFmbGV0T2JqZWN0OiBsZWFmbGV0UmVmIH07XG4gIH0sXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gcmVuZGVyKHRoaXMucmVhZHksIHRoaXMuJHNsb3RzKTtcbiAgfSxcbn07XG5cbnNjcmlwdCRnLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvTFBvbHlsaW5lLnZ1ZVwiO1xuXG5jb25zdCBwcm9wcyRrID0ge1xuICAuLi5wcm9wcyxcbiAgY29udGVudDoge1xuICAgIHR5cGU6IFN0cmluZyxcbiAgICBkZWZhdWx0OiBudWxsLFxuICB9LFxufTtcblxuY29uc3Qgc2V0dXAkaiA9IChwcm9wcywgbGVhZmxldFJlZikgPT4ge1xuICBjb25zdCB7IG9wdGlvbnMsIG1ldGhvZHM6IGNvbXBvbmVudE1ldGhvZHMgfSA9IHNldHVwKHByb3BzKTtcbiAgY29uc3QgbWV0aG9kcyA9IHtcbiAgICAuLi5jb21wb25lbnRNZXRob2RzLFxuICAgIHNldENvbnRlbnQobmV3VmFsKSB7XG4gICAgICBpZiAobGVhZmxldFJlZi52YWx1ZSAmJiBuZXdWYWwgIT09IG51bGwgJiYgbmV3VmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGVhZmxldFJlZi52YWx1ZS5zZXRDb250ZW50KG5ld1ZhbCk7XG4gICAgICB9XG4gICAgfSxcbiAgfTtcbiAgcmV0dXJuIHsgb3B0aW9ucywgbWV0aG9kcyB9O1xufTtcblxuY29uc3QgcmVuZGVyJDIgPSAoc2xvdHMpID0+IHtcbiAgaWYgKHNsb3RzLmRlZmF1bHQpIHtcbiAgICByZXR1cm4gaChcImRpdlwiLCB7IHJlZjogXCJyb290XCIgfSwgc2xvdHMuZGVmYXVsdCgpKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbmNvbnN0IHByb3BzJGwgPSB7XG4gIC4uLnByb3BzJGssXG4gIGxhdExuZzoge1xuICAgIHR5cGU6IFtPYmplY3QsIEFycmF5XSxcbiAgICBkZWZhdWx0OiAoKSA9PiBbXSxcbiAgfSxcbn07XG5cbmNvbnN0IHNldHVwJGsgPSAocHJvcHMsIGxlYWZsZXRSZWYpID0+IHtcbiAgY29uc3QgeyBvcHRpb25zLCBtZXRob2RzIH0gPSBzZXR1cCRqKHByb3BzLCBsZWFmbGV0UmVmKTtcbiAgY29uc3QgdW5iaW5kUG9wdXAgPSBpbmplY3QoXCJ1bmJpbmRQb3B1cFwiKTtcblxuICBvbkJlZm9yZVVubW91bnQoKCkgPT4ge1xuICAgIHVuYmluZFBvcHVwKCk7XG4gIH0pO1xuXG4gIHJldHVybiB7IG9wdGlvbnMsIG1ldGhvZHMgfTtcbn07XG5cbi8qKlxuICogRGlzcGxheSBhIHBvcHVwIG9uIHRoZSBtYXBcbiAqL1xudmFyIHNjcmlwdCRoID0ge1xuICBuYW1lOiBcIkxQb3B1cFwiLFxuICBwcm9wczogcHJvcHMkbCxcbiAgc2V0dXAocHJvcHMsIGNvbnRleHQpIHtcbiAgICBjb25zdCBsZWFmbGV0UmVmID0gcmVmKHt9KTtcbiAgICBjb25zdCByb290ID0gcmVmKG51bGwpO1xuXG4gICAgY29uc3QgdXNlR2xvYmFsTGVhZmxldCA9IGluamVjdChHTE9CQUxfTEVBRkxFVF9PUFQpO1xuICAgIGNvbnN0IGJpbmRQb3B1cCA9IGluamVjdChcImJpbmRQb3B1cFwiKTtcblxuICAgIGNvbnN0IHsgb3B0aW9ucywgbWV0aG9kcyB9ID0gc2V0dXAkayhwcm9wcywgbGVhZmxldFJlZik7XG5cbiAgICBvbk1vdW50ZWQoYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgeyBwb3B1cCwgRG9tRXZlbnQgfSA9IHVzZUdsb2JhbExlYWZsZXRcbiAgICAgICAgPyBXSU5ET1dfT1JfR0xPQkFMLkxcbiAgICAgICAgOiBhd2FpdCBpbXBvcnQoJ2xlYWZsZXQvZGlzdC9sZWFmbGV0LXNyYy5lc20nKTtcblxuICAgICAgbGVhZmxldFJlZi52YWx1ZSA9IHBvcHVwKG9wdGlvbnMpO1xuXG4gICAgICBpZiAocHJvcHMubGF0TG5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGVhZmxldFJlZi52YWx1ZS5zZXRMYXRMbmcocHJvcHMubGF0TG5nKTtcbiAgICAgIH1cblxuICAgICAgcHJvcHNCaW5kZXIobWV0aG9kcywgbGVhZmxldFJlZi52YWx1ZSwgcHJvcHMpO1xuICAgICAgY29uc3QgbGlzdGVuZXJzID0gcmVtYXBFdmVudHMoY29udGV4dC5hdHRycyk7XG4gICAgICBEb21FdmVudC5vbihsZWFmbGV0UmVmLnZhbHVlLCBsaXN0ZW5lcnMpO1xuICAgICAgbGVhZmxldFJlZi52YWx1ZS5zZXRDb250ZW50KHByb3BzLmNvbnRlbnQgfHwgcm9vdC52YWx1ZSk7XG4gICAgICBiaW5kUG9wdXAoeyBsZWFmbGV0T2JqZWN0OiBsZWFmbGV0UmVmLnZhbHVlIH0pO1xuICAgICAgbmV4dFRpY2soKCkgPT4gY29udGV4dC5lbWl0KFwicmVhZHlcIiwgbGVhZmxldFJlZi52YWx1ZSkpO1xuICAgIH0pO1xuICAgIHJldHVybiB7IHJvb3QsIGxlYWZsZXRPYmplY3Q6IGxlYWZsZXRSZWYgfTtcbiAgfSxcbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiByZW5kZXIkMih0aGlzLiRzbG90cyk7XG4gIH0sXG59O1xuXG5zY3JpcHQkaC5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL0xQb3B1cC52dWVcIjtcblxuY29uc3QgcHJvcHMkbSA9IHtcbiAgLi4ucHJvcHMkaixcbiAgYm91bmRzOiB7XG4gICAgdHlwZTogQXJyYXksXG4gICAgZGVmYXVsdDogdW5kZWZpbmVkLFxuICB9LFxufTtcblxuY29uc3Qgc2V0dXAkbCA9IChwcm9wcywgbGVhZmxldFJlZiwgY29udGV4dCkgPT4ge1xuICBjb25zdCB7IG9wdGlvbnM6IHBvbHlnb25PcHRpb25zLCBtZXRob2RzOiBwb2x5Z29uTWV0aG9kcyB9ID0gc2V0dXAkaShcbiAgICBwcm9wcyxcbiAgICBsZWFmbGV0UmVmLFxuICAgIGNvbnRleHRcbiAgKTtcbiAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAuLi5wb2x5Z29uT3B0aW9ucyxcbiAgICAuLi5wcm9wcyxcbiAgfTtcblxuICBjb25zdCBtZXRob2RzID0ge1xuICAgIC4uLnBvbHlnb25NZXRob2RzLFxuICAgIHNldEJvdW5kcyhsYXRMbmdCb3VuZHMpIHtcbiAgICAgIGxlYWZsZXRSZWYudmFsdWUuc2V0Qm91bmRzKGxhdExuZ0JvdW5kcyk7XG4gICAgfSxcbiAgICBzZXRMYXRMbmdzKGxhdExuZ3MpIHtcbiAgICAgIC8vIENhbGxpbmcgc2V0TGF0TG5ncyBvbiBhIExlYWZsZXQgcmVjdGFuZ2xlIHdpbGwgY29udmVydCBpdFxuICAgICAgLy8gdG8gYSBwb2x5Z29uLiBTbyBpbnN0ZWFkLCB3ZSBjYWxsIHNldEJvdW5kcyBoZXJlIHRvIGVuc3VyZVxuICAgICAgLy8gdGhhdCB0aGUgcmVjdGFuZ2xlIHJlbWFpbnMgYSByZWN0YW5nbGUsIGRlZmluZWQgYnkgdGhlXG4gICAgICAvLyBib3VuZHMgb2YgdGhlIHBvaW50cyBpbiB0aGUgbGF0TG5ncyBhcnJheS5cbiAgICAgIGxlYWZsZXRSZWYudmFsdWUuc2V0Qm91bmRzKGxhdExuZ3MpO1xuICAgIH0sXG4gIH07XG5cbiAgcmV0dXJuIHsgb3B0aW9ucywgbWV0aG9kcyB9O1xufTtcblxuLyoqXG4gKiBSZWN0YW5nbGUgY29tcG9uZW50LCBsZXRzIHlvdSBhZGQgYW5kIGN1c3RvbWl6ZSByZWN0YW5ndWxhciByZWdpb25zIG9uIHRoZSBtYXBcbiAqL1xudmFyIHNjcmlwdCRpID0ge1xuICBuYW1lOiBcIkxSZWN0YW5nbGVcIixcbiAgcHJvcHM6IHByb3BzJG0sXG4gIHNldHVwKHByb3BzLCBjb250ZXh0KSB7XG4gICAgY29uc3QgbGVhZmxldFJlZiA9IHJlZih7fSk7XG4gICAgY29uc3QgcmVhZHkgPSByZWYoZmFsc2UpO1xuXG4gICAgY29uc3QgdXNlR2xvYmFsTGVhZmxldCA9IGluamVjdChHTE9CQUxfTEVBRkxFVF9PUFQpO1xuICAgIGNvbnN0IGFkZExheWVyID0gaW5qZWN0KFwiYWRkTGF5ZXJcIik7XG5cbiAgICBjb25zdCB7IG9wdGlvbnMsIG1ldGhvZHMgfSA9IHNldHVwJGwocHJvcHMsIGxlYWZsZXRSZWYsIGNvbnRleHQpO1xuXG4gICAgb25Nb3VudGVkKGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHsgcmVjdGFuZ2xlLCBsYXRMbmdCb3VuZHMsIERvbUV2ZW50IH0gPSB1c2VHbG9iYWxMZWFmbGV0XG4gICAgICAgID8gV0lORE9XX09SX0dMT0JBTC5MXG4gICAgICAgIDogYXdhaXQgaW1wb3J0KCdsZWFmbGV0L2Rpc3QvbGVhZmxldC1zcmMuZXNtJyk7XG5cbiAgICAgIGNvbnN0IGJvdW5kcyA9XG4gICAgICAgIHByb3BzLmJvdW5kcyAmJiBwcm9wcy5ib3VuZHMubGVuZ3RoXG4gICAgICAgICAgPyBsYXRMbmdCb3VuZHMocHJvcHMuYm91bmRzKVxuICAgICAgICAgIDogbGF0TG5nQm91bmRzKHByb3BzLmxhdExuZ3MpO1xuICAgICAgbGVhZmxldFJlZi52YWx1ZSA9IHJlY3RhbmdsZShib3VuZHMsIG9wdGlvbnMpO1xuXG4gICAgICBjb25zdCBsaXN0ZW5lcnMgPSByZW1hcEV2ZW50cyhjb250ZXh0LmF0dHJzKTtcbiAgICAgIERvbUV2ZW50Lm9uKGxlYWZsZXRSZWYudmFsdWUsIGxpc3RlbmVycyk7XG5cbiAgICAgIHByb3BzQmluZGVyKG1ldGhvZHMsIGxlYWZsZXRSZWYudmFsdWUsIHByb3BzKTtcblxuICAgICAgYWRkTGF5ZXIoe1xuICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgLi4ubWV0aG9kcyxcbiAgICAgICAgbGVhZmxldE9iamVjdDogbGVhZmxldFJlZi52YWx1ZSxcbiAgICAgIH0pO1xuICAgICAgcmVhZHkudmFsdWUgPSB0cnVlO1xuICAgICAgbmV4dFRpY2soKCkgPT4gY29udGV4dC5lbWl0KFwicmVhZHlcIiwgbGVhZmxldFJlZi52YWx1ZSkpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHsgcmVhZHksIGxlYWZsZXRPYmplY3Q6IGxlYWZsZXRSZWYgfTtcbiAgfSxcbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiByZW5kZXIodGhpcy5yZWFkeSwgdGhpcy4kc2xvdHMpO1xuICB9LFxufTtcblxuc2NyaXB0JGkuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9MUmVjdGFuZ2xlLnZ1ZVwiO1xuXG5jb25zdCBwcm9wcyRuID0ge1xuICAuLi5wcm9wcyRlLFxuICB0bXM6IHtcbiAgICB0eXBlOiBCb29sZWFuLFxuICAgIGRlZmF1bHQ6IGZhbHNlLFxuICB9LFxuICBzdWJkb21haW5zOiB7XG4gICAgdHlwZTogU3RyaW5nLFxuICAgIGRlZmF1bHQ6IFwiYWJjXCIsXG4gIH0sXG4gIGRldGVjdFJldGluYToge1xuICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgZGVmYXVsdDogZmFsc2UsXG4gIH0sXG4gIHVybDoge1xuICAgIHR5cGU6IFN0cmluZyxcbiAgICBkZWZhdWx0OiBudWxsLFxuICB9LFxufTtcblxuY29uc3Qgc2V0dXAkbSA9IChwcm9wcywgbGVhZmxldFJlZikgPT4ge1xuICBjb25zdCB7XG4gICAgb3B0aW9uczogZ3JpZExheWVyT3B0aW9ucyxcbiAgICBtZXRob2RzOiBncmlkTGF5ZXJNZXRob2RzLFxuICB9ID0gc2V0dXAkZShwcm9wcywgbGVhZmxldFJlZik7XG4gIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgLi4uZ3JpZExheWVyT3B0aW9ucyxcbiAgICB0bXM6IHByb3BzLnRtcyxcbiAgICBzdWJkb21haW5zOiBwcm9wcy5zdWJkb21haW5zLFxuICAgIGRldGVjdFJldGluYTogcHJvcHMuZGV0ZWN0UmV0aW5hLFxuICB9O1xuICByZXR1cm4ge1xuICAgIG9wdGlvbnMsXG4gICAgbWV0aG9kczoge1xuICAgICAgLi4uZ3JpZExheWVyTWV0aG9kcyxcbiAgICB9LFxuICB9O1xufTtcblxudmFyIHNjcmlwdCRqID0ge1xuICBwcm9wczogcHJvcHMkbixcbiAgc2V0dXAocHJvcHMsIGNvbnRleHQpIHtcbiAgICBjb25zdCBsZWFmbGV0UmVmID0gcmVmKHt9KTtcblxuICAgIGNvbnN0IHVzZUdsb2JhbExlYWZsZXQgPSBpbmplY3QoR0xPQkFMX0xFQUZMRVRfT1BUKTtcbiAgICBjb25zdCBhZGRMYXllciA9IGluamVjdChcImFkZExheWVyXCIpO1xuXG4gICAgY29uc3QgeyBvcHRpb25zLCBtZXRob2RzIH0gPSBzZXR1cCRtKHByb3BzLCBsZWFmbGV0UmVmKTtcblxuICAgIG9uTW91bnRlZChhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IHRpbGVMYXllciwgRG9tRXZlbnQgfSA9IHVzZUdsb2JhbExlYWZsZXRcbiAgICAgICAgPyBXSU5ET1dfT1JfR0xPQkFMLkxcbiAgICAgICAgOiBhd2FpdCBpbXBvcnQoJ2xlYWZsZXQvZGlzdC9sZWFmbGV0LXNyYy5lc20nKTtcbiAgICAgIGxlYWZsZXRSZWYudmFsdWUgPSB0aWxlTGF5ZXIocHJvcHMudXJsLCBvcHRpb25zKTtcblxuICAgICAgY29uc3QgbGlzdGVuZXJzID0gcmVtYXBFdmVudHMoY29udGV4dC5hdHRycyk7XG4gICAgICBEb21FdmVudC5vbihsZWFmbGV0UmVmLnZhbHVlLCBsaXN0ZW5lcnMpO1xuXG4gICAgICBwcm9wc0JpbmRlcihtZXRob2RzLCBsZWFmbGV0UmVmLnZhbHVlLCBwcm9wcyk7XG4gICAgICBhZGRMYXllcih7XG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICAuLi5tZXRob2RzLFxuICAgICAgICBsZWFmbGV0T2JqZWN0OiBsZWFmbGV0UmVmLnZhbHVlLFxuICAgICAgfSk7XG4gICAgICBuZXh0VGljaygoKSA9PiBjb250ZXh0LmVtaXQoXCJyZWFkeVwiLCBsZWFmbGV0UmVmLnZhbHVlKSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4geyBsZWFmbGV0T2JqZWN0OiBsZWFmbGV0UmVmIH07XG4gIH0sXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcbn07XG5cbnNjcmlwdCRqLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvTFRpbGVMYXllci52dWVcIjtcblxuY29uc3QgcHJvcHMkbyA9IHtcbiAgLi4ucHJvcHMkayxcbn07XG5cbmNvbnN0IHNldHVwJG4gPSAocHJvcHMsIGxlYWZsZXRSZWYpID0+IHtcbiAgY29uc3QgeyBvcHRpb25zLCBtZXRob2RzIH0gPSBzZXR1cCRqKHByb3BzLCBsZWFmbGV0UmVmKTtcbiAgY29uc3QgdW5iaW5kVG9vbHRpcCA9IGluamVjdChcInVuYmluZFRvb2x0aXBcIik7XG5cbiAgb25CZWZvcmVVbm1vdW50KCgpID0+IHtcbiAgICB1bmJpbmRUb29sdGlwKCk7XG4gIH0pO1xuXG4gIHJldHVybiB7IG9wdGlvbnMsIG1ldGhvZHMgfTtcbn07XG5cbi8qKlxuICogRGlzcGxheSBhIHRvb2x0aXAgb24gdGhlIG1hcFxuICovXG52YXIgc2NyaXB0JGsgPSB7XG4gIG5hbWU6IFwiTFRvb2x0aXBcIixcbiAgcHJvcHM6IHByb3BzJG8sXG4gIHNldHVwKHByb3BzLCBjb250ZXh0KSB7XG4gICAgY29uc3QgbGVhZmxldFJlZiA9IHJlZih7fSk7XG4gICAgY29uc3Qgcm9vdCA9IHJlZihudWxsKTtcblxuICAgIGNvbnN0IHVzZUdsb2JhbExlYWZsZXQgPSBpbmplY3QoR0xPQkFMX0xFQUZMRVRfT1BUKTtcbiAgICBjb25zdCBiaW5kVG9vbHRpcCA9IGluamVjdChcImJpbmRUb29sdGlwXCIpO1xuXG4gICAgY29uc3QgeyBvcHRpb25zLCBtZXRob2RzIH0gPSBzZXR1cCRuKHByb3BzLCBsZWFmbGV0UmVmKTtcblxuICAgIG9uTW91bnRlZChhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IHRvb2x0aXAsIERvbUV2ZW50IH0gPSB1c2VHbG9iYWxMZWFmbGV0XG4gICAgICAgID8gV0lORE9XX09SX0dMT0JBTC5MXG4gICAgICAgIDogYXdhaXQgaW1wb3J0KCdsZWFmbGV0L2Rpc3QvbGVhZmxldC1zcmMuZXNtJyk7XG5cbiAgICAgIGxlYWZsZXRSZWYudmFsdWUgPSB0b29sdGlwKG9wdGlvbnMpO1xuXG4gICAgICBwcm9wc0JpbmRlcihtZXRob2RzLCBsZWFmbGV0UmVmLnZhbHVlLCBwcm9wcyk7XG4gICAgICBjb25zdCBsaXN0ZW5lcnMgPSByZW1hcEV2ZW50cyhjb250ZXh0LmF0dHJzKTtcbiAgICAgIERvbUV2ZW50Lm9uKGxlYWZsZXRSZWYudmFsdWUsIGxpc3RlbmVycyk7XG4gICAgICBsZWFmbGV0UmVmLnZhbHVlLnNldENvbnRlbnQocHJvcHMuY29udGVudCB8fCByb290LnZhbHVlKTtcbiAgICAgIGJpbmRUb29sdGlwKHsgbGVhZmxldE9iamVjdDogbGVhZmxldFJlZi52YWx1ZSB9KTtcbiAgICAgIG5leHRUaWNrKCgpID0+IGNvbnRleHQuZW1pdChcInJlYWR5XCIsIGxlYWZsZXRSZWYudmFsdWUpKTtcbiAgICB9KTtcbiAgICByZXR1cm4geyByb290LCBsZWFmbGV0T2JqZWN0OiBsZWFmbGV0UmVmIH07XG4gIH0sXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gcmVuZGVyJDIodGhpcy4kc2xvdHMpO1xuICB9LFxufTtcblxuc2NyaXB0JGsuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9MVG9vbHRpcC52dWVcIjtcblxuY29uc3QgcHJvcHMkcCA9IHtcbiAgLi4ucHJvcHMkbixcbiAgYmFzZVVybDoge1xuICAgIHR5cGU6IFN0cmluZyxcbiAgICBkZWZhdWx0OiBudWxsLFxuICAgIHJlcXVpcmVkOiB0cnVlLFxuICB9LFxuICBsYXllcnM6IHtcbiAgICB0eXBlOiBTdHJpbmcsXG4gICAgZGVmYXVsdDogXCJcIixcbiAgfSxcbiAgc3R5bGVzOiB7XG4gICAgdHlwZTogU3RyaW5nLFxuICAgIGRlZmF1bHQ6IFwiXCIsXG4gIH0sXG4gIGZvcm1hdDoge1xuICAgIHR5cGU6IFN0cmluZyxcbiAgICBkZWZhdWx0OiBcImltYWdlL2pwZWdcIixcbiAgfSxcbiAgdHJhbnNwYXJlbnQ6IHtcbiAgICB0eXBlOiBCb29sZWFuLFxuICAgIGN1c3RvbTogZmFsc2UsXG4gIH0sXG4gIHZlcnNpb246IHtcbiAgICB0eXBlOiBTdHJpbmcsXG4gICAgZGVmYXVsdDogXCIxLjEuMVwiLFxuICB9LFxuICBjcnM6IHtcbiAgICBkZWZhdWx0OiBudWxsLFxuICB9LFxuICB1cHBlckNhc2U6IHtcbiAgICB0eXBlOiBCb29sZWFuLFxuICAgIGRlZmF1bHQ6IGZhbHNlLFxuICB9LFxufTtcblxuY29uc3Qgc2V0dXAkbyA9IChwcm9wcywgbGVhZmxldFJlZikgPT4ge1xuICBjb25zdCB7XG4gICAgb3B0aW9uczogdGlsZUxheWVyT3B0aW9ucyxcbiAgICBtZXRob2RzOiB0aWxlTGF5ZXJNZXRob2RzLFxuICB9ID0gc2V0dXAkbShwcm9wcywgbGVhZmxldFJlZik7XG4gIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgLi4udGlsZUxheWVyT3B0aW9ucyxcbiAgICBsYXllcnM6IHByb3BzLmxheWVycyxcbiAgICBzdHlsZXM6IHByb3BzLnN0eWxlcyxcbiAgICBmb3JtYXQ6IHByb3BzLmZvcm1hdCxcbiAgICB0cmFuc3BhcmVudDogcHJvcHMudHJhbnNwYXJlbnQsXG4gICAgdmVyc2lvbjogcHJvcHMudmVyc2lvbixcbiAgICBjcnM6IHByb3BzLmNycyxcbiAgICB1cHBlckNhc2U6IHByb3BzLnVwcGVyQ2FzZSxcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBvcHRpb25zLFxuICAgIG1ldGhvZHM6IHtcbiAgICAgIC4uLnRpbGVMYXllck1ldGhvZHMsXG4gICAgfSxcbiAgfTtcbn07XG5cbnZhciBzY3JpcHQkbCA9IHtcbiAgcHJvcHM6IHByb3BzJHAsXG4gIHNldHVwKHByb3BzLCBjb250ZXh0KSB7XG4gICAgY29uc3QgbGVhZmxldFJlZiA9IHJlZih7fSk7XG5cbiAgICBjb25zdCB1c2VHbG9iYWxMZWFmbGV0ID0gaW5qZWN0KEdMT0JBTF9MRUFGTEVUX09QVCk7XG4gICAgY29uc3QgYWRkTGF5ZXIgPSBpbmplY3QoXCJhZGRMYXllclwiKTtcblxuICAgIGNvbnN0IHsgb3B0aW9ucywgbWV0aG9kcyB9ID0gc2V0dXAkbyhwcm9wcywgbGVhZmxldFJlZik7XG5cbiAgICBvbk1vdW50ZWQoYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgeyB0aWxlTGF5ZXIsIERvbUV2ZW50IH0gPSB1c2VHbG9iYWxMZWFmbGV0XG4gICAgICAgID8gV0lORE9XX09SX0dMT0JBTC5MXG4gICAgICAgIDogYXdhaXQgaW1wb3J0KCdsZWFmbGV0L2Rpc3QvbGVhZmxldC1zcmMuZXNtJyk7XG5cbiAgICAgIGxlYWZsZXRSZWYudmFsdWUgPSB0aWxlTGF5ZXIud21zKHByb3BzLmJhc2VVcmwsIG9wdGlvbnMpO1xuXG4gICAgICBjb25zdCBsaXN0ZW5lcnMgPSByZW1hcEV2ZW50cyhjb250ZXh0LmF0dHJzKTtcbiAgICAgIERvbUV2ZW50Lm9uKGxlYWZsZXRSZWYudmFsdWUsIGxpc3RlbmVycyk7XG5cbiAgICAgIHByb3BzQmluZGVyKG1ldGhvZHMsIGxlYWZsZXRSZWYudmFsdWUsIHByb3BzKTtcbiAgICAgIGFkZExheWVyKHtcbiAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgIC4uLm1ldGhvZHMsXG4gICAgICAgIGxlYWZsZXRPYmplY3Q6IGxlYWZsZXRSZWYudmFsdWUsXG4gICAgICB9KTtcbiAgICAgIG5leHRUaWNrKCgpID0+IGNvbnRleHQuZW1pdChcInJlYWR5XCIsIGxlYWZsZXRSZWYudmFsdWUpKTtcbiAgICB9KTtcbiAgICByZXR1cm4geyBsZWFmbGV0T2JqZWN0OiBsZWFmbGV0UmVmLnZhbHVlIH07XG4gIH0sXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcbn07XG5cbnNjcmlwdCRsLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvTFdtc1RpbGVMYXllci52dWVcIjtcblxuZXhwb3J0IHsgc2NyaXB0IGFzIExDaXJjbGUsIHNjcmlwdCQxIGFzIExDaXJjbGVNYXJrZXIsIHNjcmlwdCQyIGFzIExDb250cm9sLCBzY3JpcHQkMyBhcyBMQ29udHJvbEF0dHJpYnV0aW9uLCBzY3JpcHQkNCBhcyBMQ29udHJvbExheWVycywgc2NyaXB0JDUgYXMgTENvbnRyb2xTY2FsZSwgc2NyaXB0JDYgYXMgTENvbnRyb2xab29tLCBzY3JpcHQkNyBhcyBMRmVhdHVyZUdyb3VwLCBzY3JpcHQkOCBhcyBMR2VvSnNvbiwgc2NyaXB0JDkgYXMgTEdyaWRMYXllciwgc2NyaXB0JGEgYXMgTEljb24sIHNjcmlwdCRiIGFzIExJbWFnZU92ZXJsYXksIHNjcmlwdCRjIGFzIExMYXllckdyb3VwLCBzY3JpcHQkZCBhcyBMTWFwLCBzY3JpcHQkZSBhcyBMTWFya2VyLCBzY3JpcHQkZiBhcyBMUG9seWdvbiwgc2NyaXB0JGcgYXMgTFBvbHlsaW5lLCBzY3JpcHQkaCBhcyBMUG9wdXAsIHNjcmlwdCRpIGFzIExSZWN0YW5nbGUsIHNjcmlwdCRqIGFzIExUaWxlTGF5ZXIsIHNjcmlwdCRrIGFzIExUb29sdGlwLCBzY3JpcHQkbCBhcyBMV21zVGlsZUxheWVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD12dWUtbGVhZmxldC5lc20uanMubWFwXG4iLCJpbXBvcnQgeyBpc1N0cmluZywgaHlwaGVuYXRlLCBOT09QLCBleHRlbmQsIGlzT2JqZWN0LCBOTywgaXNBcnJheSwgbWFrZU1hcCwgaXNTeW1ib2wsIEVNUFRZX09CSiwgY2FwaXRhbGl6ZSwgY2FtZWxpemUgYXMgY2FtZWxpemUkMSwgUGF0Y2hGbGFnTmFtZXMsIHNsb3RGbGFnc1RleHQsIGlzT24sIGlzQnVpbHRJbkRpcmVjdGl2ZSwgaXNSZXNlcnZlZFByb3AsIHRvSGFuZGxlcktleSB9IGZyb20gJ0B2dWUvc2hhcmVkJztcbmV4cG9ydCB7IGdlbmVyYXRlQ29kZUZyYW1lIH0gZnJvbSAnQHZ1ZS9zaGFyZWQnO1xuXG5mdW5jdGlvbiBkZWZhdWx0T25FcnJvcihlcnJvcikge1xyXG4gICAgdGhyb3cgZXJyb3I7XHJcbn1cclxuZnVuY3Rpb24gZGVmYXVsdE9uV2Fybihtc2cpIHtcclxuICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBjb25zb2xlLndhcm4oYFtWdWUgd2Fybl0gJHttc2cubWVzc2FnZX1gKTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVDb21waWxlckVycm9yKGNvZGUsIGxvYywgbWVzc2FnZXMsIGFkZGl0aW9uYWxNZXNzYWdlKSB7XHJcbiAgICBjb25zdCBtc2cgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgIXRydWVcclxuICAgICAgICA/IChtZXNzYWdlcyB8fCBlcnJvck1lc3NhZ2VzKVtjb2RlXSArIChhZGRpdGlvbmFsTWVzc2FnZSB8fCBgYClcclxuICAgICAgICA6IGNvZGU7XHJcbiAgICBjb25zdCBlcnJvciA9IG5ldyBTeW50YXhFcnJvcihTdHJpbmcobXNnKSk7XHJcbiAgICBlcnJvci5jb2RlID0gY29kZTtcclxuICAgIGVycm9yLmxvYyA9IGxvYztcclxuICAgIHJldHVybiBlcnJvcjtcclxufVxyXG5jb25zdCBlcnJvck1lc3NhZ2VzID0ge1xyXG4gICAgLy8gcGFyc2UgZXJyb3JzXHJcbiAgICBbMCAvKiBBQlJVUFRfQ0xPU0lOR19PRl9FTVBUWV9DT01NRU5UICovXTogJ0lsbGVnYWwgY29tbWVudC4nLFxyXG4gICAgWzEgLyogQ0RBVEFfSU5fSFRNTF9DT05URU5UICovXTogJ0NEQVRBIHNlY3Rpb24gaXMgYWxsb3dlZCBvbmx5IGluIFhNTCBjb250ZXh0LicsXHJcbiAgICBbMiAvKiBEVVBMSUNBVEVfQVRUUklCVVRFICovXTogJ0R1cGxpY2F0ZSBhdHRyaWJ1dGUuJyxcclxuICAgIFszIC8qIEVORF9UQUdfV0lUSF9BVFRSSUJVVEVTICovXTogJ0VuZCB0YWcgY2Fubm90IGhhdmUgYXR0cmlidXRlcy4nLFxyXG4gICAgWzQgLyogRU5EX1RBR19XSVRIX1RSQUlMSU5HX1NPTElEVVMgKi9dOiBcIklsbGVnYWwgJy8nIGluIHRhZ3MuXCIsXHJcbiAgICBbNSAvKiBFT0ZfQkVGT1JFX1RBR19OQU1FICovXTogJ1VuZXhwZWN0ZWQgRU9GIGluIHRhZy4nLFxyXG4gICAgWzYgLyogRU9GX0lOX0NEQVRBICovXTogJ1VuZXhwZWN0ZWQgRU9GIGluIENEQVRBIHNlY3Rpb24uJyxcclxuICAgIFs3IC8qIEVPRl9JTl9DT01NRU5UICovXTogJ1VuZXhwZWN0ZWQgRU9GIGluIGNvbW1lbnQuJyxcclxuICAgIFs4IC8qIEVPRl9JTl9TQ1JJUFRfSFRNTF9DT01NRU5UX0xJS0VfVEVYVCAqL106ICdVbmV4cGVjdGVkIEVPRiBpbiBzY3JpcHQuJyxcclxuICAgIFs5IC8qIEVPRl9JTl9UQUcgKi9dOiAnVW5leHBlY3RlZCBFT0YgaW4gdGFnLicsXHJcbiAgICBbMTAgLyogSU5DT1JSRUNUTFlfQ0xPU0VEX0NPTU1FTlQgKi9dOiAnSW5jb3JyZWN0bHkgY2xvc2VkIGNvbW1lbnQuJyxcclxuICAgIFsxMSAvKiBJTkNPUlJFQ1RMWV9PUEVORURfQ09NTUVOVCAqL106ICdJbmNvcnJlY3RseSBvcGVuZWQgY29tbWVudC4nLFxyXG4gICAgWzEyIC8qIElOVkFMSURfRklSU1RfQ0hBUkFDVEVSX09GX1RBR19OQU1FICovXTogXCJJbGxlZ2FsIHRhZyBuYW1lLiBVc2UgJyZsdDsnIHRvIHByaW50ICc8Jy5cIixcclxuICAgIFsxMyAvKiBNSVNTSU5HX0FUVFJJQlVURV9WQUxVRSAqL106ICdBdHRyaWJ1dGUgdmFsdWUgd2FzIGV4cGVjdGVkLicsXHJcbiAgICBbMTQgLyogTUlTU0lOR19FTkRfVEFHX05BTUUgKi9dOiAnRW5kIHRhZyBuYW1lIHdhcyBleHBlY3RlZC4nLFxyXG4gICAgWzE1IC8qIE1JU1NJTkdfV0hJVEVTUEFDRV9CRVRXRUVOX0FUVFJJQlVURVMgKi9dOiAnV2hpdGVzcGFjZSB3YXMgZXhwZWN0ZWQuJyxcclxuICAgIFsxNiAvKiBORVNURURfQ09NTUVOVCAqL106IFwiVW5leHBlY3RlZCAnPCEtLScgaW4gY29tbWVudC5cIixcclxuICAgIFsxNyAvKiBVTkVYUEVDVEVEX0NIQVJBQ1RFUl9JTl9BVFRSSUJVVEVfTkFNRSAqL106ICdBdHRyaWJ1dGUgbmFtZSBjYW5ub3QgY29udGFpbiBVKzAwMjIgKFwiKSwgVSswMDI3IChcXCcpLCBhbmQgVSswMDNDICg8KS4nLFxyXG4gICAgWzE4IC8qIFVORVhQRUNURURfQ0hBUkFDVEVSX0lOX1VOUVVPVEVEX0FUVFJJQlVURV9WQUxVRSAqL106ICdVbnF1b3RlZCBhdHRyaWJ1dGUgdmFsdWUgY2Fubm90IGNvbnRhaW4gVSswMDIyIChcIiksIFUrMDAyNyAoXFwnKSwgVSswMDNDICg8KSwgVSswMDNEICg9KSwgYW5kIFUrMDA2MCAoYCkuJyxcclxuICAgIFsxOSAvKiBVTkVYUEVDVEVEX0VRVUFMU19TSUdOX0JFRk9SRV9BVFRSSUJVVEVfTkFNRSAqL106IFwiQXR0cmlidXRlIG5hbWUgY2Fubm90IHN0YXJ0IHdpdGggJz0nLlwiLFxyXG4gICAgWzIxIC8qIFVORVhQRUNURURfUVVFU1RJT05fTUFSS19JTlNURUFEX09GX1RBR19OQU1FICovXTogXCInPD8nIGlzIGFsbG93ZWQgb25seSBpbiBYTUwgY29udGV4dC5cIixcclxuICAgIFsyMCAvKiBVTkVYUEVDVEVEX05VTExfQ0hBUkFDVEVSICovXTogYFVuZXhwZWN0ZWQgbnVsbCBjaGFyYWN0ZXIuYCxcclxuICAgIFsyMiAvKiBVTkVYUEVDVEVEX1NPTElEVVNfSU5fVEFHICovXTogXCJJbGxlZ2FsICcvJyBpbiB0YWdzLlwiLFxyXG4gICAgLy8gVnVlLXNwZWNpZmljIHBhcnNlIGVycm9yc1xyXG4gICAgWzIzIC8qIFhfSU5WQUxJRF9FTkRfVEFHICovXTogJ0ludmFsaWQgZW5kIHRhZy4nLFxyXG4gICAgWzI0IC8qIFhfTUlTU0lOR19FTkRfVEFHICovXTogJ0VsZW1lbnQgaXMgbWlzc2luZyBlbmQgdGFnLicsXHJcbiAgICBbMjUgLyogWF9NSVNTSU5HX0lOVEVSUE9MQVRJT05fRU5EICovXTogJ0ludGVycG9sYXRpb24gZW5kIHNpZ24gd2FzIG5vdCBmb3VuZC4nLFxyXG4gICAgWzI3IC8qIFhfTUlTU0lOR19EWU5BTUlDX0RJUkVDVElWRV9BUkdVTUVOVF9FTkQgKi9dOiAnRW5kIGJyYWNrZXQgZm9yIGR5bmFtaWMgZGlyZWN0aXZlIGFyZ3VtZW50IHdhcyBub3QgZm91bmQuICcgK1xyXG4gICAgICAgICdOb3RlIHRoYXQgZHluYW1pYyBkaXJlY3RpdmUgYXJndW1lbnQgY2Fubm90IGNvbnRhaW4gc3BhY2VzLicsXHJcbiAgICBbMjYgLyogWF9NSVNTSU5HX0RJUkVDVElWRV9OQU1FICovXTogJ0xlZ2FsIGRpcmVjdGl2ZSBuYW1lIHdhcyBleHBlY3RlZC4nLFxyXG4gICAgLy8gdHJhbnNmb3JtIGVycm9yc1xyXG4gICAgWzI4IC8qIFhfVl9JRl9OT19FWFBSRVNTSU9OICovXTogYHYtaWYvdi1lbHNlLWlmIGlzIG1pc3NpbmcgZXhwcmVzc2lvbi5gLFxyXG4gICAgWzI5IC8qIFhfVl9JRl9TQU1FX0tFWSAqL106IGB2LWlmL2Vsc2UgYnJhbmNoZXMgbXVzdCB1c2UgdW5pcXVlIGtleXMuYCxcclxuICAgIFszMCAvKiBYX1ZfRUxTRV9OT19BREpBQ0VOVF9JRiAqL106IGB2LWVsc2Uvdi1lbHNlLWlmIGhhcyBubyBhZGphY2VudCB2LWlmIG9yIHYtZWxzZS1pZi5gLFxyXG4gICAgWzMxIC8qIFhfVl9GT1JfTk9fRVhQUkVTU0lPTiAqL106IGB2LWZvciBpcyBtaXNzaW5nIGV4cHJlc3Npb24uYCxcclxuICAgIFszMiAvKiBYX1ZfRk9SX01BTEZPUk1FRF9FWFBSRVNTSU9OICovXTogYHYtZm9yIGhhcyBpbnZhbGlkIGV4cHJlc3Npb24uYCxcclxuICAgIFszMyAvKiBYX1ZfRk9SX1RFTVBMQVRFX0tFWV9QTEFDRU1FTlQgKi9dOiBgPHRlbXBsYXRlIHYtZm9yPiBrZXkgc2hvdWxkIGJlIHBsYWNlZCBvbiB0aGUgPHRlbXBsYXRlPiB0YWcuYCxcclxuICAgIFszNCAvKiBYX1ZfQklORF9OT19FWFBSRVNTSU9OICovXTogYHYtYmluZCBpcyBtaXNzaW5nIGV4cHJlc3Npb24uYCxcclxuICAgIFszNSAvKiBYX1ZfT05fTk9fRVhQUkVTU0lPTiAqL106IGB2LW9uIGlzIG1pc3NpbmcgZXhwcmVzc2lvbi5gLFxyXG4gICAgWzM2IC8qIFhfVl9TTE9UX1VORVhQRUNURURfRElSRUNUSVZFX09OX1NMT1RfT1VUTEVUICovXTogYFVuZXhwZWN0ZWQgY3VzdG9tIGRpcmVjdGl2ZSBvbiA8c2xvdD4gb3V0bGV0LmAsXHJcbiAgICBbMzcgLyogWF9WX1NMT1RfTUlYRURfU0xPVF9VU0FHRSAqL106IGBNaXhlZCB2LXNsb3QgdXNhZ2Ugb24gYm90aCB0aGUgY29tcG9uZW50IGFuZCBuZXN0ZWQgPHRlbXBsYXRlPi5gICtcclxuICAgICAgICBgV2hlbiB0aGVyZSBhcmUgbXVsdGlwbGUgbmFtZWQgc2xvdHMsIGFsbCBzbG90cyBzaG91bGQgdXNlIDx0ZW1wbGF0ZT4gYCArXHJcbiAgICAgICAgYHN5bnRheCB0byBhdm9pZCBzY29wZSBhbWJpZ3VpdHkuYCxcclxuICAgIFszOCAvKiBYX1ZfU0xPVF9EVVBMSUNBVEVfU0xPVF9OQU1FUyAqL106IGBEdXBsaWNhdGUgc2xvdCBuYW1lcyBmb3VuZC4gYCxcclxuICAgIFszOSAvKiBYX1ZfU0xPVF9FWFRSQU5FT1VTX0RFRkFVTFRfU0xPVF9DSElMRFJFTiAqL106IGBFeHRyYW5lb3VzIGNoaWxkcmVuIGZvdW5kIHdoZW4gY29tcG9uZW50IGFscmVhZHkgaGFzIGV4cGxpY2l0bHkgbmFtZWQgYCArXHJcbiAgICAgICAgYGRlZmF1bHQgc2xvdC4gVGhlc2UgY2hpbGRyZW4gd2lsbCBiZSBpZ25vcmVkLmAsXHJcbiAgICBbNDAgLyogWF9WX1NMT1RfTUlTUExBQ0VEICovXTogYHYtc2xvdCBjYW4gb25seSBiZSB1c2VkIG9uIGNvbXBvbmVudHMgb3IgPHRlbXBsYXRlPiB0YWdzLmAsXHJcbiAgICBbNDEgLyogWF9WX01PREVMX05PX0VYUFJFU1NJT04gKi9dOiBgdi1tb2RlbCBpcyBtaXNzaW5nIGV4cHJlc3Npb24uYCxcclxuICAgIFs0MiAvKiBYX1ZfTU9ERUxfTUFMRk9STUVEX0VYUFJFU1NJT04gKi9dOiBgdi1tb2RlbCB2YWx1ZSBtdXN0IGJlIGEgdmFsaWQgSmF2YVNjcmlwdCBtZW1iZXIgZXhwcmVzc2lvbi5gLFxyXG4gICAgWzQzIC8qIFhfVl9NT0RFTF9PTl9TQ09QRV9WQVJJQUJMRSAqL106IGB2LW1vZGVsIGNhbm5vdCBiZSB1c2VkIG9uIHYtZm9yIG9yIHYtc2xvdCBzY29wZSB2YXJpYWJsZXMgYmVjYXVzZSB0aGV5IGFyZSBub3Qgd3JpdGFibGUuYCxcclxuICAgIFs0NCAvKiBYX0lOVkFMSURfRVhQUkVTU0lPTiAqL106IGBFcnJvciBwYXJzaW5nIEphdmFTY3JpcHQgZXhwcmVzc2lvbjogYCxcclxuICAgIFs0NSAvKiBYX0tFRVBfQUxJVkVfSU5WQUxJRF9DSElMRFJFTiAqL106IGA8S2VlcEFsaXZlPiBleHBlY3RzIGV4YWN0bHkgb25lIGNoaWxkIGNvbXBvbmVudC5gLFxyXG4gICAgLy8gZ2VuZXJpYyBlcnJvcnNcclxuICAgIFs0NiAvKiBYX1BSRUZJWF9JRF9OT1RfU1VQUE9SVEVEICovXTogYFwicHJlZml4SWRlbnRpZmllcnNcIiBvcHRpb24gaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJ1aWxkIG9mIGNvbXBpbGVyLmAsXHJcbiAgICBbNDcgLyogWF9NT0RVTEVfTU9ERV9OT1RfU1VQUE9SVEVEICovXTogYEVTIG1vZHVsZSBtb2RlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBidWlsZCBvZiBjb21waWxlci5gLFxyXG4gICAgWzQ4IC8qIFhfQ0FDSEVfSEFORExFUl9OT1RfU1VQUE9SVEVEICovXTogYFwiY2FjaGVIYW5kbGVyc1wiIG9wdGlvbiBpcyBvbmx5IHN1cHBvcnRlZCB3aGVuIHRoZSBcInByZWZpeElkZW50aWZpZXJzXCIgb3B0aW9uIGlzIGVuYWJsZWQuYCxcclxuICAgIFs0OSAvKiBYX1NDT1BFX0lEX05PVF9TVVBQT1JURUQgKi9dOiBgXCJzY29wZUlkXCIgb3B0aW9uIGlzIG9ubHkgc3VwcG9ydGVkIGluIG1vZHVsZSBtb2RlLmAsXHJcbiAgICAvLyBqdXN0IHRvIGZ1bGZpbGwgdHlwZXNcclxuICAgIFs1MCAvKiBfX0VYVEVORF9QT0lOVF9fICovXTogYGBcclxufTtcblxuY29uc3QgRlJBR01FTlQgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYEZyYWdtZW50YCA6IGBgKTtcclxuY29uc3QgVEVMRVBPUlQgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYFRlbGVwb3J0YCA6IGBgKTtcclxuY29uc3QgU1VTUEVOU0UgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYFN1c3BlbnNlYCA6IGBgKTtcclxuY29uc3QgS0VFUF9BTElWRSA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgS2VlcEFsaXZlYCA6IGBgKTtcclxuY29uc3QgQkFTRV9UUkFOU0lUSU9OID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBCYXNlVHJhbnNpdGlvbmAgOiBgYCk7XHJcbmNvbnN0IE9QRU5fQkxPQ0sgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYG9wZW5CbG9ja2AgOiBgYCk7XHJcbmNvbnN0IENSRUFURV9CTE9DSyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgY3JlYXRlQmxvY2tgIDogYGApO1xyXG5jb25zdCBDUkVBVEVfRUxFTUVOVF9CTE9DSyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgY3JlYXRlRWxlbWVudEJsb2NrYCA6IGBgKTtcclxuY29uc3QgQ1JFQVRFX1ZOT0RFID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBjcmVhdGVWTm9kZWAgOiBgYCk7XHJcbmNvbnN0IENSRUFURV9FTEVNRU5UX1ZOT0RFID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBjcmVhdGVFbGVtZW50Vk5vZGVgIDogYGApO1xyXG5jb25zdCBDUkVBVEVfQ09NTUVOVCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgY3JlYXRlQ29tbWVudFZOb2RlYCA6IGBgKTtcclxuY29uc3QgQ1JFQVRFX1RFWFQgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYGNyZWF0ZVRleHRWTm9kZWAgOiBgYCk7XHJcbmNvbnN0IENSRUFURV9TVEFUSUMgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYGNyZWF0ZVN0YXRpY1ZOb2RlYCA6IGBgKTtcclxuY29uc3QgUkVTT0xWRV9DT01QT05FTlQgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHJlc29sdmVDb21wb25lbnRgIDogYGApO1xyXG5jb25zdCBSRVNPTFZFX0RZTkFNSUNfQ09NUE9ORU5UID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGByZXNvbHZlRHluYW1pY0NvbXBvbmVudGAgOiBgYCk7XHJcbmNvbnN0IFJFU09MVkVfRElSRUNUSVZFID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGByZXNvbHZlRGlyZWN0aXZlYCA6IGBgKTtcclxuY29uc3QgUkVTT0xWRV9GSUxURVIgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHJlc29sdmVGaWx0ZXJgIDogYGApO1xyXG5jb25zdCBXSVRIX0RJUkVDVElWRVMgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHdpdGhEaXJlY3RpdmVzYCA6IGBgKTtcclxuY29uc3QgUkVOREVSX0xJU1QgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHJlbmRlckxpc3RgIDogYGApO1xyXG5jb25zdCBSRU5ERVJfU0xPVCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgcmVuZGVyU2xvdGAgOiBgYCk7XHJcbmNvbnN0IENSRUFURV9TTE9UUyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgY3JlYXRlU2xvdHNgIDogYGApO1xyXG5jb25zdCBUT19ESVNQTEFZX1NUUklORyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgdG9EaXNwbGF5U3RyaW5nYCA6IGBgKTtcclxuY29uc3QgTUVSR0VfUFJPUFMgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYG1lcmdlUHJvcHNgIDogYGApO1xyXG5jb25zdCBOT1JNQUxJWkVfQ0xBU1MgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYG5vcm1hbGl6ZUNsYXNzYCA6IGBgKTtcclxuY29uc3QgTk9STUFMSVpFX1NUWUxFID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBub3JtYWxpemVTdHlsZWAgOiBgYCk7XHJcbmNvbnN0IE5PUk1BTElaRV9QUk9QUyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgbm9ybWFsaXplUHJvcHNgIDogYGApO1xyXG5jb25zdCBHVUFSRF9SRUFDVElWRV9QUk9QUyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgZ3VhcmRSZWFjdGl2ZVByb3BzYCA6IGBgKTtcclxuY29uc3QgVE9fSEFORExFUlMgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHRvSGFuZGxlcnNgIDogYGApO1xyXG5jb25zdCBDQU1FTElaRSA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgY2FtZWxpemVgIDogYGApO1xyXG5jb25zdCBDQVBJVEFMSVpFID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBjYXBpdGFsaXplYCA6IGBgKTtcclxuY29uc3QgVE9fSEFORExFUl9LRVkgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHRvSGFuZGxlcktleWAgOiBgYCk7XHJcbmNvbnN0IFNFVF9CTE9DS19UUkFDS0lORyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgc2V0QmxvY2tUcmFja2luZ2AgOiBgYCk7XHJcbmNvbnN0IFBVU0hfU0NPUEVfSUQgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHB1c2hTY29wZUlkYCA6IGBgKTtcclxuY29uc3QgUE9QX1NDT1BFX0lEID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBwb3BTY29wZUlkYCA6IGBgKTtcclxuY29uc3QgV0lUSF9DVFggPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHdpdGhDdHhgIDogYGApO1xyXG5jb25zdCBVTlJFRiA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgdW5yZWZgIDogYGApO1xyXG5jb25zdCBJU19SRUYgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYGlzUmVmYCA6IGBgKTtcclxuY29uc3QgV0lUSF9NRU1PID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGB3aXRoTWVtb2AgOiBgYCk7XHJcbmNvbnN0IElTX01FTU9fU0FNRSA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgaXNNZW1vU2FtZWAgOiBgYCk7XHJcbi8vIE5hbWUgbWFwcGluZyBmb3IgcnVudGltZSBoZWxwZXJzIHRoYXQgbmVlZCB0byBiZSBpbXBvcnRlZCBmcm9tICd2dWUnIGluXHJcbi8vIGdlbmVyYXRlZCBjb2RlLiBNYWtlIHN1cmUgdGhlc2UgYXJlIGNvcnJlY3RseSBleHBvcnRlZCBpbiB0aGUgcnVudGltZSFcclxuLy8gVXNpbmcgYGFueWAgaGVyZSBiZWNhdXNlIFRTIGRvZXNuJ3QgYWxsb3cgc3ltYm9scyBhcyBpbmRleCB0eXBlLlxyXG5jb25zdCBoZWxwZXJOYW1lTWFwID0ge1xyXG4gICAgW0ZSQUdNRU5UXTogYEZyYWdtZW50YCxcclxuICAgIFtURUxFUE9SVF06IGBUZWxlcG9ydGAsXHJcbiAgICBbU1VTUEVOU0VdOiBgU3VzcGVuc2VgLFxyXG4gICAgW0tFRVBfQUxJVkVdOiBgS2VlcEFsaXZlYCxcclxuICAgIFtCQVNFX1RSQU5TSVRJT05dOiBgQmFzZVRyYW5zaXRpb25gLFxyXG4gICAgW09QRU5fQkxPQ0tdOiBgb3BlbkJsb2NrYCxcclxuICAgIFtDUkVBVEVfQkxPQ0tdOiBgY3JlYXRlQmxvY2tgLFxyXG4gICAgW0NSRUFURV9FTEVNRU5UX0JMT0NLXTogYGNyZWF0ZUVsZW1lbnRCbG9ja2AsXHJcbiAgICBbQ1JFQVRFX1ZOT0RFXTogYGNyZWF0ZVZOb2RlYCxcclxuICAgIFtDUkVBVEVfRUxFTUVOVF9WTk9ERV06IGBjcmVhdGVFbGVtZW50Vk5vZGVgLFxyXG4gICAgW0NSRUFURV9DT01NRU5UXTogYGNyZWF0ZUNvbW1lbnRWTm9kZWAsXHJcbiAgICBbQ1JFQVRFX1RFWFRdOiBgY3JlYXRlVGV4dFZOb2RlYCxcclxuICAgIFtDUkVBVEVfU1RBVElDXTogYGNyZWF0ZVN0YXRpY1ZOb2RlYCxcclxuICAgIFtSRVNPTFZFX0NPTVBPTkVOVF06IGByZXNvbHZlQ29tcG9uZW50YCxcclxuICAgIFtSRVNPTFZFX0RZTkFNSUNfQ09NUE9ORU5UXTogYHJlc29sdmVEeW5hbWljQ29tcG9uZW50YCxcclxuICAgIFtSRVNPTFZFX0RJUkVDVElWRV06IGByZXNvbHZlRGlyZWN0aXZlYCxcclxuICAgIFtSRVNPTFZFX0ZJTFRFUl06IGByZXNvbHZlRmlsdGVyYCxcclxuICAgIFtXSVRIX0RJUkVDVElWRVNdOiBgd2l0aERpcmVjdGl2ZXNgLFxyXG4gICAgW1JFTkRFUl9MSVNUXTogYHJlbmRlckxpc3RgLFxyXG4gICAgW1JFTkRFUl9TTE9UXTogYHJlbmRlclNsb3RgLFxyXG4gICAgW0NSRUFURV9TTE9UU106IGBjcmVhdGVTbG90c2AsXHJcbiAgICBbVE9fRElTUExBWV9TVFJJTkddOiBgdG9EaXNwbGF5U3RyaW5nYCxcclxuICAgIFtNRVJHRV9QUk9QU106IGBtZXJnZVByb3BzYCxcclxuICAgIFtOT1JNQUxJWkVfQ0xBU1NdOiBgbm9ybWFsaXplQ2xhc3NgLFxyXG4gICAgW05PUk1BTElaRV9TVFlMRV06IGBub3JtYWxpemVTdHlsZWAsXHJcbiAgICBbTk9STUFMSVpFX1BST1BTXTogYG5vcm1hbGl6ZVByb3BzYCxcclxuICAgIFtHVUFSRF9SRUFDVElWRV9QUk9QU106IGBndWFyZFJlYWN0aXZlUHJvcHNgLFxyXG4gICAgW1RPX0hBTkRMRVJTXTogYHRvSGFuZGxlcnNgLFxyXG4gICAgW0NBTUVMSVpFXTogYGNhbWVsaXplYCxcclxuICAgIFtDQVBJVEFMSVpFXTogYGNhcGl0YWxpemVgLFxyXG4gICAgW1RPX0hBTkRMRVJfS0VZXTogYHRvSGFuZGxlcktleWAsXHJcbiAgICBbU0VUX0JMT0NLX1RSQUNLSU5HXTogYHNldEJsb2NrVHJhY2tpbmdgLFxyXG4gICAgW1BVU0hfU0NPUEVfSURdOiBgcHVzaFNjb3BlSWRgLFxyXG4gICAgW1BPUF9TQ09QRV9JRF06IGBwb3BTY29wZUlkYCxcclxuICAgIFtXSVRIX0NUWF06IGB3aXRoQ3R4YCxcclxuICAgIFtVTlJFRl06IGB1bnJlZmAsXHJcbiAgICBbSVNfUkVGXTogYGlzUmVmYCxcclxuICAgIFtXSVRIX01FTU9dOiBgd2l0aE1lbW9gLFxyXG4gICAgW0lTX01FTU9fU0FNRV06IGBpc01lbW9TYW1lYFxyXG59O1xyXG5mdW5jdGlvbiByZWdpc3RlclJ1bnRpbWVIZWxwZXJzKGhlbHBlcnMpIHtcclxuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaGVscGVycykuZm9yRWFjaChzID0+IHtcclxuICAgICAgICBoZWxwZXJOYW1lTWFwW3NdID0gaGVscGVyc1tzXTtcclxuICAgIH0pO1xyXG59XG5cbi8vIEFTVCBVdGlsaXRpZXMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vIFNvbWUgZXhwcmVzc2lvbnMsIGUuZy4gc2VxdWVuY2UgYW5kIGNvbmRpdGlvbmFsIGV4cHJlc3Npb25zLCBhcmUgbmV2ZXJcclxuLy8gYXNzb2NpYXRlZCB3aXRoIHRlbXBsYXRlIG5vZGVzLCBzbyB0aGVpciBzb3VyY2UgbG9jYXRpb25zIGFyZSBqdXN0IGEgc3R1Yi5cclxuLy8gQ29udGFpbmVyIHR5cGVzIGxpa2UgQ29tcG91bmRFeHByZXNzaW9uIGFsc28gZG9uJ3QgbmVlZCBhIHJlYWwgbG9jYXRpb24uXHJcbmNvbnN0IGxvY1N0dWIgPSB7XHJcbiAgICBzb3VyY2U6ICcnLFxyXG4gICAgc3RhcnQ6IHsgbGluZTogMSwgY29sdW1uOiAxLCBvZmZzZXQ6IDAgfSxcclxuICAgIGVuZDogeyBsaW5lOiAxLCBjb2x1bW46IDEsIG9mZnNldDogMCB9XHJcbn07XHJcbmZ1bmN0aW9uIGNyZWF0ZVJvb3QoY2hpbGRyZW4sIGxvYyA9IGxvY1N0dWIpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogMCAvKiBST09UICovLFxyXG4gICAgICAgIGNoaWxkcmVuLFxyXG4gICAgICAgIGhlbHBlcnM6IFtdLFxyXG4gICAgICAgIGNvbXBvbmVudHM6IFtdLFxyXG4gICAgICAgIGRpcmVjdGl2ZXM6IFtdLFxyXG4gICAgICAgIGhvaXN0czogW10sXHJcbiAgICAgICAgaW1wb3J0czogW10sXHJcbiAgICAgICAgY2FjaGVkOiAwLFxyXG4gICAgICAgIHRlbXBzOiAwLFxyXG4gICAgICAgIGNvZGVnZW5Ob2RlOiB1bmRlZmluZWQsXHJcbiAgICAgICAgbG9jXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVZOb2RlQ2FsbChjb250ZXh0LCB0YWcsIHByb3BzLCBjaGlsZHJlbiwgcGF0Y2hGbGFnLCBkeW5hbWljUHJvcHMsIGRpcmVjdGl2ZXMsIGlzQmxvY2sgPSBmYWxzZSwgZGlzYWJsZVRyYWNraW5nID0gZmFsc2UsIGlzQ29tcG9uZW50ID0gZmFsc2UsIGxvYyA9IGxvY1N0dWIpIHtcclxuICAgIGlmIChjb250ZXh0KSB7XHJcbiAgICAgICAgaWYgKGlzQmxvY2spIHtcclxuICAgICAgICAgICAgY29udGV4dC5oZWxwZXIoT1BFTl9CTE9DSyk7XHJcbiAgICAgICAgICAgIGNvbnRleHQuaGVscGVyKGdldFZOb2RlQmxvY2tIZWxwZXIoY29udGV4dC5pblNTUiwgaXNDb21wb25lbnQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQuaGVscGVyKGdldFZOb2RlSGVscGVyKGNvbnRleHQuaW5TU1IsIGlzQ29tcG9uZW50KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkaXJlY3RpdmVzKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQuaGVscGVyKFdJVEhfRElSRUNUSVZFUyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAxMyAvKiBWTk9ERV9DQUxMICovLFxyXG4gICAgICAgIHRhZyxcclxuICAgICAgICBwcm9wcyxcclxuICAgICAgICBjaGlsZHJlbixcclxuICAgICAgICBwYXRjaEZsYWcsXHJcbiAgICAgICAgZHluYW1pY1Byb3BzLFxyXG4gICAgICAgIGRpcmVjdGl2ZXMsXHJcbiAgICAgICAgaXNCbG9jayxcclxuICAgICAgICBkaXNhYmxlVHJhY2tpbmcsXHJcbiAgICAgICAgaXNDb21wb25lbnQsXHJcbiAgICAgICAgbG9jXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUFycmF5RXhwcmVzc2lvbihlbGVtZW50cywgbG9jID0gbG9jU3R1Yikge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAxNyAvKiBKU19BUlJBWV9FWFBSRVNTSU9OICovLFxyXG4gICAgICAgIGxvYyxcclxuICAgICAgICBlbGVtZW50c1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVPYmplY3RFeHByZXNzaW9uKHByb3BlcnRpZXMsIGxvYyA9IGxvY1N0dWIpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogMTUgLyogSlNfT0JKRUNUX0VYUFJFU1NJT04gKi8sXHJcbiAgICAgICAgbG9jLFxyXG4gICAgICAgIHByb3BlcnRpZXNcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlT2JqZWN0UHJvcGVydHkoa2V5LCB2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAxNiAvKiBKU19QUk9QRVJUWSAqLyxcclxuICAgICAgICBsb2M6IGxvY1N0dWIsXHJcbiAgICAgICAga2V5OiBpc1N0cmluZyhrZXkpID8gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihrZXksIHRydWUpIDoga2V5LFxyXG4gICAgICAgIHZhbHVlXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oY29udGVudCwgaXNTdGF0aWMgPSBmYWxzZSwgbG9jID0gbG9jU3R1YiwgY29uc3RUeXBlID0gMCAvKiBOT1RfQ09OU1RBTlQgKi8pIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLyxcclxuICAgICAgICBsb2MsXHJcbiAgICAgICAgY29udGVudCxcclxuICAgICAgICBpc1N0YXRpYyxcclxuICAgICAgICBjb25zdFR5cGU6IGlzU3RhdGljID8gMyAvKiBDQU5fU1RSSU5HSUZZICovIDogY29uc3RUeXBlXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUludGVycG9sYXRpb24oY29udGVudCwgbG9jKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDUgLyogSU5URVJQT0xBVElPTiAqLyxcclxuICAgICAgICBsb2MsXHJcbiAgICAgICAgY29udGVudDogaXNTdHJpbmcoY29udGVudClcclxuICAgICAgICAgICAgPyBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGNvbnRlbnQsIGZhbHNlLCBsb2MpXHJcbiAgICAgICAgICAgIDogY29udGVudFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVDb21wb3VuZEV4cHJlc3Npb24oY2hpbGRyZW4sIGxvYyA9IGxvY1N0dWIpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogOCAvKiBDT01QT1VORF9FWFBSRVNTSU9OICovLFxyXG4gICAgICAgIGxvYyxcclxuICAgICAgICBjaGlsZHJlblxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVDYWxsRXhwcmVzc2lvbihjYWxsZWUsIGFyZ3MgPSBbXSwgbG9jID0gbG9jU3R1Yikge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAxNCAvKiBKU19DQUxMX0VYUFJFU1NJT04gKi8sXHJcbiAgICAgICAgbG9jLFxyXG4gICAgICAgIGNhbGxlZSxcclxuICAgICAgICBhcmd1bWVudHM6IGFyZ3NcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25FeHByZXNzaW9uKHBhcmFtcywgcmV0dXJucyA9IHVuZGVmaW5lZCwgbmV3bGluZSA9IGZhbHNlLCBpc1Nsb3QgPSBmYWxzZSwgbG9jID0gbG9jU3R1Yikge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAxOCAvKiBKU19GVU5DVElPTl9FWFBSRVNTSU9OICovLFxyXG4gICAgICAgIHBhcmFtcyxcclxuICAgICAgICByZXR1cm5zLFxyXG4gICAgICAgIG5ld2xpbmUsXHJcbiAgICAgICAgaXNTbG90LFxyXG4gICAgICAgIGxvY1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVDb25kaXRpb25hbEV4cHJlc3Npb24odGVzdCwgY29uc2VxdWVudCwgYWx0ZXJuYXRlLCBuZXdsaW5lID0gdHJ1ZSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAxOSAvKiBKU19DT05ESVRJT05BTF9FWFBSRVNTSU9OICovLFxyXG4gICAgICAgIHRlc3QsXHJcbiAgICAgICAgY29uc2VxdWVudCxcclxuICAgICAgICBhbHRlcm5hdGUsXHJcbiAgICAgICAgbmV3bGluZSxcclxuICAgICAgICBsb2M6IGxvY1N0dWJcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlQ2FjaGVFeHByZXNzaW9uKGluZGV4LCB2YWx1ZSwgaXNWTm9kZSA9IGZhbHNlKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDIwIC8qIEpTX0NBQ0hFX0VYUFJFU1NJT04gKi8sXHJcbiAgICAgICAgaW5kZXgsXHJcbiAgICAgICAgdmFsdWUsXHJcbiAgICAgICAgaXNWTm9kZSxcclxuICAgICAgICBsb2M6IGxvY1N0dWJcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlQmxvY2tTdGF0ZW1lbnQoYm9keSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAyMSAvKiBKU19CTE9DS19TVEFURU1FTlQgKi8sXHJcbiAgICAgICAgYm9keSxcclxuICAgICAgICBsb2M6IGxvY1N0dWJcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlVGVtcGxhdGVMaXRlcmFsKGVsZW1lbnRzKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDIyIC8qIEpTX1RFTVBMQVRFX0xJVEVSQUwgKi8sXHJcbiAgICAgICAgZWxlbWVudHMsXHJcbiAgICAgICAgbG9jOiBsb2NTdHViXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUlmU3RhdGVtZW50KHRlc3QsIGNvbnNlcXVlbnQsIGFsdGVybmF0ZSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAyMyAvKiBKU19JRl9TVEFURU1FTlQgKi8sXHJcbiAgICAgICAgdGVzdCxcclxuICAgICAgICBjb25zZXF1ZW50LFxyXG4gICAgICAgIGFsdGVybmF0ZSxcclxuICAgICAgICBsb2M6IGxvY1N0dWJcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlQXNzaWdubWVudEV4cHJlc3Npb24obGVmdCwgcmlnaHQpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogMjQgLyogSlNfQVNTSUdOTUVOVF9FWFBSRVNTSU9OICovLFxyXG4gICAgICAgIGxlZnQsXHJcbiAgICAgICAgcmlnaHQsXHJcbiAgICAgICAgbG9jOiBsb2NTdHViXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVNlcXVlbmNlRXhwcmVzc2lvbihleHByZXNzaW9ucykge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAyNSAvKiBKU19TRVFVRU5DRV9FWFBSRVNTSU9OICovLFxyXG4gICAgICAgIGV4cHJlc3Npb25zLFxyXG4gICAgICAgIGxvYzogbG9jU3R1YlxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVSZXR1cm5TdGF0ZW1lbnQocmV0dXJucykge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAyNiAvKiBKU19SRVRVUk5fU1RBVEVNRU5UICovLFxyXG4gICAgICAgIHJldHVybnMsXHJcbiAgICAgICAgbG9jOiBsb2NTdHViXHJcbiAgICB9O1xyXG59XG5cbmNvbnN0IGlzU3RhdGljRXhwID0gKHApID0+IHAudHlwZSA9PT0gNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLyAmJiBwLmlzU3RhdGljO1xyXG5jb25zdCBpc0J1aWx0SW5UeXBlID0gKHRhZywgZXhwZWN0ZWQpID0+IHRhZyA9PT0gZXhwZWN0ZWQgfHwgdGFnID09PSBoeXBoZW5hdGUoZXhwZWN0ZWQpO1xyXG5mdW5jdGlvbiBpc0NvcmVDb21wb25lbnQodGFnKSB7XHJcbiAgICBpZiAoaXNCdWlsdEluVHlwZSh0YWcsICdUZWxlcG9ydCcpKSB7XHJcbiAgICAgICAgcmV0dXJuIFRFTEVQT1JUO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNCdWlsdEluVHlwZSh0YWcsICdTdXNwZW5zZScpKSB7XHJcbiAgICAgICAgcmV0dXJuIFNVU1BFTlNFO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNCdWlsdEluVHlwZSh0YWcsICdLZWVwQWxpdmUnKSkge1xyXG4gICAgICAgIHJldHVybiBLRUVQX0FMSVZFO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNCdWlsdEluVHlwZSh0YWcsICdCYXNlVHJhbnNpdGlvbicpKSB7XHJcbiAgICAgICAgcmV0dXJuIEJBU0VfVFJBTlNJVElPTjtcclxuICAgIH1cclxufVxyXG5jb25zdCBub25JZGVudGlmaWVyUkUgPSAvXlxcZHxbXlxcJFxcd10vO1xyXG5jb25zdCBpc1NpbXBsZUlkZW50aWZpZXIgPSAobmFtZSkgPT4gIW5vbklkZW50aWZpZXJSRS50ZXN0KG5hbWUpO1xyXG5jb25zdCB2YWxpZEZpcnN0SWRlbnRDaGFyUkUgPSAvW0EtWmEtel8kXFx4QTAtXFx1RkZGRl0vO1xyXG5jb25zdCB2YWxpZElkZW50Q2hhclJFID0gL1tcXC5cXD9cXHckXFx4QTAtXFx1RkZGRl0vO1xyXG5jb25zdCB3aGl0ZXNwYWNlUkUgPSAvXFxzK1suW11cXHMqfFxccypbLltdXFxzKy9nO1xyXG4vKipcclxuICogU2ltcGxlIGxleGVyIHRvIGNoZWNrIGlmIGFuIGV4cHJlc3Npb24gaXMgYSBtZW1iZXIgZXhwcmVzc2lvbi4gVGhpcyBpc1xyXG4gKiBsYXggYW5kIG9ubHkgY2hlY2tzIHZhbGlkaXR5IGF0IHRoZSByb290IGxldmVsIChpLmUuIGRvZXMgbm90IHZhbGlkYXRlIGV4cHNcclxuICogaW5zaWRlIHNxdWFyZSBicmFja2V0cyksIGJ1dCBpdCdzIG9rIHNpbmNlIHRoZXNlIGFyZSBvbmx5IHVzZWQgb24gdGVtcGxhdGVcclxuICogZXhwcmVzc2lvbnMgYW5kIGZhbHNlIHBvc2l0aXZlcyBhcmUgaW52YWxpZCBleHByZXNzaW9ucyBpbiB0aGUgZmlyc3QgcGxhY2UuXHJcbiAqL1xyXG5jb25zdCBpc01lbWJlckV4cHJlc3Npb25Ccm93c2VyID0gKHBhdGgpID0+IHtcclxuICAgIC8vIHJlbW92ZSB3aGl0ZXNwYWNlcyBhcm91bmQgLiBvciBbIGZpcnN0XHJcbiAgICBwYXRoID0gcGF0aC50cmltKCkucmVwbGFjZSh3aGl0ZXNwYWNlUkUsIHMgPT4gcy50cmltKCkpO1xyXG4gICAgbGV0IHN0YXRlID0gMCAvKiBpbk1lbWJlckV4cCAqLztcclxuICAgIGxldCBzdGF0ZVN0YWNrID0gW107XHJcbiAgICBsZXQgY3VycmVudE9wZW5CcmFja2V0Q291bnQgPSAwO1xyXG4gICAgbGV0IGN1cnJlbnRPcGVuUGFyZW5zQ291bnQgPSAwO1xyXG4gICAgbGV0IGN1cnJlbnRTdHJpbmdUeXBlID0gbnVsbDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGNoYXIgPSBwYXRoLmNoYXJBdChpKTtcclxuICAgICAgICBzd2l0Y2ggKHN0YXRlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMCAvKiBpbk1lbWJlckV4cCAqLzpcclxuICAgICAgICAgICAgICAgIGlmIChjaGFyID09PSAnWycpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZVN0YWNrLnB1c2goc3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gMSAvKiBpbkJyYWNrZXRzICovO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRPcGVuQnJhY2tldENvdW50Kys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGFyID09PSAnKCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZVN0YWNrLnB1c2goc3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gMiAvKiBpblBhcmVucyAqLztcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50T3BlblBhcmVuc0NvdW50Kys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghKGkgPT09IDAgPyB2YWxpZEZpcnN0SWRlbnRDaGFyUkUgOiB2YWxpZElkZW50Q2hhclJFKS50ZXN0KGNoYXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMSAvKiBpbkJyYWNrZXRzICovOlxyXG4gICAgICAgICAgICAgICAgaWYgKGNoYXIgPT09IGAnYCB8fCBjaGFyID09PSBgXCJgIHx8IGNoYXIgPT09ICdgJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlU3RhY2sucHVzaChzdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAzIC8qIGluU3RyaW5nICovO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdHJpbmdUeXBlID0gY2hhcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoYXIgPT09IGBbYCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRPcGVuQnJhY2tldENvdW50Kys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGFyID09PSBgXWApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIS0tY3VycmVudE9wZW5CcmFja2V0Q291bnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBzdGF0ZVN0YWNrLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDIgLyogaW5QYXJlbnMgKi86XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhciA9PT0gYCdgIHx8IGNoYXIgPT09IGBcImAgfHwgY2hhciA9PT0gJ2AnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVTdGFjay5wdXNoKHN0YXRlKTtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IDMgLyogaW5TdHJpbmcgKi87XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0cmluZ1R5cGUgPSBjaGFyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hhciA9PT0gYChgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE9wZW5QYXJlbnNDb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hhciA9PT0gYClgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGV4cCBlbmRzIGFzIGEgY2FsbCB0aGVuIGl0IHNob3VsZCBub3QgYmUgY29uc2lkZXJlZCB2YWxpZFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSBwYXRoLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIS0tY3VycmVudE9wZW5QYXJlbnNDb3VudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IHN0YXRlU3RhY2sucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMyAvKiBpblN0cmluZyAqLzpcclxuICAgICAgICAgICAgICAgIGlmIChjaGFyID09PSBjdXJyZW50U3RyaW5nVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gc3RhdGVTdGFjay5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3RyaW5nVHlwZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gIWN1cnJlbnRPcGVuQnJhY2tldENvdW50ICYmICFjdXJyZW50T3BlblBhcmVuc0NvdW50O1xyXG59O1xyXG5jb25zdCBpc01lbWJlckV4cHJlc3Npb25Ob2RlID0gTk9PUFxyXG4gICAgO1xyXG5jb25zdCBpc01lbWJlckV4cHJlc3Npb24gPSBpc01lbWJlckV4cHJlc3Npb25Ccm93c2VyXHJcbiAgICA7XHJcbmZ1bmN0aW9uIGdldElubmVyUmFuZ2UobG9jLCBvZmZzZXQsIGxlbmd0aCkge1xyXG4gICAgY29uc3Qgc291cmNlID0gbG9jLnNvdXJjZS5zbGljZShvZmZzZXQsIG9mZnNldCArIGxlbmd0aCk7XHJcbiAgICBjb25zdCBuZXdMb2MgPSB7XHJcbiAgICAgICAgc291cmNlLFxyXG4gICAgICAgIHN0YXJ0OiBhZHZhbmNlUG9zaXRpb25XaXRoQ2xvbmUobG9jLnN0YXJ0LCBsb2Muc291cmNlLCBvZmZzZXQpLFxyXG4gICAgICAgIGVuZDogbG9jLmVuZFxyXG4gICAgfTtcclxuICAgIGlmIChsZW5ndGggIT0gbnVsbCkge1xyXG4gICAgICAgIG5ld0xvYy5lbmQgPSBhZHZhbmNlUG9zaXRpb25XaXRoQ2xvbmUobG9jLnN0YXJ0LCBsb2Muc291cmNlLCBvZmZzZXQgKyBsZW5ndGgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ld0xvYztcclxufVxyXG5mdW5jdGlvbiBhZHZhbmNlUG9zaXRpb25XaXRoQ2xvbmUocG9zLCBzb3VyY2UsIG51bWJlck9mQ2hhcmFjdGVycyA9IHNvdXJjZS5sZW5ndGgpIHtcclxuICAgIHJldHVybiBhZHZhbmNlUG9zaXRpb25XaXRoTXV0YXRpb24oZXh0ZW5kKHt9LCBwb3MpLCBzb3VyY2UsIG51bWJlck9mQ2hhcmFjdGVycyk7XHJcbn1cclxuLy8gYWR2YW5jZSBieSBtdXRhdGlvbiB3aXRob3V0IGNsb25pbmcgKGZvciBwZXJmb3JtYW5jZSByZWFzb25zKSwgc2luY2UgdGhpc1xyXG4vLyBnZXRzIGNhbGxlZCBhIGxvdCBpbiB0aGUgcGFyc2VyXHJcbmZ1bmN0aW9uIGFkdmFuY2VQb3NpdGlvbldpdGhNdXRhdGlvbihwb3MsIHNvdXJjZSwgbnVtYmVyT2ZDaGFyYWN0ZXJzID0gc291cmNlLmxlbmd0aCkge1xyXG4gICAgbGV0IGxpbmVzQ291bnQgPSAwO1xyXG4gICAgbGV0IGxhc3ROZXdMaW5lUG9zID0gLTE7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck9mQ2hhcmFjdGVyczsgaSsrKSB7XHJcbiAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KGkpID09PSAxMCAvKiBuZXdsaW5lIGNoYXIgY29kZSAqLykge1xyXG4gICAgICAgICAgICBsaW5lc0NvdW50Kys7XHJcbiAgICAgICAgICAgIGxhc3ROZXdMaW5lUG9zID0gaTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBwb3Mub2Zmc2V0ICs9IG51bWJlck9mQ2hhcmFjdGVycztcclxuICAgIHBvcy5saW5lICs9IGxpbmVzQ291bnQ7XHJcbiAgICBwb3MuY29sdW1uID1cclxuICAgICAgICBsYXN0TmV3TGluZVBvcyA9PT0gLTFcclxuICAgICAgICAgICAgPyBwb3MuY29sdW1uICsgbnVtYmVyT2ZDaGFyYWN0ZXJzXHJcbiAgICAgICAgICAgIDogbnVtYmVyT2ZDaGFyYWN0ZXJzIC0gbGFzdE5ld0xpbmVQb3M7XHJcbiAgICByZXR1cm4gcG9zO1xyXG59XHJcbmZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG1zZykge1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAoIWNvbmRpdGlvbikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cgfHwgYHVuZXhwZWN0ZWQgY29tcGlsZXIgY29uZGl0aW9uYCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZmluZERpcihub2RlLCBuYW1lLCBhbGxvd0VtcHR5ID0gZmFsc2UpIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5wcm9wcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHAgPSBub2RlLnByb3BzW2ldO1xyXG4gICAgICAgIGlmIChwLnR5cGUgPT09IDcgLyogRElSRUNUSVZFICovICYmXHJcbiAgICAgICAgICAgIChhbGxvd0VtcHR5IHx8IHAuZXhwKSAmJlxyXG4gICAgICAgICAgICAoaXNTdHJpbmcobmFtZSkgPyBwLm5hbWUgPT09IG5hbWUgOiBuYW1lLnRlc3QocC5uYW1lKSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGZpbmRQcm9wKG5vZGUsIG5hbWUsIGR5bmFtaWNPbmx5ID0gZmFsc2UsIGFsbG93RW1wdHkgPSBmYWxzZSkge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLnByb3BzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgcCA9IG5vZGUucHJvcHNbaV07XHJcbiAgICAgICAgaWYgKHAudHlwZSA9PT0gNiAvKiBBVFRSSUJVVEUgKi8pIHtcclxuICAgICAgICAgICAgaWYgKGR5bmFtaWNPbmx5KVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIGlmIChwLm5hbWUgPT09IG5hbWUgJiYgKHAudmFsdWUgfHwgYWxsb3dFbXB0eSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHAubmFtZSA9PT0gJ2JpbmQnICYmXHJcbiAgICAgICAgICAgIChwLmV4cCB8fCBhbGxvd0VtcHR5KSAmJlxyXG4gICAgICAgICAgICBpc1N0YXRpY0FyZ09mKHAuYXJnLCBuYW1lKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaXNTdGF0aWNBcmdPZihhcmcsIG5hbWUpIHtcclxuICAgIHJldHVybiAhIShhcmcgJiYgaXNTdGF0aWNFeHAoYXJnKSAmJiBhcmcuY29udGVudCA9PT0gbmFtZSk7XHJcbn1cclxuZnVuY3Rpb24gaGFzRHluYW1pY0tleVZCaW5kKG5vZGUpIHtcclxuICAgIHJldHVybiBub2RlLnByb3BzLnNvbWUocCA9PiBwLnR5cGUgPT09IDcgLyogRElSRUNUSVZFICovICYmXHJcbiAgICAgICAgcC5uYW1lID09PSAnYmluZCcgJiZcclxuICAgICAgICAoIXAuYXJnIHx8IC8vIHYtYmluZD1cIm9ialwiXHJcbiAgICAgICAgICAgIHAuYXJnLnR5cGUgIT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8gfHwgLy8gdi1iaW5kOltfY3R4LmZvb11cclxuICAgICAgICAgICAgIXAuYXJnLmlzU3RhdGljKSAvLyB2LWJpbmQ6W2Zvb11cclxuICAgICk7XHJcbn1cclxuZnVuY3Rpb24gaXNUZXh0KG5vZGUpIHtcclxuICAgIHJldHVybiBub2RlLnR5cGUgPT09IDUgLyogSU5URVJQT0xBVElPTiAqLyB8fCBub2RlLnR5cGUgPT09IDIgLyogVEVYVCAqLztcclxufVxyXG5mdW5jdGlvbiBpc1ZTbG90KHApIHtcclxuICAgIHJldHVybiBwLnR5cGUgPT09IDcgLyogRElSRUNUSVZFICovICYmIHAubmFtZSA9PT0gJ3Nsb3QnO1xyXG59XHJcbmZ1bmN0aW9uIGlzVGVtcGxhdGVOb2RlKG5vZGUpIHtcclxuICAgIHJldHVybiAobm9kZS50eXBlID09PSAxIC8qIEVMRU1FTlQgKi8gJiYgbm9kZS50YWdUeXBlID09PSAzIC8qIFRFTVBMQVRFICovKTtcclxufVxyXG5mdW5jdGlvbiBpc1Nsb3RPdXRsZXQobm9kZSkge1xyXG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gMSAvKiBFTEVNRU5UICovICYmIG5vZGUudGFnVHlwZSA9PT0gMiAvKiBTTE9UICovO1xyXG59XHJcbmZ1bmN0aW9uIGdldFZOb2RlSGVscGVyKHNzciwgaXNDb21wb25lbnQpIHtcclxuICAgIHJldHVybiBzc3IgfHwgaXNDb21wb25lbnQgPyBDUkVBVEVfVk5PREUgOiBDUkVBVEVfRUxFTUVOVF9WTk9ERTtcclxufVxyXG5mdW5jdGlvbiBnZXRWTm9kZUJsb2NrSGVscGVyKHNzciwgaXNDb21wb25lbnQpIHtcclxuICAgIHJldHVybiBzc3IgfHwgaXNDb21wb25lbnQgPyBDUkVBVEVfQkxPQ0sgOiBDUkVBVEVfRUxFTUVOVF9CTE9DSztcclxufVxyXG5jb25zdCBwcm9wc0hlbHBlclNldCA9IG5ldyBTZXQoW05PUk1BTElaRV9QUk9QUywgR1VBUkRfUkVBQ1RJVkVfUFJPUFNdKTtcclxuZnVuY3Rpb24gZ2V0VW5ub3JtYWxpemVkUHJvcHMocHJvcHMsIGNhbGxQYXRoID0gW10pIHtcclxuICAgIGlmIChwcm9wcyAmJlxyXG4gICAgICAgICFpc1N0cmluZyhwcm9wcykgJiZcclxuICAgICAgICBwcm9wcy50eXBlID09PSAxNCAvKiBKU19DQUxMX0VYUFJFU1NJT04gKi8pIHtcclxuICAgICAgICBjb25zdCBjYWxsZWUgPSBwcm9wcy5jYWxsZWU7XHJcbiAgICAgICAgaWYgKCFpc1N0cmluZyhjYWxsZWUpICYmIHByb3BzSGVscGVyU2V0LmhhcyhjYWxsZWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnZXRVbm5vcm1hbGl6ZWRQcm9wcyhwcm9wcy5hcmd1bWVudHNbMF0sIGNhbGxQYXRoLmNvbmNhdChwcm9wcykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBbcHJvcHMsIGNhbGxQYXRoXTtcclxufVxyXG5mdW5jdGlvbiBpbmplY3RQcm9wKG5vZGUsIHByb3AsIGNvbnRleHQpIHtcclxuICAgIGxldCBwcm9wc1dpdGhJbmplY3Rpb247XHJcbiAgICAvKipcclxuICAgICAqIDEuIG1lcmdlUHJvcHMoLi4uKVxyXG4gICAgICogMi4gdG9IYW5kbGVycyguLi4pXHJcbiAgICAgKiAzLiBub3JtYWxpemVQcm9wcyguLi4pXHJcbiAgICAgKiA0LiBub3JtYWxpemVQcm9wcyhndWFyZFJlYWN0aXZlUHJvcHMoLi4uKSlcclxuICAgICAqXHJcbiAgICAgKiB3ZSBuZWVkIHRvIGdldCB0aGUgcmVhbCBwcm9wcyBiZWZvcmUgbm9ybWFsaXphdGlvblxyXG4gICAgICovXHJcbiAgICBsZXQgcHJvcHMgPSBub2RlLnR5cGUgPT09IDEzIC8qIFZOT0RFX0NBTEwgKi8gPyBub2RlLnByb3BzIDogbm9kZS5hcmd1bWVudHNbMl07XHJcbiAgICBsZXQgY2FsbFBhdGggPSBbXTtcclxuICAgIGxldCBwYXJlbnRDYWxsO1xyXG4gICAgaWYgKHByb3BzICYmXHJcbiAgICAgICAgIWlzU3RyaW5nKHByb3BzKSAmJlxyXG4gICAgICAgIHByb3BzLnR5cGUgPT09IDE0IC8qIEpTX0NBTExfRVhQUkVTU0lPTiAqLykge1xyXG4gICAgICAgIGNvbnN0IHJldCA9IGdldFVubm9ybWFsaXplZFByb3BzKHByb3BzKTtcclxuICAgICAgICBwcm9wcyA9IHJldFswXTtcclxuICAgICAgICBjYWxsUGF0aCA9IHJldFsxXTtcclxuICAgICAgICBwYXJlbnRDYWxsID0gY2FsbFBhdGhbY2FsbFBhdGgubGVuZ3RoIC0gMV07XHJcbiAgICB9XHJcbiAgICBpZiAocHJvcHMgPT0gbnVsbCB8fCBpc1N0cmluZyhwcm9wcykpIHtcclxuICAgICAgICBwcm9wc1dpdGhJbmplY3Rpb24gPSBjcmVhdGVPYmplY3RFeHByZXNzaW9uKFtwcm9wXSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChwcm9wcy50eXBlID09PSAxNCAvKiBKU19DQUxMX0VYUFJFU1NJT04gKi8pIHtcclxuICAgICAgICAvLyBtZXJnZWQgcHJvcHMuLi4gYWRkIG91cnNcclxuICAgICAgICAvLyBvbmx5IGluamVjdCBrZXkgdG8gb2JqZWN0IGxpdGVyYWwgaWYgaXQncyB0aGUgZmlyc3QgYXJndW1lbnQgc28gdGhhdFxyXG4gICAgICAgIC8vIGlmIGRvZXNuJ3Qgb3ZlcnJpZGUgdXNlciBwcm92aWRlZCBrZXlzXHJcbiAgICAgICAgY29uc3QgZmlyc3QgPSBwcm9wcy5hcmd1bWVudHNbMF07XHJcbiAgICAgICAgaWYgKCFpc1N0cmluZyhmaXJzdCkgJiYgZmlyc3QudHlwZSA9PT0gMTUgLyogSlNfT0JKRUNUX0VYUFJFU1NJT04gKi8pIHtcclxuICAgICAgICAgICAgZmlyc3QucHJvcGVydGllcy51bnNoaWZ0KHByb3ApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHByb3BzLmNhbGxlZSA9PT0gVE9fSEFORExFUlMpIHtcclxuICAgICAgICAgICAgICAgIC8vICMyMzY2XHJcbiAgICAgICAgICAgICAgICBwcm9wc1dpdGhJbmplY3Rpb24gPSBjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlcihNRVJHRV9QUk9QUyksIFtcclxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVPYmplY3RFeHByZXNzaW9uKFtwcm9wXSksXHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcHNcclxuICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcHJvcHMuYXJndW1lbnRzLnVuc2hpZnQoY3JlYXRlT2JqZWN0RXhwcmVzc2lvbihbcHJvcF0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAhcHJvcHNXaXRoSW5qZWN0aW9uICYmIChwcm9wc1dpdGhJbmplY3Rpb24gPSBwcm9wcyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChwcm9wcy50eXBlID09PSAxNSAvKiBKU19PQkpFQ1RfRVhQUkVTU0lPTiAqLykge1xyXG4gICAgICAgIGxldCBhbHJlYWR5RXhpc3RzID0gZmFsc2U7XHJcbiAgICAgICAgLy8gY2hlY2sgZXhpc3Rpbmcga2V5IHRvIGF2b2lkIG92ZXJyaWRpbmcgdXNlciBwcm92aWRlZCBrZXlzXHJcbiAgICAgICAgaWYgKHByb3Aua2V5LnR5cGUgPT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8pIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvcEtleU5hbWUgPSBwcm9wLmtleS5jb250ZW50O1xyXG4gICAgICAgICAgICBhbHJlYWR5RXhpc3RzID0gcHJvcHMucHJvcGVydGllcy5zb21lKHAgPT4gcC5rZXkudHlwZSA9PT0gNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLyAmJlxyXG4gICAgICAgICAgICAgICAgcC5rZXkuY29udGVudCA9PT0gcHJvcEtleU5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWFscmVhZHlFeGlzdHMpIHtcclxuICAgICAgICAgICAgcHJvcHMucHJvcGVydGllcy51bnNoaWZ0KHByb3ApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwcm9wc1dpdGhJbmplY3Rpb24gPSBwcm9wcztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIHNpbmdsZSB2LWJpbmQgd2l0aCBleHByZXNzaW9uLCByZXR1cm4gYSBtZXJnZWQgcmVwbGFjZW1lbnRcclxuICAgICAgICBwcm9wc1dpdGhJbmplY3Rpb24gPSBjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlcihNRVJHRV9QUk9QUyksIFtcclxuICAgICAgICAgICAgY3JlYXRlT2JqZWN0RXhwcmVzc2lvbihbcHJvcF0pLFxyXG4gICAgICAgICAgICBwcm9wc1xyXG4gICAgICAgIF0pO1xyXG4gICAgICAgIC8vIGluIHRoZSBjYXNlIG9mIG5lc3RlZCBoZWxwZXIgY2FsbCwgZS5nLiBgbm9ybWFsaXplUHJvcHMoZ3VhcmRSZWFjdGl2ZVByb3BzKHByb3BzKSlgLFxyXG4gICAgICAgIC8vIGl0IHdpbGwgYmUgcmV3cml0dGVuIGFzIGBub3JtYWxpemVQcm9wcyhtZXJnZVByb3BzKHsga2V5OiAwIH0sIHByb3BzKSlgLFxyXG4gICAgICAgIC8vIHRoZSBgZ3VhcmRSZWFjdGl2ZVByb3BzYCB3aWxsIG5vIGxvbmdlciBiZSBuZWVkZWRcclxuICAgICAgICBpZiAocGFyZW50Q2FsbCAmJiBwYXJlbnRDYWxsLmNhbGxlZSA9PT0gR1VBUkRfUkVBQ1RJVkVfUFJPUFMpIHtcclxuICAgICAgICAgICAgcGFyZW50Q2FsbCA9IGNhbGxQYXRoW2NhbGxQYXRoLmxlbmd0aCAtIDJdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChub2RlLnR5cGUgPT09IDEzIC8qIFZOT0RFX0NBTEwgKi8pIHtcclxuICAgICAgICBpZiAocGFyZW50Q2FsbCkge1xyXG4gICAgICAgICAgICBwYXJlbnRDYWxsLmFyZ3VtZW50c1swXSA9IHByb3BzV2l0aEluamVjdGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG5vZGUucHJvcHMgPSBwcm9wc1dpdGhJbmplY3Rpb247XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKHBhcmVudENhbGwpIHtcclxuICAgICAgICAgICAgcGFyZW50Q2FsbC5hcmd1bWVudHNbMF0gPSBwcm9wc1dpdGhJbmplY3Rpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBub2RlLmFyZ3VtZW50c1syXSA9IHByb3BzV2l0aEluamVjdGlvbjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdG9WYWxpZEFzc2V0SWQobmFtZSwgdHlwZSkge1xyXG4gICAgLy8gc2VlIGlzc3VlIzQ0MjIsIHdlIG5lZWQgYWRkaW5nIGlkZW50aWZpZXIgb24gdmFsaWRBc3NldElkIGlmIHZhcmlhYmxlIGBuYW1lYCBoYXMgc3BlY2lmaWMgY2hhcmFjdGVyXHJcbiAgICByZXR1cm4gYF8ke3R5cGV9XyR7bmFtZS5yZXBsYWNlKC9bXlxcd10vZywgKHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpID0+IHtcclxuICAgICAgICByZXR1cm4gc2VhcmNoVmFsdWUgPT09ICctJyA/ICdfJyA6IG5hbWUuY2hhckNvZGVBdChyZXBsYWNlVmFsdWUpLnRvU3RyaW5nKCk7XHJcbiAgICB9KX1gO1xyXG59XHJcbi8vIENoZWNrIGlmIGEgbm9kZSBjb250YWlucyBleHByZXNzaW9ucyB0aGF0IHJlZmVyZW5jZSBjdXJyZW50IGNvbnRleHQgc2NvcGUgaWRzXHJcbmZ1bmN0aW9uIGhhc1Njb3BlUmVmKG5vZGUsIGlkcykge1xyXG4gICAgaWYgKCFub2RlIHx8IE9iamVjdC5rZXlzKGlkcykubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcclxuICAgICAgICBjYXNlIDEgLyogRUxFTUVOVCAqLzpcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLnByb3BzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwID0gbm9kZS5wcm9wc1tpXTtcclxuICAgICAgICAgICAgICAgIGlmIChwLnR5cGUgPT09IDcgLyogRElSRUNUSVZFICovICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKGhhc1Njb3BlUmVmKHAuYXJnLCBpZHMpIHx8IGhhc1Njb3BlUmVmKHAuZXhwLCBpZHMpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlLmNoaWxkcmVuLnNvbWUoYyA9PiBoYXNTY29wZVJlZihjLCBpZHMpKTtcclxuICAgICAgICBjYXNlIDExIC8qIEZPUiAqLzpcclxuICAgICAgICAgICAgaWYgKGhhc1Njb3BlUmVmKG5vZGUuc291cmNlLCBpZHMpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5jaGlsZHJlbi5zb21lKGMgPT4gaGFzU2NvcGVSZWYoYywgaWRzKSk7XHJcbiAgICAgICAgY2FzZSA5IC8qIElGICovOlxyXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5icmFuY2hlcy5zb21lKGIgPT4gaGFzU2NvcGVSZWYoYiwgaWRzKSk7XHJcbiAgICAgICAgY2FzZSAxMCAvKiBJRl9CUkFOQ0ggKi86XHJcbiAgICAgICAgICAgIGlmIChoYXNTY29wZVJlZihub2RlLmNvbmRpdGlvbiwgaWRzKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5vZGUuY2hpbGRyZW4uc29tZShjID0+IGhhc1Njb3BlUmVmKGMsIGlkcykpO1xyXG4gICAgICAgIGNhc2UgNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLzpcclxuICAgICAgICAgICAgcmV0dXJuICghbm9kZS5pc1N0YXRpYyAmJlxyXG4gICAgICAgICAgICAgICAgaXNTaW1wbGVJZGVudGlmaWVyKG5vZGUuY29udGVudCkgJiZcclxuICAgICAgICAgICAgICAgICEhaWRzW25vZGUuY29udGVudF0pO1xyXG4gICAgICAgIGNhc2UgOCAvKiBDT01QT1VORF9FWFBSRVNTSU9OICovOlxyXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5jaGlsZHJlbi5zb21lKGMgPT4gaXNPYmplY3QoYykgJiYgaGFzU2NvcGVSZWYoYywgaWRzKSk7XHJcbiAgICAgICAgY2FzZSA1IC8qIElOVEVSUE9MQVRJT04gKi86XHJcbiAgICAgICAgY2FzZSAxMiAvKiBURVhUX0NBTEwgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBoYXNTY29wZVJlZihub2RlLmNvbnRlbnQsIGlkcyk7XHJcbiAgICAgICAgY2FzZSAyIC8qIFRFWFQgKi86XHJcbiAgICAgICAgY2FzZSAzIC8qIENPTU1FTlQgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSA7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRNZW1vZWRWTm9kZUNhbGwobm9kZSkge1xyXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMTQgLyogSlNfQ0FMTF9FWFBSRVNTSU9OICovICYmIG5vZGUuY2FsbGVlID09PSBXSVRIX01FTU8pIHtcclxuICAgICAgICByZXR1cm4gbm9kZS5hcmd1bWVudHNbMV0ucmV0dXJucztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIG1ha2VCbG9jayhub2RlLCB7IGhlbHBlciwgcmVtb3ZlSGVscGVyLCBpblNTUiB9KSB7XHJcbiAgICBpZiAoIW5vZGUuaXNCbG9jaykge1xyXG4gICAgICAgIG5vZGUuaXNCbG9jayA9IHRydWU7XHJcbiAgICAgICAgcmVtb3ZlSGVscGVyKGdldFZOb2RlSGVscGVyKGluU1NSLCBub2RlLmlzQ29tcG9uZW50KSk7XHJcbiAgICAgICAgaGVscGVyKE9QRU5fQkxPQ0spO1xyXG4gICAgICAgIGhlbHBlcihnZXRWTm9kZUJsb2NrSGVscGVyKGluU1NSLCBub2RlLmlzQ29tcG9uZW50KSk7XHJcbiAgICB9XHJcbn1cblxuY29uc3QgZGVwcmVjYXRpb25EYXRhID0ge1xyXG4gICAgW1wiQ09NUElMRVJfSVNfT05fRUxFTUVOVFwiIC8qIENPTVBJTEVSX0lTX09OX0VMRU1FTlQgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogYFBsYXRmb3JtLW5hdGl2ZSBlbGVtZW50cyB3aXRoIFwiaXNcIiBwcm9wIHdpbGwgbm8gbG9uZ2VyIGJlIGAgK1xyXG4gICAgICAgICAgICBgdHJlYXRlZCBhcyBjb21wb25lbnRzIGluIFZ1ZSAzIHVubGVzcyB0aGUgXCJpc1wiIHZhbHVlIGlzIGV4cGxpY2l0bHkgYCArXHJcbiAgICAgICAgICAgIGBwcmVmaXhlZCB3aXRoIFwidnVlOlwiLmAsXHJcbiAgICAgICAgbGluazogYGh0dHBzOi8vdjMtbWlncmF0aW9uLnZ1ZWpzLm9yZy9icmVha2luZy1jaGFuZ2VzL2N1c3RvbS1lbGVtZW50cy1pbnRlcm9wLmh0bWxgXHJcbiAgICB9LFxyXG4gICAgW1wiQ09NUElMRVJfVl9CSU5EX1NZTkNcIiAvKiBDT01QSUxFUl9WX0JJTkRfU1lOQyAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBrZXkgPT4gYC5zeW5jIG1vZGlmaWVyIGZvciB2LWJpbmQgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIHYtbW9kZWwgd2l0aCBgICtcclxuICAgICAgICAgICAgYGFyZ3VtZW50IGluc3RlYWQuIFxcYHYtYmluZDoke2tleX0uc3luY1xcYCBzaG91bGQgYmUgY2hhbmdlZCB0byBgICtcclxuICAgICAgICAgICAgYFxcYHYtbW9kZWw6JHtrZXl9XFxgLmAsXHJcbiAgICAgICAgbGluazogYGh0dHBzOi8vdjMtbWlncmF0aW9uLnZ1ZWpzLm9yZy9icmVha2luZy1jaGFuZ2VzL3YtbW9kZWwuaHRtbGBcclxuICAgIH0sXHJcbiAgICBbXCJDT01QSUxFUl9WX0JJTkRfUFJPUFwiIC8qIENPTVBJTEVSX1ZfQklORF9QUk9QICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGAucHJvcCBtb2RpZmllciBmb3Igdi1iaW5kIGhhcyBiZWVuIHJlbW92ZWQgYW5kIG5vIGxvbmdlciBuZWNlc3NhcnkuIGAgK1xyXG4gICAgICAgICAgICBgVnVlIDMgd2lsbCBhdXRvbWF0aWNhbGx5IHNldCBhIGJpbmRpbmcgYXMgRE9NIHByb3BlcnR5IHdoZW4gYXBwcm9wcmlhdGUuYFxyXG4gICAgfSxcclxuICAgIFtcIkNPTVBJTEVSX1ZfQklORF9PQkpFQ1RfT1JERVJcIiAvKiBDT01QSUxFUl9WX0JJTkRfT0JKRUNUX09SREVSICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGB2LWJpbmQ9XCJvYmpcIiB1c2FnZSBpcyBub3cgb3JkZXIgc2Vuc2l0aXZlIGFuZCBiZWhhdmVzIGxpa2UgSmF2YVNjcmlwdCBgICtcclxuICAgICAgICAgICAgYG9iamVjdCBzcHJlYWQ6IGl0IHdpbGwgbm93IG92ZXJ3cml0ZSBhbiBleGlzdGluZyBub24tbWVyZ2VhYmxlIGF0dHJpYnV0ZSBgICtcclxuICAgICAgICAgICAgYHRoYXQgYXBwZWFycyBiZWZvcmUgdi1iaW5kIGluIHRoZSBjYXNlIG9mIGNvbmZsaWN0LiBgICtcclxuICAgICAgICAgICAgYFRvIHJldGFpbiAyLnggYmVoYXZpb3IsIG1vdmUgdi1iaW5kIHRvIG1ha2UgaXQgdGhlIGZpcnN0IGF0dHJpYnV0ZS4gYCArXHJcbiAgICAgICAgICAgIGBZb3UgY2FuIGFsc28gc3VwcHJlc3MgdGhpcyB3YXJuaW5nIGlmIHRoZSB1c2FnZSBpcyBpbnRlbmRlZC5gLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLW1pZ3JhdGlvbi52dWVqcy5vcmcvYnJlYWtpbmctY2hhbmdlcy92LWJpbmQuaHRtbGBcclxuICAgIH0sXHJcbiAgICBbXCJDT01QSUxFUl9WX09OX05BVElWRVwiIC8qIENPTVBJTEVSX1ZfT05fTkFUSVZFICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGAubmF0aXZlIG1vZGlmaWVyIGZvciB2LW9uIGhhcyBiZWVuIHJlbW92ZWQgYXMgaXMgbm8gbG9uZ2VyIG5lY2Vzc2FyeS5gLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLW1pZ3JhdGlvbi52dWVqcy5vcmcvYnJlYWtpbmctY2hhbmdlcy92LW9uLW5hdGl2ZS1tb2RpZmllci1yZW1vdmVkLmh0bWxgXHJcbiAgICB9LFxyXG4gICAgW1wiQ09NUElMRVJfVl9JRl9WX0ZPUl9QUkVDRURFTkNFXCIgLyogQ09NUElMRVJfVl9JRl9WX0ZPUl9QUkVDRURFTkNFICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGB2LWlmIC8gdi1mb3IgcHJlY2VkZW5jZSB3aGVuIHVzZWQgb24gdGhlIHNhbWUgZWxlbWVudCBoYXMgY2hhbmdlZCBgICtcclxuICAgICAgICAgICAgYGluIFZ1ZSAzOiB2LWlmIG5vdyB0YWtlcyBoaWdoZXIgcHJlY2VkZW5jZSBhbmQgd2lsbCBubyBsb25nZXIgaGF2ZSBgICtcclxuICAgICAgICAgICAgYGFjY2VzcyB0byB2LWZvciBzY29wZSB2YXJpYWJsZXMuIEl0IGlzIGJlc3QgdG8gYXZvaWQgdGhlIGFtYmlndWl0eSBgICtcclxuICAgICAgICAgICAgYHdpdGggPHRlbXBsYXRlPiB0YWdzIG9yIHVzZSBhIGNvbXB1dGVkIHByb3BlcnR5IHRoYXQgZmlsdGVycyB2LWZvciBgICtcclxuICAgICAgICAgICAgYGRhdGEgc291cmNlLmAsXHJcbiAgICAgICAgbGluazogYGh0dHBzOi8vdjMtbWlncmF0aW9uLnZ1ZWpzLm9yZy9icmVha2luZy1jaGFuZ2VzL3YtaWYtdi1mb3IuaHRtbGBcclxuICAgIH0sXHJcbiAgICBbXCJDT01QSUxFUl9OQVRJVkVfVEVNUExBVEVcIiAvKiBDT01QSUxFUl9OQVRJVkVfVEVNUExBVEUgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogYDx0ZW1wbGF0ZT4gd2l0aCBubyBzcGVjaWFsIGRpcmVjdGl2ZXMgd2lsbCByZW5kZXIgYXMgYSBuYXRpdmUgdGVtcGxhdGUgYCArXHJcbiAgICAgICAgICAgIGBlbGVtZW50IGluc3RlYWQgb2YgaXRzIGlubmVyIGNvbnRlbnQgaW4gVnVlIDMuYFxyXG4gICAgfSxcclxuICAgIFtcIkNPTVBJTEVSX0lOTElORV9URU1QTEFURVwiIC8qIENPTVBJTEVSX0lOTElORV9URU1QTEFURSAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgXCJpbmxpbmUtdGVtcGxhdGVcIiBoYXMgYmVlbiByZW1vdmVkIGluIFZ1ZSAzLmAsXHJcbiAgICAgICAgbGluazogYGh0dHBzOi8vdjMtbWlncmF0aW9uLnZ1ZWpzLm9yZy9icmVha2luZy1jaGFuZ2VzL2lubGluZS10ZW1wbGF0ZS1hdHRyaWJ1dGUuaHRtbGBcclxuICAgIH0sXHJcbiAgICBbXCJDT01QSUxFUl9GSUxURVJcIiAvKiBDT01QSUxFUl9GSUxURVJTICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGBmaWx0ZXJzIGhhdmUgYmVlbiByZW1vdmVkIGluIFZ1ZSAzLiBgICtcclxuICAgICAgICAgICAgYFRoZSBcInxcIiBzeW1ib2wgd2lsbCBiZSB0cmVhdGVkIGFzIG5hdGl2ZSBKYXZhU2NyaXB0IGJpdHdpc2UgT1Igb3BlcmF0b3IuIGAgK1xyXG4gICAgICAgICAgICBgVXNlIG1ldGhvZCBjYWxscyBvciBjb21wdXRlZCBwcm9wZXJ0aWVzIGluc3RlYWQuYCxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My1taWdyYXRpb24udnVlanMub3JnL2JyZWFraW5nLWNoYW5nZXMvZmlsdGVycy5odG1sYFxyXG4gICAgfVxyXG59O1xyXG5mdW5jdGlvbiBnZXRDb21wYXRWYWx1ZShrZXksIGNvbnRleHQpIHtcclxuICAgIGNvbnN0IGNvbmZpZyA9IGNvbnRleHQub3B0aW9uc1xyXG4gICAgICAgID8gY29udGV4dC5vcHRpb25zLmNvbXBhdENvbmZpZ1xyXG4gICAgICAgIDogY29udGV4dC5jb21wYXRDb25maWc7XHJcbiAgICBjb25zdCB2YWx1ZSA9IGNvbmZpZyAmJiBjb25maWdba2V5XTtcclxuICAgIGlmIChrZXkgPT09ICdNT0RFJykge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZSB8fCAzOyAvLyBjb21waWxlciBkZWZhdWx0cyB0byB2MyBiZWhhdmlvclxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzQ29tcGF0RW5hYmxlZChrZXksIGNvbnRleHQpIHtcclxuICAgIGNvbnN0IG1vZGUgPSBnZXRDb21wYXRWYWx1ZSgnTU9ERScsIGNvbnRleHQpO1xyXG4gICAgY29uc3QgdmFsdWUgPSBnZXRDb21wYXRWYWx1ZShrZXksIGNvbnRleHQpO1xyXG4gICAgLy8gaW4gdjMgbW9kZSwgb25seSBlbmFibGUgaWYgZXhwbGljaXRseSBzZXQgdG8gdHJ1ZVxyXG4gICAgLy8gb3RoZXJ3aXNlIGVuYWJsZSBmb3IgYW55IG5vbi1mYWxzZSB2YWx1ZVxyXG4gICAgcmV0dXJuIG1vZGUgPT09IDMgPyB2YWx1ZSA9PT0gdHJ1ZSA6IHZhbHVlICE9PSBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBjaGVja0NvbXBhdEVuYWJsZWQoa2V5LCBjb250ZXh0LCBsb2MsIC4uLmFyZ3MpIHtcclxuICAgIGNvbnN0IGVuYWJsZWQgPSBpc0NvbXBhdEVuYWJsZWQoa2V5LCBjb250ZXh0KTtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgZW5hYmxlZCkge1xyXG4gICAgICAgIHdhcm5EZXByZWNhdGlvbihrZXksIGNvbnRleHQsIGxvYywgLi4uYXJncyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZW5hYmxlZDtcclxufVxyXG5mdW5jdGlvbiB3YXJuRGVwcmVjYXRpb24oa2V5LCBjb250ZXh0LCBsb2MsIC4uLmFyZ3MpIHtcclxuICAgIGNvbnN0IHZhbCA9IGdldENvbXBhdFZhbHVlKGtleSwgY29udGV4dCk7XHJcbiAgICBpZiAodmFsID09PSAnc3VwcHJlc3Mtd2FybmluZycpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCB7IG1lc3NhZ2UsIGxpbmsgfSA9IGRlcHJlY2F0aW9uRGF0YVtrZXldO1xyXG4gICAgY29uc3QgbXNnID0gYChkZXByZWNhdGlvbiAke2tleX0pICR7dHlwZW9mIG1lc3NhZ2UgPT09ICdmdW5jdGlvbicgPyBtZXNzYWdlKC4uLmFyZ3MpIDogbWVzc2FnZX0ke2xpbmsgPyBgXFxuICBEZXRhaWxzOiAke2xpbmt9YCA6IGBgfWA7XHJcbiAgICBjb25zdCBlcnIgPSBuZXcgU3ludGF4RXJyb3IobXNnKTtcclxuICAgIGVyci5jb2RlID0ga2V5O1xyXG4gICAgaWYgKGxvYylcclxuICAgICAgICBlcnIubG9jID0gbG9jO1xyXG4gICAgY29udGV4dC5vbldhcm4oZXJyKTtcclxufVxuXG4vLyBUaGUgZGVmYXVsdCBkZWNvZGVyIG9ubHkgcHJvdmlkZXMgZXNjYXBlcyBmb3IgY2hhcmFjdGVycyByZXNlcnZlZCBhcyBwYXJ0IG9mXHJcbi8vIHRoZSB0ZW1wbGF0ZSBzeW50YXgsIGFuZCBpcyBvbmx5IHVzZWQgaWYgdGhlIGN1c3RvbSByZW5kZXJlciBkaWQgbm90IHByb3ZpZGVcclxuLy8gYSBwbGF0Zm9ybS1zcGVjaWZpYyBkZWNvZGVyLlxyXG5jb25zdCBkZWNvZGVSRSA9IC8mKGd0fGx0fGFtcHxhcG9zfHF1b3QpOy9nO1xyXG5jb25zdCBkZWNvZGVNYXAgPSB7XHJcbiAgICBndDogJz4nLFxyXG4gICAgbHQ6ICc8JyxcclxuICAgIGFtcDogJyYnLFxyXG4gICAgYXBvczogXCInXCIsXHJcbiAgICBxdW90OiAnXCInXHJcbn07XHJcbmNvbnN0IGRlZmF1bHRQYXJzZXJPcHRpb25zID0ge1xyXG4gICAgZGVsaW1pdGVyczogW2B7e2AsIGB9fWBdLFxyXG4gICAgZ2V0TmFtZXNwYWNlOiAoKSA9PiAwIC8qIEhUTUwgKi8sXHJcbiAgICBnZXRUZXh0TW9kZTogKCkgPT4gMCAvKiBEQVRBICovLFxyXG4gICAgaXNWb2lkVGFnOiBOTyxcclxuICAgIGlzUHJlVGFnOiBOTyxcclxuICAgIGlzQ3VzdG9tRWxlbWVudDogTk8sXHJcbiAgICBkZWNvZGVFbnRpdGllczogKHJhd1RleHQpID0+IHJhd1RleHQucmVwbGFjZShkZWNvZGVSRSwgKF8sIHAxKSA9PiBkZWNvZGVNYXBbcDFdKSxcclxuICAgIG9uRXJyb3I6IGRlZmF1bHRPbkVycm9yLFxyXG4gICAgb25XYXJuOiBkZWZhdWx0T25XYXJuLFxyXG4gICAgY29tbWVudHM6IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxyXG59O1xyXG5mdW5jdGlvbiBiYXNlUGFyc2UoY29udGVudCwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlUGFyc2VyQ29udGV4dChjb250ZW50LCBvcHRpb25zKTtcclxuICAgIGNvbnN0IHN0YXJ0ID0gZ2V0Q3Vyc29yKGNvbnRleHQpO1xyXG4gICAgcmV0dXJuIGNyZWF0ZVJvb3QocGFyc2VDaGlsZHJlbihjb250ZXh0LCAwIC8qIERBVEEgKi8sIFtdKSwgZ2V0U2VsZWN0aW9uKGNvbnRleHQsIHN0YXJ0KSk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUGFyc2VyQ29udGV4dChjb250ZW50LCByYXdPcHRpb25zKSB7XHJcbiAgICBjb25zdCBvcHRpb25zID0gZXh0ZW5kKHt9LCBkZWZhdWx0UGFyc2VyT3B0aW9ucyk7XHJcbiAgICBsZXQga2V5O1xyXG4gICAgZm9yIChrZXkgaW4gcmF3T3B0aW9ucykge1xyXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICBvcHRpb25zW2tleV0gPVxyXG4gICAgICAgICAgICByYXdPcHRpb25zW2tleV0gPT09IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgPyBkZWZhdWx0UGFyc2VyT3B0aW9uc1trZXldXHJcbiAgICAgICAgICAgICAgICA6IHJhd09wdGlvbnNba2V5XTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgb3B0aW9ucyxcclxuICAgICAgICBjb2x1bW46IDEsXHJcbiAgICAgICAgbGluZTogMSxcclxuICAgICAgICBvZmZzZXQ6IDAsXHJcbiAgICAgICAgb3JpZ2luYWxTb3VyY2U6IGNvbnRlbnQsXHJcbiAgICAgICAgc291cmNlOiBjb250ZW50LFxyXG4gICAgICAgIGluUHJlOiBmYWxzZSxcclxuICAgICAgICBpblZQcmU6IGZhbHNlLFxyXG4gICAgICAgIG9uV2Fybjogb3B0aW9ucy5vbldhcm5cclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VDaGlsZHJlbihjb250ZXh0LCBtb2RlLCBhbmNlc3RvcnMpIHtcclxuICAgIGNvbnN0IHBhcmVudCA9IGxhc3QoYW5jZXN0b3JzKTtcclxuICAgIGNvbnN0IG5zID0gcGFyZW50ID8gcGFyZW50Lm5zIDogMCAvKiBIVE1MICovO1xyXG4gICAgY29uc3Qgbm9kZXMgPSBbXTtcclxuICAgIHdoaWxlICghaXNFbmQoY29udGV4dCwgbW9kZSwgYW5jZXN0b3JzKSkge1xyXG4gICAgICAgIGNvbnN0IHMgPSBjb250ZXh0LnNvdXJjZTtcclxuICAgICAgICBsZXQgbm9kZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICBpZiAobW9kZSA9PT0gMCAvKiBEQVRBICovIHx8IG1vZGUgPT09IDEgLyogUkNEQVRBICovKSB7XHJcbiAgICAgICAgICAgIGlmICghY29udGV4dC5pblZQcmUgJiYgc3RhcnRzV2l0aChzLCBjb250ZXh0Lm9wdGlvbnMuZGVsaW1pdGVyc1swXSkpIHtcclxuICAgICAgICAgICAgICAgIC8vICd7eydcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJzZUludGVycG9sYXRpb24oY29udGV4dCwgbW9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobW9kZSA9PT0gMCAvKiBEQVRBICovICYmIHNbMF0gPT09ICc8Jykge1xyXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvcGFyc2luZy5odG1sI3RhZy1vcGVuLXN0YXRlXHJcbiAgICAgICAgICAgICAgICBpZiAocy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgNSAvKiBFT0ZfQkVGT1JFX1RBR19OQU1FICovLCAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNbMV0gPT09ICchJykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3BhcnNpbmcuaHRtbCNtYXJrdXAtZGVjbGFyYXRpb24tb3Blbi1zdGF0ZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydHNXaXRoKHMsICc8IS0tJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHBhcnNlQ29tbWVudChjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RhcnRzV2l0aChzLCAnPCFET0NUWVBFJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIERPQ1RZUEUgYnkgYSBsaW1pdGF0aW9uLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gcGFyc2VCb2d1c0NvbW1lbnQoY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0YXJ0c1dpdGgocywgJzwhW0NEQVRBWycpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChucyAhPT0gMCAvKiBIVE1MICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gcGFyc2VDREFUQShjb250ZXh0LCBhbmNlc3RvcnMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDEgLyogQ0RBVEFfSU5fSFRNTF9DT05URU5UICovKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJzZUJvZ3VzQ29tbWVudChjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDExIC8qIElOQ09SUkVDVExZX09QRU5FRF9DT01NRU5UICovKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHBhcnNlQm9ndXNDb21tZW50KGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNbMV0gPT09ICcvJykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3BhcnNpbmcuaHRtbCNlbmQtdGFnLW9wZW4tc3RhdGVcclxuICAgICAgICAgICAgICAgICAgICBpZiAocy5sZW5ndGggPT09IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDUgLyogRU9GX0JFRk9SRV9UQUdfTkFNRSAqLywgMik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNbMl0gPT09ICc+Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMTQgLyogTUlTU0lOR19FTkRfVEFHX05BTUUgKi8sIDIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZHZhbmNlQnkoY29udGV4dCwgMyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgvW2Etel0vaS50ZXN0KHNbMl0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAyMyAvKiBYX0lOVkFMSURfRU5EX1RBRyAqLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlVGFnKGNvbnRleHQsIDEgLyogRW5kICovLCBwYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAxMiAvKiBJTlZBTElEX0ZJUlNUX0NIQVJBQ1RFUl9PRl9UQUdfTkFNRSAqLywgMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJzZUJvZ3VzQ29tbWVudChjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgvW2Etel0vaS50ZXN0KHNbMV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHBhcnNlRWxlbWVudChjb250ZXh0LCBhbmNlc3RvcnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIDIueCA8dGVtcGxhdGU+IHdpdGggbm8gZGlyZWN0aXZlIGNvbXBhdFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0NvbXBhdEVuYWJsZWQoXCJDT01QSUxFUl9OQVRJVkVfVEVNUExBVEVcIiAvKiBDT01QSUxFUl9OQVRJVkVfVEVNUExBVEUgKi8sIGNvbnRleHQpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS50YWcgPT09ICd0ZW1wbGF0ZScgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgIW5vZGUucHJvcHMuc29tZShwID0+IHAudHlwZSA9PT0gNyAvKiBESVJFQ1RJVkUgKi8gJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzU3BlY2lhbFRlbXBsYXRlRGlyZWN0aXZlKHAubmFtZSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FybkRlcHJlY2F0aW9uKFwiQ09NUElMRVJfTkFUSVZFX1RFTVBMQVRFXCIgLyogQ09NUElMRVJfTkFUSVZFX1RFTVBMQVRFICovLCBjb250ZXh0LCBub2RlLmxvYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkcmVuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNbMV0gPT09ICc/Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAyMSAvKiBVTkVYUEVDVEVEX1FVRVNUSU9OX01BUktfSU5TVEVBRF9PRl9UQUdfTkFNRSAqLywgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHBhcnNlQm9ndXNDb21tZW50KGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDEyIC8qIElOVkFMSURfRklSU1RfQ0hBUkFDVEVSX09GX1RBR19OQU1FICovLCAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW5vZGUpIHtcclxuICAgICAgICAgICAgbm9kZSA9IHBhcnNlVGV4dChjb250ZXh0LCBtb2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzQXJyYXkobm9kZSkpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBwdXNoTm9kZShub2Rlcywgbm9kZVtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHB1c2hOb2RlKG5vZGVzLCBub2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBXaGl0ZXNwYWNlIGhhbmRsaW5nIHN0cmF0ZWd5IGxpa2UgdjJcclxuICAgIGxldCByZW1vdmVkV2hpdGVzcGFjZSA9IGZhbHNlO1xyXG4gICAgaWYgKG1vZGUgIT09IDIgLyogUkFXVEVYVCAqLyAmJiBtb2RlICE9PSAxIC8qIFJDREFUQSAqLykge1xyXG4gICAgICAgIGNvbnN0IHNob3VsZENvbmRlbnNlID0gY29udGV4dC5vcHRpb25zLndoaXRlc3BhY2UgIT09ICdwcmVzZXJ2ZSc7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XHJcbiAgICAgICAgICAgIGlmICghY29udGV4dC5pblByZSAmJiBub2RlLnR5cGUgPT09IDIgLyogVEVYVCAqLykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCEvW15cXHRcXHJcXG5cXGYgXS8udGVzdChub2RlLmNvbnRlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldiA9IG5vZGVzW2kgLSAxXTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gbm9kZXNbaSArIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBpZjpcclxuICAgICAgICAgICAgICAgICAgICAvLyAtIHRoZSB3aGl0ZXNwYWNlIGlzIHRoZSBmaXJzdCBvciBsYXN0IG5vZGUsIG9yOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIC0gKGNvbmRlbnNlIG1vZGUpIHRoZSB3aGl0ZXNwYWNlIGlzIGFkamFjZW50IHRvIGEgY29tbWVudCwgb3I6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gLSAoY29uZGVuc2UgbW9kZSkgdGhlIHdoaXRlc3BhY2UgaXMgYmV0d2VlbiB0d28gZWxlbWVudHMgQU5EIGNvbnRhaW5zIG5ld2xpbmVcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXByZXYgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgIW5leHQgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKHNob3VsZENvbmRlbnNlICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAocHJldi50eXBlID09PSAzIC8qIENPTU1FTlQgKi8gfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0LnR5cGUgPT09IDMgLyogQ09NTUVOVCAqLyB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChwcmV2LnR5cGUgPT09IDEgLyogRUxFTUVOVCAqLyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0LnR5cGUgPT09IDEgLyogRUxFTUVOVCAqLyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvW1xcclxcbl0vLnRlc3Qobm9kZS5jb250ZW50KSkpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVkV2hpdGVzcGFjZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzW2ldID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgdGhlIHdoaXRlc3BhY2UgaXMgY29uZGVuc2VkIGludG8gYSBzaW5nbGUgc3BhY2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5jb250ZW50ID0gJyAnO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNob3VsZENvbmRlbnNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaW4gY29uZGVuc2UgbW9kZSwgY29uc2VjdXRpdmUgd2hpdGVzcGFjZXMgaW4gdGV4dCBhcmUgY29uZGVuc2VkXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZG93biB0byBhIHNpbmdsZSBzcGFjZS5cclxuICAgICAgICAgICAgICAgICAgICBub2RlLmNvbnRlbnQgPSBub2RlLmNvbnRlbnQucmVwbGFjZSgvW1xcdFxcclxcblxcZiBdKy9nLCAnICcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSBjb21tZW50IG5vZGVzIGlmIGRlc2lyZWQgYnkgY29uZmlndXJhdGlvbi5cclxuICAgICAgICAgICAgZWxzZSBpZiAobm9kZS50eXBlID09PSAzIC8qIENPTU1FTlQgKi8gJiYgIWNvbnRleHQub3B0aW9ucy5jb21tZW50cykge1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlZFdoaXRlc3BhY2UgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgbm9kZXNbaV0gPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb250ZXh0LmluUHJlICYmIHBhcmVudCAmJiBjb250ZXh0Lm9wdGlvbnMuaXNQcmVUYWcocGFyZW50LnRhZykpIHtcclxuICAgICAgICAgICAgLy8gcmVtb3ZlIGxlYWRpbmcgbmV3bGluZSBwZXIgaHRtbCBzcGVjXHJcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2dyb3VwaW5nLWNvbnRlbnQuaHRtbCN0aGUtcHJlLWVsZW1lbnRcclxuICAgICAgICAgICAgY29uc3QgZmlyc3QgPSBub2Rlc1swXTtcclxuICAgICAgICAgICAgaWYgKGZpcnN0ICYmIGZpcnN0LnR5cGUgPT09IDIgLyogVEVYVCAqLykge1xyXG4gICAgICAgICAgICAgICAgZmlyc3QuY29udGVudCA9IGZpcnN0LmNvbnRlbnQucmVwbGFjZSgvXlxccj9cXG4vLCAnJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVtb3ZlZFdoaXRlc3BhY2UgPyBub2Rlcy5maWx0ZXIoQm9vbGVhbikgOiBub2RlcztcclxufVxyXG5mdW5jdGlvbiBwdXNoTm9kZShub2Rlcywgbm9kZSkge1xyXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMiAvKiBURVhUICovKSB7XHJcbiAgICAgICAgY29uc3QgcHJldiA9IGxhc3Qobm9kZXMpO1xyXG4gICAgICAgIC8vIE1lcmdlIGlmIGJvdGggdGhpcyBhbmQgdGhlIHByZXZpb3VzIG5vZGUgYXJlIHRleHQgYW5kIHRob3NlIGFyZVxyXG4gICAgICAgIC8vIGNvbnNlY3V0aXZlLiBUaGlzIGhhcHBlbnMgZm9yIGNhc2VzIGxpa2UgXCJhIDwgYlwiLlxyXG4gICAgICAgIGlmIChwcmV2ICYmXHJcbiAgICAgICAgICAgIHByZXYudHlwZSA9PT0gMiAvKiBURVhUICovICYmXHJcbiAgICAgICAgICAgIHByZXYubG9jLmVuZC5vZmZzZXQgPT09IG5vZGUubG9jLnN0YXJ0Lm9mZnNldCkge1xyXG4gICAgICAgICAgICBwcmV2LmNvbnRlbnQgKz0gbm9kZS5jb250ZW50O1xyXG4gICAgICAgICAgICBwcmV2LmxvYy5lbmQgPSBub2RlLmxvYy5lbmQ7XHJcbiAgICAgICAgICAgIHByZXYubG9jLnNvdXJjZSArPSBub2RlLmxvYy5zb3VyY2U7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBub2Rlcy5wdXNoKG5vZGUpO1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlQ0RBVEEoY29udGV4dCwgYW5jZXN0b3JzKSB7XHJcbiAgICBhZHZhbmNlQnkoY29udGV4dCwgOSk7XHJcbiAgICBjb25zdCBub2RlcyA9IHBhcnNlQ2hpbGRyZW4oY29udGV4dCwgMyAvKiBDREFUQSAqLywgYW5jZXN0b3JzKTtcclxuICAgIGlmIChjb250ZXh0LnNvdXJjZS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgNiAvKiBFT0ZfSU5fQ0RBVEEgKi8pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYWR2YW5jZUJ5KGNvbnRleHQsIDMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5vZGVzO1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlQ29tbWVudChjb250ZXh0KSB7XHJcbiAgICBjb25zdCBzdGFydCA9IGdldEN1cnNvcihjb250ZXh0KTtcclxuICAgIGxldCBjb250ZW50O1xyXG4gICAgLy8gUmVndWxhciBjb21tZW50LlxyXG4gICAgY29uc3QgbWF0Y2ggPSAvLS0oXFwhKT8+Ly5leGVjKGNvbnRleHQuc291cmNlKTtcclxuICAgIGlmICghbWF0Y2gpIHtcclxuICAgICAgICBjb250ZW50ID0gY29udGV4dC5zb3VyY2Uuc2xpY2UoNCk7XHJcbiAgICAgICAgYWR2YW5jZUJ5KGNvbnRleHQsIGNvbnRleHQuc291cmNlLmxlbmd0aCk7XHJcbiAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDcgLyogRU9GX0lOX0NPTU1FTlQgKi8pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKG1hdGNoLmluZGV4IDw9IDMpIHtcclxuICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDAgLyogQUJSVVBUX0NMT1NJTkdfT0ZfRU1QVFlfQ09NTUVOVCAqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtYXRjaFsxXSkge1xyXG4gICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMTAgLyogSU5DT1JSRUNUTFlfQ0xPU0VEX0NPTU1FTlQgKi8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb250ZW50ID0gY29udGV4dC5zb3VyY2Uuc2xpY2UoNCwgbWF0Y2guaW5kZXgpO1xyXG4gICAgICAgIC8vIEFkdmFuY2luZyB3aXRoIHJlcG9ydGluZyBuZXN0ZWQgY29tbWVudHMuXHJcbiAgICAgICAgY29uc3QgcyA9IGNvbnRleHQuc291cmNlLnNsaWNlKDAsIG1hdGNoLmluZGV4KTtcclxuICAgICAgICBsZXQgcHJldkluZGV4ID0gMSwgbmVzdGVkSW5kZXggPSAwO1xyXG4gICAgICAgIHdoaWxlICgobmVzdGVkSW5kZXggPSBzLmluZGV4T2YoJzwhLS0nLCBwcmV2SW5kZXgpKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgYWR2YW5jZUJ5KGNvbnRleHQsIG5lc3RlZEluZGV4IC0gcHJldkluZGV4ICsgMSk7XHJcbiAgICAgICAgICAgIGlmIChuZXN0ZWRJbmRleCArIDQgPCBzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDE2IC8qIE5FU1RFRF9DT01NRU5UICovKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwcmV2SW5kZXggPSBuZXN0ZWRJbmRleCArIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFkdmFuY2VCeShjb250ZXh0LCBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCAtIHByZXZJbmRleCArIDEpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAzIC8qIENPTU1FTlQgKi8sXHJcbiAgICAgICAgY29udGVudCxcclxuICAgICAgICBsb2M6IGdldFNlbGVjdGlvbihjb250ZXh0LCBzdGFydClcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VCb2d1c0NvbW1lbnQoY29udGV4dCkge1xyXG4gICAgY29uc3Qgc3RhcnQgPSBnZXRDdXJzb3IoY29udGV4dCk7XHJcbiAgICBjb25zdCBjb250ZW50U3RhcnQgPSBjb250ZXh0LnNvdXJjZVsxXSA9PT0gJz8nID8gMSA6IDI7XHJcbiAgICBsZXQgY29udGVudDtcclxuICAgIGNvbnN0IGNsb3NlSW5kZXggPSBjb250ZXh0LnNvdXJjZS5pbmRleE9mKCc+Jyk7XHJcbiAgICBpZiAoY2xvc2VJbmRleCA9PT0gLTEpIHtcclxuICAgICAgICBjb250ZW50ID0gY29udGV4dC5zb3VyY2Uuc2xpY2UoY29udGVudFN0YXJ0KTtcclxuICAgICAgICBhZHZhbmNlQnkoY29udGV4dCwgY29udGV4dC5zb3VyY2UubGVuZ3RoKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnRlbnQgPSBjb250ZXh0LnNvdXJjZS5zbGljZShjb250ZW50U3RhcnQsIGNsb3NlSW5kZXgpO1xyXG4gICAgICAgIGFkdmFuY2VCeShjb250ZXh0LCBjbG9zZUluZGV4ICsgMSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDMgLyogQ09NTUVOVCAqLyxcclxuICAgICAgICBjb250ZW50LFxyXG4gICAgICAgIGxvYzogZ2V0U2VsZWN0aW9uKGNvbnRleHQsIHN0YXJ0KVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBwYXJzZUVsZW1lbnQoY29udGV4dCwgYW5jZXN0b3JzKSB7XHJcbiAgICAvLyBTdGFydCB0YWcuXHJcbiAgICBjb25zdCB3YXNJblByZSA9IGNvbnRleHQuaW5QcmU7XHJcbiAgICBjb25zdCB3YXNJblZQcmUgPSBjb250ZXh0LmluVlByZTtcclxuICAgIGNvbnN0IHBhcmVudCA9IGxhc3QoYW5jZXN0b3JzKTtcclxuICAgIGNvbnN0IGVsZW1lbnQgPSBwYXJzZVRhZyhjb250ZXh0LCAwIC8qIFN0YXJ0ICovLCBwYXJlbnQpO1xyXG4gICAgY29uc3QgaXNQcmVCb3VuZGFyeSA9IGNvbnRleHQuaW5QcmUgJiYgIXdhc0luUHJlO1xyXG4gICAgY29uc3QgaXNWUHJlQm91bmRhcnkgPSBjb250ZXh0LmluVlByZSAmJiAhd2FzSW5WUHJlO1xyXG4gICAgaWYgKGVsZW1lbnQuaXNTZWxmQ2xvc2luZyB8fCBjb250ZXh0Lm9wdGlvbnMuaXNWb2lkVGFnKGVsZW1lbnQudGFnKSkge1xyXG4gICAgICAgIC8vICM0MDMwIHNlbGYtY2xvc2luZyA8cHJlPiB0YWdcclxuICAgICAgICBpZiAoaXNQcmVCb3VuZGFyeSkge1xyXG4gICAgICAgICAgICBjb250ZXh0LmluUHJlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc1ZQcmVCb3VuZGFyeSkge1xyXG4gICAgICAgICAgICBjb250ZXh0LmluVlByZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZWxlbWVudDtcclxuICAgIH1cclxuICAgIC8vIENoaWxkcmVuLlxyXG4gICAgYW5jZXN0b3JzLnB1c2goZWxlbWVudCk7XHJcbiAgICBjb25zdCBtb2RlID0gY29udGV4dC5vcHRpb25zLmdldFRleHRNb2RlKGVsZW1lbnQsIHBhcmVudCk7XHJcbiAgICBjb25zdCBjaGlsZHJlbiA9IHBhcnNlQ2hpbGRyZW4oY29udGV4dCwgbW9kZSwgYW5jZXN0b3JzKTtcclxuICAgIGFuY2VzdG9ycy5wb3AoKTtcclxuICAgIC8vIDIueCBpbmxpbmUtdGVtcGxhdGUgY29tcGF0XHJcbiAgICB7XHJcbiAgICAgICAgY29uc3QgaW5saW5lVGVtcGxhdGVQcm9wID0gZWxlbWVudC5wcm9wcy5maW5kKHAgPT4gcC50eXBlID09PSA2IC8qIEFUVFJJQlVURSAqLyAmJiBwLm5hbWUgPT09ICdpbmxpbmUtdGVtcGxhdGUnKTtcclxuICAgICAgICBpZiAoaW5saW5lVGVtcGxhdGVQcm9wICYmXHJcbiAgICAgICAgICAgIGNoZWNrQ29tcGF0RW5hYmxlZChcIkNPTVBJTEVSX0lOTElORV9URU1QTEFURVwiIC8qIENPTVBJTEVSX0lOTElORV9URU1QTEFURSAqLywgY29udGV4dCwgaW5saW5lVGVtcGxhdGVQcm9wLmxvYykpIHtcclxuICAgICAgICAgICAgY29uc3QgbG9jID0gZ2V0U2VsZWN0aW9uKGNvbnRleHQsIGVsZW1lbnQubG9jLmVuZCk7XHJcbiAgICAgICAgICAgIGlubGluZVRlbXBsYXRlUHJvcC52YWx1ZSA9IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IDIgLyogVEVYVCAqLyxcclxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGxvYy5zb3VyY2UsXHJcbiAgICAgICAgICAgICAgICBsb2NcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbGVtZW50LmNoaWxkcmVuID0gY2hpbGRyZW47XHJcbiAgICAvLyBFbmQgdGFnLlxyXG4gICAgaWYgKHN0YXJ0c1dpdGhFbmRUYWdPcGVuKGNvbnRleHQuc291cmNlLCBlbGVtZW50LnRhZykpIHtcclxuICAgICAgICBwYXJzZVRhZyhjb250ZXh0LCAxIC8qIEVuZCAqLywgcGFyZW50KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAyNCAvKiBYX01JU1NJTkdfRU5EX1RBRyAqLywgMCwgZWxlbWVudC5sb2Muc3RhcnQpO1xyXG4gICAgICAgIGlmIChjb250ZXh0LnNvdXJjZS5sZW5ndGggPT09IDAgJiYgZWxlbWVudC50YWcudG9Mb3dlckNhc2UoKSA9PT0gJ3NjcmlwdCcpIHtcclxuICAgICAgICAgICAgY29uc3QgZmlyc3QgPSBjaGlsZHJlblswXTtcclxuICAgICAgICAgICAgaWYgKGZpcnN0ICYmIHN0YXJ0c1dpdGgoZmlyc3QubG9jLnNvdXJjZSwgJzwhLS0nKSkge1xyXG4gICAgICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDggLyogRU9GX0lOX1NDUklQVF9IVE1MX0NPTU1FTlRfTElLRV9URVhUICovKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsZW1lbnQubG9jID0gZ2V0U2VsZWN0aW9uKGNvbnRleHQsIGVsZW1lbnQubG9jLnN0YXJ0KTtcclxuICAgIGlmIChpc1ByZUJvdW5kYXJ5KSB7XHJcbiAgICAgICAgY29udGV4dC5pblByZSA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzVlByZUJvdW5kYXJ5KSB7XHJcbiAgICAgICAgY29udGV4dC5pblZQcmUgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiBlbGVtZW50O1xyXG59XHJcbmNvbnN0IGlzU3BlY2lhbFRlbXBsYXRlRGlyZWN0aXZlID0gLyojX19QVVJFX18qLyBtYWtlTWFwKGBpZixlbHNlLGVsc2UtaWYsZm9yLHNsb3RgKTtcclxuZnVuY3Rpb24gcGFyc2VUYWcoY29udGV4dCwgdHlwZSwgcGFyZW50KSB7XHJcbiAgICAvLyBUYWcgb3Blbi5cclxuICAgIGNvbnN0IHN0YXJ0ID0gZ2V0Q3Vyc29yKGNvbnRleHQpO1xyXG4gICAgY29uc3QgbWF0Y2ggPSAvXjxcXC8/KFthLXpdW15cXHRcXHJcXG5cXGYgLz5dKikvaS5leGVjKGNvbnRleHQuc291cmNlKTtcclxuICAgIGNvbnN0IHRhZyA9IG1hdGNoWzFdO1xyXG4gICAgY29uc3QgbnMgPSBjb250ZXh0Lm9wdGlvbnMuZ2V0TmFtZXNwYWNlKHRhZywgcGFyZW50KTtcclxuICAgIGFkdmFuY2VCeShjb250ZXh0LCBtYXRjaFswXS5sZW5ndGgpO1xyXG4gICAgYWR2YW5jZVNwYWNlcyhjb250ZXh0KTtcclxuICAgIC8vIHNhdmUgY3VycmVudCBzdGF0ZSBpbiBjYXNlIHdlIG5lZWQgdG8gcmUtcGFyc2UgYXR0cmlidXRlcyB3aXRoIHYtcHJlXHJcbiAgICBjb25zdCBjdXJzb3IgPSBnZXRDdXJzb3IoY29udGV4dCk7XHJcbiAgICBjb25zdCBjdXJyZW50U291cmNlID0gY29udGV4dC5zb3VyY2U7XHJcbiAgICAvLyBjaGVjayA8cHJlPiB0YWdcclxuICAgIGlmIChjb250ZXh0Lm9wdGlvbnMuaXNQcmVUYWcodGFnKSkge1xyXG4gICAgICAgIGNvbnRleHQuaW5QcmUgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgLy8gQXR0cmlidXRlcy5cclxuICAgIGxldCBwcm9wcyA9IHBhcnNlQXR0cmlidXRlcyhjb250ZXh0LCB0eXBlKTtcclxuICAgIC8vIGNoZWNrIHYtcHJlXHJcbiAgICBpZiAodHlwZSA9PT0gMCAvKiBTdGFydCAqLyAmJlxyXG4gICAgICAgICFjb250ZXh0LmluVlByZSAmJlxyXG4gICAgICAgIHByb3BzLnNvbWUocCA9PiBwLnR5cGUgPT09IDcgLyogRElSRUNUSVZFICovICYmIHAubmFtZSA9PT0gJ3ByZScpKSB7XHJcbiAgICAgICAgY29udGV4dC5pblZQcmUgPSB0cnVlO1xyXG4gICAgICAgIC8vIHJlc2V0IGNvbnRleHRcclxuICAgICAgICBleHRlbmQoY29udGV4dCwgY3Vyc29yKTtcclxuICAgICAgICBjb250ZXh0LnNvdXJjZSA9IGN1cnJlbnRTb3VyY2U7XHJcbiAgICAgICAgLy8gcmUtcGFyc2UgYXR0cnMgYW5kIGZpbHRlciBvdXQgdi1wcmUgaXRzZWxmXHJcbiAgICAgICAgcHJvcHMgPSBwYXJzZUF0dHJpYnV0ZXMoY29udGV4dCwgdHlwZSkuZmlsdGVyKHAgPT4gcC5uYW1lICE9PSAndi1wcmUnKTtcclxuICAgIH1cclxuICAgIC8vIFRhZyBjbG9zZS5cclxuICAgIGxldCBpc1NlbGZDbG9zaW5nID0gZmFsc2U7XHJcbiAgICBpZiAoY29udGV4dC5zb3VyY2UubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDkgLyogRU9GX0lOX1RBRyAqLyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpc1NlbGZDbG9zaW5nID0gc3RhcnRzV2l0aChjb250ZXh0LnNvdXJjZSwgJy8+Jyk7XHJcbiAgICAgICAgaWYgKHR5cGUgPT09IDEgLyogRW5kICovICYmIGlzU2VsZkNsb3NpbmcpIHtcclxuICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDQgLyogRU5EX1RBR19XSVRIX1RSQUlMSU5HX1NPTElEVVMgKi8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhZHZhbmNlQnkoY29udGV4dCwgaXNTZWxmQ2xvc2luZyA/IDIgOiAxKTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlID09PSAxIC8qIEVuZCAqLykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIC8vIDIueCBkZXByZWNhdGlvbiBjaGVja3NcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICBpc0NvbXBhdEVuYWJsZWQoXCJDT01QSUxFUl9WX0lGX1ZfRk9SX1BSRUNFREVOQ0VcIiAvKiBDT01QSUxFUl9WX0lGX1ZfRk9SX1BSRUNFREVOQ0UgKi8sIGNvbnRleHQpKSB7XHJcbiAgICAgICAgbGV0IGhhc0lmID0gZmFsc2U7XHJcbiAgICAgICAgbGV0IGhhc0ZvciA9IGZhbHNlO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgcCA9IHByb3BzW2ldO1xyXG4gICAgICAgICAgICBpZiAocC50eXBlID09PSA3IC8qIERJUkVDVElWRSAqLykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHAubmFtZSA9PT0gJ2lmJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGhhc0lmID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHAubmFtZSA9PT0gJ2ZvcicpIHtcclxuICAgICAgICAgICAgICAgICAgICBoYXNGb3IgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChoYXNJZiAmJiBoYXNGb3IpIHtcclxuICAgICAgICAgICAgICAgIHdhcm5EZXByZWNhdGlvbihcIkNPTVBJTEVSX1ZfSUZfVl9GT1JfUFJFQ0VERU5DRVwiIC8qIENPTVBJTEVSX1ZfSUZfVl9GT1JfUFJFQ0VERU5DRSAqLywgY29udGV4dCwgZ2V0U2VsZWN0aW9uKGNvbnRleHQsIHN0YXJ0KSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGxldCB0YWdUeXBlID0gMCAvKiBFTEVNRU5UICovO1xyXG4gICAgaWYgKCFjb250ZXh0LmluVlByZSkge1xyXG4gICAgICAgIGlmICh0YWcgPT09ICdzbG90Jykge1xyXG4gICAgICAgICAgICB0YWdUeXBlID0gMiAvKiBTTE9UICovO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0YWcgPT09ICd0ZW1wbGF0ZScpIHtcclxuICAgICAgICAgICAgaWYgKHByb3BzLnNvbWUocCA9PiBwLnR5cGUgPT09IDcgLyogRElSRUNUSVZFICovICYmIGlzU3BlY2lhbFRlbXBsYXRlRGlyZWN0aXZlKHAubmFtZSkpKSB7XHJcbiAgICAgICAgICAgICAgICB0YWdUeXBlID0gMyAvKiBURU1QTEFURSAqLztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc0NvbXBvbmVudCh0YWcsIHByb3BzLCBjb250ZXh0KSkge1xyXG4gICAgICAgICAgICB0YWdUeXBlID0gMSAvKiBDT01QT05FTlQgKi87XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAxIC8qIEVMRU1FTlQgKi8sXHJcbiAgICAgICAgbnMsXHJcbiAgICAgICAgdGFnLFxyXG4gICAgICAgIHRhZ1R5cGUsXHJcbiAgICAgICAgcHJvcHMsXHJcbiAgICAgICAgaXNTZWxmQ2xvc2luZyxcclxuICAgICAgICBjaGlsZHJlbjogW10sXHJcbiAgICAgICAgbG9jOiBnZXRTZWxlY3Rpb24oY29udGV4dCwgc3RhcnQpLFxyXG4gICAgICAgIGNvZGVnZW5Ob2RlOiB1bmRlZmluZWQgLy8gdG8gYmUgY3JlYXRlZCBkdXJpbmcgdHJhbnNmb3JtIHBoYXNlXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGlzQ29tcG9uZW50KHRhZywgcHJvcHMsIGNvbnRleHQpIHtcclxuICAgIGNvbnN0IG9wdGlvbnMgPSBjb250ZXh0Lm9wdGlvbnM7XHJcbiAgICBpZiAob3B0aW9ucy5pc0N1c3RvbUVsZW1lbnQodGFnKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmICh0YWcgPT09ICdjb21wb25lbnQnIHx8XHJcbiAgICAgICAgL15bQS1aXS8udGVzdCh0YWcpIHx8XHJcbiAgICAgICAgaXNDb3JlQ29tcG9uZW50KHRhZykgfHxcclxuICAgICAgICAob3B0aW9ucy5pc0J1aWx0SW5Db21wb25lbnQgJiYgb3B0aW9ucy5pc0J1aWx0SW5Db21wb25lbnQodGFnKSkgfHxcclxuICAgICAgICAob3B0aW9ucy5pc05hdGl2ZVRhZyAmJiAhb3B0aW9ucy5pc05hdGl2ZVRhZyh0YWcpKSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgLy8gYXQgdGhpcyBwb2ludCB0aGUgdGFnIHNob3VsZCBiZSBhIG5hdGl2ZSB0YWcsIGJ1dCBjaGVjayBmb3IgcG90ZW50aWFsIFwiaXNcIlxyXG4gICAgLy8gY2FzdGluZ1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHAgPSBwcm9wc1tpXTtcclxuICAgICAgICBpZiAocC50eXBlID09PSA2IC8qIEFUVFJJQlVURSAqLykge1xyXG4gICAgICAgICAgICBpZiAocC5uYW1lID09PSAnaXMnICYmIHAudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwLnZhbHVlLmNvbnRlbnQuc3RhcnRzV2l0aCgndnVlOicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGVja0NvbXBhdEVuYWJsZWQoXCJDT01QSUxFUl9JU19PTl9FTEVNRU5UXCIgLyogQ09NUElMRVJfSVNfT05fRUxFTUVOVCAqLywgY29udGV4dCwgcC5sb2MpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGRpcmVjdGl2ZVxyXG4gICAgICAgICAgICAvLyB2LWlzIChUT0RPIERlcHJlY2F0ZSlcclxuICAgICAgICAgICAgaWYgKHAubmFtZSA9PT0gJ2lzJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoXHJcbiAgICAgICAgICAgIC8vIDppcyBvbiBwbGFpbiBlbGVtZW50IC0gb25seSB0cmVhdCBhcyBjb21wb25lbnQgaW4gY29tcGF0IG1vZGVcclxuICAgICAgICAgICAgcC5uYW1lID09PSAnYmluZCcgJiZcclxuICAgICAgICAgICAgICAgIGlzU3RhdGljQXJnT2YocC5hcmcsICdpcycpICYmXHJcbiAgICAgICAgICAgICAgICB0cnVlICYmXHJcbiAgICAgICAgICAgICAgICBjaGVja0NvbXBhdEVuYWJsZWQoXCJDT01QSUxFUl9JU19PTl9FTEVNRU5UXCIgLyogQ09NUElMRVJfSVNfT05fRUxFTUVOVCAqLywgY29udGV4dCwgcC5sb2MpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBwYXJzZUF0dHJpYnV0ZXMoY29udGV4dCwgdHlwZSkge1xyXG4gICAgY29uc3QgcHJvcHMgPSBbXTtcclxuICAgIGNvbnN0IGF0dHJpYnV0ZU5hbWVzID0gbmV3IFNldCgpO1xyXG4gICAgd2hpbGUgKGNvbnRleHQuc291cmNlLmxlbmd0aCA+IDAgJiZcclxuICAgICAgICAhc3RhcnRzV2l0aChjb250ZXh0LnNvdXJjZSwgJz4nKSAmJlxyXG4gICAgICAgICFzdGFydHNXaXRoKGNvbnRleHQuc291cmNlLCAnLz4nKSkge1xyXG4gICAgICAgIGlmIChzdGFydHNXaXRoKGNvbnRleHQuc291cmNlLCAnLycpKSB7XHJcbiAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAyMiAvKiBVTkVYUEVDVEVEX1NPTElEVVNfSU5fVEFHICovKTtcclxuICAgICAgICAgICAgYWR2YW5jZUJ5KGNvbnRleHQsIDEpO1xyXG4gICAgICAgICAgICBhZHZhbmNlU3BhY2VzKGNvbnRleHQpO1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGUgPT09IDEgLyogRW5kICovKSB7XHJcbiAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAzIC8qIEVORF9UQUdfV0lUSF9BVFRSSUJVVEVTICovKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYXR0ciA9IHBhcnNlQXR0cmlidXRlKGNvbnRleHQsIGF0dHJpYnV0ZU5hbWVzKTtcclxuICAgICAgICAvLyBUcmltIHdoaXRlc3BhY2UgYmV0d2VlbiBjbGFzc1xyXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy9jb3JlL2lzc3Vlcy80MjUxXHJcbiAgICAgICAgaWYgKGF0dHIudHlwZSA9PT0gNiAvKiBBVFRSSUJVVEUgKi8gJiZcclxuICAgICAgICAgICAgYXR0ci52YWx1ZSAmJlxyXG4gICAgICAgICAgICBhdHRyLm5hbWUgPT09ICdjbGFzcycpIHtcclxuICAgICAgICAgICAgYXR0ci52YWx1ZS5jb250ZW50ID0gYXR0ci52YWx1ZS5jb250ZW50LnJlcGxhY2UoL1xccysvZywgJyAnKS50cmltKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlID09PSAwIC8qIFN0YXJ0ICovKSB7XHJcbiAgICAgICAgICAgIHByb3BzLnB1c2goYXR0cik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgvXlteXFx0XFxyXFxuXFxmIC8+XS8udGVzdChjb250ZXh0LnNvdXJjZSkpIHtcclxuICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDE1IC8qIE1JU1NJTkdfV0hJVEVTUEFDRV9CRVRXRUVOX0FUVFJJQlVURVMgKi8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhZHZhbmNlU3BhY2VzKGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByb3BzO1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlQXR0cmlidXRlKGNvbnRleHQsIG5hbWVTZXQpIHtcclxuICAgIC8vIE5hbWUuXHJcbiAgICBjb25zdCBzdGFydCA9IGdldEN1cnNvcihjb250ZXh0KTtcclxuICAgIGNvbnN0IG1hdGNoID0gL15bXlxcdFxcclxcblxcZiAvPl1bXlxcdFxcclxcblxcZiAvPj1dKi8uZXhlYyhjb250ZXh0LnNvdXJjZSk7XHJcbiAgICBjb25zdCBuYW1lID0gbWF0Y2hbMF07XHJcbiAgICBpZiAobmFtZVNldC5oYXMobmFtZSkpIHtcclxuICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMiAvKiBEVVBMSUNBVEVfQVRUUklCVVRFICovKTtcclxuICAgIH1cclxuICAgIG5hbWVTZXQuYWRkKG5hbWUpO1xyXG4gICAgaWYgKG5hbWVbMF0gPT09ICc9Jykge1xyXG4gICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAxOSAvKiBVTkVYUEVDVEVEX0VRVUFMU19TSUdOX0JFRk9SRV9BVFRSSUJVVEVfTkFNRSAqLyk7XHJcbiAgICB9XHJcbiAgICB7XHJcbiAgICAgICAgY29uc3QgcGF0dGVybiA9IC9bXCInPF0vZztcclxuICAgICAgICBsZXQgbTtcclxuICAgICAgICB3aGlsZSAoKG0gPSBwYXR0ZXJuLmV4ZWMobmFtZSkpKSB7XHJcbiAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAxNyAvKiBVTkVYUEVDVEVEX0NIQVJBQ1RFUl9JTl9BVFRSSUJVVEVfTkFNRSAqLywgbS5pbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYWR2YW5jZUJ5KGNvbnRleHQsIG5hbWUubGVuZ3RoKTtcclxuICAgIC8vIFZhbHVlXHJcbiAgICBsZXQgdmFsdWUgPSB1bmRlZmluZWQ7XHJcbiAgICBpZiAoL15bXFx0XFxyXFxuXFxmIF0qPS8udGVzdChjb250ZXh0LnNvdXJjZSkpIHtcclxuICAgICAgICBhZHZhbmNlU3BhY2VzKGNvbnRleHQpO1xyXG4gICAgICAgIGFkdmFuY2VCeShjb250ZXh0LCAxKTtcclxuICAgICAgICBhZHZhbmNlU3BhY2VzKGNvbnRleHQpO1xyXG4gICAgICAgIHZhbHVlID0gcGFyc2VBdHRyaWJ1dGVWYWx1ZShjb250ZXh0KTtcclxuICAgICAgICBpZiAoIXZhbHVlKSB7XHJcbiAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAxMyAvKiBNSVNTSU5HX0FUVFJJQlVURV9WQUxVRSAqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgbG9jID0gZ2V0U2VsZWN0aW9uKGNvbnRleHQsIHN0YXJ0KTtcclxuICAgIGlmICghY29udGV4dC5pblZQcmUgJiYgL14odi1bQS1aYS16MC05LV18OnxcXC58QHwjKS8udGVzdChuYW1lKSkge1xyXG4gICAgICAgIGNvbnN0IG1hdGNoID0gLyg/Ol52LShbYS16MC05LV0rKSk/KD86KD86OnxeXFwufF5AfF4jKShcXFtbXlxcXV0rXFxdfFteXFwuXSspKT8oLispPyQvaS5leGVjKG5hbWUpO1xyXG4gICAgICAgIGxldCBpc1Byb3BTaG9ydGhhbmQgPSBzdGFydHNXaXRoKG5hbWUsICcuJyk7XHJcbiAgICAgICAgbGV0IGRpck5hbWUgPSBtYXRjaFsxXSB8fFxyXG4gICAgICAgICAgICAoaXNQcm9wU2hvcnRoYW5kIHx8IHN0YXJ0c1dpdGgobmFtZSwgJzonKVxyXG4gICAgICAgICAgICAgICAgPyAnYmluZCdcclxuICAgICAgICAgICAgICAgIDogc3RhcnRzV2l0aChuYW1lLCAnQCcpXHJcbiAgICAgICAgICAgICAgICAgICAgPyAnb24nXHJcbiAgICAgICAgICAgICAgICAgICAgOiAnc2xvdCcpO1xyXG4gICAgICAgIGxldCBhcmc7XHJcbiAgICAgICAgaWYgKG1hdGNoWzJdKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzU2xvdCA9IGRpck5hbWUgPT09ICdzbG90JztcclxuICAgICAgICAgICAgY29uc3Qgc3RhcnRPZmZzZXQgPSBuYW1lLmxhc3RJbmRleE9mKG1hdGNoWzJdKTtcclxuICAgICAgICAgICAgY29uc3QgbG9jID0gZ2V0U2VsZWN0aW9uKGNvbnRleHQsIGdldE5ld1Bvc2l0aW9uKGNvbnRleHQsIHN0YXJ0LCBzdGFydE9mZnNldCksIGdldE5ld1Bvc2l0aW9uKGNvbnRleHQsIHN0YXJ0LCBzdGFydE9mZnNldCArIG1hdGNoWzJdLmxlbmd0aCArICgoaXNTbG90ICYmIG1hdGNoWzNdKSB8fCAnJykubGVuZ3RoKSk7XHJcbiAgICAgICAgICAgIGxldCBjb250ZW50ID0gbWF0Y2hbMl07XHJcbiAgICAgICAgICAgIGxldCBpc1N0YXRpYyA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmIChjb250ZW50LnN0YXJ0c1dpdGgoJ1snKSkge1xyXG4gICAgICAgICAgICAgICAgaXNTdGF0aWMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGlmICghY29udGVudC5lbmRzV2l0aCgnXScpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDI3IC8qIFhfTUlTU0lOR19EWU5BTUlDX0RJUkVDVElWRV9BUkdVTUVOVF9FTkQgKi8pO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50LnNsaWNlKDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuc2xpY2UoMSwgY29udGVudC5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc1Nsb3QpIHtcclxuICAgICAgICAgICAgICAgIC8vICMxMjQxIHNwZWNpYWwgY2FzZSBmb3Igdi1zbG90OiB2dWV0aWZ5IHJlbGllcyBleHRlbnNpdmVseSBvbiBzbG90XHJcbiAgICAgICAgICAgICAgICAvLyBuYW1lcyBjb250YWluaW5nIGRvdHMuIHYtc2xvdCBkb2Vzbid0IGhhdmUgYW55IG1vZGlmaWVycyBhbmQgVnVlIDIueFxyXG4gICAgICAgICAgICAgICAgLy8gc3VwcG9ydHMgc3VjaCB1c2FnZSBzbyB3ZSBhcmUga2VlcGluZyBpdCBjb25zaXN0ZW50IHdpdGggMi54LlxyXG4gICAgICAgICAgICAgICAgY29udGVudCArPSBtYXRjaFszXSB8fCAnJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhcmcgPSB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovLFxyXG4gICAgICAgICAgICAgICAgY29udGVudCxcclxuICAgICAgICAgICAgICAgIGlzU3RhdGljLFxyXG4gICAgICAgICAgICAgICAgY29uc3RUeXBlOiBpc1N0YXRpY1xyXG4gICAgICAgICAgICAgICAgICAgID8gMyAvKiBDQU5fU1RSSU5HSUZZICovXHJcbiAgICAgICAgICAgICAgICAgICAgOiAwIC8qIE5PVF9DT05TVEFOVCAqLyxcclxuICAgICAgICAgICAgICAgIGxvY1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWUuaXNRdW90ZWQpIHtcclxuICAgICAgICAgICAgY29uc3QgdmFsdWVMb2MgPSB2YWx1ZS5sb2M7XHJcbiAgICAgICAgICAgIHZhbHVlTG9jLnN0YXJ0Lm9mZnNldCsrO1xyXG4gICAgICAgICAgICB2YWx1ZUxvYy5zdGFydC5jb2x1bW4rKztcclxuICAgICAgICAgICAgdmFsdWVMb2MuZW5kID0gYWR2YW5jZVBvc2l0aW9uV2l0aENsb25lKHZhbHVlTG9jLnN0YXJ0LCB2YWx1ZS5jb250ZW50KTtcclxuICAgICAgICAgICAgdmFsdWVMb2Muc291cmNlID0gdmFsdWVMb2Muc291cmNlLnNsaWNlKDEsIC0xKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbW9kaWZpZXJzID0gbWF0Y2hbM10gPyBtYXRjaFszXS5zbGljZSgxKS5zcGxpdCgnLicpIDogW107XHJcbiAgICAgICAgaWYgKGlzUHJvcFNob3J0aGFuZClcclxuICAgICAgICAgICAgbW9kaWZpZXJzLnB1c2goJ3Byb3AnKTtcclxuICAgICAgICAvLyAyLnggY29tcGF0IHYtYmluZDpmb28uc3luYyAtPiB2LW1vZGVsOmZvb1xyXG4gICAgICAgIGlmIChkaXJOYW1lID09PSAnYmluZCcgJiYgYXJnKSB7XHJcbiAgICAgICAgICAgIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoJ3N5bmMnKSAmJlxyXG4gICAgICAgICAgICAgICAgY2hlY2tDb21wYXRFbmFibGVkKFwiQ09NUElMRVJfVl9CSU5EX1NZTkNcIiAvKiBDT01QSUxFUl9WX0JJTkRfU1lOQyAqLywgY29udGV4dCwgbG9jLCBhcmcubG9jLnNvdXJjZSkpIHtcclxuICAgICAgICAgICAgICAgIGRpck5hbWUgPSAnbW9kZWwnO1xyXG4gICAgICAgICAgICAgICAgbW9kaWZpZXJzLnNwbGljZShtb2RpZmllcnMuaW5kZXhPZignc3luYycpLCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIG1vZGlmaWVycy5pbmNsdWRlcygncHJvcCcpKSB7XHJcbiAgICAgICAgICAgICAgICBjaGVja0NvbXBhdEVuYWJsZWQoXCJDT01QSUxFUl9WX0JJTkRfUFJPUFwiIC8qIENPTVBJTEVSX1ZfQklORF9QUk9QICovLCBjb250ZXh0LCBsb2MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHR5cGU6IDcgLyogRElSRUNUSVZFICovLFxyXG4gICAgICAgICAgICBuYW1lOiBkaXJOYW1lLFxyXG4gICAgICAgICAgICBleHA6IHZhbHVlICYmIHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8sXHJcbiAgICAgICAgICAgICAgICBjb250ZW50OiB2YWx1ZS5jb250ZW50LFxyXG4gICAgICAgICAgICAgICAgaXNTdGF0aWM6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgLy8gVHJlYXQgYXMgbm9uLWNvbnN0YW50IGJ5IGRlZmF1bHQuIFRoaXMgY2FuIGJlIHBvdGVudGlhbGx5IHNldCB0b1xyXG4gICAgICAgICAgICAgICAgLy8gb3RoZXIgdmFsdWVzIGJ5IGB0cmFuc2Zvcm1FeHByZXNzaW9uYCB0byBtYWtlIGl0IGVsaWdpYmxlIGZvciBob2lzdGluZy5cclxuICAgICAgICAgICAgICAgIGNvbnN0VHlwZTogMCAvKiBOT1RfQ09OU1RBTlQgKi8sXHJcbiAgICAgICAgICAgICAgICBsb2M6IHZhbHVlLmxvY1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhcmcsXHJcbiAgICAgICAgICAgIG1vZGlmaWVycyxcclxuICAgICAgICAgICAgbG9jXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8vIG1pc3NpbmcgZGlyZWN0aXZlIG5hbWUgb3IgaWxsZWdhbCBkaXJlY3RpdmUgbmFtZVxyXG4gICAgaWYgKCFjb250ZXh0LmluVlByZSAmJiBzdGFydHNXaXRoKG5hbWUsICd2LScpKSB7XHJcbiAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDI2IC8qIFhfTUlTU0lOR19ESVJFQ1RJVkVfTkFNRSAqLyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDYgLyogQVRUUklCVVRFICovLFxyXG4gICAgICAgIG5hbWUsXHJcbiAgICAgICAgdmFsdWU6IHZhbHVlICYmIHtcclxuICAgICAgICAgICAgdHlwZTogMiAvKiBURVhUICovLFxyXG4gICAgICAgICAgICBjb250ZW50OiB2YWx1ZS5jb250ZW50LFxyXG4gICAgICAgICAgICBsb2M6IHZhbHVlLmxvY1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbG9jXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlQXR0cmlidXRlVmFsdWUoY29udGV4dCkge1xyXG4gICAgY29uc3Qgc3RhcnQgPSBnZXRDdXJzb3IoY29udGV4dCk7XHJcbiAgICBsZXQgY29udGVudDtcclxuICAgIGNvbnN0IHF1b3RlID0gY29udGV4dC5zb3VyY2VbMF07XHJcbiAgICBjb25zdCBpc1F1b3RlZCA9IHF1b3RlID09PSBgXCJgIHx8IHF1b3RlID09PSBgJ2A7XHJcbiAgICBpZiAoaXNRdW90ZWQpIHtcclxuICAgICAgICAvLyBRdW90ZWQgdmFsdWUuXHJcbiAgICAgICAgYWR2YW5jZUJ5KGNvbnRleHQsIDEpO1xyXG4gICAgICAgIGNvbnN0IGVuZEluZGV4ID0gY29udGV4dC5zb3VyY2UuaW5kZXhPZihxdW90ZSk7XHJcbiAgICAgICAgaWYgKGVuZEluZGV4ID09PSAtMSkge1xyXG4gICAgICAgICAgICBjb250ZW50ID0gcGFyc2VUZXh0RGF0YShjb250ZXh0LCBjb250ZXh0LnNvdXJjZS5sZW5ndGgsIDQgLyogQVRUUklCVVRFX1ZBTFVFICovKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnRlbnQgPSBwYXJzZVRleHREYXRhKGNvbnRleHQsIGVuZEluZGV4LCA0IC8qIEFUVFJJQlVURV9WQUxVRSAqLyk7XHJcbiAgICAgICAgICAgIGFkdmFuY2VCeShjb250ZXh0LCAxKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBVbnF1b3RlZFxyXG4gICAgICAgIGNvbnN0IG1hdGNoID0gL15bXlxcdFxcclxcblxcZiA+XSsvLmV4ZWMoY29udGV4dC5zb3VyY2UpO1xyXG4gICAgICAgIGlmICghbWF0Y2gpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdW5leHBlY3RlZENoYXJzID0gL1tcIic8PWBdL2c7XHJcbiAgICAgICAgbGV0IG07XHJcbiAgICAgICAgd2hpbGUgKChtID0gdW5leHBlY3RlZENoYXJzLmV4ZWMobWF0Y2hbMF0pKSkge1xyXG4gICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMTggLyogVU5FWFBFQ1RFRF9DSEFSQUNURVJfSU5fVU5RVU9URURfQVRUUklCVVRFX1ZBTFVFICovLCBtLmluZGV4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29udGVudCA9IHBhcnNlVGV4dERhdGEoY29udGV4dCwgbWF0Y2hbMF0ubGVuZ3RoLCA0IC8qIEFUVFJJQlVURV9WQUxVRSAqLyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyBjb250ZW50LCBpc1F1b3RlZCwgbG9jOiBnZXRTZWxlY3Rpb24oY29udGV4dCwgc3RhcnQpIH07XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VJbnRlcnBvbGF0aW9uKGNvbnRleHQsIG1vZGUpIHtcclxuICAgIGNvbnN0IFtvcGVuLCBjbG9zZV0gPSBjb250ZXh0Lm9wdGlvbnMuZGVsaW1pdGVycztcclxuICAgIGNvbnN0IGNsb3NlSW5kZXggPSBjb250ZXh0LnNvdXJjZS5pbmRleE9mKGNsb3NlLCBvcGVuLmxlbmd0aCk7XHJcbiAgICBpZiAoY2xvc2VJbmRleCA9PT0gLTEpIHtcclxuICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMjUgLyogWF9NSVNTSU5HX0lOVEVSUE9MQVRJT05fRU5EICovKTtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgc3RhcnQgPSBnZXRDdXJzb3IoY29udGV4dCk7XHJcbiAgICBhZHZhbmNlQnkoY29udGV4dCwgb3Blbi5sZW5ndGgpO1xyXG4gICAgY29uc3QgaW5uZXJTdGFydCA9IGdldEN1cnNvcihjb250ZXh0KTtcclxuICAgIGNvbnN0IGlubmVyRW5kID0gZ2V0Q3Vyc29yKGNvbnRleHQpO1xyXG4gICAgY29uc3QgcmF3Q29udGVudExlbmd0aCA9IGNsb3NlSW5kZXggLSBvcGVuLmxlbmd0aDtcclxuICAgIGNvbnN0IHJhd0NvbnRlbnQgPSBjb250ZXh0LnNvdXJjZS5zbGljZSgwLCByYXdDb250ZW50TGVuZ3RoKTtcclxuICAgIGNvbnN0IHByZVRyaW1Db250ZW50ID0gcGFyc2VUZXh0RGF0YShjb250ZXh0LCByYXdDb250ZW50TGVuZ3RoLCBtb2RlKTtcclxuICAgIGNvbnN0IGNvbnRlbnQgPSBwcmVUcmltQ29udGVudC50cmltKCk7XHJcbiAgICBjb25zdCBzdGFydE9mZnNldCA9IHByZVRyaW1Db250ZW50LmluZGV4T2YoY29udGVudCk7XHJcbiAgICBpZiAoc3RhcnRPZmZzZXQgPiAwKSB7XHJcbiAgICAgICAgYWR2YW5jZVBvc2l0aW9uV2l0aE11dGF0aW9uKGlubmVyU3RhcnQsIHJhd0NvbnRlbnQsIHN0YXJ0T2Zmc2V0KTtcclxuICAgIH1cclxuICAgIGNvbnN0IGVuZE9mZnNldCA9IHJhd0NvbnRlbnRMZW5ndGggLSAocHJlVHJpbUNvbnRlbnQubGVuZ3RoIC0gY29udGVudC5sZW5ndGggLSBzdGFydE9mZnNldCk7XHJcbiAgICBhZHZhbmNlUG9zaXRpb25XaXRoTXV0YXRpb24oaW5uZXJFbmQsIHJhd0NvbnRlbnQsIGVuZE9mZnNldCk7XHJcbiAgICBhZHZhbmNlQnkoY29udGV4dCwgY2xvc2UubGVuZ3RoKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogNSAvKiBJTlRFUlBPTEFUSU9OICovLFxyXG4gICAgICAgIGNvbnRlbnQ6IHtcclxuICAgICAgICAgICAgdHlwZTogNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLyxcclxuICAgICAgICAgICAgaXNTdGF0aWM6IGZhbHNlLFxyXG4gICAgICAgICAgICAvLyBTZXQgYGlzQ29uc3RhbnRgIHRvIGZhbHNlIGJ5IGRlZmF1bHQgYW5kIHdpbGwgZGVjaWRlIGluIHRyYW5zZm9ybUV4cHJlc3Npb25cclxuICAgICAgICAgICAgY29uc3RUeXBlOiAwIC8qIE5PVF9DT05TVEFOVCAqLyxcclxuICAgICAgICAgICAgY29udGVudCxcclxuICAgICAgICAgICAgbG9jOiBnZXRTZWxlY3Rpb24oY29udGV4dCwgaW5uZXJTdGFydCwgaW5uZXJFbmQpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBsb2M6IGdldFNlbGVjdGlvbihjb250ZXh0LCBzdGFydClcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VUZXh0KGNvbnRleHQsIG1vZGUpIHtcclxuICAgIGNvbnN0IGVuZFRva2VucyA9IG1vZGUgPT09IDMgLyogQ0RBVEEgKi8gPyBbJ11dPiddIDogWyc8JywgY29udGV4dC5vcHRpb25zLmRlbGltaXRlcnNbMF1dO1xyXG4gICAgbGV0IGVuZEluZGV4ID0gY29udGV4dC5zb3VyY2UubGVuZ3RoO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbmRUb2tlbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBpbmRleCA9IGNvbnRleHQuc291cmNlLmluZGV4T2YoZW5kVG9rZW5zW2ldLCAxKTtcclxuICAgICAgICBpZiAoaW5kZXggIT09IC0xICYmIGVuZEluZGV4ID4gaW5kZXgpIHtcclxuICAgICAgICAgICAgZW5kSW5kZXggPSBpbmRleDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBzdGFydCA9IGdldEN1cnNvcihjb250ZXh0KTtcclxuICAgIGNvbnN0IGNvbnRlbnQgPSBwYXJzZVRleHREYXRhKGNvbnRleHQsIGVuZEluZGV4LCBtb2RlKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogMiAvKiBURVhUICovLFxyXG4gICAgICAgIGNvbnRlbnQsXHJcbiAgICAgICAgbG9jOiBnZXRTZWxlY3Rpb24oY29udGV4dCwgc3RhcnQpXHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBHZXQgdGV4dCBkYXRhIHdpdGggYSBnaXZlbiBsZW5ndGggZnJvbSB0aGUgY3VycmVudCBsb2NhdGlvbi5cclxuICogVGhpcyB0cmFuc2xhdGVzIEhUTUwgZW50aXRpZXMgaW4gdGhlIHRleHQgZGF0YS5cclxuICovXHJcbmZ1bmN0aW9uIHBhcnNlVGV4dERhdGEoY29udGV4dCwgbGVuZ3RoLCBtb2RlKSB7XHJcbiAgICBjb25zdCByYXdUZXh0ID0gY29udGV4dC5zb3VyY2Uuc2xpY2UoMCwgbGVuZ3RoKTtcclxuICAgIGFkdmFuY2VCeShjb250ZXh0LCBsZW5ndGgpO1xyXG4gICAgaWYgKG1vZGUgPT09IDIgLyogUkFXVEVYVCAqLyB8fFxyXG4gICAgICAgIG1vZGUgPT09IDMgLyogQ0RBVEEgKi8gfHxcclxuICAgICAgICAhcmF3VGV4dC5pbmNsdWRlcygnJicpKSB7XHJcbiAgICAgICAgcmV0dXJuIHJhd1RleHQ7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBEQVRBIG9yIFJDREFUQSBjb250YWluaW5nIFwiJlwiXCIuIEVudGl0eSBkZWNvZGluZyByZXF1aXJlZC5cclxuICAgICAgICByZXR1cm4gY29udGV4dC5vcHRpb25zLmRlY29kZUVudGl0aWVzKHJhd1RleHQsIG1vZGUgPT09IDQgLyogQVRUUklCVVRFX1ZBTFVFICovKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRDdXJzb3IoY29udGV4dCkge1xyXG4gICAgY29uc3QgeyBjb2x1bW4sIGxpbmUsIG9mZnNldCB9ID0gY29udGV4dDtcclxuICAgIHJldHVybiB7IGNvbHVtbiwgbGluZSwgb2Zmc2V0IH07XHJcbn1cclxuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uKGNvbnRleHQsIHN0YXJ0LCBlbmQpIHtcclxuICAgIGVuZCA9IGVuZCB8fCBnZXRDdXJzb3IoY29udGV4dCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHN0YXJ0LFxyXG4gICAgICAgIGVuZCxcclxuICAgICAgICBzb3VyY2U6IGNvbnRleHQub3JpZ2luYWxTb3VyY2Uuc2xpY2Uoc3RhcnQub2Zmc2V0LCBlbmQub2Zmc2V0KVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBsYXN0KHhzKSB7XHJcbiAgICByZXR1cm4geHNbeHMubGVuZ3RoIC0gMV07XHJcbn1cclxuZnVuY3Rpb24gc3RhcnRzV2l0aChzb3VyY2UsIHNlYXJjaFN0cmluZykge1xyXG4gICAgcmV0dXJuIHNvdXJjZS5zdGFydHNXaXRoKHNlYXJjaFN0cmluZyk7XHJcbn1cclxuZnVuY3Rpb24gYWR2YW5jZUJ5KGNvbnRleHQsIG51bWJlck9mQ2hhcmFjdGVycykge1xyXG4gICAgY29uc3QgeyBzb3VyY2UgfSA9IGNvbnRleHQ7XHJcbiAgICBhZHZhbmNlUG9zaXRpb25XaXRoTXV0YXRpb24oY29udGV4dCwgc291cmNlLCBudW1iZXJPZkNoYXJhY3RlcnMpO1xyXG4gICAgY29udGV4dC5zb3VyY2UgPSBzb3VyY2Uuc2xpY2UobnVtYmVyT2ZDaGFyYWN0ZXJzKTtcclxufVxyXG5mdW5jdGlvbiBhZHZhbmNlU3BhY2VzKGNvbnRleHQpIHtcclxuICAgIGNvbnN0IG1hdGNoID0gL15bXFx0XFxyXFxuXFxmIF0rLy5leGVjKGNvbnRleHQuc291cmNlKTtcclxuICAgIGlmIChtYXRjaCkge1xyXG4gICAgICAgIGFkdmFuY2VCeShjb250ZXh0LCBtYXRjaFswXS5sZW5ndGgpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldE5ld1Bvc2l0aW9uKGNvbnRleHQsIHN0YXJ0LCBudW1iZXJPZkNoYXJhY3RlcnMpIHtcclxuICAgIHJldHVybiBhZHZhbmNlUG9zaXRpb25XaXRoQ2xvbmUoc3RhcnQsIGNvbnRleHQub3JpZ2luYWxTb3VyY2Uuc2xpY2Uoc3RhcnQub2Zmc2V0LCBudW1iZXJPZkNoYXJhY3RlcnMpLCBudW1iZXJPZkNoYXJhY3RlcnMpO1xyXG59XHJcbmZ1bmN0aW9uIGVtaXRFcnJvcihjb250ZXh0LCBjb2RlLCBvZmZzZXQsIGxvYyA9IGdldEN1cnNvcihjb250ZXh0KSkge1xyXG4gICAgaWYgKG9mZnNldCkge1xyXG4gICAgICAgIGxvYy5vZmZzZXQgKz0gb2Zmc2V0O1xyXG4gICAgICAgIGxvYy5jb2x1bW4gKz0gb2Zmc2V0O1xyXG4gICAgfVxyXG4gICAgY29udGV4dC5vcHRpb25zLm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcihjb2RlLCB7XHJcbiAgICAgICAgc3RhcnQ6IGxvYyxcclxuICAgICAgICBlbmQ6IGxvYyxcclxuICAgICAgICBzb3VyY2U6ICcnXHJcbiAgICB9KSk7XHJcbn1cclxuZnVuY3Rpb24gaXNFbmQoY29udGV4dCwgbW9kZSwgYW5jZXN0b3JzKSB7XHJcbiAgICBjb25zdCBzID0gY29udGV4dC5zb3VyY2U7XHJcbiAgICBzd2l0Y2ggKG1vZGUpIHtcclxuICAgICAgICBjYXNlIDAgLyogREFUQSAqLzpcclxuICAgICAgICAgICAgaWYgKHN0YXJ0c1dpdGgocywgJzwvJykpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE86IHByb2JhYmx5IGJhZCBwZXJmb3JtYW5jZVxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGFuY2VzdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydHNXaXRoRW5kVGFnT3BlbihzLCBhbmNlc3RvcnNbaV0udGFnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAxIC8qIFJDREFUQSAqLzpcclxuICAgICAgICBjYXNlIDIgLyogUkFXVEVYVCAqLzoge1xyXG4gICAgICAgICAgICBjb25zdCBwYXJlbnQgPSBsYXN0KGFuY2VzdG9ycyk7XHJcbiAgICAgICAgICAgIGlmIChwYXJlbnQgJiYgc3RhcnRzV2l0aEVuZFRhZ09wZW4ocywgcGFyZW50LnRhZykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIDMgLyogQ0RBVEEgKi86XHJcbiAgICAgICAgICAgIGlmIChzdGFydHNXaXRoKHMsICddXT4nKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gIXM7XHJcbn1cclxuZnVuY3Rpb24gc3RhcnRzV2l0aEVuZFRhZ09wZW4oc291cmNlLCB0YWcpIHtcclxuICAgIHJldHVybiAoc3RhcnRzV2l0aChzb3VyY2UsICc8LycpICYmXHJcbiAgICAgICAgc291cmNlLnNsaWNlKDIsIDIgKyB0YWcubGVuZ3RoKS50b0xvd2VyQ2FzZSgpID09PSB0YWcudG9Mb3dlckNhc2UoKSAmJlxyXG4gICAgICAgIC9bXFx0XFxyXFxuXFxmIC8+XS8udGVzdChzb3VyY2VbMiArIHRhZy5sZW5ndGhdIHx8ICc+JykpO1xyXG59XG5cbmZ1bmN0aW9uIGhvaXN0U3RhdGljKHJvb3QsIGNvbnRleHQpIHtcclxuICAgIHdhbGsocm9vdCwgY29udGV4dCwgXHJcbiAgICAvLyBSb290IG5vZGUgaXMgdW5mb3J0dW5hdGVseSBub24taG9pc3RhYmxlIGR1ZSB0byBwb3RlbnRpYWwgcGFyZW50XHJcbiAgICAvLyBmYWxsdGhyb3VnaCBhdHRyaWJ1dGVzLlxyXG4gICAgaXNTaW5nbGVFbGVtZW50Um9vdChyb290LCByb290LmNoaWxkcmVuWzBdKSk7XHJcbn1cclxuZnVuY3Rpb24gaXNTaW5nbGVFbGVtZW50Um9vdChyb290LCBjaGlsZCkge1xyXG4gICAgY29uc3QgeyBjaGlsZHJlbiB9ID0gcm9vdDtcclxuICAgIHJldHVybiAoY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmXHJcbiAgICAgICAgY2hpbGQudHlwZSA9PT0gMSAvKiBFTEVNRU5UICovICYmXHJcbiAgICAgICAgIWlzU2xvdE91dGxldChjaGlsZCkpO1xyXG59XHJcbmZ1bmN0aW9uIHdhbGsobm9kZSwgY29udGV4dCwgZG9Ob3RIb2lzdE5vZGUgPSBmYWxzZSkge1xyXG4gICAgY29uc3QgeyBjaGlsZHJlbiB9ID0gbm9kZTtcclxuICAgIGNvbnN0IG9yaWdpbmFsQ291bnQgPSBjaGlsZHJlbi5sZW5ndGg7XHJcbiAgICBsZXQgaG9pc3RlZENvdW50ID0gMDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xyXG4gICAgICAgIC8vIG9ubHkgcGxhaW4gZWxlbWVudHMgJiB0ZXh0IGNhbGxzIGFyZSBlbGlnaWJsZSBmb3IgaG9pc3RpbmcuXHJcbiAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IDEgLyogRUxFTUVOVCAqLyAmJlxyXG4gICAgICAgICAgICBjaGlsZC50YWdUeXBlID09PSAwIC8qIEVMRU1FTlQgKi8pIHtcclxuICAgICAgICAgICAgY29uc3QgY29uc3RhbnRUeXBlID0gZG9Ob3RIb2lzdE5vZGVcclxuICAgICAgICAgICAgICAgID8gMCAvKiBOT1RfQ09OU1RBTlQgKi9cclxuICAgICAgICAgICAgICAgIDogZ2V0Q29uc3RhbnRUeXBlKGNoaWxkLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgaWYgKGNvbnN0YW50VHlwZSA+IDAgLyogTk9UX0NPTlNUQU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29uc3RhbnRUeXBlID49IDIgLyogQ0FOX0hPSVNUICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuY29kZWdlbk5vZGUucGF0Y2hGbGFnID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLTEgLyogSE9JU1RFRCAqLyArICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgIC8qIEhPSVNURUQgKi9gIDogYGApO1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmNvZGVnZW5Ob2RlID0gY29udGV4dC5ob2lzdChjaGlsZC5jb2RlZ2VuTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaG9pc3RlZENvdW50Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBub2RlIG1heSBjb250YWluIGR5bmFtaWMgY2hpbGRyZW4sIGJ1dCBpdHMgcHJvcHMgbWF5IGJlIGVsaWdpYmxlIGZvclxyXG4gICAgICAgICAgICAgICAgLy8gaG9pc3RpbmcuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb2RlZ2VuTm9kZSA9IGNoaWxkLmNvZGVnZW5Ob2RlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvZGVnZW5Ob2RlLnR5cGUgPT09IDEzIC8qIFZOT0RFX0NBTEwgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmbGFnID0gZ2V0UGF0Y2hGbGFnKGNvZGVnZW5Ob2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKCFmbGFnIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsYWcgPT09IDUxMiAvKiBORUVEX1BBVENIICovIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsYWcgPT09IDEgLyogVEVYVCAqLykgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0R2VuZXJhdGVkUHJvcHNDb25zdGFudFR5cGUoY2hpbGQsIGNvbnRleHQpID49XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAyIC8qIENBTl9IT0lTVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wcyA9IGdldE5vZGVQcm9wcyhjaGlsZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZWdlbk5vZGUucHJvcHMgPSBjb250ZXh0LmhvaXN0KHByb3BzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZWdlbk5vZGUuZHluYW1pY1Byb3BzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVnZW5Ob2RlLmR5bmFtaWNQcm9wcyA9IGNvbnRleHQuaG9pc3QoY29kZWdlbk5vZGUuZHluYW1pY1Byb3BzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY2hpbGQudHlwZSA9PT0gMTIgLyogVEVYVF9DQUxMICovICYmXHJcbiAgICAgICAgICAgIGdldENvbnN0YW50VHlwZShjaGlsZC5jb250ZW50LCBjb250ZXh0KSA+PSAyIC8qIENBTl9IT0lTVCAqLykge1xyXG4gICAgICAgICAgICBjaGlsZC5jb2RlZ2VuTm9kZSA9IGNvbnRleHQuaG9pc3QoY2hpbGQuY29kZWdlbk5vZGUpO1xyXG4gICAgICAgICAgICBob2lzdGVkQ291bnQrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gd2FsayBmdXJ0aGVyXHJcbiAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IDEgLyogRUxFTUVOVCAqLykge1xyXG4gICAgICAgICAgICBjb25zdCBpc0NvbXBvbmVudCA9IGNoaWxkLnRhZ1R5cGUgPT09IDEgLyogQ09NUE9ORU5UICovO1xyXG4gICAgICAgICAgICBpZiAoaXNDb21wb25lbnQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuc2NvcGVzLnZTbG90Kys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgd2FsayhjaGlsZCwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGlmIChpc0NvbXBvbmVudCkge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5zY29wZXMudlNsb3QtLTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjaGlsZC50eXBlID09PSAxMSAvKiBGT1IgKi8pIHtcclxuICAgICAgICAgICAgLy8gRG8gbm90IGhvaXN0IHYtZm9yIHNpbmdsZSBjaGlsZCBiZWNhdXNlIGl0IGhhcyB0byBiZSBhIGJsb2NrXHJcbiAgICAgICAgICAgIHdhbGsoY2hpbGQsIGNvbnRleHQsIGNoaWxkLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNoaWxkLnR5cGUgPT09IDkgLyogSUYgKi8pIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZC5icmFuY2hlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgLy8gRG8gbm90IGhvaXN0IHYtaWYgc2luZ2xlIGNoaWxkIGJlY2F1c2UgaXQgaGFzIHRvIGJlIGEgYmxvY2tcclxuICAgICAgICAgICAgICAgIHdhbGsoY2hpbGQuYnJhbmNoZXNbaV0sIGNvbnRleHQsIGNoaWxkLmJyYW5jaGVzW2ldLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoaG9pc3RlZENvdW50ICYmIGNvbnRleHQudHJhbnNmb3JtSG9pc3QpIHtcclxuICAgICAgICBjb250ZXh0LnRyYW5zZm9ybUhvaXN0KGNoaWxkcmVuLCBjb250ZXh0LCBub2RlKTtcclxuICAgIH1cclxuICAgIC8vIGFsbCBjaGlsZHJlbiB3ZXJlIGhvaXN0ZWQgLSB0aGUgZW50aXJlIGNoaWxkcmVuIGFycmF5IGlzIGhvaXN0YWJsZS5cclxuICAgIGlmIChob2lzdGVkQ291bnQgJiZcclxuICAgICAgICBob2lzdGVkQ291bnQgPT09IG9yaWdpbmFsQ291bnQgJiZcclxuICAgICAgICBub2RlLnR5cGUgPT09IDEgLyogRUxFTUVOVCAqLyAmJlxyXG4gICAgICAgIG5vZGUudGFnVHlwZSA9PT0gMCAvKiBFTEVNRU5UICovICYmXHJcbiAgICAgICAgbm9kZS5jb2RlZ2VuTm9kZSAmJlxyXG4gICAgICAgIG5vZGUuY29kZWdlbk5vZGUudHlwZSA9PT0gMTMgLyogVk5PREVfQ0FMTCAqLyAmJlxyXG4gICAgICAgIGlzQXJyYXkobm9kZS5jb2RlZ2VuTm9kZS5jaGlsZHJlbikpIHtcclxuICAgICAgICBub2RlLmNvZGVnZW5Ob2RlLmNoaWxkcmVuID0gY29udGV4dC5ob2lzdChjcmVhdGVBcnJheUV4cHJlc3Npb24obm9kZS5jb2RlZ2VuTm9kZS5jaGlsZHJlbikpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldENvbnN0YW50VHlwZShub2RlLCBjb250ZXh0KSB7XHJcbiAgICBjb25zdCB7IGNvbnN0YW50Q2FjaGUgfSA9IGNvbnRleHQ7XHJcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xyXG4gICAgICAgIGNhc2UgMSAvKiBFTEVNRU5UICovOlxyXG4gICAgICAgICAgICBpZiAobm9kZS50YWdUeXBlICE9PSAwIC8qIEVMRU1FTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAwIC8qIE5PVF9DT05TVEFOVCAqLztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBjYWNoZWQgPSBjb25zdGFudENhY2hlLmdldChub2RlKTtcclxuICAgICAgICAgICAgaWYgKGNhY2hlZCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGNvZGVnZW5Ob2RlID0gbm9kZS5jb2RlZ2VuTm9kZTtcclxuICAgICAgICAgICAgaWYgKGNvZGVnZW5Ob2RlLnR5cGUgIT09IDEzIC8qIFZOT0RFX0NBTEwgKi8pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAwIC8qIE5PVF9DT05TVEFOVCAqLztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY29kZWdlbk5vZGUuaXNCbG9jayAmJlxyXG4gICAgICAgICAgICAgICAgbm9kZS50YWcgIT09ICdzdmcnICYmXHJcbiAgICAgICAgICAgICAgICBub2RlLnRhZyAhPT0gJ2ZvcmVpZ25PYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMCAvKiBOT1RfQ09OU1RBTlQgKi87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgZmxhZyA9IGdldFBhdGNoRmxhZyhjb2RlZ2VuTm9kZSk7XHJcbiAgICAgICAgICAgIGlmICghZmxhZykge1xyXG4gICAgICAgICAgICAgICAgbGV0IHJldHVyblR5cGUgPSAzIC8qIENBTl9TVFJJTkdJRlkgKi87XHJcbiAgICAgICAgICAgICAgICAvLyBFbGVtZW50IGl0c2VsZiBoYXMgbm8gcGF0Y2ggZmxhZy4gSG93ZXZlciB3ZSBzdGlsbCBuZWVkIHRvIGNoZWNrOlxyXG4gICAgICAgICAgICAgICAgLy8gMS4gRXZlbiBmb3IgYSBub2RlIHdpdGggbm8gcGF0Y2ggZmxhZywgaXQgaXMgcG9zc2libGUgZm9yIGl0IHRvIGNvbnRhaW5cclxuICAgICAgICAgICAgICAgIC8vIG5vbi1ob2lzdGFibGUgZXhwcmVzc2lvbnMgdGhhdCByZWZlcnMgdG8gc2NvcGUgdmFyaWFibGVzLCBlLmcuIGNvbXBpbGVyXHJcbiAgICAgICAgICAgICAgICAvLyBpbmplY3RlZCBrZXlzIG9yIGNhY2hlZCBldmVudCBoYW5kbGVycy4gVGhlcmVmb3JlIHdlIG5lZWQgdG8gYWx3YXlzXHJcbiAgICAgICAgICAgICAgICAvLyBjaGVjayB0aGUgY29kZWdlbk5vZGUncyBwcm9wcyB0byBiZSBzdXJlLlxyXG4gICAgICAgICAgICAgICAgY29uc3QgZ2VuZXJhdGVkUHJvcHNUeXBlID0gZ2V0R2VuZXJhdGVkUHJvcHNDb25zdGFudFR5cGUobm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZ2VuZXJhdGVkUHJvcHNUeXBlID09PSAwIC8qIE5PVF9DT05TVEFOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0YW50Q2FjaGUuc2V0KG5vZGUsIDAgLyogTk9UX0NPTlNUQU5UICovKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMCAvKiBOT1RfQ09OU1RBTlQgKi87XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZ2VuZXJhdGVkUHJvcHNUeXBlIDwgcmV0dXJuVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblR5cGUgPSBnZW5lcmF0ZWRQcm9wc1R5cGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyAyLiBpdHMgY2hpbGRyZW4uXHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZFR5cGUgPSBnZXRDb25zdGFudFR5cGUobm9kZS5jaGlsZHJlbltpXSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkVHlwZSA9PT0gMCAvKiBOT1RfQ09OU1RBTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RhbnRDYWNoZS5zZXQobm9kZSwgMCAvKiBOT1RfQ09OU1RBTlQgKi8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMCAvKiBOT1RfQ09OU1RBTlQgKi87XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZFR5cGUgPCByZXR1cm5UeXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblR5cGUgPSBjaGlsZFR5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gMy4gaWYgdGhlIHR5cGUgaXMgbm90IGFscmVhZHkgQ0FOX1NLSVBfUEFUQ0ggd2hpY2ggaXMgdGhlIGxvd2VzdCBub24tMFxyXG4gICAgICAgICAgICAgICAgLy8gdHlwZSwgY2hlY2sgaWYgYW55IG9mIHRoZSBwcm9wcyBjYW4gY2F1c2UgdGhlIHR5cGUgdG8gYmUgbG93ZXJlZFxyXG4gICAgICAgICAgICAgICAgLy8gd2UgY2FuIHNraXAgY2FuX3BhdGNoIGJlY2F1c2UgaXQncyBndWFyYW50ZWVkIGJ5IHRoZSBhYnNlbmNlIG9mIGFcclxuICAgICAgICAgICAgICAgIC8vIHBhdGNoRmxhZy5cclxuICAgICAgICAgICAgICAgIGlmIChyZXR1cm5UeXBlID4gMSAvKiBDQU5fU0tJUF9QQVRDSCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5wcm9wcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwID0gbm9kZS5wcm9wc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHAudHlwZSA9PT0gNyAvKiBESVJFQ1RJVkUgKi8gJiYgcC5uYW1lID09PSAnYmluZCcgJiYgcC5leHApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4cFR5cGUgPSBnZXRDb25zdGFudFR5cGUocC5leHAsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4cFR5cGUgPT09IDAgLyogTk9UX0NPTlNUQU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RhbnRDYWNoZS5zZXQobm9kZSwgMCAvKiBOT1RfQ09OU1RBTlQgKi8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwIC8qIE5PVF9DT05TVEFOVCAqLztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHBUeXBlIDwgcmV0dXJuVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblR5cGUgPSBleHBUeXBlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gb25seSBzdmcvZm9yZWlnbk9iamVjdCBjb3VsZCBiZSBibG9jayBoZXJlLCBob3dldmVyIGlmIHRoZXkgYXJlXHJcbiAgICAgICAgICAgICAgICAvLyBzdGF0aWMgdGhlbiB0aGV5IGRvbid0IG5lZWQgdG8gYmUgYmxvY2tzIHNpbmNlIHRoZXJlIHdpbGwgYmUgbm9cclxuICAgICAgICAgICAgICAgIC8vIG5lc3RlZCB1cGRhdGVzLlxyXG4gICAgICAgICAgICAgICAgaWYgKGNvZGVnZW5Ob2RlLmlzQmxvY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBleGNlcHQgc2V0IGN1c3RvbSBkaXJlY3RpdmVzLlxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5wcm9wcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwID0gbm9kZS5wcm9wc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHAudHlwZSA9PT0gNyAvKiBESVJFQ1RJVkUgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0YW50Q2FjaGUuc2V0KG5vZGUsIDAgLyogTk9UX0NPTlNUQU5UICovKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwIC8qIE5PVF9DT05TVEFOVCAqLztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnJlbW92ZUhlbHBlcihPUEVOX0JMT0NLKTtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnJlbW92ZUhlbHBlcihnZXRWTm9kZUJsb2NrSGVscGVyKGNvbnRleHQuaW5TU1IsIGNvZGVnZW5Ob2RlLmlzQ29tcG9uZW50KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29kZWdlbk5vZGUuaXNCbG9jayA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuaGVscGVyKGdldFZOb2RlSGVscGVyKGNvbnRleHQuaW5TU1IsIGNvZGVnZW5Ob2RlLmlzQ29tcG9uZW50KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdGFudENhY2hlLnNldChub2RlLCByZXR1cm5UeXBlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5UeXBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3RhbnRDYWNoZS5zZXQobm9kZSwgMCAvKiBOT1RfQ09OU1RBTlQgKi8pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDAgLyogTk9UX0NPTlNUQU5UICovO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgY2FzZSAyIC8qIFRFWFQgKi86XHJcbiAgICAgICAgY2FzZSAzIC8qIENPTU1FTlQgKi86XHJcbiAgICAgICAgICAgIHJldHVybiAzIC8qIENBTl9TVFJJTkdJRlkgKi87XHJcbiAgICAgICAgY2FzZSA5IC8qIElGICovOlxyXG4gICAgICAgIGNhc2UgMTEgLyogRk9SICovOlxyXG4gICAgICAgIGNhc2UgMTAgLyogSUZfQlJBTkNIICovOlxyXG4gICAgICAgICAgICByZXR1cm4gMCAvKiBOT1RfQ09OU1RBTlQgKi87XHJcbiAgICAgICAgY2FzZSA1IC8qIElOVEVSUE9MQVRJT04gKi86XHJcbiAgICAgICAgY2FzZSAxMiAvKiBURVhUX0NBTEwgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBnZXRDb25zdGFudFR5cGUobm9kZS5jb250ZW50LCBjb250ZXh0KTtcclxuICAgICAgICBjYXNlIDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi86XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlLmNvbnN0VHlwZTtcclxuICAgICAgICBjYXNlIDggLyogQ09NUE9VTkRfRVhQUkVTU0lPTiAqLzpcclxuICAgICAgICAgICAgbGV0IHJldHVyblR5cGUgPSAzIC8qIENBTl9TVFJJTkdJRlkgKi87XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzU3RyaW5nKGNoaWxkKSB8fCBpc1N5bWJvbChjaGlsZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkVHlwZSA9IGdldENvbnN0YW50VHlwZShjaGlsZCwgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRUeXBlID09PSAwIC8qIE5PVF9DT05TVEFOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwIC8qIE5PVF9DT05TVEFOVCAqLztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkVHlwZSA8IHJldHVyblR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm5UeXBlID0gY2hpbGRUeXBlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5UeXBlO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIDtcclxuICAgICAgICAgICAgcmV0dXJuIDAgLyogTk9UX0NPTlNUQU5UICovO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IGFsbG93SG9pc3RlZEhlbHBlclNldCA9IG5ldyBTZXQoW1xyXG4gICAgTk9STUFMSVpFX0NMQVNTLFxyXG4gICAgTk9STUFMSVpFX1NUWUxFLFxyXG4gICAgTk9STUFMSVpFX1BST1BTLFxyXG4gICAgR1VBUkRfUkVBQ1RJVkVfUFJPUFNcclxuXSk7XHJcbmZ1bmN0aW9uIGdldENvbnN0YW50VHlwZU9mSGVscGVyQ2FsbCh2YWx1ZSwgY29udGV4dCkge1xyXG4gICAgaWYgKHZhbHVlLnR5cGUgPT09IDE0IC8qIEpTX0NBTExfRVhQUkVTU0lPTiAqLyAmJlxyXG4gICAgICAgICFpc1N0cmluZyh2YWx1ZS5jYWxsZWUpICYmXHJcbiAgICAgICAgYWxsb3dIb2lzdGVkSGVscGVyU2V0Lmhhcyh2YWx1ZS5jYWxsZWUpKSB7XHJcbiAgICAgICAgY29uc3QgYXJnID0gdmFsdWUuYXJndW1lbnRzWzBdO1xyXG4gICAgICAgIGlmIChhcmcudHlwZSA9PT0gNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLykge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29uc3RhbnRUeXBlKGFyZywgY29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGFyZy50eXBlID09PSAxNCAvKiBKU19DQUxMX0VYUFJFU1NJT04gKi8pIHtcclxuICAgICAgICAgICAgLy8gaW4gdGhlIGNhc2Ugb2YgbmVzdGVkIGhlbHBlciBjYWxsLCBlLmcuIGBub3JtYWxpemVQcm9wcyhndWFyZFJlYWN0aXZlUHJvcHMoZXhwKSlgXHJcbiAgICAgICAgICAgIHJldHVybiBnZXRDb25zdGFudFR5cGVPZkhlbHBlckNhbGwoYXJnLCBjb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gMCAvKiBOT1RfQ09OU1RBTlQgKi87XHJcbn1cclxuZnVuY3Rpb24gZ2V0R2VuZXJhdGVkUHJvcHNDb25zdGFudFR5cGUobm9kZSwgY29udGV4dCkge1xyXG4gICAgbGV0IHJldHVyblR5cGUgPSAzIC8qIENBTl9TVFJJTkdJRlkgKi87XHJcbiAgICBjb25zdCBwcm9wcyA9IGdldE5vZGVQcm9wcyhub2RlKTtcclxuICAgIGlmIChwcm9wcyAmJiBwcm9wcy50eXBlID09PSAxNSAvKiBKU19PQkpFQ1RfRVhQUkVTU0lPTiAqLykge1xyXG4gICAgICAgIGNvbnN0IHsgcHJvcGVydGllcyB9ID0gcHJvcHM7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsga2V5LCB2YWx1ZSB9ID0gcHJvcGVydGllc1tpXTtcclxuICAgICAgICAgICAgY29uc3Qga2V5VHlwZSA9IGdldENvbnN0YW50VHlwZShrZXksIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBpZiAoa2V5VHlwZSA9PT0gMCAvKiBOT1RfQ09OU1RBTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBrZXlUeXBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChrZXlUeXBlIDwgcmV0dXJuVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuVHlwZSA9IGtleVR5cGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHZhbHVlVHlwZTtcclxuICAgICAgICAgICAgaWYgKHZhbHVlLnR5cGUgPT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8pIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlVHlwZSA9IGdldENvbnN0YW50VHlwZSh2YWx1ZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUudHlwZSA9PT0gMTQgLyogSlNfQ0FMTF9FWFBSRVNTSU9OICovKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBzb21lIGhlbHBlciBjYWxscyBjYW4gYmUgaG9pc3RlZCxcclxuICAgICAgICAgICAgICAgIC8vIHN1Y2ggYXMgdGhlIGBub3JtYWxpemVQcm9wc2AgZ2VuZXJhdGVkIGJ5IHRoZSBjb21waWxlciBmb3IgcHJlLW5vcm1hbGl6ZSBjbGFzcyxcclxuICAgICAgICAgICAgICAgIC8vIGluIHRoaXMgY2FzZSB3ZSBuZWVkIHRvIHJlc3BlY3QgdGhlIENvbnN0YW50VHlwZSBvZiB0aGUgaGVscGVyJ3MgYXJndW1lbnRzXHJcbiAgICAgICAgICAgICAgICB2YWx1ZVR5cGUgPSBnZXRDb25zdGFudFR5cGVPZkhlbHBlckNhbGwodmFsdWUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFsdWVUeXBlID0gMCAvKiBOT1RfQ09OU1RBTlQgKi87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHZhbHVlVHlwZSA9PT0gMCAvKiBOT1RfQ09OU1RBTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZVR5cGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHZhbHVlVHlwZSA8IHJldHVyblR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVyblR5cGUgPSB2YWx1ZVR5cGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0dXJuVHlwZTtcclxufVxyXG5mdW5jdGlvbiBnZXROb2RlUHJvcHMobm9kZSkge1xyXG4gICAgY29uc3QgY29kZWdlbk5vZGUgPSBub2RlLmNvZGVnZW5Ob2RlO1xyXG4gICAgaWYgKGNvZGVnZW5Ob2RlLnR5cGUgPT09IDEzIC8qIFZOT0RFX0NBTEwgKi8pIHtcclxuICAgICAgICByZXR1cm4gY29kZWdlbk5vZGUucHJvcHM7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0UGF0Y2hGbGFnKG5vZGUpIHtcclxuICAgIGNvbnN0IGZsYWcgPSBub2RlLnBhdGNoRmxhZztcclxuICAgIHJldHVybiBmbGFnID8gcGFyc2VJbnQoZmxhZywgMTApIDogdW5kZWZpbmVkO1xyXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRyYW5zZm9ybUNvbnRleHQocm9vdCwgeyBmaWxlbmFtZSA9ICcnLCBwcmVmaXhJZGVudGlmaWVycyA9IGZhbHNlLCBob2lzdFN0YXRpYyA9IGZhbHNlLCBjYWNoZUhhbmRsZXJzID0gZmFsc2UsIG5vZGVUcmFuc2Zvcm1zID0gW10sIGRpcmVjdGl2ZVRyYW5zZm9ybXMgPSB7fSwgdHJhbnNmb3JtSG9pc3QgPSBudWxsLCBpc0J1aWx0SW5Db21wb25lbnQgPSBOT09QLCBpc0N1c3RvbUVsZW1lbnQgPSBOT09QLCBleHByZXNzaW9uUGx1Z2lucyA9IFtdLCBzY29wZUlkID0gbnVsbCwgc2xvdHRlZCA9IHRydWUsIHNzciA9IGZhbHNlLCBpblNTUiA9IGZhbHNlLCBzc3JDc3NWYXJzID0gYGAsIGJpbmRpbmdNZXRhZGF0YSA9IEVNUFRZX09CSiwgaW5saW5lID0gZmFsc2UsIGlzVFMgPSBmYWxzZSwgb25FcnJvciA9IGRlZmF1bHRPbkVycm9yLCBvbldhcm4gPSBkZWZhdWx0T25XYXJuLCBjb21wYXRDb25maWcgfSkge1xyXG4gICAgY29uc3QgbmFtZU1hdGNoID0gZmlsZW5hbWUucmVwbGFjZSgvXFw/LiokLywgJycpLm1hdGNoKC8oW14vXFxcXF0rKVxcLlxcdyskLyk7XHJcbiAgICBjb25zdCBjb250ZXh0ID0ge1xyXG4gICAgICAgIC8vIG9wdGlvbnNcclxuICAgICAgICBzZWxmTmFtZTogbmFtZU1hdGNoICYmIGNhcGl0YWxpemUoY2FtZWxpemUkMShuYW1lTWF0Y2hbMV0pKSxcclxuICAgICAgICBwcmVmaXhJZGVudGlmaWVycyxcclxuICAgICAgICBob2lzdFN0YXRpYyxcclxuICAgICAgICBjYWNoZUhhbmRsZXJzLFxyXG4gICAgICAgIG5vZGVUcmFuc2Zvcm1zLFxyXG4gICAgICAgIGRpcmVjdGl2ZVRyYW5zZm9ybXMsXHJcbiAgICAgICAgdHJhbnNmb3JtSG9pc3QsXHJcbiAgICAgICAgaXNCdWlsdEluQ29tcG9uZW50LFxyXG4gICAgICAgIGlzQ3VzdG9tRWxlbWVudCxcclxuICAgICAgICBleHByZXNzaW9uUGx1Z2lucyxcclxuICAgICAgICBzY29wZUlkLFxyXG4gICAgICAgIHNsb3R0ZWQsXHJcbiAgICAgICAgc3NyLFxyXG4gICAgICAgIGluU1NSLFxyXG4gICAgICAgIHNzckNzc1ZhcnMsXHJcbiAgICAgICAgYmluZGluZ01ldGFkYXRhLFxyXG4gICAgICAgIGlubGluZSxcclxuICAgICAgICBpc1RTLFxyXG4gICAgICAgIG9uRXJyb3IsXHJcbiAgICAgICAgb25XYXJuLFxyXG4gICAgICAgIGNvbXBhdENvbmZpZyxcclxuICAgICAgICAvLyBzdGF0ZVxyXG4gICAgICAgIHJvb3QsXHJcbiAgICAgICAgaGVscGVyczogbmV3IE1hcCgpLFxyXG4gICAgICAgIGNvbXBvbmVudHM6IG5ldyBTZXQoKSxcclxuICAgICAgICBkaXJlY3RpdmVzOiBuZXcgU2V0KCksXHJcbiAgICAgICAgaG9pc3RzOiBbXSxcclxuICAgICAgICBpbXBvcnRzOiBbXSxcclxuICAgICAgICBjb25zdGFudENhY2hlOiBuZXcgTWFwKCksXHJcbiAgICAgICAgdGVtcHM6IDAsXHJcbiAgICAgICAgY2FjaGVkOiAwLFxyXG4gICAgICAgIGlkZW50aWZpZXJzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxyXG4gICAgICAgIHNjb3Blczoge1xyXG4gICAgICAgICAgICB2Rm9yOiAwLFxyXG4gICAgICAgICAgICB2U2xvdDogMCxcclxuICAgICAgICAgICAgdlByZTogMCxcclxuICAgICAgICAgICAgdk9uY2U6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHBhcmVudDogbnVsbCxcclxuICAgICAgICBjdXJyZW50Tm9kZTogcm9vdCxcclxuICAgICAgICBjaGlsZEluZGV4OiAwLFxyXG4gICAgICAgIGluVk9uY2U6IGZhbHNlLFxyXG4gICAgICAgIC8vIG1ldGhvZHNcclxuICAgICAgICBoZWxwZXIobmFtZSkge1xyXG4gICAgICAgICAgICBjb25zdCBjb3VudCA9IGNvbnRleHQuaGVscGVycy5nZXQobmFtZSkgfHwgMDtcclxuICAgICAgICAgICAgY29udGV4dC5oZWxwZXJzLnNldChuYW1lLCBjb3VudCArIDEpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmFtZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlbW92ZUhlbHBlcihuYW1lKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvdW50ID0gY29udGV4dC5oZWxwZXJzLmdldChuYW1lKTtcclxuICAgICAgICAgICAgaWYgKGNvdW50KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50Q291bnQgPSBjb3VudCAtIDE7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRDb3VudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuaGVscGVycy5kZWxldGUobmFtZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmhlbHBlcnMuc2V0KG5hbWUsIGN1cnJlbnRDb3VudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGhlbHBlclN0cmluZyhuYW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBgXyR7aGVscGVyTmFtZU1hcFtjb250ZXh0LmhlbHBlcihuYW1lKV19YDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlcGxhY2VOb2RlKG5vZGUpIHtcclxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgIGlmICghY29udGV4dC5jdXJyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm9kZSBiZWluZyByZXBsYWNlZCBpcyBhbHJlYWR5IHJlbW92ZWQuYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWNvbnRleHQucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcmVwbGFjZSByb290IG5vZGUuYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29udGV4dC5wYXJlbnQuY2hpbGRyZW5bY29udGV4dC5jaGlsZEluZGV4XSA9IGNvbnRleHQuY3VycmVudE5vZGUgPSBub2RlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVtb3ZlTm9kZShub2RlKSB7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWNvbnRleHQucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCByZW1vdmUgcm9vdCBub2RlLmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGxpc3QgPSBjb250ZXh0LnBhcmVudC5jaGlsZHJlbjtcclxuICAgICAgICAgICAgY29uc3QgcmVtb3ZhbEluZGV4ID0gbm9kZVxyXG4gICAgICAgICAgICAgICAgPyBsaXN0LmluZGV4T2Yobm9kZSlcclxuICAgICAgICAgICAgICAgIDogY29udGV4dC5jdXJyZW50Tm9kZVxyXG4gICAgICAgICAgICAgICAgICAgID8gY29udGV4dC5jaGlsZEluZGV4XHJcbiAgICAgICAgICAgICAgICAgICAgOiAtMTtcclxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgcmVtb3ZhbEluZGV4IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBub2RlIGJlaW5nIHJlbW92ZWQgaXMgbm90IGEgY2hpbGQgb2YgY3VycmVudCBwYXJlbnRgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIW5vZGUgfHwgbm9kZSA9PT0gY29udGV4dC5jdXJyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gY3VycmVudCBub2RlIHJlbW92ZWRcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuY3VycmVudE5vZGUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5vbk5vZGVSZW1vdmVkKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBzaWJsaW5nIG5vZGUgcmVtb3ZlZFxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHQuY2hpbGRJbmRleCA+IHJlbW92YWxJbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuY2hpbGRJbmRleC0tO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQub25Ob2RlUmVtb3ZlZCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnRleHQucGFyZW50LmNoaWxkcmVuLnNwbGljZShyZW1vdmFsSW5kZXgsIDEpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25Ob2RlUmVtb3ZlZDogKCkgPT4geyB9LFxyXG4gICAgICAgIGFkZElkZW50aWZpZXJzKGV4cCkge1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVtb3ZlSWRlbnRpZmllcnMoZXhwKSB7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBob2lzdChleHApIHtcclxuICAgICAgICAgICAgaWYgKGlzU3RyaW5nKGV4cCkpXHJcbiAgICAgICAgICAgICAgICBleHAgPSBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGV4cCk7XHJcbiAgICAgICAgICAgIGNvbnRleHQuaG9pc3RzLnB1c2goZXhwKTtcclxuICAgICAgICAgICAgY29uc3QgaWRlbnRpZmllciA9IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYF9ob2lzdGVkXyR7Y29udGV4dC5ob2lzdHMubGVuZ3RofWAsIGZhbHNlLCBleHAubG9jLCAyIC8qIENBTl9IT0lTVCAqLyk7XHJcbiAgICAgICAgICAgIGlkZW50aWZpZXIuaG9pc3RlZCA9IGV4cDtcclxuICAgICAgICAgICAgcmV0dXJuIGlkZW50aWZpZXI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjYWNoZShleHAsIGlzVk5vZGUgPSBmYWxzZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlQ2FjaGVFeHByZXNzaW9uKGNvbnRleHQuY2FjaGVkKyssIGV4cCwgaXNWTm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHtcclxuICAgICAgICBjb250ZXh0LmZpbHRlcnMgPSBuZXcgU2V0KCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY29udGV4dDtcclxufVxyXG5mdW5jdGlvbiB0cmFuc2Zvcm0ocm9vdCwgb3B0aW9ucykge1xyXG4gICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZVRyYW5zZm9ybUNvbnRleHQocm9vdCwgb3B0aW9ucyk7XHJcbiAgICB0cmF2ZXJzZU5vZGUocm9vdCwgY29udGV4dCk7XHJcbiAgICBpZiAob3B0aW9ucy5ob2lzdFN0YXRpYykge1xyXG4gICAgICAgIGhvaXN0U3RhdGljKHJvb3QsIGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgaWYgKCFvcHRpb25zLnNzcikge1xyXG4gICAgICAgIGNyZWF0ZVJvb3RDb2RlZ2VuKHJvb3QsIGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgLy8gZmluYWxpemUgbWV0YSBpbmZvcm1hdGlvblxyXG4gICAgcm9vdC5oZWxwZXJzID0gWy4uLmNvbnRleHQuaGVscGVycy5rZXlzKCldO1xyXG4gICAgcm9vdC5jb21wb25lbnRzID0gWy4uLmNvbnRleHQuY29tcG9uZW50c107XHJcbiAgICByb290LmRpcmVjdGl2ZXMgPSBbLi4uY29udGV4dC5kaXJlY3RpdmVzXTtcclxuICAgIHJvb3QuaW1wb3J0cyA9IGNvbnRleHQuaW1wb3J0cztcclxuICAgIHJvb3QuaG9pc3RzID0gY29udGV4dC5ob2lzdHM7XHJcbiAgICByb290LnRlbXBzID0gY29udGV4dC50ZW1wcztcclxuICAgIHJvb3QuY2FjaGVkID0gY29udGV4dC5jYWNoZWQ7XHJcbiAgICB7XHJcbiAgICAgICAgcm9vdC5maWx0ZXJzID0gWy4uLmNvbnRleHQuZmlsdGVyc107XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUm9vdENvZGVnZW4ocm9vdCwgY29udGV4dCkge1xyXG4gICAgY29uc3QgeyBoZWxwZXIgfSA9IGNvbnRleHQ7XHJcbiAgICBjb25zdCB7IGNoaWxkcmVuIH0gPSByb290O1xyXG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5bMF07XHJcbiAgICAgICAgLy8gaWYgdGhlIHNpbmdsZSBjaGlsZCBpcyBhbiBlbGVtZW50LCB0dXJuIGl0IGludG8gYSBibG9jay5cclxuICAgICAgICBpZiAoaXNTaW5nbGVFbGVtZW50Um9vdChyb290LCBjaGlsZCkgJiYgY2hpbGQuY29kZWdlbk5vZGUpIHtcclxuICAgICAgICAgICAgLy8gc2luZ2xlIGVsZW1lbnQgcm9vdCBpcyBuZXZlciBob2lzdGVkIHNvIGNvZGVnZW5Ob2RlIHdpbGwgbmV2ZXIgYmVcclxuICAgICAgICAgICAgLy8gU2ltcGxlRXhwcmVzc2lvbk5vZGVcclxuICAgICAgICAgICAgY29uc3QgY29kZWdlbk5vZGUgPSBjaGlsZC5jb2RlZ2VuTm9kZTtcclxuICAgICAgICAgICAgaWYgKGNvZGVnZW5Ob2RlLnR5cGUgPT09IDEzIC8qIFZOT0RFX0NBTEwgKi8pIHtcclxuICAgICAgICAgICAgICAgIG1ha2VCbG9jayhjb2RlZ2VuTm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcm9vdC5jb2RlZ2VuTm9kZSA9IGNvZGVnZW5Ob2RlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gLSBzaW5nbGUgPHNsb3QvPiwgSWZOb2RlLCBGb3JOb2RlOiBhbHJlYWR5IGJsb2Nrcy5cclxuICAgICAgICAgICAgLy8gLSBzaW5nbGUgdGV4dCBub2RlOiBhbHdheXMgcGF0Y2hlZC5cclxuICAgICAgICAgICAgLy8gcm9vdCBjb2RlZ2VuIGZhbGxzIHRocm91Z2ggdmlhIGdlbk5vZGUoKVxyXG4gICAgICAgICAgICByb290LmNvZGVnZW5Ob2RlID0gY2hpbGQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xyXG4gICAgICAgIC8vIHJvb3QgaGFzIG11bHRpcGxlIG5vZGVzIC0gcmV0dXJuIGEgZnJhZ21lbnQgYmxvY2suXHJcbiAgICAgICAgbGV0IHBhdGNoRmxhZyA9IDY0IC8qIFNUQUJMRV9GUkFHTUVOVCAqLztcclxuICAgICAgICBsZXQgcGF0Y2hGbGFnVGV4dCA9IFBhdGNoRmxhZ05hbWVzWzY0IC8qIFNUQUJMRV9GUkFHTUVOVCAqL107XHJcbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlIGZyYWdtZW50IGFjdHVhbGx5IGNvbnRhaW5zIGEgc2luZ2xlIHZhbGlkIGNoaWxkIHdpdGhcclxuICAgICAgICAvLyB0aGUgcmVzdCBiZWluZyBjb21tZW50c1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgY2hpbGRyZW4uZmlsdGVyKGMgPT4gYy50eXBlICE9PSAzIC8qIENPTU1FTlQgKi8pLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICBwYXRjaEZsYWcgfD0gMjA0OCAvKiBERVZfUk9PVF9GUkFHTUVOVCAqLztcclxuICAgICAgICAgICAgcGF0Y2hGbGFnVGV4dCArPSBgLCAke1BhdGNoRmxhZ05hbWVzWzIwNDggLyogREVWX1JPT1RfRlJBR01FTlQgKi9dfWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJvb3QuY29kZWdlbk5vZGUgPSBjcmVhdGVWTm9kZUNhbGwoY29udGV4dCwgaGVscGVyKEZSQUdNRU5UKSwgdW5kZWZpbmVkLCByb290LmNoaWxkcmVuLCBwYXRjaEZsYWcgKyAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYCAvKiAke3BhdGNoRmxhZ1RleHR9ICovYCA6IGBgKSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHRydWUsIHVuZGVmaW5lZCwgZmFsc2UgLyogaXNDb21wb25lbnQgKi8pO1xyXG4gICAgfVxyXG4gICAgZWxzZSA7XHJcbn1cclxuZnVuY3Rpb24gdHJhdmVyc2VDaGlsZHJlbihwYXJlbnQsIGNvbnRleHQpIHtcclxuICAgIGxldCBpID0gMDtcclxuICAgIGNvbnN0IG5vZGVSZW1vdmVkID0gKCkgPT4ge1xyXG4gICAgICAgIGktLTtcclxuICAgIH07XHJcbiAgICBmb3IgKDsgaSA8IHBhcmVudC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGNoaWxkID0gcGFyZW50LmNoaWxkcmVuW2ldO1xyXG4gICAgICAgIGlmIChpc1N0cmluZyhjaGlsZCkpXHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIGNvbnRleHQucGFyZW50ID0gcGFyZW50O1xyXG4gICAgICAgIGNvbnRleHQuY2hpbGRJbmRleCA9IGk7XHJcbiAgICAgICAgY29udGV4dC5vbk5vZGVSZW1vdmVkID0gbm9kZVJlbW92ZWQ7XHJcbiAgICAgICAgdHJhdmVyc2VOb2RlKGNoaWxkLCBjb250ZXh0KTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB0cmF2ZXJzZU5vZGUobm9kZSwgY29udGV4dCkge1xyXG4gICAgY29udGV4dC5jdXJyZW50Tm9kZSA9IG5vZGU7XHJcbiAgICAvLyBhcHBseSB0cmFuc2Zvcm0gcGx1Z2luc1xyXG4gICAgY29uc3QgeyBub2RlVHJhbnNmb3JtcyB9ID0gY29udGV4dDtcclxuICAgIGNvbnN0IGV4aXRGbnMgPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZVRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBvbkV4aXQgPSBub2RlVHJhbnNmb3Jtc1tpXShub2RlLCBjb250ZXh0KTtcclxuICAgICAgICBpZiAob25FeGl0KSB7XHJcbiAgICAgICAgICAgIGlmIChpc0FycmF5KG9uRXhpdCkpIHtcclxuICAgICAgICAgICAgICAgIGV4aXRGbnMucHVzaCguLi5vbkV4aXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZXhpdEZucy5wdXNoKG9uRXhpdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFjb250ZXh0LmN1cnJlbnROb2RlKSB7XHJcbiAgICAgICAgICAgIC8vIG5vZGUgd2FzIHJlbW92ZWRcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gbm9kZSBtYXkgaGF2ZSBiZWVuIHJlcGxhY2VkXHJcbiAgICAgICAgICAgIG5vZGUgPSBjb250ZXh0LmN1cnJlbnROb2RlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XHJcbiAgICAgICAgY2FzZSAzIC8qIENPTU1FTlQgKi86XHJcbiAgICAgICAgICAgIGlmICghY29udGV4dC5zc3IpIHtcclxuICAgICAgICAgICAgICAgIC8vIGluamVjdCBpbXBvcnQgZm9yIHRoZSBDb21tZW50IHN5bWJvbCwgd2hpY2ggaXMgbmVlZGVkIGZvciBjcmVhdGluZ1xyXG4gICAgICAgICAgICAgICAgLy8gY29tbWVudCBub2RlcyB3aXRoIGBjcmVhdGVWTm9kZWBcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuaGVscGVyKENSRUFURV9DT01NRU5UKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDUgLyogSU5URVJQT0xBVElPTiAqLzpcclxuICAgICAgICAgICAgLy8gbm8gbmVlZCB0byB0cmF2ZXJzZSwgYnV0IHdlIG5lZWQgdG8gaW5qZWN0IHRvU3RyaW5nIGhlbHBlclxyXG4gICAgICAgICAgICBpZiAoIWNvbnRleHQuc3NyKSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmhlbHBlcihUT19ESVNQTEFZX1NUUklORyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgLy8gZm9yIGNvbnRhaW5lciB0eXBlcywgZnVydGhlciB0cmF2ZXJzZSBkb3dud2FyZHNcclxuICAgICAgICBjYXNlIDkgLyogSUYgKi86XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5icmFuY2hlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdHJhdmVyc2VOb2RlKG5vZGUuYnJhbmNoZXNbaV0sIGNvbnRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMTAgLyogSUZfQlJBTkNIICovOlxyXG4gICAgICAgIGNhc2UgMTEgLyogRk9SICovOlxyXG4gICAgICAgIGNhc2UgMSAvKiBFTEVNRU5UICovOlxyXG4gICAgICAgIGNhc2UgMCAvKiBST09UICovOlxyXG4gICAgICAgICAgICB0cmF2ZXJzZUNoaWxkcmVuKG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgIH1cclxuICAgIC8vIGV4aXQgdHJhbnNmb3Jtc1xyXG4gICAgY29udGV4dC5jdXJyZW50Tm9kZSA9IG5vZGU7XHJcbiAgICBsZXQgaSA9IGV4aXRGbnMubGVuZ3RoO1xyXG4gICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgIGV4aXRGbnNbaV0oKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjcmVhdGVTdHJ1Y3R1cmFsRGlyZWN0aXZlVHJhbnNmb3JtKG5hbWUsIGZuKSB7XHJcbiAgICBjb25zdCBtYXRjaGVzID0gaXNTdHJpbmcobmFtZSlcclxuICAgICAgICA/IChuKSA9PiBuID09PSBuYW1lXHJcbiAgICAgICAgOiAobikgPT4gbmFtZS50ZXN0KG4pO1xyXG4gICAgcmV0dXJuIChub2RlLCBjb250ZXh0KSA9PiB7XHJcbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gMSAvKiBFTEVNRU5UICovKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgcHJvcHMgfSA9IG5vZGU7XHJcbiAgICAgICAgICAgIC8vIHN0cnVjdHVyYWwgZGlyZWN0aXZlIHRyYW5zZm9ybXMgYXJlIG5vdCBjb25jZXJuZWQgd2l0aCBzbG90c1xyXG4gICAgICAgICAgICAvLyBhcyB0aGV5IGFyZSBoYW5kbGVkIHNlcGFyYXRlbHkgaW4gdlNsb3QudHNcclxuICAgICAgICAgICAgaWYgKG5vZGUudGFnVHlwZSA9PT0gMyAvKiBURU1QTEFURSAqLyAmJiBwcm9wcy5zb21lKGlzVlNsb3QpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgZXhpdEZucyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wID0gcHJvcHNbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvcC50eXBlID09PSA3IC8qIERJUkVDVElWRSAqLyAmJiBtYXRjaGVzKHByb3AubmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZXMgYXJlIHJlbW92ZWQgdG8gYXZvaWQgaW5maW5pdGUgcmVjdXJzaW9uXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYWxzbyB3ZSByZW1vdmUgdGhlbSAqYmVmb3JlKiBhcHBseWluZyBzbyB0aGF0IGl0IGNhbiBmdXJ0aGVyXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJhdmVyc2UgaXRzZWxmIGluIGNhc2UgaXQgbW92ZXMgdGhlIG5vZGUgYXJvdW5kXHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGktLTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBvbkV4aXQgPSBmbihub2RlLCBwcm9wLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob25FeGl0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBleGl0Rm5zLnB1c2gob25FeGl0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZXhpdEZucztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XG5cbmNvbnN0IFBVUkVfQU5OT1RBVElPTiA9IGAvKiNfX1BVUkVfXyovYDtcclxuY29uc3QgYWxpYXNIZWxwZXIgPSAocykgPT4gYCR7aGVscGVyTmFtZU1hcFtzXX06IF8ke2hlbHBlck5hbWVNYXBbc119YDtcclxuZnVuY3Rpb24gY3JlYXRlQ29kZWdlbkNvbnRleHQoYXN0LCB7IG1vZGUgPSAnZnVuY3Rpb24nLCBwcmVmaXhJZGVudGlmaWVycyA9IG1vZGUgPT09ICdtb2R1bGUnLCBzb3VyY2VNYXAgPSBmYWxzZSwgZmlsZW5hbWUgPSBgdGVtcGxhdGUudnVlLmh0bWxgLCBzY29wZUlkID0gbnVsbCwgb3B0aW1pemVJbXBvcnRzID0gZmFsc2UsIHJ1bnRpbWVHbG9iYWxOYW1lID0gYFZ1ZWAsIHJ1bnRpbWVNb2R1bGVOYW1lID0gYHZ1ZWAsIHNzclJ1bnRpbWVNb2R1bGVOYW1lID0gJ3Z1ZS9zZXJ2ZXItcmVuZGVyZXInLCBzc3IgPSBmYWxzZSwgaXNUUyA9IGZhbHNlLCBpblNTUiA9IGZhbHNlIH0pIHtcclxuICAgIGNvbnN0IGNvbnRleHQgPSB7XHJcbiAgICAgICAgbW9kZSxcclxuICAgICAgICBwcmVmaXhJZGVudGlmaWVycyxcclxuICAgICAgICBzb3VyY2VNYXAsXHJcbiAgICAgICAgZmlsZW5hbWUsXHJcbiAgICAgICAgc2NvcGVJZCxcclxuICAgICAgICBvcHRpbWl6ZUltcG9ydHMsXHJcbiAgICAgICAgcnVudGltZUdsb2JhbE5hbWUsXHJcbiAgICAgICAgcnVudGltZU1vZHVsZU5hbWUsXHJcbiAgICAgICAgc3NyUnVudGltZU1vZHVsZU5hbWUsXHJcbiAgICAgICAgc3NyLFxyXG4gICAgICAgIGlzVFMsXHJcbiAgICAgICAgaW5TU1IsXHJcbiAgICAgICAgc291cmNlOiBhc3QubG9jLnNvdXJjZSxcclxuICAgICAgICBjb2RlOiBgYCxcclxuICAgICAgICBjb2x1bW46IDEsXHJcbiAgICAgICAgbGluZTogMSxcclxuICAgICAgICBvZmZzZXQ6IDAsXHJcbiAgICAgICAgaW5kZW50TGV2ZWw6IDAsXHJcbiAgICAgICAgcHVyZTogZmFsc2UsXHJcbiAgICAgICAgbWFwOiB1bmRlZmluZWQsXHJcbiAgICAgICAgaGVscGVyKGtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYF8ke2hlbHBlck5hbWVNYXBba2V5XX1gO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcHVzaChjb2RlLCBub2RlKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQuY29kZSArPSBjb2RlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaW5kZW50KCkge1xyXG4gICAgICAgICAgICBuZXdsaW5lKCsrY29udGV4dC5pbmRlbnRMZXZlbCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkZWluZGVudCh3aXRob3V0TmV3TGluZSA9IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGlmICh3aXRob3V0TmV3TGluZSkge1xyXG4gICAgICAgICAgICAgICAgLS1jb250ZXh0LmluZGVudExldmVsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbmV3bGluZSgtLWNvbnRleHQuaW5kZW50TGV2ZWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBuZXdsaW5lKCkge1xyXG4gICAgICAgICAgICBuZXdsaW5lKGNvbnRleHQuaW5kZW50TGV2ZWwpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBmdW5jdGlvbiBuZXdsaW5lKG4pIHtcclxuICAgICAgICBjb250ZXh0LnB1c2goJ1xcbicgKyBgICBgLnJlcGVhdChuKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY29udGV4dDtcclxufVxyXG5mdW5jdGlvbiBnZW5lcmF0ZShhc3QsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZUNvZGVnZW5Db250ZXh0KGFzdCwgb3B0aW9ucyk7XHJcbiAgICBpZiAob3B0aW9ucy5vbkNvbnRleHRDcmVhdGVkKVxyXG4gICAgICAgIG9wdGlvbnMub25Db250ZXh0Q3JlYXRlZChjb250ZXh0KTtcclxuICAgIGNvbnN0IHsgbW9kZSwgcHVzaCwgcHJlZml4SWRlbnRpZmllcnMsIGluZGVudCwgZGVpbmRlbnQsIG5ld2xpbmUsIHNjb3BlSWQsIHNzciB9ID0gY29udGV4dDtcclxuICAgIGNvbnN0IGhhc0hlbHBlcnMgPSBhc3QuaGVscGVycy5sZW5ndGggPiAwO1xyXG4gICAgY29uc3QgdXNlV2l0aEJsb2NrID0gIXByZWZpeElkZW50aWZpZXJzICYmIG1vZGUgIT09ICdtb2R1bGUnO1xyXG4gICAgLy8gcHJlYW1ibGVzXHJcbiAgICAvLyBpbiBzZXR1cCgpIGlubGluZSBtb2RlLCB0aGUgcHJlYW1ibGUgaXMgZ2VuZXJhdGVkIGluIGEgc3ViIGNvbnRleHRcclxuICAgIC8vIGFuZCByZXR1cm5lZCBzZXBhcmF0ZWx5LlxyXG4gICAgY29uc3QgcHJlYW1ibGVDb250ZXh0ID0gY29udGV4dDtcclxuICAgIHtcclxuICAgICAgICBnZW5GdW5jdGlvblByZWFtYmxlKGFzdCwgcHJlYW1ibGVDb250ZXh0KTtcclxuICAgIH1cclxuICAgIC8vIGVudGVyIHJlbmRlciBmdW5jdGlvblxyXG4gICAgY29uc3QgZnVuY3Rpb25OYW1lID0gc3NyID8gYHNzclJlbmRlcmAgOiBgcmVuZGVyYDtcclxuICAgIGNvbnN0IGFyZ3MgPSBzc3IgPyBbJ19jdHgnLCAnX3B1c2gnLCAnX3BhcmVudCcsICdfYXR0cnMnXSA6IFsnX2N0eCcsICdfY2FjaGUnXTtcclxuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGFyZ3Muam9pbignLCAnKTtcclxuICAgIHtcclxuICAgICAgICBwdXNoKGBmdW5jdGlvbiAke2Z1bmN0aW9uTmFtZX0oJHtzaWduYXR1cmV9KSB7YCk7XHJcbiAgICB9XHJcbiAgICBpbmRlbnQoKTtcclxuICAgIGlmICh1c2VXaXRoQmxvY2spIHtcclxuICAgICAgICBwdXNoKGB3aXRoIChfY3R4KSB7YCk7XHJcbiAgICAgICAgaW5kZW50KCk7XHJcbiAgICAgICAgLy8gZnVuY3Rpb24gbW9kZSBjb25zdCBkZWNsYXJhdGlvbnMgc2hvdWxkIGJlIGluc2lkZSB3aXRoIGJsb2NrXHJcbiAgICAgICAgLy8gYWxzbyB0aGV5IHNob3VsZCBiZSByZW5hbWVkIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIHVzZXIgcHJvcGVydGllc1xyXG4gICAgICAgIGlmIChoYXNIZWxwZXJzKSB7XHJcbiAgICAgICAgICAgIHB1c2goYGNvbnN0IHsgJHthc3QuaGVscGVycy5tYXAoYWxpYXNIZWxwZXIpLmpvaW4oJywgJyl9IH0gPSBfVnVlYCk7XHJcbiAgICAgICAgICAgIHB1c2goYFxcbmApO1xyXG4gICAgICAgICAgICBuZXdsaW5lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gZ2VuZXJhdGUgYXNzZXQgcmVzb2x1dGlvbiBzdGF0ZW1lbnRzXHJcbiAgICBpZiAoYXN0LmNvbXBvbmVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgZ2VuQXNzZXRzKGFzdC5jb21wb25lbnRzLCAnY29tcG9uZW50JywgY29udGV4dCk7XHJcbiAgICAgICAgaWYgKGFzdC5kaXJlY3RpdmVzLmxlbmd0aCB8fCBhc3QudGVtcHMgPiAwKSB7XHJcbiAgICAgICAgICAgIG5ld2xpbmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoYXN0LmRpcmVjdGl2ZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgZ2VuQXNzZXRzKGFzdC5kaXJlY3RpdmVzLCAnZGlyZWN0aXZlJywgY29udGV4dCk7XHJcbiAgICAgICAgaWYgKGFzdC50ZW1wcyA+IDApIHtcclxuICAgICAgICAgICAgbmV3bGluZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChhc3QuZmlsdGVycyAmJiBhc3QuZmlsdGVycy5sZW5ndGgpIHtcclxuICAgICAgICBuZXdsaW5lKCk7XHJcbiAgICAgICAgZ2VuQXNzZXRzKGFzdC5maWx0ZXJzLCAnZmlsdGVyJywgY29udGV4dCk7XHJcbiAgICAgICAgbmV3bGluZSgpO1xyXG4gICAgfVxyXG4gICAgaWYgKGFzdC50ZW1wcyA+IDApIHtcclxuICAgICAgICBwdXNoKGBsZXQgYCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhc3QudGVtcHM7IGkrKykge1xyXG4gICAgICAgICAgICBwdXNoKGAke2kgPiAwID8gYCwgYCA6IGBgfV90ZW1wJHtpfWApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChhc3QuY29tcG9uZW50cy5sZW5ndGggfHwgYXN0LmRpcmVjdGl2ZXMubGVuZ3RoIHx8IGFzdC50ZW1wcykge1xyXG4gICAgICAgIHB1c2goYFxcbmApO1xyXG4gICAgICAgIG5ld2xpbmUoKTtcclxuICAgIH1cclxuICAgIC8vIGdlbmVyYXRlIHRoZSBWTm9kZSB0cmVlIGV4cHJlc3Npb25cclxuICAgIGlmICghc3NyKSB7XHJcbiAgICAgICAgcHVzaChgcmV0dXJuIGApO1xyXG4gICAgfVxyXG4gICAgaWYgKGFzdC5jb2RlZ2VuTm9kZSkge1xyXG4gICAgICAgIGdlbk5vZGUoYXN0LmNvZGVnZW5Ob2RlLCBjb250ZXh0KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHB1c2goYG51bGxgKTtcclxuICAgIH1cclxuICAgIGlmICh1c2VXaXRoQmxvY2spIHtcclxuICAgICAgICBkZWluZGVudCgpO1xyXG4gICAgICAgIHB1c2goYH1gKTtcclxuICAgIH1cclxuICAgIGRlaW5kZW50KCk7XHJcbiAgICBwdXNoKGB9YCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGFzdCxcclxuICAgICAgICBjb2RlOiBjb250ZXh0LmNvZGUsXHJcbiAgICAgICAgcHJlYW1ibGU6IGBgLFxyXG4gICAgICAgIC8vIFNvdXJjZU1hcEdlbmVyYXRvciBkb2VzIGhhdmUgdG9KU09OKCkgbWV0aG9kIGJ1dCBpdCdzIG5vdCBpbiB0aGUgdHlwZXNcclxuICAgICAgICBtYXA6IGNvbnRleHQubWFwID8gY29udGV4dC5tYXAudG9KU09OKCkgOiB1bmRlZmluZWRcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gZ2VuRnVuY3Rpb25QcmVhbWJsZShhc3QsIGNvbnRleHQpIHtcclxuICAgIGNvbnN0IHsgc3NyLCBwcmVmaXhJZGVudGlmaWVycywgcHVzaCwgbmV3bGluZSwgcnVudGltZU1vZHVsZU5hbWUsIHJ1bnRpbWVHbG9iYWxOYW1lLCBzc3JSdW50aW1lTW9kdWxlTmFtZSB9ID0gY29udGV4dDtcclxuICAgIGNvbnN0IFZ1ZUJpbmRpbmcgPSBydW50aW1lR2xvYmFsTmFtZTtcclxuICAgIC8vIEdlbmVyYXRlIGNvbnN0IGRlY2xhcmF0aW9uIGZvciBoZWxwZXJzXHJcbiAgICAvLyBJbiBwcmVmaXggbW9kZSwgd2UgcGxhY2UgdGhlIGNvbnN0IGRlY2xhcmF0aW9uIGF0IHRvcCBzbyBpdCdzIGRvbmVcclxuICAgIC8vIG9ubHkgb25jZTsgQnV0IGlmIHdlIG5vdCBwcmVmaXhpbmcsIHdlIHBsYWNlIHRoZSBkZWNsYXJhdGlvbiBpbnNpZGUgdGhlXHJcbiAgICAvLyB3aXRoIGJsb2NrIHNvIGl0IGRvZXNuJ3QgaW5jdXIgdGhlIGBpbmAgY2hlY2sgY29zdCBmb3IgZXZlcnkgaGVscGVyIGFjY2Vzcy5cclxuICAgIGlmIChhc3QuaGVscGVycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBcIndpdGhcIiBtb2RlLlxyXG4gICAgICAgICAgICAvLyBzYXZlIFZ1ZSBpbiBhIHNlcGFyYXRlIHZhcmlhYmxlIHRvIGF2b2lkIGNvbGxpc2lvblxyXG4gICAgICAgICAgICBwdXNoKGBjb25zdCBfVnVlID0gJHtWdWVCaW5kaW5nfVxcbmApO1xyXG4gICAgICAgICAgICAvLyBpbiBcIndpdGhcIiBtb2RlLCBoZWxwZXJzIGFyZSBkZWNsYXJlZCBpbnNpZGUgdGhlIHdpdGggYmxvY2sgdG8gYXZvaWRcclxuICAgICAgICAgICAgLy8gaGFzIGNoZWNrIGNvc3QsIGJ1dCBob2lzdHMgYXJlIGxpZnRlZCBvdXQgb2YgdGhlIGZ1bmN0aW9uIC0gd2UgbmVlZFxyXG4gICAgICAgICAgICAvLyB0byBwcm92aWRlIHRoZSBoZWxwZXIgaGVyZS5cclxuICAgICAgICAgICAgaWYgKGFzdC5ob2lzdHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdGF0aWNIZWxwZXJzID0gW1xyXG4gICAgICAgICAgICAgICAgICAgIENSRUFURV9WTk9ERSxcclxuICAgICAgICAgICAgICAgICAgICBDUkVBVEVfRUxFTUVOVF9WTk9ERSxcclxuICAgICAgICAgICAgICAgICAgICBDUkVBVEVfQ09NTUVOVCxcclxuICAgICAgICAgICAgICAgICAgICBDUkVBVEVfVEVYVCxcclxuICAgICAgICAgICAgICAgICAgICBDUkVBVEVfU1RBVElDXHJcbiAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihoZWxwZXIgPT4gYXN0LmhlbHBlcnMuaW5jbHVkZXMoaGVscGVyKSlcclxuICAgICAgICAgICAgICAgICAgICAubWFwKGFsaWFzSGVscGVyKVxyXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKCcsICcpO1xyXG4gICAgICAgICAgICAgICAgcHVzaChgY29uc3QgeyAke3N0YXRpY0hlbHBlcnN9IH0gPSBfVnVlXFxuYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZW5Ib2lzdHMoYXN0LmhvaXN0cywgY29udGV4dCk7XHJcbiAgICBuZXdsaW5lKCk7XHJcbiAgICBwdXNoKGByZXR1cm4gYCk7XHJcbn1cclxuZnVuY3Rpb24gZ2VuQXNzZXRzKGFzc2V0cywgdHlwZSwgeyBoZWxwZXIsIHB1c2gsIG5ld2xpbmUsIGlzVFMgfSkge1xyXG4gICAgY29uc3QgcmVzb2x2ZXIgPSBoZWxwZXIodHlwZSA9PT0gJ2ZpbHRlcidcclxuICAgICAgICA/IFJFU09MVkVfRklMVEVSXHJcbiAgICAgICAgOiB0eXBlID09PSAnY29tcG9uZW50J1xyXG4gICAgICAgICAgICA/IFJFU09MVkVfQ09NUE9ORU5UXHJcbiAgICAgICAgICAgIDogUkVTT0xWRV9ESVJFQ1RJVkUpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhc3NldHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBsZXQgaWQgPSBhc3NldHNbaV07XHJcbiAgICAgICAgLy8gcG90ZW50aWFsIGNvbXBvbmVudCBpbXBsaWNpdCBzZWxmLXJlZmVyZW5jZSBpbmZlcnJlZCBmcm9tIFNGQyBmaWxlbmFtZVxyXG4gICAgICAgIGNvbnN0IG1heWJlU2VsZlJlZmVyZW5jZSA9IGlkLmVuZHNXaXRoKCdfX3NlbGYnKTtcclxuICAgICAgICBpZiAobWF5YmVTZWxmUmVmZXJlbmNlKSB7XHJcbiAgICAgICAgICAgIGlkID0gaWQuc2xpY2UoMCwgLTYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwdXNoKGBjb25zdCAke3RvVmFsaWRBc3NldElkKGlkLCB0eXBlKX0gPSAke3Jlc29sdmVyfSgke0pTT04uc3RyaW5naWZ5KGlkKX0ke21heWJlU2VsZlJlZmVyZW5jZSA/IGAsIHRydWVgIDogYGB9KSR7aXNUUyA/IGAhYCA6IGBgfWApO1xyXG4gICAgICAgIGlmIChpIDwgYXNzZXRzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgbmV3bGluZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZW5Ib2lzdHMoaG9pc3RzLCBjb250ZXh0KSB7XHJcbiAgICBpZiAoIWhvaXN0cy5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb250ZXh0LnB1cmUgPSB0cnVlO1xyXG4gICAgY29uc3QgeyBwdXNoLCBuZXdsaW5lLCBoZWxwZXIsIHNjb3BlSWQsIG1vZGUgfSA9IGNvbnRleHQ7XHJcbiAgICBuZXdsaW5lKCk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhvaXN0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGV4cCA9IGhvaXN0c1tpXTtcclxuICAgICAgICBpZiAoZXhwKSB7XHJcbiAgICAgICAgICAgIHB1c2goYGNvbnN0IF9ob2lzdGVkXyR7aSArIDF9ID0gJHtgYH1gKTtcclxuICAgICAgICAgICAgZ2VuTm9kZShleHAsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBuZXdsaW5lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29udGV4dC5wdXJlID0gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gaXNUZXh0JDEobikge1xyXG4gICAgcmV0dXJuIChpc1N0cmluZyhuKSB8fFxyXG4gICAgICAgIG4udHlwZSA9PT0gNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLyB8fFxyXG4gICAgICAgIG4udHlwZSA9PT0gMiAvKiBURVhUICovIHx8XHJcbiAgICAgICAgbi50eXBlID09PSA1IC8qIElOVEVSUE9MQVRJT04gKi8gfHxcclxuICAgICAgICBuLnR5cGUgPT09IDggLyogQ09NUE9VTkRfRVhQUkVTU0lPTiAqLyk7XHJcbn1cclxuZnVuY3Rpb24gZ2VuTm9kZUxpc3RBc0FycmF5KG5vZGVzLCBjb250ZXh0KSB7XHJcbiAgICBjb25zdCBtdWx0aWxpbmVzID0gbm9kZXMubGVuZ3RoID4gMyB8fFxyXG4gICAgICAgICgoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSAmJiBub2Rlcy5zb21lKG4gPT4gaXNBcnJheShuKSB8fCAhaXNUZXh0JDEobikpKTtcclxuICAgIGNvbnRleHQucHVzaChgW2ApO1xyXG4gICAgbXVsdGlsaW5lcyAmJiBjb250ZXh0LmluZGVudCgpO1xyXG4gICAgZ2VuTm9kZUxpc3Qobm9kZXMsIGNvbnRleHQsIG11bHRpbGluZXMpO1xyXG4gICAgbXVsdGlsaW5lcyAmJiBjb250ZXh0LmRlaW5kZW50KCk7XHJcbiAgICBjb250ZXh0LnB1c2goYF1gKTtcclxufVxyXG5mdW5jdGlvbiBnZW5Ob2RlTGlzdChub2RlcywgY29udGV4dCwgbXVsdGlsaW5lcyA9IGZhbHNlLCBjb21tYSA9IHRydWUpIHtcclxuICAgIGNvbnN0IHsgcHVzaCwgbmV3bGluZSB9ID0gY29udGV4dDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XHJcbiAgICAgICAgaWYgKGlzU3RyaW5nKG5vZGUpKSB7XHJcbiAgICAgICAgICAgIHB1c2gobm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzQXJyYXkobm9kZSkpIHtcclxuICAgICAgICAgICAgZ2VuTm9kZUxpc3RBc0FycmF5KG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZ2VuTm9kZShub2RlLCBjb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGkgPCBub2Rlcy5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgIGlmIChtdWx0aWxpbmVzKSB7XHJcbiAgICAgICAgICAgICAgICBjb21tYSAmJiBwdXNoKCcsJyk7XHJcbiAgICAgICAgICAgICAgICBuZXdsaW5lKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb21tYSAmJiBwdXNoKCcsICcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdlbk5vZGUobm9kZSwgY29udGV4dCkge1xyXG4gICAgaWYgKGlzU3RyaW5nKG5vZGUpKSB7XHJcbiAgICAgICAgY29udGV4dC5wdXNoKG5vZGUpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmIChpc1N5bWJvbChub2RlKSkge1xyXG4gICAgICAgIGNvbnRleHQucHVzaChjb250ZXh0LmhlbHBlcihub2RlKSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcclxuICAgICAgICBjYXNlIDEgLyogRUxFTUVOVCAqLzpcclxuICAgICAgICBjYXNlIDkgLyogSUYgKi86XHJcbiAgICAgICAgY2FzZSAxMSAvKiBGT1IgKi86XHJcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgYXNzZXJ0KG5vZGUuY29kZWdlbk5vZGUgIT0gbnVsbCwgYENvZGVnZW4gbm9kZSBpcyBtaXNzaW5nIGZvciBlbGVtZW50L2lmL2ZvciBub2RlLiBgICtcclxuICAgICAgICAgICAgICAgICAgICBgQXBwbHkgYXBwcm9wcmlhdGUgdHJhbnNmb3JtcyBmaXJzdC5gKTtcclxuICAgICAgICAgICAgZ2VuTm9kZShub2RlLmNvZGVnZW5Ob2RlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAyIC8qIFRFWFQgKi86XHJcbiAgICAgICAgICAgIGdlblRleHQobm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLzpcclxuICAgICAgICAgICAgZ2VuRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSA1IC8qIElOVEVSUE9MQVRJT04gKi86XHJcbiAgICAgICAgICAgIGdlbkludGVycG9sYXRpb24obm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMTIgLyogVEVYVF9DQUxMICovOlxyXG4gICAgICAgICAgICBnZW5Ob2RlKG5vZGUuY29kZWdlbk5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDggLyogQ09NUE9VTkRfRVhQUkVTU0lPTiAqLzpcclxuICAgICAgICAgICAgZ2VuQ29tcG91bmRFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDMgLyogQ09NTUVOVCAqLzpcclxuICAgICAgICAgICAgZ2VuQ29tbWVudChub2RlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAxMyAvKiBWTk9ERV9DQUxMICovOlxyXG4gICAgICAgICAgICBnZW5WTm9kZUNhbGwobm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMTQgLyogSlNfQ0FMTF9FWFBSRVNTSU9OICovOlxyXG4gICAgICAgICAgICBnZW5DYWxsRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAxNSAvKiBKU19PQkpFQ1RfRVhQUkVTU0lPTiAqLzpcclxuICAgICAgICAgICAgZ2VuT2JqZWN0RXhwcmVzc2lvbihub2RlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAxNyAvKiBKU19BUlJBWV9FWFBSRVNTSU9OICovOlxyXG4gICAgICAgICAgICBnZW5BcnJheUV4cHJlc3Npb24obm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMTggLyogSlNfRlVOQ1RJT05fRVhQUkVTU0lPTiAqLzpcclxuICAgICAgICAgICAgZ2VuRnVuY3Rpb25FeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDE5IC8qIEpTX0NPTkRJVElPTkFMX0VYUFJFU1NJT04gKi86XHJcbiAgICAgICAgICAgIGdlbkNvbmRpdGlvbmFsRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAyMCAvKiBKU19DQUNIRV9FWFBSRVNTSU9OICovOlxyXG4gICAgICAgICAgICBnZW5DYWNoZUV4cHJlc3Npb24obm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMjEgLyogSlNfQkxPQ0tfU1RBVEVNRU5UICovOlxyXG4gICAgICAgICAgICBnZW5Ob2RlTGlzdChub2RlLmJvZHksIGNvbnRleHQsIHRydWUsIGZhbHNlKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgLy8gU1NSIG9ubHkgdHlwZXNcclxuICAgICAgICBjYXNlIDIyIC8qIEpTX1RFTVBMQVRFX0xJVEVSQUwgKi86XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMjMgLyogSlNfSUZfU1RBVEVNRU5UICovOlxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDI0IC8qIEpTX0FTU0lHTk1FTlRfRVhQUkVTU0lPTiAqLzpcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAyNSAvKiBKU19TRVFVRU5DRV9FWFBSRVNTSU9OICovOlxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDI2IC8qIEpTX1JFVFVSTl9TVEFURU1FTlQgKi86XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgY2FzZSAxMCAvKiBJRl9CUkFOQ0ggKi86XHJcbiAgICAgICAgICAgIC8vIG5vb3BcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBgdW5oYW5kbGVkIGNvZGVnZW4gbm9kZSB0eXBlOiAke25vZGUudHlwZX1gKTtcclxuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBleGhhdXN0IGFsbCBwb3NzaWJsZSB0eXBlc1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZXhoYXVzdGl2ZUNoZWNrID0gbm9kZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBleGhhdXN0aXZlQ2hlY2s7XHJcbiAgICAgICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZW5UZXh0KG5vZGUsIGNvbnRleHQpIHtcclxuICAgIGNvbnRleHQucHVzaChKU09OLnN0cmluZ2lmeShub2RlLmNvbnRlbnQpLCBub2RlKTtcclxufVxyXG5mdW5jdGlvbiBnZW5FeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpIHtcclxuICAgIGNvbnN0IHsgY29udGVudCwgaXNTdGF0aWMgfSA9IG5vZGU7XHJcbiAgICBjb250ZXh0LnB1c2goaXNTdGF0aWMgPyBKU09OLnN0cmluZ2lmeShjb250ZW50KSA6IGNvbnRlbnQsIG5vZGUpO1xyXG59XHJcbmZ1bmN0aW9uIGdlbkludGVycG9sYXRpb24obm9kZSwgY29udGV4dCkge1xyXG4gICAgY29uc3QgeyBwdXNoLCBoZWxwZXIsIHB1cmUgfSA9IGNvbnRleHQ7XHJcbiAgICBpZiAocHVyZSlcclxuICAgICAgICBwdXNoKFBVUkVfQU5OT1RBVElPTik7XHJcbiAgICBwdXNoKGAke2hlbHBlcihUT19ESVNQTEFZX1NUUklORyl9KGApO1xyXG4gICAgZ2VuTm9kZShub2RlLmNvbnRlbnQsIGNvbnRleHQpO1xyXG4gICAgcHVzaChgKWApO1xyXG59XHJcbmZ1bmN0aW9uIGdlbkNvbXBvdW5kRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XHJcbiAgICAgICAgaWYgKGlzU3RyaW5nKGNoaWxkKSkge1xyXG4gICAgICAgICAgICBjb250ZXh0LnB1c2goY2hpbGQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZ2VuTm9kZShjaGlsZCwgY29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdlbkV4cHJlc3Npb25Bc1Byb3BlcnR5S2V5KG5vZGUsIGNvbnRleHQpIHtcclxuICAgIGNvbnN0IHsgcHVzaCB9ID0gY29udGV4dDtcclxuICAgIGlmIChub2RlLnR5cGUgPT09IDggLyogQ09NUE9VTkRfRVhQUkVTU0lPTiAqLykge1xyXG4gICAgICAgIHB1c2goYFtgKTtcclxuICAgICAgICBnZW5Db21wb3VuZEV4cHJlc3Npb24obm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgcHVzaChgXWApO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobm9kZS5pc1N0YXRpYykge1xyXG4gICAgICAgIC8vIG9ubHkgcXVvdGUga2V5cyBpZiBuZWNlc3NhcnlcclxuICAgICAgICBjb25zdCB0ZXh0ID0gaXNTaW1wbGVJZGVudGlmaWVyKG5vZGUuY29udGVudClcclxuICAgICAgICAgICAgPyBub2RlLmNvbnRlbnRcclxuICAgICAgICAgICAgOiBKU09OLnN0cmluZ2lmeShub2RlLmNvbnRlbnQpO1xyXG4gICAgICAgIHB1c2godGV4dCwgbm9kZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBwdXNoKGBbJHtub2RlLmNvbnRlbnR9XWAsIG5vZGUpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdlbkNvbW1lbnQobm9kZSwgY29udGV4dCkge1xyXG4gICAgY29uc3QgeyBwdXNoLCBoZWxwZXIsIHB1cmUgfSA9IGNvbnRleHQ7XHJcbiAgICBpZiAocHVyZSkge1xyXG4gICAgICAgIHB1c2goUFVSRV9BTk5PVEFUSU9OKTtcclxuICAgIH1cclxuICAgIHB1c2goYCR7aGVscGVyKENSRUFURV9DT01NRU5UKX0oJHtKU09OLnN0cmluZ2lmeShub2RlLmNvbnRlbnQpfSlgLCBub2RlKTtcclxufVxyXG5mdW5jdGlvbiBnZW5WTm9kZUNhbGwobm9kZSwgY29udGV4dCkge1xyXG4gICAgY29uc3QgeyBwdXNoLCBoZWxwZXIsIHB1cmUgfSA9IGNvbnRleHQ7XHJcbiAgICBjb25zdCB7IHRhZywgcHJvcHMsIGNoaWxkcmVuLCBwYXRjaEZsYWcsIGR5bmFtaWNQcm9wcywgZGlyZWN0aXZlcywgaXNCbG9jaywgZGlzYWJsZVRyYWNraW5nLCBpc0NvbXBvbmVudCB9ID0gbm9kZTtcclxuICAgIGlmIChkaXJlY3RpdmVzKSB7XHJcbiAgICAgICAgcHVzaChoZWxwZXIoV0lUSF9ESVJFQ1RJVkVTKSArIGAoYCk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNCbG9jaykge1xyXG4gICAgICAgIHB1c2goYCgke2hlbHBlcihPUEVOX0JMT0NLKX0oJHtkaXNhYmxlVHJhY2tpbmcgPyBgdHJ1ZWAgOiBgYH0pLCBgKTtcclxuICAgIH1cclxuICAgIGlmIChwdXJlKSB7XHJcbiAgICAgICAgcHVzaChQVVJFX0FOTk9UQVRJT04pO1xyXG4gICAgfVxyXG4gICAgY29uc3QgY2FsbEhlbHBlciA9IGlzQmxvY2tcclxuICAgICAgICA/IGdldFZOb2RlQmxvY2tIZWxwZXIoY29udGV4dC5pblNTUiwgaXNDb21wb25lbnQpXHJcbiAgICAgICAgOiBnZXRWTm9kZUhlbHBlcihjb250ZXh0LmluU1NSLCBpc0NvbXBvbmVudCk7XHJcbiAgICBwdXNoKGhlbHBlcihjYWxsSGVscGVyKSArIGAoYCwgbm9kZSk7XHJcbiAgICBnZW5Ob2RlTGlzdChnZW5OdWxsYWJsZUFyZ3MoW3RhZywgcHJvcHMsIGNoaWxkcmVuLCBwYXRjaEZsYWcsIGR5bmFtaWNQcm9wc10pLCBjb250ZXh0KTtcclxuICAgIHB1c2goYClgKTtcclxuICAgIGlmIChpc0Jsb2NrKSB7XHJcbiAgICAgICAgcHVzaChgKWApO1xyXG4gICAgfVxyXG4gICAgaWYgKGRpcmVjdGl2ZXMpIHtcclxuICAgICAgICBwdXNoKGAsIGApO1xyXG4gICAgICAgIGdlbk5vZGUoZGlyZWN0aXZlcywgY29udGV4dCk7XHJcbiAgICAgICAgcHVzaChgKWApO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdlbk51bGxhYmxlQXJncyhhcmdzKSB7XHJcbiAgICBsZXQgaSA9IGFyZ3MubGVuZ3RoO1xyXG4gICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgIGlmIChhcmdzW2ldICE9IG51bGwpXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyZ3Muc2xpY2UoMCwgaSArIDEpLm1hcChhcmcgPT4gYXJnIHx8IGBudWxsYCk7XHJcbn1cclxuLy8gSmF2YVNjcmlwdFxyXG5mdW5jdGlvbiBnZW5DYWxsRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KSB7XHJcbiAgICBjb25zdCB7IHB1c2gsIGhlbHBlciwgcHVyZSB9ID0gY29udGV4dDtcclxuICAgIGNvbnN0IGNhbGxlZSA9IGlzU3RyaW5nKG5vZGUuY2FsbGVlKSA/IG5vZGUuY2FsbGVlIDogaGVscGVyKG5vZGUuY2FsbGVlKTtcclxuICAgIGlmIChwdXJlKSB7XHJcbiAgICAgICAgcHVzaChQVVJFX0FOTk9UQVRJT04pO1xyXG4gICAgfVxyXG4gICAgcHVzaChjYWxsZWUgKyBgKGAsIG5vZGUpO1xyXG4gICAgZ2VuTm9kZUxpc3Qobm9kZS5hcmd1bWVudHMsIGNvbnRleHQpO1xyXG4gICAgcHVzaChgKWApO1xyXG59XHJcbmZ1bmN0aW9uIGdlbk9iamVjdEV4cHJlc3Npb24obm9kZSwgY29udGV4dCkge1xyXG4gICAgY29uc3QgeyBwdXNoLCBpbmRlbnQsIGRlaW5kZW50LCBuZXdsaW5lIH0gPSBjb250ZXh0O1xyXG4gICAgY29uc3QgeyBwcm9wZXJ0aWVzIH0gPSBub2RlO1xyXG4gICAgaWYgKCFwcm9wZXJ0aWVzLmxlbmd0aCkge1xyXG4gICAgICAgIHB1c2goYHt9YCwgbm9kZSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbXVsdGlsaW5lcyA9IHByb3BlcnRpZXMubGVuZ3RoID4gMSB8fFxyXG4gICAgICAgICgoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSAmJlxyXG4gICAgICAgICAgICBwcm9wZXJ0aWVzLnNvbWUocCA9PiBwLnZhbHVlLnR5cGUgIT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8pKTtcclxuICAgIHB1c2gobXVsdGlsaW5lcyA/IGB7YCA6IGB7IGApO1xyXG4gICAgbXVsdGlsaW5lcyAmJiBpbmRlbnQoKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHsga2V5LCB2YWx1ZSB9ID0gcHJvcGVydGllc1tpXTtcclxuICAgICAgICAvLyBrZXlcclxuICAgICAgICBnZW5FeHByZXNzaW9uQXNQcm9wZXJ0eUtleShrZXksIGNvbnRleHQpO1xyXG4gICAgICAgIHB1c2goYDogYCk7XHJcbiAgICAgICAgLy8gdmFsdWVcclxuICAgICAgICBnZW5Ob2RlKHZhbHVlLCBjb250ZXh0KTtcclxuICAgICAgICBpZiAoaSA8IHByb3BlcnRpZXMubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAvLyB3aWxsIG9ubHkgcmVhY2ggdGhpcyBpZiBpdCdzIG11bHRpbGluZXNcclxuICAgICAgICAgICAgcHVzaChgLGApO1xyXG4gICAgICAgICAgICBuZXdsaW5lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbXVsdGlsaW5lcyAmJiBkZWluZGVudCgpO1xyXG4gICAgcHVzaChtdWx0aWxpbmVzID8gYH1gIDogYCB9YCk7XHJcbn1cclxuZnVuY3Rpb24gZ2VuQXJyYXlFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpIHtcclxuICAgIGdlbk5vZGVMaXN0QXNBcnJheShub2RlLmVsZW1lbnRzLCBjb250ZXh0KTtcclxufVxyXG5mdW5jdGlvbiBnZW5GdW5jdGlvbkV4cHJlc3Npb24obm9kZSwgY29udGV4dCkge1xyXG4gICAgY29uc3QgeyBwdXNoLCBpbmRlbnQsIGRlaW5kZW50IH0gPSBjb250ZXh0O1xyXG4gICAgY29uc3QgeyBwYXJhbXMsIHJldHVybnMsIGJvZHksIG5ld2xpbmUsIGlzU2xvdCB9ID0gbm9kZTtcclxuICAgIGlmIChpc1Nsb3QpIHtcclxuICAgICAgICAvLyB3cmFwIHNsb3QgZnVuY3Rpb25zIHdpdGggb3duZXIgY29udGV4dFxyXG4gICAgICAgIHB1c2goYF8ke2hlbHBlck5hbWVNYXBbV0lUSF9DVFhdfShgKTtcclxuICAgIH1cclxuICAgIHB1c2goYChgLCBub2RlKTtcclxuICAgIGlmIChpc0FycmF5KHBhcmFtcykpIHtcclxuICAgICAgICBnZW5Ob2RlTGlzdChwYXJhbXMsIGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocGFyYW1zKSB7XHJcbiAgICAgICAgZ2VuTm9kZShwYXJhbXMsIGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgcHVzaChgKSA9PiBgKTtcclxuICAgIGlmIChuZXdsaW5lIHx8IGJvZHkpIHtcclxuICAgICAgICBwdXNoKGB7YCk7XHJcbiAgICAgICAgaW5kZW50KCk7XHJcbiAgICB9XHJcbiAgICBpZiAocmV0dXJucykge1xyXG4gICAgICAgIGlmIChuZXdsaW5lKSB7XHJcbiAgICAgICAgICAgIHB1c2goYHJldHVybiBgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzQXJyYXkocmV0dXJucykpIHtcclxuICAgICAgICAgICAgZ2VuTm9kZUxpc3RBc0FycmF5KHJldHVybnMsIGNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZ2VuTm9kZShyZXR1cm5zLCBjb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChib2R5KSB7XHJcbiAgICAgICAgZ2VuTm9kZShib2R5LCBjb250ZXh0KTtcclxuICAgIH1cclxuICAgIGlmIChuZXdsaW5lIHx8IGJvZHkpIHtcclxuICAgICAgICBkZWluZGVudCgpO1xyXG4gICAgICAgIHB1c2goYH1gKTtcclxuICAgIH1cclxuICAgIGlmIChpc1Nsb3QpIHtcclxuICAgICAgICBpZiAobm9kZS5pc05vblNjb3BlZFNsb3QpIHtcclxuICAgICAgICAgICAgcHVzaChgLCB1bmRlZmluZWQsIHRydWVgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHVzaChgKWApO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdlbkNvbmRpdGlvbmFsRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KSB7XHJcbiAgICBjb25zdCB7IHRlc3QsIGNvbnNlcXVlbnQsIGFsdGVybmF0ZSwgbmV3bGluZTogbmVlZE5ld2xpbmUgfSA9IG5vZGU7XHJcbiAgICBjb25zdCB7IHB1c2gsIGluZGVudCwgZGVpbmRlbnQsIG5ld2xpbmUgfSA9IGNvbnRleHQ7XHJcbiAgICBpZiAodGVzdC50eXBlID09PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovKSB7XHJcbiAgICAgICAgY29uc3QgbmVlZHNQYXJlbnMgPSAhaXNTaW1wbGVJZGVudGlmaWVyKHRlc3QuY29udGVudCk7XHJcbiAgICAgICAgbmVlZHNQYXJlbnMgJiYgcHVzaChgKGApO1xyXG4gICAgICAgIGdlbkV4cHJlc3Npb24odGVzdCwgY29udGV4dCk7XHJcbiAgICAgICAgbmVlZHNQYXJlbnMgJiYgcHVzaChgKWApO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcHVzaChgKGApO1xyXG4gICAgICAgIGdlbk5vZGUodGVzdCwgY29udGV4dCk7XHJcbiAgICAgICAgcHVzaChgKWApO1xyXG4gICAgfVxyXG4gICAgbmVlZE5ld2xpbmUgJiYgaW5kZW50KCk7XHJcbiAgICBjb250ZXh0LmluZGVudExldmVsKys7XHJcbiAgICBuZWVkTmV3bGluZSB8fCBwdXNoKGAgYCk7XHJcbiAgICBwdXNoKGA/IGApO1xyXG4gICAgZ2VuTm9kZShjb25zZXF1ZW50LCBjb250ZXh0KTtcclxuICAgIGNvbnRleHQuaW5kZW50TGV2ZWwtLTtcclxuICAgIG5lZWROZXdsaW5lICYmIG5ld2xpbmUoKTtcclxuICAgIG5lZWROZXdsaW5lIHx8IHB1c2goYCBgKTtcclxuICAgIHB1c2goYDogYCk7XHJcbiAgICBjb25zdCBpc05lc3RlZCA9IGFsdGVybmF0ZS50eXBlID09PSAxOSAvKiBKU19DT05ESVRJT05BTF9FWFBSRVNTSU9OICovO1xyXG4gICAgaWYgKCFpc05lc3RlZCkge1xyXG4gICAgICAgIGNvbnRleHQuaW5kZW50TGV2ZWwrKztcclxuICAgIH1cclxuICAgIGdlbk5vZGUoYWx0ZXJuYXRlLCBjb250ZXh0KTtcclxuICAgIGlmICghaXNOZXN0ZWQpIHtcclxuICAgICAgICBjb250ZXh0LmluZGVudExldmVsLS07XHJcbiAgICB9XHJcbiAgICBuZWVkTmV3bGluZSAmJiBkZWluZGVudCh0cnVlIC8qIHdpdGhvdXQgbmV3bGluZSAqLyk7XHJcbn1cclxuZnVuY3Rpb24gZ2VuQ2FjaGVFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpIHtcclxuICAgIGNvbnN0IHsgcHVzaCwgaGVscGVyLCBpbmRlbnQsIGRlaW5kZW50LCBuZXdsaW5lIH0gPSBjb250ZXh0O1xyXG4gICAgcHVzaChgX2NhY2hlWyR7bm9kZS5pbmRleH1dIHx8IChgKTtcclxuICAgIGlmIChub2RlLmlzVk5vZGUpIHtcclxuICAgICAgICBpbmRlbnQoKTtcclxuICAgICAgICBwdXNoKGAke2hlbHBlcihTRVRfQkxPQ0tfVFJBQ0tJTkcpfSgtMSksYCk7XHJcbiAgICAgICAgbmV3bGluZSgpO1xyXG4gICAgfVxyXG4gICAgcHVzaChgX2NhY2hlWyR7bm9kZS5pbmRleH1dID0gYCk7XHJcbiAgICBnZW5Ob2RlKG5vZGUudmFsdWUsIGNvbnRleHQpO1xyXG4gICAgaWYgKG5vZGUuaXNWTm9kZSkge1xyXG4gICAgICAgIHB1c2goYCxgKTtcclxuICAgICAgICBuZXdsaW5lKCk7XHJcbiAgICAgICAgcHVzaChgJHtoZWxwZXIoU0VUX0JMT0NLX1RSQUNLSU5HKX0oMSksYCk7XHJcbiAgICAgICAgbmV3bGluZSgpO1xyXG4gICAgICAgIHB1c2goYF9jYWNoZVske25vZGUuaW5kZXh9XWApO1xyXG4gICAgICAgIGRlaW5kZW50KCk7XHJcbiAgICB9XHJcbiAgICBwdXNoKGApYCk7XHJcbn1cblxuZnVuY3Rpb24gd2Fsa0lkZW50aWZpZXJzKHJvb3QsIG9uSWRlbnRpZmllciwgaW5jbHVkZUFsbCA9IGZhbHNlLCBwYXJlbnRTdGFjayA9IFtdLCBrbm93bklkcyA9IE9iamVjdC5jcmVhdGUobnVsbCkpIHtcclxuICAgIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaXNSZWZlcmVuY2VkSWRlbnRpZmllcihpZCwgcGFyZW50LCBwYXJlbnRTdGFjaykge1xyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpc0luRGVzdHJ1Y3R1cmVBc3NpZ25tZW50KHBhcmVudCwgcGFyZW50U3RhY2spIHtcclxuICAgIGlmIChwYXJlbnQgJiZcclxuICAgICAgICAocGFyZW50LnR5cGUgPT09ICdPYmplY3RQcm9wZXJ0eScgfHwgcGFyZW50LnR5cGUgPT09ICdBcnJheVBhdHRlcm4nKSkge1xyXG4gICAgICAgIGxldCBpID0gcGFyZW50U3RhY2subGVuZ3RoO1xyXG4gICAgICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICAgICAgY29uc3QgcCA9IHBhcmVudFN0YWNrW2ldO1xyXG4gICAgICAgICAgICBpZiAocC50eXBlID09PSAnQXNzaWdubWVudEV4cHJlc3Npb24nKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChwLnR5cGUgIT09ICdPYmplY3RQcm9wZXJ0eScgJiYgIXAudHlwZS5lbmRzV2l0aCgnUGF0dGVybicpKSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiB3YWxrRnVuY3Rpb25QYXJhbXMobm9kZSwgb25JZGVudCkge1xyXG4gICAgZm9yIChjb25zdCBwIG9mIG5vZGUucGFyYW1zKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBpZCBvZiBleHRyYWN0SWRlbnRpZmllcnMocCkpIHtcclxuICAgICAgICAgICAgb25JZGVudChpZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHdhbGtCbG9ja0RlY2xhcmF0aW9ucyhibG9jaywgb25JZGVudCkge1xyXG4gICAgZm9yIChjb25zdCBzdG10IG9mIGJsb2NrLmJvZHkpIHtcclxuICAgICAgICBpZiAoc3RtdC50eXBlID09PSAnVmFyaWFibGVEZWNsYXJhdGlvbicpIHtcclxuICAgICAgICAgICAgaWYgKHN0bXQuZGVjbGFyZSlcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGRlY2wgb2Ygc3RtdC5kZWNsYXJhdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaWQgb2YgZXh0cmFjdElkZW50aWZpZXJzKGRlY2wuaWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb25JZGVudChpZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc3RtdC50eXBlID09PSAnRnVuY3Rpb25EZWNsYXJhdGlvbicgfHxcclxuICAgICAgICAgICAgc3RtdC50eXBlID09PSAnQ2xhc3NEZWNsYXJhdGlvbicpIHtcclxuICAgICAgICAgICAgaWYgKHN0bXQuZGVjbGFyZSB8fCAhc3RtdC5pZClcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICBvbklkZW50KHN0bXQuaWQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBleHRyYWN0SWRlbnRpZmllcnMocGFyYW0sIG5vZGVzID0gW10pIHtcclxuICAgIHN3aXRjaCAocGFyYW0udHlwZSkge1xyXG4gICAgICAgIGNhc2UgJ0lkZW50aWZpZXInOlxyXG4gICAgICAgICAgICBub2Rlcy5wdXNoKHBhcmFtKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnTWVtYmVyRXhwcmVzc2lvbic6XHJcbiAgICAgICAgICAgIGxldCBvYmplY3QgPSBwYXJhbTtcclxuICAgICAgICAgICAgd2hpbGUgKG9iamVjdC50eXBlID09PSAnTWVtYmVyRXhwcmVzc2lvbicpIHtcclxuICAgICAgICAgICAgICAgIG9iamVjdCA9IG9iamVjdC5vYmplY3Q7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbm9kZXMucHVzaChvYmplY3QpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdPYmplY3RQYXR0ZXJuJzpcclxuICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wIG9mIHBhcmFtLnByb3BlcnRpZXMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwcm9wLnR5cGUgPT09ICdSZXN0RWxlbWVudCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBleHRyYWN0SWRlbnRpZmllcnMocHJvcC5hcmd1bWVudCwgbm9kZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFjdElkZW50aWZpZXJzKHByb3AudmFsdWUsIG5vZGVzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdBcnJheVBhdHRlcm4nOlxyXG4gICAgICAgICAgICBwYXJhbS5lbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFjdElkZW50aWZpZXJzKGVsZW1lbnQsIG5vZGVzKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ1Jlc3RFbGVtZW50JzpcclxuICAgICAgICAgICAgZXh0cmFjdElkZW50aWZpZXJzKHBhcmFtLmFyZ3VtZW50LCBub2Rlcyk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ0Fzc2lnbm1lbnRQYXR0ZXJuJzpcclxuICAgICAgICAgICAgZXh0cmFjdElkZW50aWZpZXJzKHBhcmFtLmxlZnQsIG5vZGVzKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbm9kZXM7XHJcbn1cclxuY29uc3QgaXNGdW5jdGlvblR5cGUgPSAobm9kZSkgPT4ge1xyXG4gICAgcmV0dXJuIC9GdW5jdGlvbig/OkV4cHJlc3Npb258RGVjbGFyYXRpb24pJHxNZXRob2QkLy50ZXN0KG5vZGUudHlwZSk7XHJcbn07XHJcbmNvbnN0IGlzU3RhdGljUHJvcGVydHkgPSAobm9kZSkgPT4gbm9kZSAmJlxyXG4gICAgKG5vZGUudHlwZSA9PT0gJ09iamVjdFByb3BlcnR5JyB8fCBub2RlLnR5cGUgPT09ICdPYmplY3RNZXRob2QnKSAmJlxyXG4gICAgIW5vZGUuY29tcHV0ZWQ7XHJcbmNvbnN0IGlzU3RhdGljUHJvcGVydHlLZXkgPSAobm9kZSwgcGFyZW50KSA9PiBpc1N0YXRpY1Byb3BlcnR5KHBhcmVudCkgJiYgcGFyZW50LmtleSA9PT0gbm9kZTtcblxuLy8gdGhlc2Uga2V5d29yZHMgc2hvdWxkIG5vdCBhcHBlYXIgaW5zaWRlIGV4cHJlc3Npb25zLCBidXQgb3BlcmF0b3JzIGxpa2VcclxuLy8gdHlwZW9mLCBpbnN0YW5jZW9mIGFuZCBpbiBhcmUgYWxsb3dlZFxyXG5jb25zdCBwcm9oaWJpdGVkS2V5d29yZFJFID0gbmV3IFJlZ0V4cCgnXFxcXGInICtcclxuICAgICgnZG8saWYsZm9yLGxldCxuZXcsdHJ5LHZhcixjYXNlLGVsc2Usd2l0aCxhd2FpdCxicmVhayxjYXRjaCxjbGFzcyxjb25zdCwnICtcclxuICAgICAgICAnc3VwZXIsdGhyb3csd2hpbGUseWllbGQsZGVsZXRlLGV4cG9ydCxpbXBvcnQscmV0dXJuLHN3aXRjaCxkZWZhdWx0LCcgK1xyXG4gICAgICAgICdleHRlbmRzLGZpbmFsbHksY29udGludWUsZGVidWdnZXIsZnVuY3Rpb24sYXJndW1lbnRzLHR5cGVvZix2b2lkJylcclxuICAgICAgICAuc3BsaXQoJywnKVxyXG4gICAgICAgIC5qb2luKCdcXFxcYnxcXFxcYicpICtcclxuICAgICdcXFxcYicpO1xyXG4vLyBzdHJpcCBzdHJpbmdzIGluIGV4cHJlc3Npb25zXHJcbmNvbnN0IHN0cmlwU3RyaW5nUkUgPSAvJyg/OlteJ1xcXFxdfFxcXFwuKSonfFwiKD86W15cIlxcXFxdfFxcXFwuKSpcInxgKD86W15gXFxcXF18XFxcXC4pKlxcJFxce3xcXH0oPzpbXmBcXFxcXXxcXFxcLikqYHxgKD86W15gXFxcXF18XFxcXC4pKmAvZztcclxuLyoqXHJcbiAqIFZhbGlkYXRlIGEgbm9uLXByZWZpeGVkIGV4cHJlc3Npb24uXHJcbiAqIFRoaXMgaXMgb25seSBjYWxsZWQgd2hlbiB1c2luZyB0aGUgaW4tYnJvd3NlciBydW50aW1lIGNvbXBpbGVyIHNpbmNlIGl0XHJcbiAqIGRvZXNuJ3QgcHJlZml4IGV4cHJlc3Npb25zLlxyXG4gKi9cclxuZnVuY3Rpb24gdmFsaWRhdGVCcm93c2VyRXhwcmVzc2lvbihub2RlLCBjb250ZXh0LCBhc1BhcmFtcyA9IGZhbHNlLCBhc1Jhd1N0YXRlbWVudHMgPSBmYWxzZSkge1xyXG4gICAgY29uc3QgZXhwID0gbm9kZS5jb250ZW50O1xyXG4gICAgLy8gZW1wdHkgZXhwcmVzc2lvbnMgYXJlIHZhbGlkYXRlZCBwZXItZGlyZWN0aXZlIHNpbmNlIHNvbWUgZGlyZWN0aXZlc1xyXG4gICAgLy8gZG8gYWxsb3cgZW1wdHkgZXhwcmVzc2lvbnMuXHJcbiAgICBpZiAoIWV4cC50cmltKCkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB0cnkge1xyXG4gICAgICAgIG5ldyBGdW5jdGlvbihhc1Jhd1N0YXRlbWVudHNcclxuICAgICAgICAgICAgPyBgICR7ZXhwfSBgXHJcbiAgICAgICAgICAgIDogYHJldHVybiAke2FzUGFyYW1zID8gYCgke2V4cH0pID0+IHt9YCA6IGAoJHtleHB9KWB9YCk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIGxldCBtZXNzYWdlID0gZS5tZXNzYWdlO1xyXG4gICAgICAgIGNvbnN0IGtleXdvcmRNYXRjaCA9IGV4cFxyXG4gICAgICAgICAgICAucmVwbGFjZShzdHJpcFN0cmluZ1JFLCAnJylcclxuICAgICAgICAgICAgLm1hdGNoKHByb2hpYml0ZWRLZXl3b3JkUkUpO1xyXG4gICAgICAgIGlmIChrZXl3b3JkTWF0Y2gpIHtcclxuICAgICAgICAgICAgbWVzc2FnZSA9IGBhdm9pZCB1c2luZyBKYXZhU2NyaXB0IGtleXdvcmQgYXMgcHJvcGVydHkgbmFtZTogXCIke2tleXdvcmRNYXRjaFswXX1cImA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDQ0IC8qIFhfSU5WQUxJRF9FWFBSRVNTSU9OICovLCBub2RlLmxvYywgdW5kZWZpbmVkLCBtZXNzYWdlKSk7XHJcbiAgICB9XHJcbn1cblxuY29uc3QgdHJhbnNmb3JtRXhwcmVzc2lvbiA9IChub2RlLCBjb250ZXh0KSA9PiB7XHJcbiAgICBpZiAobm9kZS50eXBlID09PSA1IC8qIElOVEVSUE9MQVRJT04gKi8pIHtcclxuICAgICAgICBub2RlLmNvbnRlbnQgPSBwcm9jZXNzRXhwcmVzc2lvbihub2RlLmNvbnRlbnQsIGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobm9kZS50eXBlID09PSAxIC8qIEVMRU1FTlQgKi8pIHtcclxuICAgICAgICAvLyBoYW5kbGUgZGlyZWN0aXZlcyBvbiBlbGVtZW50XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLnByb3BzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRpciA9IG5vZGUucHJvcHNbaV07XHJcbiAgICAgICAgICAgIC8vIGRvIG5vdCBwcm9jZXNzIGZvciB2LW9uICYgdi1mb3Igc2luY2UgdGhleSBhcmUgc3BlY2lhbCBoYW5kbGVkXHJcbiAgICAgICAgICAgIGlmIChkaXIudHlwZSA9PT0gNyAvKiBESVJFQ1RJVkUgKi8gJiYgZGlyLm5hbWUgIT09ICdmb3InKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBleHAgPSBkaXIuZXhwO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYXJnID0gZGlyLmFyZztcclxuICAgICAgICAgICAgICAgIC8vIGRvIG5vdCBwcm9jZXNzIGV4cCBpZiB0aGlzIGlzIHYtb246YXJnIC0gd2UgbmVlZCBzcGVjaWFsIGhhbmRsaW5nXHJcbiAgICAgICAgICAgICAgICAvLyBmb3Igd3JhcHBpbmcgaW5saW5lIHN0YXRlbWVudHMuXHJcbiAgICAgICAgICAgICAgICBpZiAoZXhwICYmXHJcbiAgICAgICAgICAgICAgICAgICAgZXhwLnR5cGUgPT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8gJiZcclxuICAgICAgICAgICAgICAgICAgICAhKGRpci5uYW1lID09PSAnb24nICYmIGFyZykpIHtcclxuICAgICAgICAgICAgICAgICAgICBkaXIuZXhwID0gcHJvY2Vzc0V4cHJlc3Npb24oZXhwLCBjb250ZXh0LCBcclxuICAgICAgICAgICAgICAgICAgICAvLyBzbG90IGFyZ3MgbXVzdCBiZSBwcm9jZXNzZWQgYXMgZnVuY3Rpb24gcGFyYW1zXHJcbiAgICAgICAgICAgICAgICAgICAgZGlyLm5hbWUgPT09ICdzbG90Jyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoYXJnICYmIGFyZy50eXBlID09PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovICYmICFhcmcuaXNTdGF0aWMpIHtcclxuICAgICAgICAgICAgICAgICAgICBkaXIuYXJnID0gcHJvY2Vzc0V4cHJlc3Npb24oYXJnLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuLy8gSW1wb3J0YW50OiBzaW5jZSB0aGlzIGZ1bmN0aW9uIHVzZXMgTm9kZS5qcyBvbmx5IGRlcGVuZGVuY2llcywgaXQgc2hvdWxkXHJcbi8vIGFsd2F5cyBiZSB1c2VkIHdpdGggYSBsZWFkaW5nICF0cnVlIGNoZWNrIHNvIHRoYXQgaXQgY2FuIGJlXHJcbi8vIHRyZWUtc2hha2VuIGZyb20gdGhlIGJyb3dzZXIgYnVpbGQuXHJcbmZ1bmN0aW9uIHByb2Nlc3NFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQsIFxyXG4vLyBzb21lIGV4cHJlc3Npb25zIGxpa2Ugdi1zbG90IHByb3BzICYgdi1mb3IgYWxpYXNlcyBzaG91bGQgYmUgcGFyc2VkIGFzXHJcbi8vIGZ1bmN0aW9uIHBhcmFtc1xyXG5hc1BhcmFtcyA9IGZhbHNlLCBcclxuLy8gdi1vbiBoYW5kbGVyIHZhbHVlcyBtYXkgY29udGFpbiBtdWx0aXBsZSBzdGF0ZW1lbnRzXHJcbmFzUmF3U3RhdGVtZW50cyA9IGZhbHNlLCBsb2NhbFZhcnMgPSBPYmplY3QuY3JlYXRlKGNvbnRleHQuaWRlbnRpZmllcnMpKSB7XHJcbiAgICB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAvLyBzaW1wbGUgaW4tYnJvd3NlciB2YWxpZGF0aW9uIChzYW1lIGxvZ2ljIGluIDIueClcclxuICAgICAgICAgICAgdmFsaWRhdGVCcm93c2VyRXhwcmVzc2lvbihub2RlLCBjb250ZXh0LCBhc1BhcmFtcywgYXNSYXdTdGF0ZW1lbnRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICB9XHJcbn1cblxuY29uc3QgdHJhbnNmb3JtSWYgPSBjcmVhdGVTdHJ1Y3R1cmFsRGlyZWN0aXZlVHJhbnNmb3JtKC9eKGlmfGVsc2V8ZWxzZS1pZikkLywgKG5vZGUsIGRpciwgY29udGV4dCkgPT4ge1xyXG4gICAgcmV0dXJuIHByb2Nlc3NJZihub2RlLCBkaXIsIGNvbnRleHQsIChpZk5vZGUsIGJyYW5jaCwgaXNSb290KSA9PiB7XHJcbiAgICAgICAgLy8gIzE1ODc6IFdlIG5lZWQgdG8gZHluYW1pY2FsbHkgaW5jcmVtZW50IHRoZSBrZXkgYmFzZWQgb24gdGhlIGN1cnJlbnRcclxuICAgICAgICAvLyBub2RlJ3Mgc2libGluZyBub2Rlcywgc2luY2UgY2hhaW5lZCB2LWlmL2Vsc2UgYnJhbmNoZXMgYXJlXHJcbiAgICAgICAgLy8gcmVuZGVyZWQgYXQgdGhlIHNhbWUgZGVwdGhcclxuICAgICAgICBjb25zdCBzaWJsaW5ncyA9IGNvbnRleHQucGFyZW50LmNoaWxkcmVuO1xyXG4gICAgICAgIGxldCBpID0gc2libGluZ3MuaW5kZXhPZihpZk5vZGUpO1xyXG4gICAgICAgIGxldCBrZXkgPSAwO1xyXG4gICAgICAgIHdoaWxlIChpLS0gPj0gMCkge1xyXG4gICAgICAgICAgICBjb25zdCBzaWJsaW5nID0gc2libGluZ3NbaV07XHJcbiAgICAgICAgICAgIGlmIChzaWJsaW5nICYmIHNpYmxpbmcudHlwZSA9PT0gOSAvKiBJRiAqLykge1xyXG4gICAgICAgICAgICAgICAga2V5ICs9IHNpYmxpbmcuYnJhbmNoZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEV4aXQgY2FsbGJhY2suIENvbXBsZXRlIHRoZSBjb2RlZ2VuTm9kZSB3aGVuIGFsbCBjaGlsZHJlbiBoYXZlIGJlZW5cclxuICAgICAgICAvLyB0cmFuc2Zvcm1lZC5cclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoaXNSb290KSB7XHJcbiAgICAgICAgICAgICAgICBpZk5vZGUuY29kZWdlbk5vZGUgPSBjcmVhdGVDb2RlZ2VuTm9kZUZvckJyYW5jaChicmFuY2gsIGtleSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBhdHRhY2ggdGhpcyBicmFuY2gncyBjb2RlZ2VuIG5vZGUgdG8gdGhlIHYtaWYgcm9vdC5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudENvbmRpdGlvbiA9IGdldFBhcmVudENvbmRpdGlvbihpZk5vZGUuY29kZWdlbk5vZGUpO1xyXG4gICAgICAgICAgICAgICAgcGFyZW50Q29uZGl0aW9uLmFsdGVybmF0ZSA9IGNyZWF0ZUNvZGVnZW5Ob2RlRm9yQnJhbmNoKGJyYW5jaCwga2V5ICsgaWZOb2RlLmJyYW5jaGVzLmxlbmd0aCAtIDEsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH0pO1xyXG59KTtcclxuLy8gdGFyZ2V0LWFnbm9zdGljIHRyYW5zZm9ybSB1c2VkIGZvciBib3RoIENsaWVudCBhbmQgU1NSXHJcbmZ1bmN0aW9uIHByb2Nlc3NJZihub2RlLCBkaXIsIGNvbnRleHQsIHByb2Nlc3NDb2RlZ2VuKSB7XHJcbiAgICBpZiAoZGlyLm5hbWUgIT09ICdlbHNlJyAmJlxyXG4gICAgICAgICghZGlyLmV4cCB8fCAhZGlyLmV4cC5jb250ZW50LnRyaW0oKSkpIHtcclxuICAgICAgICBjb25zdCBsb2MgPSBkaXIuZXhwID8gZGlyLmV4cC5sb2MgOiBub2RlLmxvYztcclxuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcigyOCAvKiBYX1ZfSUZfTk9fRVhQUkVTU0lPTiAqLywgZGlyLmxvYykpO1xyXG4gICAgICAgIGRpci5leHAgPSBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGB0cnVlYCwgZmFsc2UsIGxvYyk7XHJcbiAgICB9XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHRydWUgJiYgZGlyLmV4cCkge1xyXG4gICAgICAgIHZhbGlkYXRlQnJvd3NlckV4cHJlc3Npb24oZGlyLmV4cCwgY29udGV4dCk7XHJcbiAgICB9XHJcbiAgICBpZiAoZGlyLm5hbWUgPT09ICdpZicpIHtcclxuICAgICAgICBjb25zdCBicmFuY2ggPSBjcmVhdGVJZkJyYW5jaChub2RlLCBkaXIpO1xyXG4gICAgICAgIGNvbnN0IGlmTm9kZSA9IHtcclxuICAgICAgICAgICAgdHlwZTogOSAvKiBJRiAqLyxcclxuICAgICAgICAgICAgbG9jOiBub2RlLmxvYyxcclxuICAgICAgICAgICAgYnJhbmNoZXM6IFticmFuY2hdXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb250ZXh0LnJlcGxhY2VOb2RlKGlmTm9kZSk7XHJcbiAgICAgICAgaWYgKHByb2Nlc3NDb2RlZ2VuKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm9jZXNzQ29kZWdlbihpZk5vZGUsIGJyYW5jaCwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gbG9jYXRlIHRoZSBhZGphY2VudCB2LWlmXHJcbiAgICAgICAgY29uc3Qgc2libGluZ3MgPSBjb250ZXh0LnBhcmVudC5jaGlsZHJlbjtcclxuICAgICAgICBjb25zdCBjb21tZW50cyA9IFtdO1xyXG4gICAgICAgIGxldCBpID0gc2libGluZ3MuaW5kZXhPZihub2RlKTtcclxuICAgICAgICB3aGlsZSAoaS0tID49IC0xKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNpYmxpbmcgPSBzaWJsaW5nc1tpXTtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBzaWJsaW5nICYmIHNpYmxpbmcudHlwZSA9PT0gMyAvKiBDT01NRU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LnJlbW92ZU5vZGUoc2libGluZyk7XHJcbiAgICAgICAgICAgICAgICBjb21tZW50cy51bnNoaWZ0KHNpYmxpbmcpO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHNpYmxpbmcgJiZcclxuICAgICAgICAgICAgICAgIHNpYmxpbmcudHlwZSA9PT0gMiAvKiBURVhUICovICYmXHJcbiAgICAgICAgICAgICAgICAhc2libGluZy5jb250ZW50LnRyaW0oKS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQucmVtb3ZlTm9kZShzaWJsaW5nKTtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzaWJsaW5nICYmIHNpYmxpbmcudHlwZSA9PT0gOSAvKiBJRiAqLykge1xyXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdi1lbHNlIHdhcyBmb2xsb3dlZCBieSB2LWVsc2UtaWZcclxuICAgICAgICAgICAgICAgIGlmIChkaXIubmFtZSA9PT0gJ2Vsc2UtaWYnICYmXHJcbiAgICAgICAgICAgICAgICAgICAgc2libGluZy5icmFuY2hlc1tzaWJsaW5nLmJyYW5jaGVzLmxlbmd0aCAtIDFdLmNvbmRpdGlvbiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoMzAgLyogWF9WX0VMU0VfTk9fQURKQUNFTlRfSUYgKi8sIG5vZGUubG9jKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBtb3ZlIHRoZSBub2RlIHRvIHRoZSBpZiBub2RlJ3MgYnJhbmNoZXNcclxuICAgICAgICAgICAgICAgIGNvbnRleHQucmVtb3ZlTm9kZSgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYnJhbmNoID0gY3JlYXRlSWZCcmFuY2gobm9kZSwgZGlyKTtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgICAgICBjb21tZW50cy5sZW5ndGggJiZcclxuICAgICAgICAgICAgICAgICAgICAvLyAjMzYxOSBpZ25vcmUgY29tbWVudHMgaWYgdGhlIHYtaWYgaXMgZGlyZWN0IGNoaWxkIG9mIDx0cmFuc2l0aW9uPlxyXG4gICAgICAgICAgICAgICAgICAgICEoY29udGV4dC5wYXJlbnQgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5wYXJlbnQudHlwZSA9PT0gMSAvKiBFTEVNRU5UICovICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQnVpbHRJblR5cGUoY29udGV4dC5wYXJlbnQudGFnLCAndHJhbnNpdGlvbicpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyYW5jaC5jaGlsZHJlbiA9IFsuLi5jb21tZW50cywgLi4uYnJhbmNoLmNoaWxkcmVuXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHVzZXIgaXMgZm9yY2luZyBzYW1lIGtleSBvbiBkaWZmZXJlbnQgYnJhbmNoZXNcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgIXRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBicmFuY2gudXNlcktleTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpYmxpbmcuYnJhbmNoZXMuZm9yRWFjaCgoeyB1c2VyS2V5IH0pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1NhbWVLZXkodXNlcktleSwga2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDI5IC8qIFhfVl9JRl9TQU1FX0tFWSAqLywgYnJhbmNoLnVzZXJLZXkubG9jKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNpYmxpbmcuYnJhbmNoZXMucHVzaChicmFuY2gpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb25FeGl0ID0gcHJvY2Vzc0NvZGVnZW4gJiYgcHJvY2Vzc0NvZGVnZW4oc2libGluZywgYnJhbmNoLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAvLyBzaW5jZSB0aGUgYnJhbmNoIHdhcyByZW1vdmVkLCBpdCB3aWxsIG5vdCBiZSB0cmF2ZXJzZWQuXHJcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgdG8gdHJhdmVyc2UgaGVyZS5cclxuICAgICAgICAgICAgICAgIHRyYXZlcnNlTm9kZShicmFuY2gsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgLy8gY2FsbCBvbiBleGl0XHJcbiAgICAgICAgICAgICAgICBpZiAob25FeGl0KVxyXG4gICAgICAgICAgICAgICAgICAgIG9uRXhpdCgpO1xyXG4gICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHRvIHJlc2V0IGN1cnJlbnROb2RlIGFmdGVyIHRyYXZlcnNhbCB0byBpbmRpY2F0ZSB0aGlzXHJcbiAgICAgICAgICAgICAgICAvLyBub2RlIGhhcyBiZWVuIHJlbW92ZWQuXHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmN1cnJlbnROb2RlID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDMwIC8qIFhfVl9FTFNFX05PX0FESkFDRU5UX0lGICovLCBub2RlLmxvYykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjcmVhdGVJZkJyYW5jaChub2RlLCBkaXIpIHtcclxuICAgIGNvbnN0IGlzVGVtcGxhdGVJZiA9IG5vZGUudGFnVHlwZSA9PT0gMyAvKiBURU1QTEFURSAqLztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogMTAgLyogSUZfQlJBTkNIICovLFxyXG4gICAgICAgIGxvYzogbm9kZS5sb2MsXHJcbiAgICAgICAgY29uZGl0aW9uOiBkaXIubmFtZSA9PT0gJ2Vsc2UnID8gdW5kZWZpbmVkIDogZGlyLmV4cCxcclxuICAgICAgICBjaGlsZHJlbjogaXNUZW1wbGF0ZUlmICYmICFmaW5kRGlyKG5vZGUsICdmb3InKSA/IG5vZGUuY2hpbGRyZW4gOiBbbm9kZV0sXHJcbiAgICAgICAgdXNlcktleTogZmluZFByb3Aobm9kZSwgYGtleWApLFxyXG4gICAgICAgIGlzVGVtcGxhdGVJZlxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVDb2RlZ2VuTm9kZUZvckJyYW5jaChicmFuY2gsIGtleUluZGV4LCBjb250ZXh0KSB7XHJcbiAgICBpZiAoYnJhbmNoLmNvbmRpdGlvbikge1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVDb25kaXRpb25hbEV4cHJlc3Npb24oYnJhbmNoLmNvbmRpdGlvbiwgY3JlYXRlQ2hpbGRyZW5Db2RlZ2VuTm9kZShicmFuY2gsIGtleUluZGV4LCBjb250ZXh0KSwgXHJcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRvIHBhc3MgaW4gYXNCbG9jazogdHJ1ZSBzbyB0aGF0IHRoZSBjb21tZW50IG5vZGUgY2FsbFxyXG4gICAgICAgIC8vIGNsb3NlcyB0aGUgY3VycmVudCBibG9jay5cclxuICAgICAgICBjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlcihDUkVBVEVfQ09NTUVOVCksIFtcclxuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gJ1widi1pZlwiJyA6ICdcIlwiJyxcclxuICAgICAgICAgICAgJ3RydWUnXHJcbiAgICAgICAgXSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUNoaWxkcmVuQ29kZWdlbk5vZGUoYnJhbmNoLCBrZXlJbmRleCwgY29udGV4dCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlQ2hpbGRyZW5Db2RlZ2VuTm9kZShicmFuY2gsIGtleUluZGV4LCBjb250ZXh0KSB7XHJcbiAgICBjb25zdCB7IGhlbHBlciB9ID0gY29udGV4dDtcclxuICAgIGNvbnN0IGtleVByb3BlcnR5ID0gY3JlYXRlT2JqZWN0UHJvcGVydHkoYGtleWAsIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYCR7a2V5SW5kZXh9YCwgZmFsc2UsIGxvY1N0dWIsIDIgLyogQ0FOX0hPSVNUICovKSk7XHJcbiAgICBjb25zdCB7IGNoaWxkcmVuIH0gPSBicmFuY2g7XHJcbiAgICBjb25zdCBmaXJzdENoaWxkID0gY2hpbGRyZW5bMF07XHJcbiAgICBjb25zdCBuZWVkRnJhZ21lbnRXcmFwcGVyID0gY2hpbGRyZW4ubGVuZ3RoICE9PSAxIHx8IGZpcnN0Q2hpbGQudHlwZSAhPT0gMSAvKiBFTEVNRU5UICovO1xyXG4gICAgaWYgKG5lZWRGcmFnbWVudFdyYXBwZXIpIHtcclxuICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIGZpcnN0Q2hpbGQudHlwZSA9PT0gMTEgLyogRk9SICovKSB7XHJcbiAgICAgICAgICAgIC8vIG9wdGltaXplIGF3YXkgbmVzdGVkIGZyYWdtZW50cyB3aGVuIGNoaWxkIGlzIGEgRm9yTm9kZVxyXG4gICAgICAgICAgICBjb25zdCB2bm9kZUNhbGwgPSBmaXJzdENoaWxkLmNvZGVnZW5Ob2RlO1xyXG4gICAgICAgICAgICBpbmplY3RQcm9wKHZub2RlQ2FsbCwga2V5UHJvcGVydHksIGNvbnRleHQpO1xyXG4gICAgICAgICAgICByZXR1cm4gdm5vZGVDYWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbGV0IHBhdGNoRmxhZyA9IDY0IC8qIFNUQUJMRV9GUkFHTUVOVCAqLztcclxuICAgICAgICAgICAgbGV0IHBhdGNoRmxhZ1RleHQgPSBQYXRjaEZsYWdOYW1lc1s2NCAvKiBTVEFCTEVfRlJBR01FTlQgKi9dO1xyXG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgZnJhZ21lbnQgYWN0dWFsbHkgY29udGFpbnMgYSBzaW5nbGUgdmFsaWQgY2hpbGQgd2l0aFxyXG4gICAgICAgICAgICAvLyB0aGUgcmVzdCBiZWluZyBjb21tZW50c1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgICAgICAhYnJhbmNoLmlzVGVtcGxhdGVJZiAmJlxyXG4gICAgICAgICAgICAgICAgY2hpbGRyZW4uZmlsdGVyKGMgPT4gYy50eXBlICE9PSAzIC8qIENPTU1FTlQgKi8pLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgcGF0Y2hGbGFnIHw9IDIwNDggLyogREVWX1JPT1RfRlJBR01FTlQgKi87XHJcbiAgICAgICAgICAgICAgICBwYXRjaEZsYWdUZXh0ICs9IGAsICR7UGF0Y2hGbGFnTmFtZXNbMjA0OCAvKiBERVZfUk9PVF9GUkFHTUVOVCAqL119YDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGVDYWxsKGNvbnRleHQsIGhlbHBlcihGUkFHTUVOVCksIGNyZWF0ZU9iamVjdEV4cHJlc3Npb24oW2tleVByb3BlcnR5XSksIGNoaWxkcmVuLCBwYXRjaEZsYWcgKyAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYCAvKiAke3BhdGNoRmxhZ1RleHR9ICovYCA6IGBgKSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHRydWUsIGZhbHNlLCBmYWxzZSAvKiBpc0NvbXBvbmVudCAqLywgYnJhbmNoLmxvYyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3QgcmV0ID0gZmlyc3RDaGlsZC5jb2RlZ2VuTm9kZTtcclxuICAgICAgICBjb25zdCB2bm9kZUNhbGwgPSBnZXRNZW1vZWRWTm9kZUNhbGwocmV0KTtcclxuICAgICAgICAvLyBDaGFuZ2UgY3JlYXRlVk5vZGUgdG8gY3JlYXRlQmxvY2suXHJcbiAgICAgICAgaWYgKHZub2RlQ2FsbC50eXBlID09PSAxMyAvKiBWTk9ERV9DQUxMICovKSB7XHJcbiAgICAgICAgICAgIG1ha2VCbG9jayh2bm9kZUNhbGwsIGNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpbmplY3QgYnJhbmNoIGtleVxyXG4gICAgICAgIGluamVjdFByb3Aodm5vZGVDYWxsLCBrZXlQcm9wZXJ0eSwgY29udGV4dCk7XHJcbiAgICAgICAgcmV0dXJuIHJldDtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpc1NhbWVLZXkoYSwgYikge1xyXG4gICAgaWYgKCFhIHx8IGEudHlwZSAhPT0gYi50eXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKGEudHlwZSA9PT0gNiAvKiBBVFRSSUJVVEUgKi8pIHtcclxuICAgICAgICBpZiAoYS52YWx1ZS5jb250ZW50ICE9PSBiLnZhbHVlLmNvbnRlbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIGRpcmVjdGl2ZVxyXG4gICAgICAgIGNvbnN0IGV4cCA9IGEuZXhwO1xyXG4gICAgICAgIGNvbnN0IGJyYW5jaEV4cCA9IGIuZXhwO1xyXG4gICAgICAgIGlmIChleHAudHlwZSAhPT0gYnJhbmNoRXhwLnR5cGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZXhwLnR5cGUgIT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8gfHxcclxuICAgICAgICAgICAgZXhwLmlzU3RhdGljICE9PSBicmFuY2hFeHAuaXNTdGF0aWMgfHxcclxuICAgICAgICAgICAgZXhwLmNvbnRlbnQgIT09IGJyYW5jaEV4cC5jb250ZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiBnZXRQYXJlbnRDb25kaXRpb24obm9kZSkge1xyXG4gICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICBpZiAobm9kZS50eXBlID09PSAxOSAvKiBKU19DT05ESVRJT05BTF9FWFBSRVNTSU9OICovKSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlLmFsdGVybmF0ZS50eXBlID09PSAxOSAvKiBKU19DT05ESVRJT05BTF9FWFBSRVNTSU9OICovKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5hbHRlcm5hdGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChub2RlLnR5cGUgPT09IDIwIC8qIEpTX0NBQ0hFX0VYUFJFU1NJT04gKi8pIHtcclxuICAgICAgICAgICAgbm9kZSA9IG5vZGUudmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmNvbnN0IHRyYW5zZm9ybUZvciA9IGNyZWF0ZVN0cnVjdHVyYWxEaXJlY3RpdmVUcmFuc2Zvcm0oJ2ZvcicsIChub2RlLCBkaXIsIGNvbnRleHQpID0+IHtcclxuICAgIGNvbnN0IHsgaGVscGVyLCByZW1vdmVIZWxwZXIgfSA9IGNvbnRleHQ7XHJcbiAgICByZXR1cm4gcHJvY2Vzc0Zvcihub2RlLCBkaXIsIGNvbnRleHQsIGZvck5vZGUgPT4ge1xyXG4gICAgICAgIC8vIGNyZWF0ZSB0aGUgbG9vcCByZW5kZXIgZnVuY3Rpb24gZXhwcmVzc2lvbiBub3csIGFuZCBhZGQgdGhlXHJcbiAgICAgICAgLy8gaXRlcmF0b3Igb24gZXhpdCBhZnRlciBhbGwgY2hpbGRyZW4gaGF2ZSBiZWVuIHRyYXZlcnNlZFxyXG4gICAgICAgIGNvbnN0IHJlbmRlckV4cCA9IGNyZWF0ZUNhbGxFeHByZXNzaW9uKGhlbHBlcihSRU5ERVJfTElTVCksIFtcclxuICAgICAgICAgICAgZm9yTm9kZS5zb3VyY2VcclxuICAgICAgICBdKTtcclxuICAgICAgICBjb25zdCBpc1RlbXBsYXRlID0gaXNUZW1wbGF0ZU5vZGUobm9kZSk7XHJcbiAgICAgICAgY29uc3QgbWVtbyA9IGZpbmREaXIobm9kZSwgJ21lbW8nKTtcclxuICAgICAgICBjb25zdCBrZXlQcm9wID0gZmluZFByb3Aobm9kZSwgYGtleWApO1xyXG4gICAgICAgIGNvbnN0IGtleUV4cCA9IGtleVByb3AgJiZcclxuICAgICAgICAgICAgKGtleVByb3AudHlwZSA9PT0gNiAvKiBBVFRSSUJVVEUgKi9cclxuICAgICAgICAgICAgICAgID8gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihrZXlQcm9wLnZhbHVlLmNvbnRlbnQsIHRydWUpXHJcbiAgICAgICAgICAgICAgICA6IGtleVByb3AuZXhwKTtcclxuICAgICAgICBjb25zdCBrZXlQcm9wZXJ0eSA9IGtleVByb3AgPyBjcmVhdGVPYmplY3RQcm9wZXJ0eShga2V5YCwga2V5RXhwKSA6IG51bGw7XHJcbiAgICAgICAgY29uc3QgaXNTdGFibGVGcmFnbWVudCA9IGZvck5vZGUuc291cmNlLnR5cGUgPT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8gJiZcclxuICAgICAgICAgICAgZm9yTm9kZS5zb3VyY2UuY29uc3RUeXBlID4gMCAvKiBOT1RfQ09OU1RBTlQgKi87XHJcbiAgICAgICAgY29uc3QgZnJhZ21lbnRGbGFnID0gaXNTdGFibGVGcmFnbWVudFxyXG4gICAgICAgICAgICA/IDY0IC8qIFNUQUJMRV9GUkFHTUVOVCAqL1xyXG4gICAgICAgICAgICA6IGtleVByb3BcclxuICAgICAgICAgICAgICAgID8gMTI4IC8qIEtFWUVEX0ZSQUdNRU5UICovXHJcbiAgICAgICAgICAgICAgICA6IDI1NiAvKiBVTktFWUVEX0ZSQUdNRU5UICovO1xyXG4gICAgICAgIGZvck5vZGUuY29kZWdlbk5vZGUgPSBjcmVhdGVWTm9kZUNhbGwoY29udGV4dCwgaGVscGVyKEZSQUdNRU5UKSwgdW5kZWZpbmVkLCByZW5kZXJFeHAsIGZyYWdtZW50RmxhZyArXHJcbiAgICAgICAgICAgICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgIC8qICR7UGF0Y2hGbGFnTmFtZXNbZnJhZ21lbnRGbGFnXX0gKi9gIDogYGApLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdHJ1ZSAvKiBpc0Jsb2NrICovLCAhaXNTdGFibGVGcmFnbWVudCAvKiBkaXNhYmxlVHJhY2tpbmcgKi8sIGZhbHNlIC8qIGlzQ29tcG9uZW50ICovLCBub2RlLmxvYyk7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgLy8gZmluaXNoIHRoZSBjb2RlZ2VuIG5vdyB0aGF0IGFsbCBjaGlsZHJlbiBoYXZlIGJlZW4gdHJhdmVyc2VkXHJcbiAgICAgICAgICAgIGxldCBjaGlsZEJsb2NrO1xyXG4gICAgICAgICAgICBjb25zdCB7IGNoaWxkcmVuIH0gPSBmb3JOb2RlO1xyXG4gICAgICAgICAgICAvLyBjaGVjayA8dGVtcGxhdGUgdi1mb3I+IGtleSBwbGFjZW1lbnRcclxuICAgICAgICAgICAgaWYgKCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgIXRydWUpICYmIGlzVGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4uc29tZShjID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYy50eXBlID09PSAxIC8qIEVMRU1FTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gZmluZFByb3AoYywgJ2tleScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcigzMyAvKiBYX1ZfRk9SX1RFTVBMQVRFX0tFWV9QTEFDRU1FTlQgKi8sIGtleS5sb2MpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgbmVlZEZyYWdtZW50V3JhcHBlciA9IGNoaWxkcmVuLmxlbmd0aCAhPT0gMSB8fCBjaGlsZHJlblswXS50eXBlICE9PSAxIC8qIEVMRU1FTlQgKi87XHJcbiAgICAgICAgICAgIGNvbnN0IHNsb3RPdXRsZXQgPSBpc1Nsb3RPdXRsZXQobm9kZSlcclxuICAgICAgICAgICAgICAgID8gbm9kZVxyXG4gICAgICAgICAgICAgICAgOiBpc1RlbXBsYXRlICYmXHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcclxuICAgICAgICAgICAgICAgICAgICBpc1Nsb3RPdXRsZXQobm9kZS5jaGlsZHJlblswXSlcclxuICAgICAgICAgICAgICAgICAgICA/IG5vZGUuY2hpbGRyZW5bMF0gLy8gYXBpLWV4dHJhY3RvciBzb21laG93IGZhaWxzIHRvIGluZmVyIHRoaXNcclxuICAgICAgICAgICAgICAgICAgICA6IG51bGw7XHJcbiAgICAgICAgICAgIGlmIChzbG90T3V0bGV0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyA8c2xvdCB2LWZvcj1cIi4uLlwiPiBvciA8dGVtcGxhdGUgdi1mb3I9XCIuLi5cIj48c2xvdC8+PC90ZW1wbGF0ZT5cclxuICAgICAgICAgICAgICAgIGNoaWxkQmxvY2sgPSBzbG90T3V0bGV0LmNvZGVnZW5Ob2RlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzVGVtcGxhdGUgJiYga2V5UHJvcGVydHkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyA8dGVtcGxhdGUgdi1mb3I9XCIuLi5cIiA6a2V5PVwiLi4uXCI+PHNsb3QvPjwvdGVtcGxhdGU+XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBpbmplY3QgdGhlIGtleSB0byB0aGUgcmVuZGVyU2xvdCgpIGNhbGwuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHByb3BzIGZvciByZW5kZXJTbG90IGlzIHBhc3NlZCBhcyB0aGUgM3JkIGFyZ3VtZW50LlxyXG4gICAgICAgICAgICAgICAgICAgIGluamVjdFByb3AoY2hpbGRCbG9jaywga2V5UHJvcGVydHksIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG5lZWRGcmFnbWVudFdyYXBwZXIpIHtcclxuICAgICAgICAgICAgICAgIC8vIDx0ZW1wbGF0ZSB2LWZvcj1cIi4uLlwiPiB3aXRoIHRleHQgb3IgbXVsdGktZWxlbWVudHNcclxuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBnZW5lcmF0ZSBhIGZyYWdtZW50IGJsb2NrIGZvciBlYWNoIGxvb3BcclxuICAgICAgICAgICAgICAgIGNoaWxkQmxvY2sgPSBjcmVhdGVWTm9kZUNhbGwoY29udGV4dCwgaGVscGVyKEZSQUdNRU5UKSwga2V5UHJvcGVydHkgPyBjcmVhdGVPYmplY3RFeHByZXNzaW9uKFtrZXlQcm9wZXJ0eV0pIDogdW5kZWZpbmVkLCBub2RlLmNoaWxkcmVuLCA2NCAvKiBTVEFCTEVfRlJBR01FTlQgKi8gK1xyXG4gICAgICAgICAgICAgICAgICAgICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBgIC8qICR7UGF0Y2hGbGFnTmFtZXNbNjQgLyogU1RBQkxFX0ZSQUdNRU5UICovXX0gKi9gXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYGApLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdHJ1ZSwgdW5kZWZpbmVkLCBmYWxzZSAvKiBpc0NvbXBvbmVudCAqLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBOb3JtYWwgZWxlbWVudCB2LWZvci4gRGlyZWN0bHkgdXNlIHRoZSBjaGlsZCdzIGNvZGVnZW5Ob2RlXHJcbiAgICAgICAgICAgICAgICAvLyBidXQgbWFyayBpdCBhcyBhIGJsb2NrLlxyXG4gICAgICAgICAgICAgICAgY2hpbGRCbG9jayA9IGNoaWxkcmVuWzBdXHJcbiAgICAgICAgICAgICAgICAgICAgLmNvZGVnZW5Ob2RlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzVGVtcGxhdGUgJiYga2V5UHJvcGVydHkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbmplY3RQcm9wKGNoaWxkQmxvY2ssIGtleVByb3BlcnR5LCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChjaGlsZEJsb2NrLmlzQmxvY2sgIT09ICFpc1N0YWJsZUZyYWdtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkQmxvY2suaXNCbG9jaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzd2l0Y2ggZnJvbSBibG9jayB0byB2bm9kZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVIZWxwZXIoT1BFTl9CTE9DSyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUhlbHBlcihnZXRWTm9kZUJsb2NrSGVscGVyKGNvbnRleHQuaW5TU1IsIGNoaWxkQmxvY2suaXNDb21wb25lbnQpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN3aXRjaCBmcm9tIHZub2RlIHRvIGJsb2NrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUhlbHBlcihnZXRWTm9kZUhlbHBlcihjb250ZXh0LmluU1NSLCBjaGlsZEJsb2NrLmlzQ29tcG9uZW50KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2hpbGRCbG9jay5pc0Jsb2NrID0gIWlzU3RhYmxlRnJhZ21lbnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRCbG9jay5pc0Jsb2NrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVscGVyKE9QRU5fQkxPQ0spO1xyXG4gICAgICAgICAgICAgICAgICAgIGhlbHBlcihnZXRWTm9kZUJsb2NrSGVscGVyKGNvbnRleHQuaW5TU1IsIGNoaWxkQmxvY2suaXNDb21wb25lbnQpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGhlbHBlcihnZXRWTm9kZUhlbHBlcihjb250ZXh0LmluU1NSLCBjaGlsZEJsb2NrLmlzQ29tcG9uZW50KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG1lbW8pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxvb3AgPSBjcmVhdGVGdW5jdGlvbkV4cHJlc3Npb24oY3JlYXRlRm9yTG9vcFBhcmFtcyhmb3JOb2RlLnBhcnNlUmVzdWx0LCBbXHJcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgX2NhY2hlZGApXHJcbiAgICAgICAgICAgICAgICBdKSk7XHJcbiAgICAgICAgICAgICAgICBsb29wLmJvZHkgPSBjcmVhdGVCbG9ja1N0YXRlbWVudChbXHJcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uKFtgY29uc3QgX21lbW8gPSAoYCwgbWVtby5leHAsIGApYF0pLFxyXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUNvbXBvdW5kRXhwcmVzc2lvbihbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGBpZiAoX2NhY2hlZGAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLihrZXlFeHAgPyBbYCAmJiBfY2FjaGVkLmtleSA9PT0gYCwga2V5RXhwXSA6IFtdKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYCAmJiAke2NvbnRleHQuaGVscGVyU3RyaW5nKElTX01FTU9fU0FNRSl9KF9jYWNoZWQsIF9tZW1vKSkgcmV0dXJuIF9jYWNoZWRgXHJcbiAgICAgICAgICAgICAgICAgICAgXSksXHJcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uKFtgY29uc3QgX2l0ZW0gPSBgLCBjaGlsZEJsb2NrXSksXHJcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgX2l0ZW0ubWVtbyA9IF9tZW1vYCksXHJcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgcmV0dXJuIF9pdGVtYClcclxuICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICAgICAgcmVuZGVyRXhwLmFyZ3VtZW50cy5wdXNoKGxvb3AsIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYF9jYWNoZWApLCBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKFN0cmluZyhjb250ZXh0LmNhY2hlZCsrKSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVuZGVyRXhwLmFyZ3VtZW50cy5wdXNoKGNyZWF0ZUZ1bmN0aW9uRXhwcmVzc2lvbihjcmVhdGVGb3JMb29wUGFyYW1zKGZvck5vZGUucGFyc2VSZXN1bHQpLCBjaGlsZEJsb2NrLCB0cnVlIC8qIGZvcmNlIG5ld2xpbmUgKi8pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxufSk7XHJcbi8vIHRhcmdldC1hZ25vc3RpYyB0cmFuc2Zvcm0gdXNlZCBmb3IgYm90aCBDbGllbnQgYW5kIFNTUlxyXG5mdW5jdGlvbiBwcm9jZXNzRm9yKG5vZGUsIGRpciwgY29udGV4dCwgcHJvY2Vzc0NvZGVnZW4pIHtcclxuICAgIGlmICghZGlyLmV4cCkge1xyXG4gICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDMxIC8qIFhfVl9GT1JfTk9fRVhQUkVTU0lPTiAqLywgZGlyLmxvYykpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IHBhcnNlUmVzdWx0ID0gcGFyc2VGb3JFeHByZXNzaW9uKFxyXG4gICAgLy8gY2FuIG9ubHkgYmUgc2ltcGxlIGV4cHJlc3Npb24gYmVjYXVzZSB2Rm9yIHRyYW5zZm9ybSBpcyBhcHBsaWVkXHJcbiAgICAvLyBiZWZvcmUgZXhwcmVzc2lvbiB0cmFuc2Zvcm0uXHJcbiAgICBkaXIuZXhwLCBjb250ZXh0KTtcclxuICAgIGlmICghcGFyc2VSZXN1bHQpIHtcclxuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcigzMiAvKiBYX1ZfRk9SX01BTEZPUk1FRF9FWFBSRVNTSU9OICovLCBkaXIubG9jKSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyBhZGRJZGVudGlmaWVycywgcmVtb3ZlSWRlbnRpZmllcnMsIHNjb3BlcyB9ID0gY29udGV4dDtcclxuICAgIGNvbnN0IHsgc291cmNlLCB2YWx1ZSwga2V5LCBpbmRleCB9ID0gcGFyc2VSZXN1bHQ7XHJcbiAgICBjb25zdCBmb3JOb2RlID0ge1xyXG4gICAgICAgIHR5cGU6IDExIC8qIEZPUiAqLyxcclxuICAgICAgICBsb2M6IGRpci5sb2MsXHJcbiAgICAgICAgc291cmNlLFxyXG4gICAgICAgIHZhbHVlQWxpYXM6IHZhbHVlLFxyXG4gICAgICAgIGtleUFsaWFzOiBrZXksXHJcbiAgICAgICAgb2JqZWN0SW5kZXhBbGlhczogaW5kZXgsXHJcbiAgICAgICAgcGFyc2VSZXN1bHQsXHJcbiAgICAgICAgY2hpbGRyZW46IGlzVGVtcGxhdGVOb2RlKG5vZGUpID8gbm9kZS5jaGlsZHJlbiA6IFtub2RlXVxyXG4gICAgfTtcclxuICAgIGNvbnRleHQucmVwbGFjZU5vZGUoZm9yTm9kZSk7XHJcbiAgICAvLyBib29ra2VlcGluZ1xyXG4gICAgc2NvcGVzLnZGb3IrKztcclxuICAgIGNvbnN0IG9uRXhpdCA9IHByb2Nlc3NDb2RlZ2VuICYmIHByb2Nlc3NDb2RlZ2VuKGZvck5vZGUpO1xyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICBzY29wZXMudkZvci0tO1xyXG4gICAgICAgIGlmIChvbkV4aXQpXHJcbiAgICAgICAgICAgIG9uRXhpdCgpO1xyXG4gICAgfTtcclxufVxyXG5jb25zdCBmb3JBbGlhc1JFID0gLyhbXFxzXFxTXSo/KVxccysoPzppbnxvZilcXHMrKFtcXHNcXFNdKikvO1xyXG4vLyBUaGlzIHJlZ2V4IGRvZXNuJ3QgY292ZXIgdGhlIGNhc2UgaWYga2V5IG9yIGluZGV4IGFsaWFzZXMgaGF2ZSBkZXN0cnVjdHVyaW5nLFxyXG4vLyBidXQgdGhvc2UgZG8gbm90IG1ha2Ugc2Vuc2UgaW4gdGhlIGZpcnN0IHBsYWNlLCBzbyB0aGlzIHdvcmtzIGluIHByYWN0aWNlLlxyXG5jb25zdCBmb3JJdGVyYXRvclJFID0gLywoW14sXFx9XFxdXSopKD86LChbXixcXH1cXF1dKikpPyQvO1xyXG5jb25zdCBzdHJpcFBhcmVuc1JFID0gL15cXCh8XFwpJC9nO1xyXG5mdW5jdGlvbiBwYXJzZUZvckV4cHJlc3Npb24oaW5wdXQsIGNvbnRleHQpIHtcclxuICAgIGNvbnN0IGxvYyA9IGlucHV0LmxvYztcclxuICAgIGNvbnN0IGV4cCA9IGlucHV0LmNvbnRlbnQ7XHJcbiAgICBjb25zdCBpbk1hdGNoID0gZXhwLm1hdGNoKGZvckFsaWFzUkUpO1xyXG4gICAgaWYgKCFpbk1hdGNoKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIGNvbnN0IFssIExIUywgUkhTXSA9IGluTWF0Y2g7XHJcbiAgICBjb25zdCByZXN1bHQgPSB7XHJcbiAgICAgICAgc291cmNlOiBjcmVhdGVBbGlhc0V4cHJlc3Npb24obG9jLCBSSFMudHJpbSgpLCBleHAuaW5kZXhPZihSSFMsIExIUy5sZW5ndGgpKSxcclxuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxyXG4gICAgICAgIGtleTogdW5kZWZpbmVkLFxyXG4gICAgICAgIGluZGV4OiB1bmRlZmluZWRcclxuICAgIH07XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHRydWUpIHtcclxuICAgICAgICB2YWxpZGF0ZUJyb3dzZXJFeHByZXNzaW9uKHJlc3VsdC5zb3VyY2UsIGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgbGV0IHZhbHVlQ29udGVudCA9IExIUy50cmltKCkucmVwbGFjZShzdHJpcFBhcmVuc1JFLCAnJykudHJpbSgpO1xyXG4gICAgY29uc3QgdHJpbW1lZE9mZnNldCA9IExIUy5pbmRleE9mKHZhbHVlQ29udGVudCk7XHJcbiAgICBjb25zdCBpdGVyYXRvck1hdGNoID0gdmFsdWVDb250ZW50Lm1hdGNoKGZvckl0ZXJhdG9yUkUpO1xyXG4gICAgaWYgKGl0ZXJhdG9yTWF0Y2gpIHtcclxuICAgICAgICB2YWx1ZUNvbnRlbnQgPSB2YWx1ZUNvbnRlbnQucmVwbGFjZShmb3JJdGVyYXRvclJFLCAnJykudHJpbSgpO1xyXG4gICAgICAgIGNvbnN0IGtleUNvbnRlbnQgPSBpdGVyYXRvck1hdGNoWzFdLnRyaW0oKTtcclxuICAgICAgICBsZXQga2V5T2Zmc2V0O1xyXG4gICAgICAgIGlmIChrZXlDb250ZW50KSB7XHJcbiAgICAgICAgICAgIGtleU9mZnNldCA9IGV4cC5pbmRleE9mKGtleUNvbnRlbnQsIHRyaW1tZWRPZmZzZXQgKyB2YWx1ZUNvbnRlbnQubGVuZ3RoKTtcclxuICAgICAgICAgICAgcmVzdWx0LmtleSA9IGNyZWF0ZUFsaWFzRXhwcmVzc2lvbihsb2MsIGtleUNvbnRlbnQsIGtleU9mZnNldCk7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFsaWRhdGVCcm93c2VyRXhwcmVzc2lvbihyZXN1bHQua2V5LCBjb250ZXh0LCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXRlcmF0b3JNYXRjaFsyXSkge1xyXG4gICAgICAgICAgICBjb25zdCBpbmRleENvbnRlbnQgPSBpdGVyYXRvck1hdGNoWzJdLnRyaW0oKTtcclxuICAgICAgICAgICAgaWYgKGluZGV4Q29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LmluZGV4ID0gY3JlYXRlQWxpYXNFeHByZXNzaW9uKGxvYywgaW5kZXhDb250ZW50LCBleHAuaW5kZXhPZihpbmRleENvbnRlbnQsIHJlc3VsdC5rZXlcclxuICAgICAgICAgICAgICAgICAgICA/IGtleU9mZnNldCArIGtleUNvbnRlbnQubGVuZ3RoXHJcbiAgICAgICAgICAgICAgICAgICAgOiB0cmltbWVkT2Zmc2V0ICsgdmFsdWVDb250ZW50Lmxlbmd0aCkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVCcm93c2VyRXhwcmVzc2lvbihyZXN1bHQuaW5kZXgsIGNvbnRleHQsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHZhbHVlQ29udGVudCkge1xyXG4gICAgICAgIHJlc3VsdC52YWx1ZSA9IGNyZWF0ZUFsaWFzRXhwcmVzc2lvbihsb2MsIHZhbHVlQ29udGVudCwgdHJpbW1lZE9mZnNldCk7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB0cnVlKSB7XHJcbiAgICAgICAgICAgIHZhbGlkYXRlQnJvd3NlckV4cHJlc3Npb24ocmVzdWx0LnZhbHVlLCBjb250ZXh0LCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUFsaWFzRXhwcmVzc2lvbihyYW5nZSwgY29udGVudCwgb2Zmc2V0KSB7XHJcbiAgICByZXR1cm4gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihjb250ZW50LCBmYWxzZSwgZ2V0SW5uZXJSYW5nZShyYW5nZSwgb2Zmc2V0LCBjb250ZW50Lmxlbmd0aCkpO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUZvckxvb3BQYXJhbXMoeyB2YWx1ZSwga2V5LCBpbmRleCB9LCBtZW1vQXJncyA9IFtdKSB7XHJcbiAgICByZXR1cm4gY3JlYXRlUGFyYW1zTGlzdChbdmFsdWUsIGtleSwgaW5kZXgsIC4uLm1lbW9BcmdzXSk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUGFyYW1zTGlzdChhcmdzKSB7XHJcbiAgICBsZXQgaSA9IGFyZ3MubGVuZ3RoO1xyXG4gICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgIGlmIChhcmdzW2ldKVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgIH1cclxuICAgIHJldHVybiBhcmdzXHJcbiAgICAgICAgLnNsaWNlKDAsIGkgKyAxKVxyXG4gICAgICAgIC5tYXAoKGFyZywgaSkgPT4gYXJnIHx8IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYF9gLnJlcGVhdChpICsgMSksIGZhbHNlKSk7XHJcbn1cblxuY29uc3QgZGVmYXVsdEZhbGxiYWNrID0gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgdW5kZWZpbmVkYCwgZmFsc2UpO1xyXG4vLyBBIE5vZGVUcmFuc2Zvcm0gdGhhdDpcclxuLy8gMS4gVHJhY2tzIHNjb3BlIGlkZW50aWZpZXJzIGZvciBzY29wZWQgc2xvdHMgc28gdGhhdCB0aGV5IGRvbid0IGdldCBwcmVmaXhlZFxyXG4vLyAgICBieSB0cmFuc2Zvcm1FeHByZXNzaW9uLiBUaGlzIGlzIG9ubHkgYXBwbGllZCBpbiBub24tYnJvd3NlciBidWlsZHMgd2l0aFxyXG4vLyAgICB7IHByZWZpeElkZW50aWZpZXJzOiB0cnVlIH0uXHJcbi8vIDIuIFRyYWNrIHYtc2xvdCBkZXB0aHMgc28gdGhhdCB3ZSBrbm93IGEgc2xvdCBpcyBpbnNpZGUgYW5vdGhlciBzbG90LlxyXG4vLyAgICBOb3RlIHRoZSBleGl0IGNhbGxiYWNrIGlzIGV4ZWN1dGVkIGJlZm9yZSBidWlsZFNsb3RzKCkgb24gdGhlIHNhbWUgbm9kZSxcclxuLy8gICAgc28gb25seSBuZXN0ZWQgc2xvdHMgc2VlIHBvc2l0aXZlIG51bWJlcnMuXHJcbmNvbnN0IHRyYWNrU2xvdFNjb3BlcyA9IChub2RlLCBjb250ZXh0KSA9PiB7XHJcbiAgICBpZiAobm9kZS50eXBlID09PSAxIC8qIEVMRU1FTlQgKi8gJiZcclxuICAgICAgICAobm9kZS50YWdUeXBlID09PSAxIC8qIENPTVBPTkVOVCAqLyB8fFxyXG4gICAgICAgICAgICBub2RlLnRhZ1R5cGUgPT09IDMgLyogVEVNUExBVEUgKi8pKSB7XHJcbiAgICAgICAgLy8gV2UgYXJlIG9ubHkgY2hlY2tpbmcgbm9uLWVtcHR5IHYtc2xvdCBoZXJlXHJcbiAgICAgICAgLy8gc2luY2Ugd2Ugb25seSBjYXJlIGFib3V0IHNsb3RzIHRoYXQgaW50cm9kdWNlIHNjb3BlIHZhcmlhYmxlcy5cclxuICAgICAgICBjb25zdCB2U2xvdCA9IGZpbmREaXIobm9kZSwgJ3Nsb3QnKTtcclxuICAgICAgICBpZiAodlNsb3QpIHtcclxuICAgICAgICAgICAgdlNsb3QuZXhwO1xyXG4gICAgICAgICAgICBjb250ZXh0LnNjb3Blcy52U2xvdCsrO1xyXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5zY29wZXMudlNsb3QtLTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbi8vIEEgTm9kZVRyYW5zZm9ybSB0aGF0IHRyYWNrcyBzY29wZSBpZGVudGlmaWVycyBmb3Igc2NvcGVkIHNsb3RzIHdpdGggdi1mb3IuXHJcbi8vIFRoaXMgdHJhbnNmb3JtIGlzIG9ubHkgYXBwbGllZCBpbiBub24tYnJvd3NlciBidWlsZHMgd2l0aCB7IHByZWZpeElkZW50aWZpZXJzOiB0cnVlIH1cclxuY29uc3QgdHJhY2tWRm9yU2xvdFNjb3BlcyA9IChub2RlLCBjb250ZXh0KSA9PiB7XHJcbiAgICBsZXQgdkZvcjtcclxuICAgIGlmIChpc1RlbXBsYXRlTm9kZShub2RlKSAmJlxyXG4gICAgICAgIG5vZGUucHJvcHMuc29tZShpc1ZTbG90KSAmJlxyXG4gICAgICAgICh2Rm9yID0gZmluZERpcihub2RlLCAnZm9yJykpKSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gKHZGb3IucGFyc2VSZXN1bHQgPSBwYXJzZUZvckV4cHJlc3Npb24odkZvci5leHAsIGNvbnRleHQpKTtcclxuICAgICAgICBpZiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgdmFsdWUsIGtleSwgaW5kZXggfSA9IHJlc3VsdDtcclxuICAgICAgICAgICAgY29uc3QgeyBhZGRJZGVudGlmaWVycywgcmVtb3ZlSWRlbnRpZmllcnMgfSA9IGNvbnRleHQ7XHJcbiAgICAgICAgICAgIHZhbHVlICYmIGFkZElkZW50aWZpZXJzKHZhbHVlKTtcclxuICAgICAgICAgICAga2V5ICYmIGFkZElkZW50aWZpZXJzKGtleSk7XHJcbiAgICAgICAgICAgIGluZGV4ICYmIGFkZElkZW50aWZpZXJzKGluZGV4KTtcclxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHZhbHVlICYmIHJlbW92ZUlkZW50aWZpZXJzKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGtleSAmJiByZW1vdmVJZGVudGlmaWVycyhrZXkpO1xyXG4gICAgICAgICAgICAgICAgaW5kZXggJiYgcmVtb3ZlSWRlbnRpZmllcnMoaW5kZXgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuY29uc3QgYnVpbGRDbGllbnRTbG90Rm4gPSAocHJvcHMsIGNoaWxkcmVuLCBsb2MpID0+IGNyZWF0ZUZ1bmN0aW9uRXhwcmVzc2lvbihwcm9wcywgY2hpbGRyZW4sIGZhbHNlIC8qIG5ld2xpbmUgKi8sIHRydWUgLyogaXNTbG90ICovLCBjaGlsZHJlbi5sZW5ndGggPyBjaGlsZHJlblswXS5sb2MgOiBsb2MpO1xyXG4vLyBJbnN0ZWFkIG9mIGJlaW5nIGEgRGlyZWN0aXZlVHJhbnNmb3JtLCB2LXNsb3QgcHJvY2Vzc2luZyBpcyBjYWxsZWQgZHVyaW5nXHJcbi8vIHRyYW5zZm9ybUVsZW1lbnQgdG8gYnVpbGQgdGhlIHNsb3RzIG9iamVjdCBmb3IgYSBjb21wb25lbnQuXHJcbmZ1bmN0aW9uIGJ1aWxkU2xvdHMobm9kZSwgY29udGV4dCwgYnVpbGRTbG90Rm4gPSBidWlsZENsaWVudFNsb3RGbikge1xyXG4gICAgY29udGV4dC5oZWxwZXIoV0lUSF9DVFgpO1xyXG4gICAgY29uc3QgeyBjaGlsZHJlbiwgbG9jIH0gPSBub2RlO1xyXG4gICAgY29uc3Qgc2xvdHNQcm9wZXJ0aWVzID0gW107XHJcbiAgICBjb25zdCBkeW5hbWljU2xvdHMgPSBbXTtcclxuICAgIC8vIElmIHRoZSBzbG90IGlzIGluc2lkZSBhIHYtZm9yIG9yIGFub3RoZXIgdi1zbG90LCBmb3JjZSBpdCB0byBiZSBkeW5hbWljXHJcbiAgICAvLyBzaW5jZSBpdCBsaWtlbHkgdXNlcyBhIHNjb3BlIHZhcmlhYmxlLlxyXG4gICAgbGV0IGhhc0R5bmFtaWNTbG90cyA9IGNvbnRleHQuc2NvcGVzLnZTbG90ID4gMCB8fCBjb250ZXh0LnNjb3Blcy52Rm9yID4gMDtcclxuICAgIC8vIDEuIENoZWNrIGZvciBzbG90IHdpdGggc2xvdFByb3BzIG9uIGNvbXBvbmVudCBpdHNlbGYuXHJcbiAgICAvLyAgICA8Q29tcCB2LXNsb3Q9XCJ7IHByb3AgfVwiLz5cclxuICAgIGNvbnN0IG9uQ29tcG9uZW50U2xvdCA9IGZpbmREaXIobm9kZSwgJ3Nsb3QnLCB0cnVlKTtcclxuICAgIGlmIChvbkNvbXBvbmVudFNsb3QpIHtcclxuICAgICAgICBjb25zdCB7IGFyZywgZXhwIH0gPSBvbkNvbXBvbmVudFNsb3Q7XHJcbiAgICAgICAgaWYgKGFyZyAmJiAhaXNTdGF0aWNFeHAoYXJnKSkge1xyXG4gICAgICAgICAgICBoYXNEeW5hbWljU2xvdHMgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzbG90c1Byb3BlcnRpZXMucHVzaChjcmVhdGVPYmplY3RQcm9wZXJ0eShhcmcgfHwgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbignZGVmYXVsdCcsIHRydWUpLCBidWlsZFNsb3RGbihleHAsIGNoaWxkcmVuLCBsb2MpKSk7XHJcbiAgICB9XHJcbiAgICAvLyAyLiBJdGVyYXRlIHRocm91Z2ggY2hpbGRyZW4gYW5kIGNoZWNrIGZvciB0ZW1wbGF0ZSBzbG90c1xyXG4gICAgLy8gICAgPHRlbXBsYXRlIHYtc2xvdDpmb289XCJ7IHByb3AgfVwiPlxyXG4gICAgbGV0IGhhc1RlbXBsYXRlU2xvdHMgPSBmYWxzZTtcclxuICAgIGxldCBoYXNOYW1lZERlZmF1bHRTbG90ID0gZmFsc2U7XHJcbiAgICBjb25zdCBpbXBsaWNpdERlZmF1bHRDaGlsZHJlbiA9IFtdO1xyXG4gICAgY29uc3Qgc2VlblNsb3ROYW1lcyA9IG5ldyBTZXQoKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBzbG90RWxlbWVudCA9IGNoaWxkcmVuW2ldO1xyXG4gICAgICAgIGxldCBzbG90RGlyO1xyXG4gICAgICAgIGlmICghaXNUZW1wbGF0ZU5vZGUoc2xvdEVsZW1lbnQpIHx8XHJcbiAgICAgICAgICAgICEoc2xvdERpciA9IGZpbmREaXIoc2xvdEVsZW1lbnQsICdzbG90JywgdHJ1ZSkpKSB7XHJcbiAgICAgICAgICAgIC8vIG5vdCBhIDx0ZW1wbGF0ZSB2LXNsb3Q+LCBza2lwLlxyXG4gICAgICAgICAgICBpZiAoc2xvdEVsZW1lbnQudHlwZSAhPT0gMyAvKiBDT01NRU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICBpbXBsaWNpdERlZmF1bHRDaGlsZHJlbi5wdXNoKHNsb3RFbGVtZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9uQ29tcG9uZW50U2xvdCkge1xyXG4gICAgICAgICAgICAvLyBhbHJlYWR5IGhhcyBvbi1jb21wb25lbnQgc2xvdCAtIHRoaXMgaXMgaW5jb3JyZWN0IHVzYWdlLlxyXG4gICAgICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcigzNyAvKiBYX1ZfU0xPVF9NSVhFRF9TTE9UX1VTQUdFICovLCBzbG90RGlyLmxvYykpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgaGFzVGVtcGxhdGVTbG90cyA9IHRydWU7XHJcbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbjogc2xvdENoaWxkcmVuLCBsb2M6IHNsb3RMb2MgfSA9IHNsb3RFbGVtZW50O1xyXG4gICAgICAgIGNvbnN0IHsgYXJnOiBzbG90TmFtZSA9IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYGRlZmF1bHRgLCB0cnVlKSwgZXhwOiBzbG90UHJvcHMsIGxvYzogZGlyTG9jIH0gPSBzbG90RGlyO1xyXG4gICAgICAgIC8vIGNoZWNrIGlmIG5hbWUgaXMgZHluYW1pYy5cclxuICAgICAgICBsZXQgc3RhdGljU2xvdE5hbWU7XHJcbiAgICAgICAgaWYgKGlzU3RhdGljRXhwKHNsb3ROYW1lKSkge1xyXG4gICAgICAgICAgICBzdGF0aWNTbG90TmFtZSA9IHNsb3ROYW1lID8gc2xvdE5hbWUuY29udGVudCA6IGBkZWZhdWx0YDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGhhc0R5bmFtaWNTbG90cyA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHNsb3RGdW5jdGlvbiA9IGJ1aWxkU2xvdEZuKHNsb3RQcm9wcywgc2xvdENoaWxkcmVuLCBzbG90TG9jKTtcclxuICAgICAgICAvLyBjaGVjayBpZiB0aGlzIHNsb3QgaXMgY29uZGl0aW9uYWwgKHYtaWYvdi1mb3IpXHJcbiAgICAgICAgbGV0IHZJZjtcclxuICAgICAgICBsZXQgdkVsc2U7XHJcbiAgICAgICAgbGV0IHZGb3I7XHJcbiAgICAgICAgaWYgKCh2SWYgPSBmaW5kRGlyKHNsb3RFbGVtZW50LCAnaWYnKSkpIHtcclxuICAgICAgICAgICAgaGFzRHluYW1pY1Nsb3RzID0gdHJ1ZTtcclxuICAgICAgICAgICAgZHluYW1pY1Nsb3RzLnB1c2goY3JlYXRlQ29uZGl0aW9uYWxFeHByZXNzaW9uKHZJZi5leHAsIGJ1aWxkRHluYW1pY1Nsb3Qoc2xvdE5hbWUsIHNsb3RGdW5jdGlvbiksIGRlZmF1bHRGYWxsYmFjaykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgodkVsc2UgPSBmaW5kRGlyKHNsb3RFbGVtZW50LCAvXmVsc2UoLWlmKT8kLywgdHJ1ZSAvKiBhbGxvd0VtcHR5ICovKSkpIHtcclxuICAgICAgICAgICAgLy8gZmluZCBhZGphY2VudCB2LWlmXHJcbiAgICAgICAgICAgIGxldCBqID0gaTtcclxuICAgICAgICAgICAgbGV0IHByZXY7XHJcbiAgICAgICAgICAgIHdoaWxlIChqLS0pIHtcclxuICAgICAgICAgICAgICAgIHByZXYgPSBjaGlsZHJlbltqXTtcclxuICAgICAgICAgICAgICAgIGlmIChwcmV2LnR5cGUgIT09IDMgLyogQ09NTUVOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwcmV2ICYmIGlzVGVtcGxhdGVOb2RlKHByZXYpICYmIGZpbmREaXIocHJldiwgJ2lmJykpIHtcclxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBub2RlXHJcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICBpLS07XHJcbiAgICAgICAgICAgICAgICAvLyBhdHRhY2ggdGhpcyBzbG90IHRvIHByZXZpb3VzIGNvbmRpdGlvbmFsXHJcbiAgICAgICAgICAgICAgICBsZXQgY29uZGl0aW9uYWwgPSBkeW5hbWljU2xvdHNbZHluYW1pY1Nsb3RzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGNvbmRpdGlvbmFsLmFsdGVybmF0ZS50eXBlID09PSAxOSAvKiBKU19DT05ESVRJT05BTF9FWFBSRVNTSU9OICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uYWwgPSBjb25kaXRpb25hbC5hbHRlcm5hdGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25kaXRpb25hbC5hbHRlcm5hdGUgPSB2RWxzZS5leHBcclxuICAgICAgICAgICAgICAgICAgICA/IGNyZWF0ZUNvbmRpdGlvbmFsRXhwcmVzc2lvbih2RWxzZS5leHAsIGJ1aWxkRHluYW1pY1Nsb3Qoc2xvdE5hbWUsIHNsb3RGdW5jdGlvbiksIGRlZmF1bHRGYWxsYmFjaylcclxuICAgICAgICAgICAgICAgICAgICA6IGJ1aWxkRHluYW1pY1Nsb3Qoc2xvdE5hbWUsIHNsb3RGdW5jdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcigzMCAvKiBYX1ZfRUxTRV9OT19BREpBQ0VOVF9JRiAqLywgdkVsc2UubG9jKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoKHZGb3IgPSBmaW5kRGlyKHNsb3RFbGVtZW50LCAnZm9yJykpKSB7XHJcbiAgICAgICAgICAgIGhhc0R5bmFtaWNTbG90cyA9IHRydWU7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlUmVzdWx0ID0gdkZvci5wYXJzZVJlc3VsdCB8fFxyXG4gICAgICAgICAgICAgICAgcGFyc2VGb3JFeHByZXNzaW9uKHZGb3IuZXhwLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgaWYgKHBhcnNlUmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBSZW5kZXIgdGhlIGR5bmFtaWMgc2xvdHMgYXMgYW4gYXJyYXkgYW5kIGFkZCBpdCB0byB0aGUgY3JlYXRlU2xvdCgpXHJcbiAgICAgICAgICAgICAgICAvLyBhcmdzLiBUaGUgcnVudGltZSBrbm93cyBob3cgdG8gaGFuZGxlIGl0IGFwcHJvcHJpYXRlbHkuXHJcbiAgICAgICAgICAgICAgICBkeW5hbWljU2xvdHMucHVzaChjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlcihSRU5ERVJfTElTVCksIFtcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZVJlc3VsdC5zb3VyY2UsXHJcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlRnVuY3Rpb25FeHByZXNzaW9uKGNyZWF0ZUZvckxvb3BQYXJhbXMocGFyc2VSZXN1bHQpLCBidWlsZER5bmFtaWNTbG90KHNsb3ROYW1lLCBzbG90RnVuY3Rpb24pLCB0cnVlIC8qIGZvcmNlIG5ld2xpbmUgKi8pXHJcbiAgICAgICAgICAgICAgICBdKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcigzMiAvKiBYX1ZfRk9SX01BTEZPUk1FRF9FWFBSRVNTSU9OICovLCB2Rm9yLmxvYykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBjaGVjayBkdXBsaWNhdGUgc3RhdGljIG5hbWVzXHJcbiAgICAgICAgICAgIGlmIChzdGF0aWNTbG90TmFtZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlZW5TbG90TmFtZXMuaGFzKHN0YXRpY1Nsb3ROYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDM4IC8qIFhfVl9TTE9UX0RVUExJQ0FURV9TTE9UX05BTUVTICovLCBkaXJMb2MpKTtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNlZW5TbG90TmFtZXMuYWRkKHN0YXRpY1Nsb3ROYW1lKTtcclxuICAgICAgICAgICAgICAgIGlmIChzdGF0aWNTbG90TmFtZSA9PT0gJ2RlZmF1bHQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzTmFtZWREZWZhdWx0U2xvdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2xvdHNQcm9wZXJ0aWVzLnB1c2goY3JlYXRlT2JqZWN0UHJvcGVydHkoc2xvdE5hbWUsIHNsb3RGdW5jdGlvbikpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghb25Db21wb25lbnRTbG90KSB7XHJcbiAgICAgICAgY29uc3QgYnVpbGREZWZhdWx0U2xvdFByb3BlcnR5ID0gKHByb3BzLCBjaGlsZHJlbikgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBmbiA9IGJ1aWxkU2xvdEZuKHByb3BzLCBjaGlsZHJlbiwgbG9jKTtcclxuICAgICAgICAgICAgaWYgKGNvbnRleHQuY29tcGF0Q29uZmlnKSB7XHJcbiAgICAgICAgICAgICAgICBmbi5pc05vblNjb3BlZFNsb3QgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVPYmplY3RQcm9wZXJ0eShgZGVmYXVsdGAsIGZuKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICghaGFzVGVtcGxhdGVTbG90cykge1xyXG4gICAgICAgICAgICAvLyBpbXBsaWNpdCBkZWZhdWx0IHNsb3QgKG9uIGNvbXBvbmVudClcclxuICAgICAgICAgICAgc2xvdHNQcm9wZXJ0aWVzLnB1c2goYnVpbGREZWZhdWx0U2xvdFByb3BlcnR5KHVuZGVmaW5lZCwgY2hpbGRyZW4pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaW1wbGljaXREZWZhdWx0Q2hpbGRyZW4ubGVuZ3RoICYmXHJcbiAgICAgICAgICAgIC8vICMzNzY2XHJcbiAgICAgICAgICAgIC8vIHdpdGggd2hpdGVzcGFjZTogJ3ByZXNlcnZlJywgd2hpdGVzcGFjZXMgYmV0d2VlbiBzbG90cyB3aWxsIGVuZCB1cCBpblxyXG4gICAgICAgICAgICAvLyBpbXBsaWNpdERlZmF1bHRDaGlsZHJlbi4gSWdub3JlIGlmIGFsbCBpbXBsaWNpdCBjaGlsZHJlbiBhcmUgd2hpdGVzcGFjZXMuXHJcbiAgICAgICAgICAgIGltcGxpY2l0RGVmYXVsdENoaWxkcmVuLnNvbWUobm9kZSA9PiBpc05vbldoaXRlc3BhY2VDb250ZW50KG5vZGUpKSkge1xyXG4gICAgICAgICAgICAvLyBpbXBsaWNpdCBkZWZhdWx0IHNsb3QgKG1peGVkIHdpdGggbmFtZWQgc2xvdHMpXHJcbiAgICAgICAgICAgIGlmIChoYXNOYW1lZERlZmF1bHRTbG90KSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcigzOSAvKiBYX1ZfU0xPVF9FWFRSQU5FT1VTX0RFRkFVTFRfU0xPVF9DSElMRFJFTiAqLywgaW1wbGljaXREZWZhdWx0Q2hpbGRyZW5bMF0ubG9jKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzbG90c1Byb3BlcnRpZXMucHVzaChidWlsZERlZmF1bHRTbG90UHJvcGVydHkodW5kZWZpbmVkLCBpbXBsaWNpdERlZmF1bHRDaGlsZHJlbikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3Qgc2xvdEZsYWcgPSBoYXNEeW5hbWljU2xvdHNcclxuICAgICAgICA/IDIgLyogRFlOQU1JQyAqL1xyXG4gICAgICAgIDogaGFzRm9yd2FyZGVkU2xvdHMobm9kZS5jaGlsZHJlbilcclxuICAgICAgICAgICAgPyAzIC8qIEZPUldBUkRFRCAqL1xyXG4gICAgICAgICAgICA6IDEgLyogU1RBQkxFICovO1xyXG4gICAgbGV0IHNsb3RzID0gY3JlYXRlT2JqZWN0RXhwcmVzc2lvbihzbG90c1Byb3BlcnRpZXMuY29uY2F0KGNyZWF0ZU9iamVjdFByb3BlcnR5KGBfYCwgXHJcbiAgICAvLyAyID0gY29tcGlsZWQgYnV0IGR5bmFtaWMgPSBjYW4gc2tpcCBub3JtYWxpemF0aW9uLCBidXQgbXVzdCBydW4gZGlmZlxyXG4gICAgLy8gMSA9IGNvbXBpbGVkIGFuZCBzdGF0aWMgPSBjYW4gc2tpcCBub3JtYWxpemF0aW9uIEFORCBkaWZmIGFzIG9wdGltaXplZFxyXG4gICAgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihzbG90RmxhZyArICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgIC8qICR7c2xvdEZsYWdzVGV4dFtzbG90RmxhZ119ICovYCA6IGBgKSwgZmFsc2UpKSksIGxvYyk7XHJcbiAgICBpZiAoZHluYW1pY1Nsb3RzLmxlbmd0aCkge1xyXG4gICAgICAgIHNsb3RzID0gY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXIoQ1JFQVRFX1NMT1RTKSwgW1xyXG4gICAgICAgICAgICBzbG90cyxcclxuICAgICAgICAgICAgY3JlYXRlQXJyYXlFeHByZXNzaW9uKGR5bmFtaWNTbG90cylcclxuICAgICAgICBdKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgc2xvdHMsXHJcbiAgICAgICAgaGFzRHluYW1pY1Nsb3RzXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGJ1aWxkRHluYW1pY1Nsb3QobmFtZSwgZm4pIHtcclxuICAgIHJldHVybiBjcmVhdGVPYmplY3RFeHByZXNzaW9uKFtcclxuICAgICAgICBjcmVhdGVPYmplY3RQcm9wZXJ0eShgbmFtZWAsIG5hbWUpLFxyXG4gICAgICAgIGNyZWF0ZU9iamVjdFByb3BlcnR5KGBmbmAsIGZuKVxyXG4gICAgXSk7XHJcbn1cclxuZnVuY3Rpb24gaGFzRm9yd2FyZGVkU2xvdHMoY2hpbGRyZW4pIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xyXG4gICAgICAgIHN3aXRjaCAoY2hpbGQudHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIDEgLyogRUxFTUVOVCAqLzpcclxuICAgICAgICAgICAgICAgIGlmIChjaGlsZC50YWdUeXBlID09PSAyIC8qIFNMT1QgKi8gfHxcclxuICAgICAgICAgICAgICAgICAgICBoYXNGb3J3YXJkZWRTbG90cyhjaGlsZC5jaGlsZHJlbikpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDkgLyogSUYgKi86XHJcbiAgICAgICAgICAgICAgICBpZiAoaGFzRm9yd2FyZGVkU2xvdHMoY2hpbGQuYnJhbmNoZXMpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMTAgLyogSUZfQlJBTkNIICovOlxyXG4gICAgICAgICAgICBjYXNlIDExIC8qIEZPUiAqLzpcclxuICAgICAgICAgICAgICAgIGlmIChoYXNGb3J3YXJkZWRTbG90cyhjaGlsZC5jaGlsZHJlbikpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gaXNOb25XaGl0ZXNwYWNlQ29udGVudChub2RlKSB7XHJcbiAgICBpZiAobm9kZS50eXBlICE9PSAyIC8qIFRFWFQgKi8gJiYgbm9kZS50eXBlICE9PSAxMiAvKiBURVhUX0NBTEwgKi8pXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSAyIC8qIFRFWFQgKi9cclxuICAgICAgICA/ICEhbm9kZS5jb250ZW50LnRyaW0oKVxyXG4gICAgICAgIDogaXNOb25XaGl0ZXNwYWNlQ29udGVudChub2RlLmNvbnRlbnQpO1xyXG59XG5cbi8vIHNvbWUgZGlyZWN0aXZlIHRyYW5zZm9ybXMgKGUuZy4gdi1tb2RlbCkgbWF5IHJldHVybiBhIHN5bWJvbCBmb3IgcnVudGltZVxyXG4vLyBpbXBvcnQsIHdoaWNoIHNob3VsZCBiZSB1c2VkIGluc3RlYWQgb2YgYSByZXNvbHZlRGlyZWN0aXZlIGNhbGwuXHJcbmNvbnN0IGRpcmVjdGl2ZUltcG9ydE1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbi8vIGdlbmVyYXRlIGEgSmF2YVNjcmlwdCBBU1QgZm9yIHRoaXMgZWxlbWVudCdzIGNvZGVnZW5cclxuY29uc3QgdHJhbnNmb3JtRWxlbWVudCA9IChub2RlLCBjb250ZXh0KSA9PiB7XHJcbiAgICAvLyBwZXJmb3JtIHRoZSB3b3JrIG9uIGV4aXQsIGFmdGVyIGFsbCBjaGlsZCBleHByZXNzaW9ucyBoYXZlIGJlZW5cclxuICAgIC8vIHByb2Nlc3NlZCBhbmQgbWVyZ2VkLlxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHBvc3RUcmFuc2Zvcm1FbGVtZW50KCkge1xyXG4gICAgICAgIG5vZGUgPSBjb250ZXh0LmN1cnJlbnROb2RlO1xyXG4gICAgICAgIGlmICghKG5vZGUudHlwZSA9PT0gMSAvKiBFTEVNRU5UICovICYmXHJcbiAgICAgICAgICAgIChub2RlLnRhZ1R5cGUgPT09IDAgLyogRUxFTUVOVCAqLyB8fFxyXG4gICAgICAgICAgICAgICAgbm9kZS50YWdUeXBlID09PSAxIC8qIENPTVBPTkVOVCAqLykpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgeyB0YWcsIHByb3BzIH0gPSBub2RlO1xyXG4gICAgICAgIGNvbnN0IGlzQ29tcG9uZW50ID0gbm9kZS50YWdUeXBlID09PSAxIC8qIENPTVBPTkVOVCAqLztcclxuICAgICAgICAvLyBUaGUgZ29hbCBvZiB0aGUgdHJhbnNmb3JtIGlzIHRvIGNyZWF0ZSBhIGNvZGVnZW5Ob2RlIGltcGxlbWVudGluZyB0aGVcclxuICAgICAgICAvLyBWTm9kZUNhbGwgaW50ZXJmYWNlLlxyXG4gICAgICAgIGxldCB2bm9kZVRhZyA9IGlzQ29tcG9uZW50XHJcbiAgICAgICAgICAgID8gcmVzb2x2ZUNvbXBvbmVudFR5cGUobm9kZSwgY29udGV4dClcclxuICAgICAgICAgICAgOiBgXCIke3RhZ31cImA7XHJcbiAgICAgICAgY29uc3QgaXNEeW5hbWljQ29tcG9uZW50ID0gaXNPYmplY3Qodm5vZGVUYWcpICYmIHZub2RlVGFnLmNhbGxlZSA9PT0gUkVTT0xWRV9EWU5BTUlDX0NPTVBPTkVOVDtcclxuICAgICAgICBsZXQgdm5vZGVQcm9wcztcclxuICAgICAgICBsZXQgdm5vZGVDaGlsZHJlbjtcclxuICAgICAgICBsZXQgdm5vZGVQYXRjaEZsYWc7XHJcbiAgICAgICAgbGV0IHBhdGNoRmxhZyA9IDA7XHJcbiAgICAgICAgbGV0IHZub2RlRHluYW1pY1Byb3BzO1xyXG4gICAgICAgIGxldCBkeW5hbWljUHJvcE5hbWVzO1xyXG4gICAgICAgIGxldCB2bm9kZURpcmVjdGl2ZXM7XHJcbiAgICAgICAgbGV0IHNob3VsZFVzZUJsb2NrID0gXHJcbiAgICAgICAgLy8gZHluYW1pYyBjb21wb25lbnQgbWF5IHJlc29sdmUgdG8gcGxhaW4gZWxlbWVudHNcclxuICAgICAgICBpc0R5bmFtaWNDb21wb25lbnQgfHxcclxuICAgICAgICAgICAgdm5vZGVUYWcgPT09IFRFTEVQT1JUIHx8XHJcbiAgICAgICAgICAgIHZub2RlVGFnID09PSBTVVNQRU5TRSB8fFxyXG4gICAgICAgICAgICAoIWlzQ29tcG9uZW50ICYmXHJcbiAgICAgICAgICAgICAgICAvLyA8c3ZnPiBhbmQgPGZvcmVpZ25PYmplY3Q+IG11c3QgYmUgZm9yY2VkIGludG8gYmxvY2tzIHNvIHRoYXQgYmxvY2tcclxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZXMgaW5zaWRlIGdldCBwcm9wZXIgaXNTVkcgZmxhZyBhdCBydW50aW1lLiAoIzYzOSwgIzY0MylcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgdGVjaG5pY2FsbHkgd2ViLXNwZWNpZmljLCBidXQgc3BsaXR0aW5nIHRoZSBsb2dpYyBvdXQgb2YgY29yZVxyXG4gICAgICAgICAgICAgICAgLy8gbGVhZHMgdG8gdG9vIG11Y2ggdW5uZWNlc3NhcnkgY29tcGxleGl0eS5cclxuICAgICAgICAgICAgICAgICh0YWcgPT09ICdzdmcnIHx8IHRhZyA9PT0gJ2ZvcmVpZ25PYmplY3QnKSk7XHJcbiAgICAgICAgLy8gcHJvcHNcclxuICAgICAgICBpZiAocHJvcHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBjb25zdCBwcm9wc0J1aWxkUmVzdWx0ID0gYnVpbGRQcm9wcyhub2RlLCBjb250ZXh0LCB1bmRlZmluZWQsIGlzQ29tcG9uZW50LCBpc0R5bmFtaWNDb21wb25lbnQpO1xyXG4gICAgICAgICAgICB2bm9kZVByb3BzID0gcHJvcHNCdWlsZFJlc3VsdC5wcm9wcztcclxuICAgICAgICAgICAgcGF0Y2hGbGFnID0gcHJvcHNCdWlsZFJlc3VsdC5wYXRjaEZsYWc7XHJcbiAgICAgICAgICAgIGR5bmFtaWNQcm9wTmFtZXMgPSBwcm9wc0J1aWxkUmVzdWx0LmR5bmFtaWNQcm9wTmFtZXM7XHJcbiAgICAgICAgICAgIGNvbnN0IGRpcmVjdGl2ZXMgPSBwcm9wc0J1aWxkUmVzdWx0LmRpcmVjdGl2ZXM7XHJcbiAgICAgICAgICAgIHZub2RlRGlyZWN0aXZlcyA9XHJcbiAgICAgICAgICAgICAgICBkaXJlY3RpdmVzICYmIGRpcmVjdGl2ZXMubGVuZ3RoXHJcbiAgICAgICAgICAgICAgICAgICAgPyBjcmVhdGVBcnJheUV4cHJlc3Npb24oZGlyZWN0aXZlcy5tYXAoZGlyID0+IGJ1aWxkRGlyZWN0aXZlQXJncyhkaXIsIGNvbnRleHQpKSlcclxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgaWYgKHByb3BzQnVpbGRSZXN1bHQuc2hvdWxkVXNlQmxvY2spIHtcclxuICAgICAgICAgICAgICAgIHNob3VsZFVzZUJsb2NrID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjaGlsZHJlblxyXG4gICAgICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgaWYgKHZub2RlVGFnID09PSBLRUVQX0FMSVZFKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBBbHRob3VnaCBhIGJ1aWx0LWluIGNvbXBvbmVudCwgd2UgY29tcGlsZSBLZWVwQWxpdmUgd2l0aCByYXcgY2hpbGRyZW5cclxuICAgICAgICAgICAgICAgIC8vIGluc3RlYWQgb2Ygc2xvdCBmdW5jdGlvbnMgc28gdGhhdCBpdCBjYW4gYmUgdXNlZCBpbnNpZGUgVHJhbnNpdGlvblxyXG4gICAgICAgICAgICAgICAgLy8gb3Igb3RoZXIgVHJhbnNpdGlvbi13cmFwcGluZyBIT0NzLlxyXG4gICAgICAgICAgICAgICAgLy8gVG8gZW5zdXJlIGNvcnJlY3QgdXBkYXRlcyB3aXRoIGJsb2NrIG9wdGltaXphdGlvbnMsIHdlIG5lZWQgdG86XHJcbiAgICAgICAgICAgICAgICAvLyAxLiBGb3JjZSBrZWVwLWFsaXZlIGludG8gYSBibG9jay4gVGhpcyBhdm9pZHMgaXRzIGNoaWxkcmVuIGJlaW5nXHJcbiAgICAgICAgICAgICAgICAvLyAgICBjb2xsZWN0ZWQgYnkgYSBwYXJlbnQgYmxvY2suXHJcbiAgICAgICAgICAgICAgICBzaG91bGRVc2VCbG9jayA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAvLyAyLiBGb3JjZSBrZWVwLWFsaXZlIHRvIGFsd2F5cyBiZSB1cGRhdGVkLCBzaW5jZSBpdCB1c2VzIHJhdyBjaGlsZHJlbi5cclxuICAgICAgICAgICAgICAgIHBhdGNoRmxhZyB8PSAxMDI0IC8qIERZTkFNSUNfU0xPVFMgKi87XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDQ1IC8qIFhfS0VFUF9BTElWRV9JTlZBTElEX0NISUxEUkVOICovLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBub2RlLmNoaWxkcmVuWzBdLmxvYy5zdGFydCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBub2RlLmNoaWxkcmVuW25vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMV0ubG9jLmVuZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiAnJ1xyXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBzaG91bGRCdWlsZEFzU2xvdHMgPSBpc0NvbXBvbmVudCAmJlxyXG4gICAgICAgICAgICAgICAgLy8gVGVsZXBvcnQgaXMgbm90IGEgcmVhbCBjb21wb25lbnQgYW5kIGhhcyBkZWRpY2F0ZWQgcnVudGltZSBoYW5kbGluZ1xyXG4gICAgICAgICAgICAgICAgdm5vZGVUYWcgIT09IFRFTEVQT1JUICYmXHJcbiAgICAgICAgICAgICAgICAvLyBleHBsYWluZWQgYWJvdmUuXHJcbiAgICAgICAgICAgICAgICB2bm9kZVRhZyAhPT0gS0VFUF9BTElWRTtcclxuICAgICAgICAgICAgaWYgKHNob3VsZEJ1aWxkQXNTbG90cykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBzbG90cywgaGFzRHluYW1pY1Nsb3RzIH0gPSBidWlsZFNsb3RzKG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgdm5vZGVDaGlsZHJlbiA9IHNsb3RzO1xyXG4gICAgICAgICAgICAgICAgaWYgKGhhc0R5bmFtaWNTbG90cykge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoRmxhZyB8PSAxMDI0IC8qIERZTkFNSUNfU0xPVFMgKi87XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgdm5vZGVUYWcgIT09IFRFTEVQT1JUKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IG5vZGUuY2hpbGRyZW5bMF07XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlID0gY2hpbGQudHlwZTtcclxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciBkeW5hbWljIHRleHQgY2hpbGRyZW5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGhhc0R5bmFtaWNUZXh0Q2hpbGQgPSB0eXBlID09PSA1IC8qIElOVEVSUE9MQVRJT04gKi8gfHxcclxuICAgICAgICAgICAgICAgICAgICB0eXBlID09PSA4IC8qIENPTVBPVU5EX0VYUFJFU1NJT04gKi87XHJcbiAgICAgICAgICAgICAgICBpZiAoaGFzRHluYW1pY1RleHRDaGlsZCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGdldENvbnN0YW50VHlwZShjaGlsZCwgY29udGV4dCkgPT09IDAgLyogTk9UX0NPTlNUQU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2hGbGFnIHw9IDEgLyogVEVYVCAqLztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHBhc3MgZGlyZWN0bHkgaWYgdGhlIG9ubHkgY2hpbGQgaXMgYSB0ZXh0IG5vZGVcclxuICAgICAgICAgICAgICAgIC8vIChwbGFpbiAvIGludGVycG9sYXRpb24gLyBleHByZXNzaW9uKVxyXG4gICAgICAgICAgICAgICAgaWYgKGhhc0R5bmFtaWNUZXh0Q2hpbGQgfHwgdHlwZSA9PT0gMiAvKiBURVhUICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdm5vZGVDaGlsZHJlbiA9IGNoaWxkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdm5vZGVDaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2bm9kZUNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBwYXRjaEZsYWcgJiBkeW5hbWljUHJvcE5hbWVzXHJcbiAgICAgICAgaWYgKHBhdGNoRmxhZyAhPT0gMCkge1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocGF0Y2hGbGFnIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNwZWNpYWwgZmxhZ3MgKG5lZ2F0aXZlIGFuZCBtdXR1YWxseSBleGNsdXNpdmUpXHJcbiAgICAgICAgICAgICAgICAgICAgdm5vZGVQYXRjaEZsYWcgPSBwYXRjaEZsYWcgKyBgIC8qICR7UGF0Y2hGbGFnTmFtZXNbcGF0Y2hGbGFnXX0gKi9gO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYml0d2lzZSBmbGFnc1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZsYWdOYW1lcyA9IE9iamVjdC5rZXlzKFBhdGNoRmxhZ05hbWVzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKE51bWJlcilcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihuID0+IG4gPiAwICYmIHBhdGNoRmxhZyAmIG4pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAobiA9PiBQYXRjaEZsYWdOYW1lc1tuXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmpvaW4oYCwgYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdm5vZGVQYXRjaEZsYWcgPSBwYXRjaEZsYWcgKyBgIC8qICR7ZmxhZ05hbWVzfSAqL2A7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2bm9kZVBhdGNoRmxhZyA9IFN0cmluZyhwYXRjaEZsYWcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkeW5hbWljUHJvcE5hbWVzICYmIGR5bmFtaWNQcm9wTmFtZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB2bm9kZUR5bmFtaWNQcm9wcyA9IHN0cmluZ2lmeUR5bmFtaWNQcm9wTmFtZXMoZHluYW1pY1Byb3BOYW1lcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbm9kZS5jb2RlZ2VuTm9kZSA9IGNyZWF0ZVZOb2RlQ2FsbChjb250ZXh0LCB2bm9kZVRhZywgdm5vZGVQcm9wcywgdm5vZGVDaGlsZHJlbiwgdm5vZGVQYXRjaEZsYWcsIHZub2RlRHluYW1pY1Byb3BzLCB2bm9kZURpcmVjdGl2ZXMsICEhc2hvdWxkVXNlQmxvY2ssIGZhbHNlIC8qIGRpc2FibGVUcmFja2luZyAqLywgaXNDb21wb25lbnQsIG5vZGUubG9jKTtcclxuICAgIH07XHJcbn07XHJcbmZ1bmN0aW9uIHJlc29sdmVDb21wb25lbnRUeXBlKG5vZGUsIGNvbnRleHQsIHNzciA9IGZhbHNlKSB7XHJcbiAgICBsZXQgeyB0YWcgfSA9IG5vZGU7XHJcbiAgICAvLyAxLiBkeW5hbWljIGNvbXBvbmVudFxyXG4gICAgY29uc3QgaXNFeHBsaWNpdER5bmFtaWMgPSBpc0NvbXBvbmVudFRhZyh0YWcpO1xyXG4gICAgY29uc3QgaXNQcm9wID0gZmluZFByb3Aobm9kZSwgJ2lzJyk7XHJcbiAgICBpZiAoaXNQcm9wKSB7XHJcbiAgICAgICAgaWYgKGlzRXhwbGljaXREeW5hbWljIHx8XHJcbiAgICAgICAgICAgIChpc0NvbXBhdEVuYWJsZWQoXCJDT01QSUxFUl9JU19PTl9FTEVNRU5UXCIgLyogQ09NUElMRVJfSVNfT05fRUxFTUVOVCAqLywgY29udGV4dCkpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGV4cCA9IGlzUHJvcC50eXBlID09PSA2IC8qIEFUVFJJQlVURSAqL1xyXG4gICAgICAgICAgICAgICAgPyBpc1Byb3AudmFsdWUgJiYgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihpc1Byb3AudmFsdWUuY29udGVudCwgdHJ1ZSlcclxuICAgICAgICAgICAgICAgIDogaXNQcm9wLmV4cDtcclxuICAgICAgICAgICAgaWYgKGV4cCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKFJFU09MVkVfRFlOQU1JQ19DT01QT05FTlQpLCBbXHJcbiAgICAgICAgICAgICAgICAgICAgZXhwXHJcbiAgICAgICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc1Byb3AudHlwZSA9PT0gNiAvKiBBVFRSSUJVVEUgKi8gJiZcclxuICAgICAgICAgICAgaXNQcm9wLnZhbHVlLmNvbnRlbnQuc3RhcnRzV2l0aCgndnVlOicpKSB7XHJcbiAgICAgICAgICAgIC8vIDxidXR0b24gaXM9XCJ2dWU6eHh4XCI+XHJcbiAgICAgICAgICAgIC8vIGlmIG5vdCA8Y29tcG9uZW50Piwgb25seSBpcyB2YWx1ZSB0aGF0IHN0YXJ0cyB3aXRoIFwidnVlOlwiIHdpbGwgYmVcclxuICAgICAgICAgICAgLy8gdHJlYXRlZCBhcyBjb21wb25lbnQgYnkgdGhlIHBhcnNlIHBoYXNlIGFuZCByZWFjaCBoZXJlLCB1bmxlc3MgaXQnc1xyXG4gICAgICAgICAgICAvLyBjb21wYXQgbW9kZSB3aGVyZSBhbGwgaXMgdmFsdWVzIGFyZSBjb25zaWRlcmVkIGNvbXBvbmVudHNcclxuICAgICAgICAgICAgdGFnID0gaXNQcm9wLnZhbHVlLmNvbnRlbnQuc2xpY2UoNCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gMS41IHYtaXMgKFRPRE86IERlcHJlY2F0ZSlcclxuICAgIGNvbnN0IGlzRGlyID0gIWlzRXhwbGljaXREeW5hbWljICYmIGZpbmREaXIobm9kZSwgJ2lzJyk7XHJcbiAgICBpZiAoaXNEaXIgJiYgaXNEaXIuZXhwKSB7XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKFJFU09MVkVfRFlOQU1JQ19DT01QT05FTlQpLCBbXHJcbiAgICAgICAgICAgIGlzRGlyLmV4cFxyXG4gICAgICAgIF0pO1xyXG4gICAgfVxyXG4gICAgLy8gMi4gYnVpbHQtaW4gY29tcG9uZW50cyAoVGVsZXBvcnQsIFRyYW5zaXRpb24sIEtlZXBBbGl2ZSwgU3VzcGVuc2UuLi4pXHJcbiAgICBjb25zdCBidWlsdEluID0gaXNDb3JlQ29tcG9uZW50KHRhZykgfHwgY29udGV4dC5pc0J1aWx0SW5Db21wb25lbnQodGFnKTtcclxuICAgIGlmIChidWlsdEluKSB7XHJcbiAgICAgICAgLy8gYnVpbHQtaW5zIGFyZSBzaW1wbHkgZmFsbHRocm91Z2hzIC8gaGF2ZSBzcGVjaWFsIGhhbmRsaW5nIGR1cmluZyBzc3JcclxuICAgICAgICAvLyBzbyB3ZSBkb24ndCBuZWVkIHRvIGltcG9ydCB0aGVpciBydW50aW1lIGVxdWl2YWxlbnRzXHJcbiAgICAgICAgaWYgKCFzc3IpXHJcbiAgICAgICAgICAgIGNvbnRleHQuaGVscGVyKGJ1aWx0SW4pO1xyXG4gICAgICAgIHJldHVybiBidWlsdEluO1xyXG4gICAgfVxyXG4gICAgLy8gNS4gdXNlciBjb21wb25lbnQgKHJlc29sdmUpXHJcbiAgICBjb250ZXh0LmhlbHBlcihSRVNPTFZFX0NPTVBPTkVOVCk7XHJcbiAgICBjb250ZXh0LmNvbXBvbmVudHMuYWRkKHRhZyk7XHJcbiAgICByZXR1cm4gdG9WYWxpZEFzc2V0SWQodGFnLCBgY29tcG9uZW50YCk7XHJcbn1cclxuZnVuY3Rpb24gYnVpbGRQcm9wcyhub2RlLCBjb250ZXh0LCBwcm9wcyA9IG5vZGUucHJvcHMsIGlzQ29tcG9uZW50LCBpc0R5bmFtaWNDb21wb25lbnQsIHNzciA9IGZhbHNlKSB7XHJcbiAgICBjb25zdCB7IHRhZywgbG9jOiBlbGVtZW50TG9jLCBjaGlsZHJlbiB9ID0gbm9kZTtcclxuICAgIGxldCBwcm9wZXJ0aWVzID0gW107XHJcbiAgICBjb25zdCBtZXJnZUFyZ3MgPSBbXTtcclxuICAgIGNvbnN0IHJ1bnRpbWVEaXJlY3RpdmVzID0gW107XHJcbiAgICBjb25zdCBoYXNDaGlsZHJlbiA9IGNoaWxkcmVuLmxlbmd0aCA+IDA7XHJcbiAgICBsZXQgc2hvdWxkVXNlQmxvY2sgPSBmYWxzZTtcclxuICAgIC8vIHBhdGNoRmxhZyBhbmFseXNpc1xyXG4gICAgbGV0IHBhdGNoRmxhZyA9IDA7XHJcbiAgICBsZXQgaGFzUmVmID0gZmFsc2U7XHJcbiAgICBsZXQgaGFzQ2xhc3NCaW5kaW5nID0gZmFsc2U7XHJcbiAgICBsZXQgaGFzU3R5bGVCaW5kaW5nID0gZmFsc2U7XHJcbiAgICBsZXQgaGFzSHlkcmF0aW9uRXZlbnRCaW5kaW5nID0gZmFsc2U7XHJcbiAgICBsZXQgaGFzRHluYW1pY0tleXMgPSBmYWxzZTtcclxuICAgIGxldCBoYXNWbm9kZUhvb2sgPSBmYWxzZTtcclxuICAgIGNvbnN0IGR5bmFtaWNQcm9wTmFtZXMgPSBbXTtcclxuICAgIGNvbnN0IGFuYWx5emVQYXRjaEZsYWcgPSAoeyBrZXksIHZhbHVlIH0pID0+IHtcclxuICAgICAgICBpZiAoaXNTdGF0aWNFeHAoa2V5KSkge1xyXG4gICAgICAgICAgICBjb25zdCBuYW1lID0ga2V5LmNvbnRlbnQ7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzRXZlbnRIYW5kbGVyID0gaXNPbihuYW1lKTtcclxuICAgICAgICAgICAgaWYgKGlzRXZlbnRIYW5kbGVyICYmXHJcbiAgICAgICAgICAgICAgICAoIWlzQ29tcG9uZW50IHx8IGlzRHluYW1pY0NvbXBvbmVudCkgJiZcclxuICAgICAgICAgICAgICAgIC8vIG9taXQgdGhlIGZsYWcgZm9yIGNsaWNrIGhhbmRsZXJzIGJlY2F1c2UgaHlkcmF0aW9uIGdpdmVzIGNsaWNrXHJcbiAgICAgICAgICAgICAgICAvLyBkZWRpY2F0ZWQgZmFzdCBwYXRoLlxyXG4gICAgICAgICAgICAgICAgbmFtZS50b0xvd2VyQ2FzZSgpICE9PSAnb25jbGljaycgJiZcclxuICAgICAgICAgICAgICAgIC8vIG9taXQgdi1tb2RlbCBoYW5kbGVyc1xyXG4gICAgICAgICAgICAgICAgbmFtZSAhPT0gJ29uVXBkYXRlOm1vZGVsVmFsdWUnICYmXHJcbiAgICAgICAgICAgICAgICAvLyBvbWl0IG9uVm5vZGVYWFggaG9va3NcclxuICAgICAgICAgICAgICAgICFpc1Jlc2VydmVkUHJvcChuYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgaGFzSHlkcmF0aW9uRXZlbnRCaW5kaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaXNFdmVudEhhbmRsZXIgJiYgaXNSZXNlcnZlZFByb3AobmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIGhhc1Zub2RlSG9vayA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHZhbHVlLnR5cGUgPT09IDIwIC8qIEpTX0NBQ0hFX0VYUFJFU1NJT04gKi8gfHxcclxuICAgICAgICAgICAgICAgICgodmFsdWUudHlwZSA9PT0gNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLyB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLnR5cGUgPT09IDggLyogQ09NUE9VTkRfRVhQUkVTU0lPTiAqLykgJiZcclxuICAgICAgICAgICAgICAgICAgICBnZXRDb25zdGFudFR5cGUodmFsdWUsIGNvbnRleHQpID4gMCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIHNraXAgaWYgdGhlIHByb3AgaXMgYSBjYWNoZWQgaGFuZGxlciBvciBoYXMgY29uc3RhbnQgdmFsdWVcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ3JlZicpIHtcclxuICAgICAgICAgICAgICAgIGhhc1JlZiA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobmFtZSA9PT0gJ2NsYXNzJykge1xyXG4gICAgICAgICAgICAgICAgaGFzQ2xhc3NCaW5kaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChuYW1lID09PSAnc3R5bGUnKSB7XHJcbiAgICAgICAgICAgICAgICBoYXNTdHlsZUJpbmRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG5hbWUgIT09ICdrZXknICYmICFkeW5hbWljUHJvcE5hbWVzLmluY2x1ZGVzKG5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICBkeW5hbWljUHJvcE5hbWVzLnB1c2gobmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gdHJlYXQgdGhlIGR5bmFtaWMgY2xhc3MgYW5kIHN0eWxlIGJpbmRpbmcgb2YgdGhlIGNvbXBvbmVudCBhcyBkeW5hbWljIHByb3BzXHJcbiAgICAgICAgICAgIGlmIChpc0NvbXBvbmVudCAmJlxyXG4gICAgICAgICAgICAgICAgKG5hbWUgPT09ICdjbGFzcycgfHwgbmFtZSA9PT0gJ3N0eWxlJykgJiZcclxuICAgICAgICAgICAgICAgICFkeW5hbWljUHJvcE5hbWVzLmluY2x1ZGVzKG5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICBkeW5hbWljUHJvcE5hbWVzLnB1c2gobmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGhhc0R5bmFtaWNLZXlzID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIC8vIHN0YXRpYyBhdHRyaWJ1dGVcclxuICAgICAgICBjb25zdCBwcm9wID0gcHJvcHNbaV07XHJcbiAgICAgICAgaWYgKHByb3AudHlwZSA9PT0gNiAvKiBBVFRSSUJVVEUgKi8pIHtcclxuICAgICAgICAgICAgY29uc3QgeyBsb2MsIG5hbWUsIHZhbHVlIH0gPSBwcm9wO1xyXG4gICAgICAgICAgICBsZXQgaXNTdGF0aWMgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ3JlZicpIHtcclxuICAgICAgICAgICAgICAgIGhhc1JlZiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5zY29wZXMudkZvciA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLnB1c2goY3JlYXRlT2JqZWN0UHJvcGVydHkoY3JlYXRlU2ltcGxlRXhwcmVzc2lvbigncmVmX2ZvcicsIHRydWUpLCBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKCd0cnVlJykpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBza2lwIGlzIG9uIDxjb21wb25lbnQ+LCBvciBpcz1cInZ1ZTp4eHhcIlxyXG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2lzJyAmJlxyXG4gICAgICAgICAgICAgICAgKGlzQ29tcG9uZW50VGFnKHRhZykgfHxcclxuICAgICAgICAgICAgICAgICAgICAodmFsdWUgJiYgdmFsdWUuY29udGVudC5zdGFydHNXaXRoKCd2dWU6JykpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKGlzQ29tcGF0RW5hYmxlZChcIkNPTVBJTEVSX0lTX09OX0VMRU1FTlRcIiAvKiBDT01QSUxFUl9JU19PTl9FTEVNRU5UICovLCBjb250ZXh0KSkpKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwcm9wZXJ0aWVzLnB1c2goY3JlYXRlT2JqZWN0UHJvcGVydHkoY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihuYW1lLCB0cnVlLCBnZXRJbm5lclJhbmdlKGxvYywgMCwgbmFtZS5sZW5ndGgpKSwgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbih2YWx1ZSA/IHZhbHVlLmNvbnRlbnQgOiAnJywgaXNTdGF0aWMsIHZhbHVlID8gdmFsdWUubG9jIDogbG9jKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gZGlyZWN0aXZlc1xyXG4gICAgICAgICAgICBjb25zdCB7IG5hbWUsIGFyZywgZXhwLCBsb2MgfSA9IHByb3A7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzVkJpbmQgPSBuYW1lID09PSAnYmluZCc7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzVk9uID0gbmFtZSA9PT0gJ29uJztcclxuICAgICAgICAgICAgLy8gc2tpcCB2LXNsb3QgLSBpdCBpcyBoYW5kbGVkIGJ5IGl0cyBkZWRpY2F0ZWQgdHJhbnNmb3JtLlxyXG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ3Nsb3QnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzQ29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoNDAgLyogWF9WX1NMT1RfTUlTUExBQ0VEICovLCBsb2MpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHNraXAgdi1vbmNlL3YtbWVtbyAtIHRoZXkgYXJlIGhhbmRsZWQgYnkgZGVkaWNhdGVkIHRyYW5zZm9ybXMuXHJcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnb25jZScgfHwgbmFtZSA9PT0gJ21lbW8nKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBza2lwIHYtaXMgYW5kIDppcyBvbiA8Y29tcG9uZW50PlxyXG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2lzJyB8fFxyXG4gICAgICAgICAgICAgICAgKGlzVkJpbmQgJiZcclxuICAgICAgICAgICAgICAgICAgICBpc1N0YXRpY0FyZ09mKGFyZywgJ2lzJykgJiZcclxuICAgICAgICAgICAgICAgICAgICAoaXNDb21wb25lbnRUYWcodGFnKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoaXNDb21wYXRFbmFibGVkKFwiQ09NUElMRVJfSVNfT05fRUxFTUVOVFwiIC8qIENPTVBJTEVSX0lTX09OX0VMRU1FTlQgKi8sIGNvbnRleHQpKSkpKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBza2lwIHYtb24gaW4gU1NSIGNvbXBpbGF0aW9uXHJcbiAgICAgICAgICAgIGlmIChpc1ZPbiAmJiBzc3IpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgLy8gIzkzODogZWxlbWVudHMgd2l0aCBkeW5hbWljIGtleXMgc2hvdWxkIGJlIGZvcmNlZCBpbnRvIGJsb2Nrc1xyXG4gICAgICAgICAgICAoaXNWQmluZCAmJiBpc1N0YXRpY0FyZ09mKGFyZywgJ2tleScpKSB8fFxyXG4gICAgICAgICAgICAgICAgLy8gaW5saW5lIGJlZm9yZS11cGRhdGUgaG9va3MgbmVlZCB0byBmb3JjZSBibG9jayBzbyB0aGF0IGl0IGlzIGludm9rZWRcclxuICAgICAgICAgICAgICAgIC8vIGJlZm9yZSBjaGlsZHJlblxyXG4gICAgICAgICAgICAgICAgKGlzVk9uICYmIGhhc0NoaWxkcmVuICYmIGlzU3RhdGljQXJnT2YoYXJnLCAndnVlOmJlZm9yZS11cGRhdGUnKSkpIHtcclxuICAgICAgICAgICAgICAgIHNob3VsZFVzZUJsb2NrID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaXNWQmluZCAmJiBpc1N0YXRpY0FyZ09mKGFyZywgJ3JlZicpICYmIGNvbnRleHQuc2NvcGVzLnZGb3IgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLnB1c2goY3JlYXRlT2JqZWN0UHJvcGVydHkoY3JlYXRlU2ltcGxlRXhwcmVzc2lvbigncmVmX2ZvcicsIHRydWUpLCBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKCd0cnVlJykpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBzcGVjaWFsIGNhc2UgZm9yIHYtYmluZCBhbmQgdi1vbiB3aXRoIG5vIGFyZ3VtZW50XHJcbiAgICAgICAgICAgIGlmICghYXJnICYmIChpc1ZCaW5kIHx8IGlzVk9uKSkge1xyXG4gICAgICAgICAgICAgICAgaGFzRHluYW1pY0tleXMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGV4cCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXJnZUFyZ3MucHVzaChjcmVhdGVPYmplY3RFeHByZXNzaW9uKGRlZHVwZVByb3BlcnRpZXMocHJvcGVydGllcyksIGVsZW1lbnRMb2MpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNWQmluZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAyLnggdi1iaW5kIG9iamVjdCBvcmRlciBjb21wYXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBoYXNPdmVycmlkYWJsZUtleXMgPSBtZXJnZUFyZ3Muc29tZShhcmcgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJnLnR5cGUgPT09IDE1IC8qIEpTX09CSkVDVF9FWFBSRVNTSU9OICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnLnByb3BlcnRpZXMuc29tZSgoeyBrZXkgfSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkudHlwZSAhPT0gNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLyB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAha2V5LmlzU3RhdGljKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGtleS5jb250ZW50ICE9PSAnY2xhc3MnICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleS5jb250ZW50ICE9PSAnc3R5bGUnICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICFpc09uKGtleS5jb250ZW50KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGR5bmFtaWMgZXhwcmVzc2lvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzT3ZlcnJpZGFibGVLZXlzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrQ29tcGF0RW5hYmxlZChcIkNPTVBJTEVSX1ZfQklORF9PQkpFQ1RfT1JERVJcIiAvKiBDT01QSUxFUl9WX0JJTkRfT0JKRUNUX09SREVSICovLCBjb250ZXh0LCBsb2MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0NvbXBhdEVuYWJsZWQoXCJDT01QSUxFUl9WX0JJTkRfT0JKRUNUX09SREVSXCIgLyogQ09NUElMRVJfVl9CSU5EX09CSkVDVF9PUkRFUiAqLywgY29udGV4dCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXJnZUFyZ3MudW5zaGlmdChleHApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlQXJncy5wdXNoKGV4cCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB2LW9uPVwib2JqXCIgLT4gdG9IYW5kbGVycyhvYmopXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlQXJncy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IDE0IC8qIEpTX0NBTExfRVhQUkVTU0lPTiAqLyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvYyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxlZTogY29udGV4dC5oZWxwZXIoVE9fSEFORExFUlMpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBbZXhwXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcihpc1ZCaW5kXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gMzQgLyogWF9WX0JJTkRfTk9fRVhQUkVTU0lPTiAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IDM1IC8qIFhfVl9PTl9OT19FWFBSRVNTSU9OICovLCBsb2MpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGRpcmVjdGl2ZVRyYW5zZm9ybSA9IGNvbnRleHQuZGlyZWN0aXZlVHJhbnNmb3Jtc1tuYW1lXTtcclxuICAgICAgICAgICAgaWYgKGRpcmVjdGl2ZVRyYW5zZm9ybSkge1xyXG4gICAgICAgICAgICAgICAgLy8gaGFzIGJ1aWx0LWluIGRpcmVjdGl2ZSB0cmFuc2Zvcm0uXHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IHByb3BzLCBuZWVkUnVudGltZSB9ID0gZGlyZWN0aXZlVHJhbnNmb3JtKHByb3AsIG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgIXNzciAmJiBwcm9wcy5mb3JFYWNoKGFuYWx5emVQYXRjaEZsYWcpO1xyXG4gICAgICAgICAgICAgICAgcHJvcGVydGllcy5wdXNoKC4uLnByb3BzKTtcclxuICAgICAgICAgICAgICAgIGlmIChuZWVkUnVudGltZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJ1bnRpbWVEaXJlY3RpdmVzLnB1c2gocHJvcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3ltYm9sKG5lZWRSdW50aW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3RpdmVJbXBvcnRNYXAuc2V0KHByb3AsIG5lZWRSdW50aW1lKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzQnVpbHRJbkRpcmVjdGl2ZShuYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gbm8gYnVpbHQtaW4gdHJhbnNmb3JtLCB0aGlzIGlzIGEgdXNlciBjdXN0b20gZGlyZWN0aXZlLlxyXG4gICAgICAgICAgICAgICAgcnVudGltZURpcmVjdGl2ZXMucHVzaChwcm9wKTtcclxuICAgICAgICAgICAgICAgIC8vIGN1c3RvbSBkaXJzIG1heSB1c2UgYmVmb3JlVXBkYXRlIHNvIHRoZXkgbmVlZCB0byBmb3JjZSBibG9ja3NcclxuICAgICAgICAgICAgICAgIC8vIHRvIGVuc3VyZSBiZWZvcmUtdXBkYXRlIGdldHMgY2FsbGVkIGJlZm9yZSBjaGlsZHJlbiB1cGRhdGVcclxuICAgICAgICAgICAgICAgIGlmIChoYXNDaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHNob3VsZFVzZUJsb2NrID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGxldCBwcm9wc0V4cHJlc3Npb24gPSB1bmRlZmluZWQ7XHJcbiAgICAvLyBoYXMgdi1iaW5kPVwib2JqZWN0XCIgb3Igdi1vbj1cIm9iamVjdFwiLCB3cmFwIHdpdGggbWVyZ2VQcm9wc1xyXG4gICAgaWYgKG1lcmdlQXJncy5sZW5ndGgpIHtcclxuICAgICAgICBpZiAocHJvcGVydGllcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgbWVyZ2VBcmdzLnB1c2goY3JlYXRlT2JqZWN0RXhwcmVzc2lvbihkZWR1cGVQcm9wZXJ0aWVzKHByb3BlcnRpZXMpLCBlbGVtZW50TG9jKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtZXJnZUFyZ3MubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICBwcm9wc0V4cHJlc3Npb24gPSBjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlcihNRVJHRV9QUk9QUyksIG1lcmdlQXJncywgZWxlbWVudExvYyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBzaW5nbGUgdi1iaW5kIHdpdGggbm90aGluZyBlbHNlIC0gbm8gbmVlZCBmb3IgYSBtZXJnZVByb3BzIGNhbGxcclxuICAgICAgICAgICAgcHJvcHNFeHByZXNzaW9uID0gbWVyZ2VBcmdzWzBdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHByb3BlcnRpZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgcHJvcHNFeHByZXNzaW9uID0gY3JlYXRlT2JqZWN0RXhwcmVzc2lvbihkZWR1cGVQcm9wZXJ0aWVzKHByb3BlcnRpZXMpLCBlbGVtZW50TG9jKTtcclxuICAgIH1cclxuICAgIC8vIHBhdGNoRmxhZyBhbmFseXNpc1xyXG4gICAgaWYgKGhhc0R5bmFtaWNLZXlzKSB7XHJcbiAgICAgICAgcGF0Y2hGbGFnIHw9IDE2IC8qIEZVTExfUFJPUFMgKi87XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAoaGFzQ2xhc3NCaW5kaW5nICYmICFpc0NvbXBvbmVudCkge1xyXG4gICAgICAgICAgICBwYXRjaEZsYWcgfD0gMiAvKiBDTEFTUyAqLztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGhhc1N0eWxlQmluZGluZyAmJiAhaXNDb21wb25lbnQpIHtcclxuICAgICAgICAgICAgcGF0Y2hGbGFnIHw9IDQgLyogU1RZTEUgKi87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkeW5hbWljUHJvcE5hbWVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBwYXRjaEZsYWcgfD0gOCAvKiBQUk9QUyAqLztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGhhc0h5ZHJhdGlvbkV2ZW50QmluZGluZykge1xyXG4gICAgICAgICAgICBwYXRjaEZsYWcgfD0gMzIgLyogSFlEUkFURV9FVkVOVFMgKi87XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCFzaG91bGRVc2VCbG9jayAmJlxyXG4gICAgICAgIChwYXRjaEZsYWcgPT09IDAgfHwgcGF0Y2hGbGFnID09PSAzMiAvKiBIWURSQVRFX0VWRU5UUyAqLykgJiZcclxuICAgICAgICAoaGFzUmVmIHx8IGhhc1Zub2RlSG9vayB8fCBydW50aW1lRGlyZWN0aXZlcy5sZW5ndGggPiAwKSkge1xyXG4gICAgICAgIHBhdGNoRmxhZyB8PSA1MTIgLyogTkVFRF9QQVRDSCAqLztcclxuICAgIH1cclxuICAgIC8vIHByZS1ub3JtYWxpemUgcHJvcHMsIFNTUiBpcyBza2lwcGVkIGZvciBub3dcclxuICAgIGlmICghY29udGV4dC5pblNTUiAmJiBwcm9wc0V4cHJlc3Npb24pIHtcclxuICAgICAgICBzd2l0Y2ggKHByb3BzRXhwcmVzc2lvbi50eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMTUgLyogSlNfT0JKRUNUX0VYUFJFU1NJT04gKi86XHJcbiAgICAgICAgICAgICAgICAvLyBtZWFucyB0aGF0IHRoZXJlIGlzIG5vIHYtYmluZCxcclxuICAgICAgICAgICAgICAgIC8vIGJ1dCBzdGlsbCBuZWVkIHRvIGRlYWwgd2l0aCBkeW5hbWljIGtleSBiaW5kaW5nXHJcbiAgICAgICAgICAgICAgICBsZXQgY2xhc3NLZXlJbmRleCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgbGV0IHN0eWxlS2V5SW5kZXggPSAtMTtcclxuICAgICAgICAgICAgICAgIGxldCBoYXNEeW5hbWljS2V5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BzRXhwcmVzc2lvbi5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gcHJvcHNFeHByZXNzaW9uLnByb3BlcnRpZXNbaV0ua2V5O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1N0YXRpY0V4cChrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkuY29udGVudCA9PT0gJ2NsYXNzJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NLZXlJbmRleCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoa2V5LmNvbnRlbnQgPT09ICdzdHlsZScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlS2V5SW5kZXggPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFrZXkuaXNIYW5kbGVyS2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0R5bmFtaWNLZXkgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IGNsYXNzUHJvcCA9IHByb3BzRXhwcmVzc2lvbi5wcm9wZXJ0aWVzW2NsYXNzS2V5SW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3R5bGVQcm9wID0gcHJvcHNFeHByZXNzaW9uLnByb3BlcnRpZXNbc3R5bGVLZXlJbmRleF07XHJcbiAgICAgICAgICAgICAgICAvLyBubyBkeW5hbWljIGtleVxyXG4gICAgICAgICAgICAgICAgaWYgKCFoYXNEeW5hbWljS2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNsYXNzUHJvcCAmJiAhaXNTdGF0aWNFeHAoY2xhc3NQcm9wLnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc1Byb3AudmFsdWUgPSBjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlcihOT1JNQUxJWkVfQ0xBU1MpLCBbY2xhc3NQcm9wLnZhbHVlXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHlsZVByb3AgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHN0YXRpYyBzdHlsZSBpcyBjb21waWxlZCBpbnRvIGFuIG9iamVjdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc28gdXNlIGBoYXNTdHlsZUJpbmRpbmdgIHRvIGVuc3VyZSB0aGF0IGl0IGlzIGEgZHluYW1pYyBzdHlsZSBiaW5kaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChoYXNTdHlsZUJpbmRpbmcgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzdHlsZVByb3AudmFsdWUudHlwZSA9PT0gNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlUHJvcC52YWx1ZS5jb250ZW50LnRyaW0oKVswXSA9PT0gYFtgKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdi1iaW5kOnN0eWxlIGFuZCBzdHlsZSBib3RoIGV4aXN0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdi1iaW5kOnN0eWxlIHdpdGggc3RhdGljIGxpdGVyYWwgb2JqZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZVByb3AudmFsdWUudHlwZSA9PT0gMTcgLyogSlNfQVJSQVlfRVhQUkVTU0lPTiAqLykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVQcm9wLnZhbHVlID0gY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXIoTk9STUFMSVpFX1NUWUxFKSwgW3N0eWxlUHJvcC52YWx1ZV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGR5bmFtaWMga2V5IGJpbmRpbmcsIHdyYXAgd2l0aCBgbm9ybWFsaXplUHJvcHNgXHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcHNFeHByZXNzaW9uID0gY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXIoTk9STUFMSVpFX1BST1BTKSwgW3Byb3BzRXhwcmVzc2lvbl0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMTQgLyogSlNfQ0FMTF9FWFBSRVNTSU9OICovOlxyXG4gICAgICAgICAgICAgICAgLy8gbWVyZ2VQcm9wcyBjYWxsLCBkbyBub3RoaW5nXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIC8vIHNpbmdsZSB2LWJpbmRcclxuICAgICAgICAgICAgICAgIHByb3BzRXhwcmVzc2lvbiA9IGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKE5PUk1BTElaRV9QUk9QUyksIFtcclxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlcihHVUFSRF9SRUFDVElWRV9QUk9QUyksIFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHNFeHByZXNzaW9uXHJcbiAgICAgICAgICAgICAgICAgICAgXSlcclxuICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBwcm9wczogcHJvcHNFeHByZXNzaW9uLFxyXG4gICAgICAgIGRpcmVjdGl2ZXM6IHJ1bnRpbWVEaXJlY3RpdmVzLFxyXG4gICAgICAgIHBhdGNoRmxhZyxcclxuICAgICAgICBkeW5hbWljUHJvcE5hbWVzLFxyXG4gICAgICAgIHNob3VsZFVzZUJsb2NrXHJcbiAgICB9O1xyXG59XHJcbi8vIERlZHVwZSBwcm9wcyBpbiBhbiBvYmplY3QgbGl0ZXJhbC5cclxuLy8gTGl0ZXJhbCBkdXBsaWNhdGVkIGF0dHJpYnV0ZXMgd291bGQgaGF2ZSBiZWVuIHdhcm5lZCBkdXJpbmcgdGhlIHBhcnNlIHBoYXNlLFxyXG4vLyBob3dldmVyLCBpdCdzIHBvc3NpYmxlIHRvIGVuY291bnRlciBkdXBsaWNhdGVkIGBvblhYWGAgaGFuZGxlcnMgd2l0aCBkaWZmZXJlbnRcclxuLy8gbW9kaWZpZXJzLiBXZSBhbHNvIG5lZWQgdG8gbWVyZ2Ugc3RhdGljIGFuZCBkeW5hbWljIGNsYXNzIC8gc3R5bGUgYXR0cmlidXRlcy5cclxuLy8gLSBvblhYWCBoYW5kbGVycyAvIHN0eWxlOiBtZXJnZSBpbnRvIGFycmF5XHJcbi8vIC0gY2xhc3M6IG1lcmdlIGludG8gc2luZ2xlIGV4cHJlc3Npb24gd2l0aCBjb25jYXRlbmF0aW9uXHJcbmZ1bmN0aW9uIGRlZHVwZVByb3BlcnRpZXMocHJvcGVydGllcykge1xyXG4gICAgY29uc3Qga25vd25Qcm9wcyA9IG5ldyBNYXAoKTtcclxuICAgIGNvbnN0IGRlZHVwZWQgPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHByb3AgPSBwcm9wZXJ0aWVzW2ldO1xyXG4gICAgICAgIC8vIGR5bmFtaWMga2V5cyBhcmUgYWx3YXlzIGFsbG93ZWRcclxuICAgICAgICBpZiAocHJvcC5rZXkudHlwZSA9PT0gOCAvKiBDT01QT1VORF9FWFBSRVNTSU9OICovIHx8ICFwcm9wLmtleS5pc1N0YXRpYykge1xyXG4gICAgICAgICAgICBkZWR1cGVkLnB1c2gocHJvcCk7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBuYW1lID0gcHJvcC5rZXkuY29udGVudDtcclxuICAgICAgICBjb25zdCBleGlzdGluZyA9IGtub3duUHJvcHMuZ2V0KG5hbWUpO1xyXG4gICAgICAgIGlmIChleGlzdGluZykge1xyXG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ3N0eWxlJyB8fCBuYW1lID09PSAnY2xhc3MnIHx8IGlzT24obmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIG1lcmdlQXNBcnJheShleGlzdGluZywgcHJvcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gdW5leHBlY3RlZCBkdXBsaWNhdGUsIHNob3VsZCBoYXZlIGVtaXR0ZWQgZXJyb3IgZHVyaW5nIHBhcnNlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBrbm93blByb3BzLnNldChuYW1lLCBwcm9wKTtcclxuICAgICAgICAgICAgZGVkdXBlZC5wdXNoKHByb3ApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBkZWR1cGVkO1xyXG59XHJcbmZ1bmN0aW9uIG1lcmdlQXNBcnJheShleGlzdGluZywgaW5jb21pbmcpIHtcclxuICAgIGlmIChleGlzdGluZy52YWx1ZS50eXBlID09PSAxNyAvKiBKU19BUlJBWV9FWFBSRVNTSU9OICovKSB7XHJcbiAgICAgICAgZXhpc3RpbmcudmFsdWUuZWxlbWVudHMucHVzaChpbmNvbWluZy52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBleGlzdGluZy52YWx1ZSA9IGNyZWF0ZUFycmF5RXhwcmVzc2lvbihbZXhpc3RpbmcudmFsdWUsIGluY29taW5nLnZhbHVlXSwgZXhpc3RpbmcubG9jKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBidWlsZERpcmVjdGl2ZUFyZ3MoZGlyLCBjb250ZXh0KSB7XHJcbiAgICBjb25zdCBkaXJBcmdzID0gW107XHJcbiAgICBjb25zdCBydW50aW1lID0gZGlyZWN0aXZlSW1wb3J0TWFwLmdldChkaXIpO1xyXG4gICAgaWYgKHJ1bnRpbWUpIHtcclxuICAgICAgICAvLyBidWlsdC1pbiBkaXJlY3RpdmUgd2l0aCBydW50aW1lXHJcbiAgICAgICAgZGlyQXJncy5wdXNoKGNvbnRleHQuaGVscGVyU3RyaW5nKHJ1bnRpbWUpKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gaW5qZWN0IHN0YXRlbWVudCBmb3IgcmVzb2x2aW5nIGRpcmVjdGl2ZVxyXG4gICAgICAgICAgICBjb250ZXh0LmhlbHBlcihSRVNPTFZFX0RJUkVDVElWRSk7XHJcbiAgICAgICAgICAgIGNvbnRleHQuZGlyZWN0aXZlcy5hZGQoZGlyLm5hbWUpO1xyXG4gICAgICAgICAgICBkaXJBcmdzLnB1c2godG9WYWxpZEFzc2V0SWQoZGlyLm5hbWUsIGBkaXJlY3RpdmVgKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgeyBsb2MgfSA9IGRpcjtcclxuICAgIGlmIChkaXIuZXhwKVxyXG4gICAgICAgIGRpckFyZ3MucHVzaChkaXIuZXhwKTtcclxuICAgIGlmIChkaXIuYXJnKSB7XHJcbiAgICAgICAgaWYgKCFkaXIuZXhwKSB7XHJcbiAgICAgICAgICAgIGRpckFyZ3MucHVzaChgdm9pZCAwYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRpckFyZ3MucHVzaChkaXIuYXJnKTtcclxuICAgIH1cclxuICAgIGlmIChPYmplY3Qua2V5cyhkaXIubW9kaWZpZXJzKS5sZW5ndGgpIHtcclxuICAgICAgICBpZiAoIWRpci5hcmcpIHtcclxuICAgICAgICAgICAgaWYgKCFkaXIuZXhwKSB7XHJcbiAgICAgICAgICAgICAgICBkaXJBcmdzLnB1c2goYHZvaWQgMGApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRpckFyZ3MucHVzaChgdm9pZCAwYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHRydWVFeHByZXNzaW9uID0gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgdHJ1ZWAsIGZhbHNlLCBsb2MpO1xyXG4gICAgICAgIGRpckFyZ3MucHVzaChjcmVhdGVPYmplY3RFeHByZXNzaW9uKGRpci5tb2RpZmllcnMubWFwKG1vZGlmaWVyID0+IGNyZWF0ZU9iamVjdFByb3BlcnR5KG1vZGlmaWVyLCB0cnVlRXhwcmVzc2lvbikpLCBsb2MpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjcmVhdGVBcnJheUV4cHJlc3Npb24oZGlyQXJncywgZGlyLmxvYyk7XHJcbn1cclxuZnVuY3Rpb24gc3RyaW5naWZ5RHluYW1pY1Byb3BOYW1lcyhwcm9wcykge1xyXG4gICAgbGV0IHByb3BzTmFtZXNTdHJpbmcgPSBgW2A7XHJcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IHByb3BzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIHByb3BzTmFtZXNTdHJpbmcgKz0gSlNPTi5zdHJpbmdpZnkocHJvcHNbaV0pO1xyXG4gICAgICAgIGlmIChpIDwgbCAtIDEpXHJcbiAgICAgICAgICAgIHByb3BzTmFtZXNTdHJpbmcgKz0gJywgJztcclxuICAgIH1cclxuICAgIHJldHVybiBwcm9wc05hbWVzU3RyaW5nICsgYF1gO1xyXG59XHJcbmZ1bmN0aW9uIGlzQ29tcG9uZW50VGFnKHRhZykge1xyXG4gICAgcmV0dXJuIHRhZyA9PT0gJ2NvbXBvbmVudCcgfHwgdGFnID09PSAnQ29tcG9uZW50JztcclxufVxuXG4ocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcclxuICAgID8gT2JqZWN0LmZyZWV6ZSh7fSlcclxuICAgIDoge307XHJcbihwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IE9iamVjdC5mcmVlemUoW10pIDogW107XHJcbmNvbnN0IGNhY2hlU3RyaW5nRnVuY3Rpb24gPSAoZm4pID0+IHtcclxuICAgIGNvbnN0IGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIHJldHVybiAoKHN0cikgPT4ge1xyXG4gICAgICAgIGNvbnN0IGhpdCA9IGNhY2hlW3N0cl07XHJcbiAgICAgICAgcmV0dXJuIGhpdCB8fCAoY2FjaGVbc3RyXSA9IGZuKHN0cikpO1xyXG4gICAgfSk7XHJcbn07XHJcbmNvbnN0IGNhbWVsaXplUkUgPSAvLShcXHcpL2c7XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29uc3QgY2FtZWxpemUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKChzdHIpID0+IHtcclxuICAgIHJldHVybiBzdHIucmVwbGFjZShjYW1lbGl6ZVJFLCAoXywgYykgPT4gKGMgPyBjLnRvVXBwZXJDYXNlKCkgOiAnJykpO1xyXG59KTtcblxuY29uc3QgdHJhbnNmb3JtU2xvdE91dGxldCA9IChub2RlLCBjb250ZXh0KSA9PiB7XHJcbiAgICBpZiAoaXNTbG90T3V0bGV0KG5vZGUpKSB7XHJcbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbiwgbG9jIH0gPSBub2RlO1xyXG4gICAgICAgIGNvbnN0IHsgc2xvdE5hbWUsIHNsb3RQcm9wcyB9ID0gcHJvY2Vzc1Nsb3RPdXRsZXQobm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgY29uc3Qgc2xvdEFyZ3MgPSBbXHJcbiAgICAgICAgICAgIGNvbnRleHQucHJlZml4SWRlbnRpZmllcnMgPyBgX2N0eC4kc2xvdHNgIDogYCRzbG90c2AsXHJcbiAgICAgICAgICAgIHNsb3ROYW1lLFxyXG4gICAgICAgICAgICAne30nLFxyXG4gICAgICAgICAgICAndW5kZWZpbmVkJyxcclxuICAgICAgICAgICAgJ3RydWUnXHJcbiAgICAgICAgXTtcclxuICAgICAgICBsZXQgZXhwZWN0ZWRMZW4gPSAyO1xyXG4gICAgICAgIGlmIChzbG90UHJvcHMpIHtcclxuICAgICAgICAgICAgc2xvdEFyZ3NbMl0gPSBzbG90UHJvcHM7XHJcbiAgICAgICAgICAgIGV4cGVjdGVkTGVuID0gMztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBzbG90QXJnc1szXSA9IGNyZWF0ZUZ1bmN0aW9uRXhwcmVzc2lvbihbXSwgY2hpbGRyZW4sIGZhbHNlLCBmYWxzZSwgbG9jKTtcclxuICAgICAgICAgICAgZXhwZWN0ZWRMZW4gPSA0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29udGV4dC5zY29wZUlkICYmICFjb250ZXh0LnNsb3R0ZWQpIHtcclxuICAgICAgICAgICAgZXhwZWN0ZWRMZW4gPSA1O1xyXG4gICAgICAgIH1cclxuICAgICAgICBzbG90QXJncy5zcGxpY2UoZXhwZWN0ZWRMZW4pOyAvLyByZW1vdmUgdW51c2VkIGFyZ3VtZW50c1xyXG4gICAgICAgIG5vZGUuY29kZWdlbk5vZGUgPSBjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlcihSRU5ERVJfU0xPVCksIHNsb3RBcmdzLCBsb2MpO1xyXG4gICAgfVxyXG59O1xyXG5mdW5jdGlvbiBwcm9jZXNzU2xvdE91dGxldChub2RlLCBjb250ZXh0KSB7XHJcbiAgICBsZXQgc2xvdE5hbWUgPSBgXCJkZWZhdWx0XCJgO1xyXG4gICAgbGV0IHNsb3RQcm9wcyA9IHVuZGVmaW5lZDtcclxuICAgIGNvbnN0IG5vbk5hbWVQcm9wcyA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLnByb3BzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgcCA9IG5vZGUucHJvcHNbaV07XHJcbiAgICAgICAgaWYgKHAudHlwZSA9PT0gNiAvKiBBVFRSSUJVVEUgKi8pIHtcclxuICAgICAgICAgICAgaWYgKHAudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwLm5hbWUgPT09ICduYW1lJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNsb3ROYW1lID0gSlNPTi5zdHJpbmdpZnkocC52YWx1ZS5jb250ZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHAubmFtZSA9IGNhbWVsaXplKHAubmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9uTmFtZVByb3BzLnB1c2gocCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChwLm5hbWUgPT09ICdiaW5kJyAmJiBpc1N0YXRpY0FyZ09mKHAuYXJnLCAnbmFtZScpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocC5leHApXHJcbiAgICAgICAgICAgICAgICAgICAgc2xvdE5hbWUgPSBwLmV4cDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChwLm5hbWUgPT09ICdiaW5kJyAmJiBwLmFyZyAmJiBpc1N0YXRpY0V4cChwLmFyZykpIHtcclxuICAgICAgICAgICAgICAgICAgICBwLmFyZy5jb250ZW50ID0gY2FtZWxpemUocC5hcmcuY29udGVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBub25OYW1lUHJvcHMucHVzaChwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChub25OYW1lUHJvcHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGNvbnN0IHsgcHJvcHMsIGRpcmVjdGl2ZXMgfSA9IGJ1aWxkUHJvcHMobm9kZSwgY29udGV4dCwgbm9uTmFtZVByb3BzLCBmYWxzZSwgZmFsc2UpO1xyXG4gICAgICAgIHNsb3RQcm9wcyA9IHByb3BzO1xyXG4gICAgICAgIGlmIChkaXJlY3RpdmVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcigzNiAvKiBYX1ZfU0xPVF9VTkVYUEVDVEVEX0RJUkVDVElWRV9PTl9TTE9UX09VVExFVCAqLywgZGlyZWN0aXZlc1swXS5sb2MpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHNsb3ROYW1lLFxyXG4gICAgICAgIHNsb3RQcm9wc1xyXG4gICAgfTtcclxufVxuXG5jb25zdCBmbkV4cFJFID0gL15cXHMqKFtcXHckX10rfChhc3luY1xccyopP1xcKFteKV0qP1xcKSlcXHMqPT58XlxccyooYXN5bmNcXHMrKT9mdW5jdGlvbig/OlxccytbXFx3JF0rKT9cXHMqXFwoLztcclxuY29uc3QgdHJhbnNmb3JtT24gPSAoZGlyLCBub2RlLCBjb250ZXh0LCBhdWdtZW50b3IpID0+IHtcclxuICAgIGNvbnN0IHsgbG9jLCBtb2RpZmllcnMsIGFyZyB9ID0gZGlyO1xyXG4gICAgaWYgKCFkaXIuZXhwICYmICFtb2RpZmllcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoMzUgLyogWF9WX09OX05PX0VYUFJFU1NJT04gKi8sIGxvYykpO1xyXG4gICAgfVxyXG4gICAgbGV0IGV2ZW50TmFtZTtcclxuICAgIGlmIChhcmcudHlwZSA9PT0gNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLykge1xyXG4gICAgICAgIGlmIChhcmcuaXNTdGF0aWMpIHtcclxuICAgICAgICAgICAgbGV0IHJhd05hbWUgPSBhcmcuY29udGVudDtcclxuICAgICAgICAgICAgLy8gVE9ETyBkZXByZWNhdGUgQHZub2RlWFhYIHVzYWdlXHJcbiAgICAgICAgICAgIGlmIChyYXdOYW1lLnN0YXJ0c1dpdGgoJ3Z1ZTonKSkge1xyXG4gICAgICAgICAgICAgICAgcmF3TmFtZSA9IGB2bm9kZS0ke3Jhd05hbWUuc2xpY2UoNCl9YDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBmb3IgYWxsIGV2ZW50IGxpc3RlbmVycywgYXV0byBjb252ZXJ0IGl0IHRvIGNhbWVsQ2FzZS4gU2VlIGlzc3VlICMyMjQ5XHJcbiAgICAgICAgICAgIGV2ZW50TmFtZSA9IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24odG9IYW5kbGVyS2V5KGNhbWVsaXplJDEocmF3TmFtZSkpLCB0cnVlLCBhcmcubG9jKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vICMyMzg4XHJcbiAgICAgICAgICAgIGV2ZW50TmFtZSA9IGNyZWF0ZUNvbXBvdW5kRXhwcmVzc2lvbihbXHJcbiAgICAgICAgICAgICAgICBgJHtjb250ZXh0LmhlbHBlclN0cmluZyhUT19IQU5ETEVSX0tFWSl9KGAsXHJcbiAgICAgICAgICAgICAgICBhcmcsXHJcbiAgICAgICAgICAgICAgICBgKWBcclxuICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gYWxyZWFkeSBhIGNvbXBvdW5kIGV4cHJlc3Npb24uXHJcbiAgICAgICAgZXZlbnROYW1lID0gYXJnO1xyXG4gICAgICAgIGV2ZW50TmFtZS5jaGlsZHJlbi51bnNoaWZ0KGAke2NvbnRleHQuaGVscGVyU3RyaW5nKFRPX0hBTkRMRVJfS0VZKX0oYCk7XHJcbiAgICAgICAgZXZlbnROYW1lLmNoaWxkcmVuLnB1c2goYClgKTtcclxuICAgIH1cclxuICAgIC8vIGhhbmRsZXIgcHJvY2Vzc2luZ1xyXG4gICAgbGV0IGV4cCA9IGRpci5leHA7XHJcbiAgICBpZiAoZXhwICYmICFleHAuY29udGVudC50cmltKCkpIHtcclxuICAgICAgICBleHAgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICBsZXQgc2hvdWxkQ2FjaGUgPSBjb250ZXh0LmNhY2hlSGFuZGxlcnMgJiYgIWV4cCAmJiAhY29udGV4dC5pblZPbmNlO1xyXG4gICAgaWYgKGV4cCkge1xyXG4gICAgICAgIGNvbnN0IGlzTWVtYmVyRXhwID0gaXNNZW1iZXJFeHByZXNzaW9uKGV4cC5jb250ZW50KTtcclxuICAgICAgICBjb25zdCBpc0lubGluZVN0YXRlbWVudCA9ICEoaXNNZW1iZXJFeHAgfHwgZm5FeHBSRS50ZXN0KGV4cC5jb250ZW50KSk7XHJcbiAgICAgICAgY29uc3QgaGFzTXVsdGlwbGVTdGF0ZW1lbnRzID0gZXhwLmNvbnRlbnQuaW5jbHVkZXMoYDtgKTtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHRydWUpIHtcclxuICAgICAgICAgICAgdmFsaWRhdGVCcm93c2VyRXhwcmVzc2lvbihleHAsIGNvbnRleHQsIGZhbHNlLCBoYXNNdWx0aXBsZVN0YXRlbWVudHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNJbmxpbmVTdGF0ZW1lbnQgfHwgKHNob3VsZENhY2hlICYmIGlzTWVtYmVyRXhwKSkge1xyXG4gICAgICAgICAgICAvLyB3cmFwIGlubGluZSBzdGF0ZW1lbnQgaW4gYSBmdW5jdGlvbiBleHByZXNzaW9uXHJcbiAgICAgICAgICAgIGV4cCA9IGNyZWF0ZUNvbXBvdW5kRXhwcmVzc2lvbihbXHJcbiAgICAgICAgICAgICAgICBgJHtpc0lubGluZVN0YXRlbWVudFxyXG4gICAgICAgICAgICAgICAgICAgID8gYCRldmVudGBcclxuICAgICAgICAgICAgICAgICAgICA6IGAke2BgfSguLi5hcmdzKWB9ID0+ICR7aGFzTXVsdGlwbGVTdGF0ZW1lbnRzID8gYHtgIDogYChgfWAsXHJcbiAgICAgICAgICAgICAgICBleHAsXHJcbiAgICAgICAgICAgICAgICBoYXNNdWx0aXBsZVN0YXRlbWVudHMgPyBgfWAgOiBgKWBcclxuICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbGV0IHJldCA9IHtcclxuICAgICAgICBwcm9wczogW1xyXG4gICAgICAgICAgICBjcmVhdGVPYmplY3RQcm9wZXJ0eShldmVudE5hbWUsIGV4cCB8fCBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGAoKSA9PiB7fWAsIGZhbHNlLCBsb2MpKVxyXG4gICAgICAgIF1cclxuICAgIH07XHJcbiAgICAvLyBhcHBseSBleHRlbmRlZCBjb21waWxlciBhdWdtZW50b3JcclxuICAgIGlmIChhdWdtZW50b3IpIHtcclxuICAgICAgICByZXQgPSBhdWdtZW50b3IocmV0KTtcclxuICAgIH1cclxuICAgIGlmIChzaG91bGRDYWNoZSkge1xyXG4gICAgICAgIC8vIGNhY2hlIGhhbmRsZXJzIHNvIHRoYXQgaXQncyBhbHdheXMgdGhlIHNhbWUgaGFuZGxlciBiZWluZyBwYXNzZWQgZG93bi5cclxuICAgICAgICAvLyB0aGlzIGF2b2lkcyB1bm5lY2Vzc2FyeSByZS1yZW5kZXJzIHdoZW4gdXNlcnMgdXNlIGlubGluZSBoYW5kbGVycyBvblxyXG4gICAgICAgIC8vIGNvbXBvbmVudHMuXHJcbiAgICAgICAgcmV0LnByb3BzWzBdLnZhbHVlID0gY29udGV4dC5jYWNoZShyZXQucHJvcHNbMF0udmFsdWUpO1xyXG4gICAgfVxyXG4gICAgLy8gbWFyayB0aGUga2V5IGFzIGhhbmRsZXIgZm9yIHByb3BzIG5vcm1hbGl6YXRpb24gY2hlY2tcclxuICAgIHJldC5wcm9wcy5mb3JFYWNoKHAgPT4gKHAua2V5LmlzSGFuZGxlcktleSA9IHRydWUpKTtcclxuICAgIHJldHVybiByZXQ7XHJcbn07XG5cbi8vIHYtYmluZCB3aXRob3V0IGFyZyBpcyBoYW5kbGVkIGRpcmVjdGx5IGluIC4vdHJhbnNmb3JtRWxlbWVudHMudHMgZHVlIHRvIGl0IGFmZmVjdGluZ1xyXG4vLyBjb2RlZ2VuIGZvciB0aGUgZW50aXJlIHByb3BzIG9iamVjdC4gVGhpcyB0cmFuc2Zvcm0gaGVyZSBpcyBvbmx5IGZvciB2LWJpbmRcclxuLy8gKndpdGgqIGFyZ3MuXHJcbmNvbnN0IHRyYW5zZm9ybUJpbmQgPSAoZGlyLCBfbm9kZSwgY29udGV4dCkgPT4ge1xyXG4gICAgY29uc3QgeyBleHAsIG1vZGlmaWVycywgbG9jIH0gPSBkaXI7XHJcbiAgICBjb25zdCBhcmcgPSBkaXIuYXJnO1xyXG4gICAgaWYgKGFyZy50eXBlICE9PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovKSB7XHJcbiAgICAgICAgYXJnLmNoaWxkcmVuLnVuc2hpZnQoYChgKTtcclxuICAgICAgICBhcmcuY2hpbGRyZW4ucHVzaChgKSB8fCBcIlwiYCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICghYXJnLmlzU3RhdGljKSB7XHJcbiAgICAgICAgYXJnLmNvbnRlbnQgPSBgJHthcmcuY29udGVudH0gfHwgXCJcImA7XHJcbiAgICB9XHJcbiAgICAvLyAuc3luYyBpcyByZXBsYWNlZCBieSB2LW1vZGVsOmFyZ1xyXG4gICAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcygnY2FtZWwnKSkge1xyXG4gICAgICAgIGlmIChhcmcudHlwZSA9PT0gNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLykge1xyXG4gICAgICAgICAgICBpZiAoYXJnLmlzU3RhdGljKSB7XHJcbiAgICAgICAgICAgICAgICBhcmcuY29udGVudCA9IGNhbWVsaXplJDEoYXJnLmNvbnRlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYXJnLmNvbnRlbnQgPSBgJHtjb250ZXh0LmhlbHBlclN0cmluZyhDQU1FTElaRSl9KCR7YXJnLmNvbnRlbnR9KWA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGFyZy5jaGlsZHJlbi51bnNoaWZ0KGAke2NvbnRleHQuaGVscGVyU3RyaW5nKENBTUVMSVpFKX0oYCk7XHJcbiAgICAgICAgICAgIGFyZy5jaGlsZHJlbi5wdXNoKGApYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCFjb250ZXh0LmluU1NSKSB7XHJcbiAgICAgICAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcygncHJvcCcpKSB7XHJcbiAgICAgICAgICAgIGluamVjdFByZWZpeChhcmcsICcuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoJ2F0dHInKSkge1xyXG4gICAgICAgICAgICBpbmplY3RQcmVmaXgoYXJnLCAnXicpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghZXhwIHx8XHJcbiAgICAgICAgKGV4cC50eXBlID09PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovICYmICFleHAuY29udGVudC50cmltKCkpKSB7XHJcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoMzQgLyogWF9WX0JJTkRfTk9fRVhQUkVTU0lPTiAqLywgbG9jKSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcHJvcHM6IFtjcmVhdGVPYmplY3RQcm9wZXJ0eShhcmcsIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oJycsIHRydWUsIGxvYykpXVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHByb3BzOiBbY3JlYXRlT2JqZWN0UHJvcGVydHkoYXJnLCBleHApXVxyXG4gICAgfTtcclxufTtcclxuY29uc3QgaW5qZWN0UHJlZml4ID0gKGFyZywgcHJlZml4KSA9PiB7XHJcbiAgICBpZiAoYXJnLnR5cGUgPT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8pIHtcclxuICAgICAgICBpZiAoYXJnLmlzU3RhdGljKSB7XHJcbiAgICAgICAgICAgIGFyZy5jb250ZW50ID0gcHJlZml4ICsgYXJnLmNvbnRlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhcmcuY29udGVudCA9IGBcXGAke3ByZWZpeH1cXCR7JHthcmcuY29udGVudH19XFxgYDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhcmcuY2hpbGRyZW4udW5zaGlmdChgJyR7cHJlZml4fScgKyAoYCk7XHJcbiAgICAgICAgYXJnLmNoaWxkcmVuLnB1c2goYClgKTtcclxuICAgIH1cclxufTtcblxuLy8gTWVyZ2UgYWRqYWNlbnQgdGV4dCBub2RlcyBhbmQgZXhwcmVzc2lvbnMgaW50byBhIHNpbmdsZSBleHByZXNzaW9uXHJcbi8vIGUuZy4gPGRpdj5hYmMge3sgZCB9fSB7eyBlIH19PC9kaXY+IHNob3VsZCBoYXZlIGEgc2luZ2xlIGV4cHJlc3Npb24gbm9kZSBhcyBjaGlsZC5cclxuY29uc3QgdHJhbnNmb3JtVGV4dCA9IChub2RlLCBjb250ZXh0KSA9PiB7XHJcbiAgICBpZiAobm9kZS50eXBlID09PSAwIC8qIFJPT1QgKi8gfHxcclxuICAgICAgICBub2RlLnR5cGUgPT09IDEgLyogRUxFTUVOVCAqLyB8fFxyXG4gICAgICAgIG5vZGUudHlwZSA9PT0gMTEgLyogRk9SICovIHx8XHJcbiAgICAgICAgbm9kZS50eXBlID09PSAxMCAvKiBJRl9CUkFOQ0ggKi8pIHtcclxuICAgICAgICAvLyBwZXJmb3JtIHRoZSB0cmFuc2Zvcm0gb24gbm9kZSBleGl0IHNvIHRoYXQgYWxsIGV4cHJlc3Npb25zIGhhdmUgYWxyZWFkeVxyXG4gICAgICAgIC8vIGJlZW4gcHJvY2Vzc2VkLlxyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcclxuICAgICAgICAgICAgbGV0IGN1cnJlbnRDb250YWluZXIgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIGxldCBoYXNUZXh0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNUZXh0KGNoaWxkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGhhc1RleHQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IGNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSBjaGlsZHJlbltqXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVGV4dChuZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50Q29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudENvbnRhaW5lciA9IGNoaWxkcmVuW2ldID0gY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uKFtjaGlsZF0sIGNoaWxkLmxvYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGUgaW50byBjdXJyZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q29udGFpbmVyLmNoaWxkcmVuLnB1c2goYCArIGAsIG5leHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4uc3BsaWNlKGosIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgai0tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudENvbnRhaW5lciA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghaGFzVGV4dCB8fFxyXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBpcyBhIHBsYWluIGVsZW1lbnQgd2l0aCBhIHNpbmdsZSB0ZXh0IGNoaWxkLCBsZWF2ZSBpdFxyXG4gICAgICAgICAgICAgICAgLy8gYXMtaXMgc2luY2UgdGhlIHJ1bnRpbWUgaGFzIGRlZGljYXRlZCBmYXN0IHBhdGggZm9yIHRoaXMgYnkgZGlyZWN0bHlcclxuICAgICAgICAgICAgICAgIC8vIHNldHRpbmcgdGV4dENvbnRlbnQgb2YgdGhlIGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAgICAvLyBmb3IgY29tcG9uZW50IHJvb3QgaXQncyBhbHdheXMgbm9ybWFsaXplZCBhbnl3YXkuXHJcbiAgICAgICAgICAgICAgICAoY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKG5vZGUudHlwZSA9PT0gMCAvKiBST09UICovIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChub2RlLnR5cGUgPT09IDEgLyogRUxFTUVOVCAqLyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS50YWdUeXBlID09PSAwIC8qIEVMRU1FTlQgKi8gJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICMzNzU2XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjdXN0b20gZGlyZWN0aXZlcyBjYW4gcG90ZW50aWFsbHkgYWRkIERPTSBlbGVtZW50cyBhcmJpdHJhcmlseSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gYXZvaWQgc2V0dGluZyB0ZXh0Q29udGVudCBvZiB0aGUgZWxlbWVudCBhdCBydW50aW1lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0byBhdm9pZCBhY2NpZGVudGFsbHkgb3ZlcndyaXRpbmcgdGhlIERPTSBlbGVtZW50cyBhZGRlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnkgdGhlIHVzZXIgdGhyb3VnaCBjdXN0b20gZGlyZWN0aXZlcy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICFub2RlLnByb3BzLmZpbmQocCA9PiBwLnR5cGUgPT09IDcgLyogRElSRUNUSVZFICovICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWNvbnRleHQuZGlyZWN0aXZlVHJhbnNmb3Jtc1twLm5hbWVdKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gY29tcGF0IG1vZGUsIDx0ZW1wbGF0ZT4gdGFncyB3aXRoIG5vIHNwZWNpYWwgZGlyZWN0aXZlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2lsbCBiZSByZW5kZXJlZCBhcyBhIGZyYWdtZW50IHNvIGl0cyBjaGlsZHJlbiBtdXN0IGJlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb252ZXJ0ZWQgaW50byB2bm9kZXMuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhKG5vZGUudGFnID09PSAndGVtcGxhdGUnKSkpKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHByZS1jb252ZXJ0IHRleHQgbm9kZXMgaW50byBjcmVhdGVUZXh0Vk5vZGUodGV4dCkgY2FsbHMgdG8gYXZvaWRcclxuICAgICAgICAgICAgLy8gcnVudGltZSBub3JtYWxpemF0aW9uLlxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzVGV4dChjaGlsZCkgfHwgY2hpbGQudHlwZSA9PT0gOCAvKiBDT01QT1VORF9FWFBSRVNTSU9OICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FsbEFyZ3MgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGVUZXh0Vk5vZGUgZGVmYXVsdHMgdG8gc2luZ2xlIHdoaXRlc3BhY2UsIHNvIGlmIGl0IGlzIGFcclxuICAgICAgICAgICAgICAgICAgICAvLyBzaW5nbGUgc3BhY2UgdGhlIGNvZGUgY291bGQgYmUgYW4gZW1wdHkgY2FsbCB0byBzYXZlIGJ5dGVzLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC50eXBlICE9PSAyIC8qIFRFWFQgKi8gfHwgY2hpbGQuY29udGVudCAhPT0gJyAnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxBcmdzLnB1c2goY2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBtYXJrIGR5bmFtaWMgdGV4dCB3aXRoIGZsYWcgc28gaXQgZ2V0cyBwYXRjaGVkIGluc2lkZSBhIGJsb2NrXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb250ZXh0LnNzciAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRDb25zdGFudFR5cGUoY2hpbGQsIGNvbnRleHQpID09PSAwIC8qIE5PVF9DT05TVEFOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsQXJncy5wdXNoKDEgLyogVEVYVCAqLyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYCAvKiAke1BhdGNoRmxhZ05hbWVzWzEgLyogVEVYVCAqL119ICovYCA6IGBgKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuW2ldID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAxMiAvKiBURVhUX0NBTEwgKi8sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGNoaWxkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2M6IGNoaWxkLmxvYyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZWdlbk5vZGU6IGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKENSRUFURV9URVhUKSwgY2FsbEFyZ3MpXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn07XG5cbmNvbnN0IHNlZW4gPSBuZXcgV2Vha1NldCgpO1xyXG5jb25zdCB0cmFuc2Zvcm1PbmNlID0gKG5vZGUsIGNvbnRleHQpID0+IHtcclxuICAgIGlmIChub2RlLnR5cGUgPT09IDEgLyogRUxFTUVOVCAqLyAmJiBmaW5kRGlyKG5vZGUsICdvbmNlJywgdHJ1ZSkpIHtcclxuICAgICAgICBpZiAoc2Vlbi5oYXMobm9kZSkgfHwgY29udGV4dC5pblZPbmNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2Vlbi5hZGQobm9kZSk7XHJcbiAgICAgICAgY29udGV4dC5pblZPbmNlID0gdHJ1ZTtcclxuICAgICAgICBjb250ZXh0LmhlbHBlcihTRVRfQkxPQ0tfVFJBQ0tJTkcpO1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnRleHQuaW5WT25jZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBjb25zdCBjdXIgPSBjb250ZXh0LmN1cnJlbnROb2RlO1xyXG4gICAgICAgICAgICBpZiAoY3VyLmNvZGVnZW5Ob2RlKSB7XHJcbiAgICAgICAgICAgICAgICBjdXIuY29kZWdlbk5vZGUgPSBjb250ZXh0LmNhY2hlKGN1ci5jb2RlZ2VuTm9kZSwgdHJ1ZSAvKiBpc1ZOb2RlICovKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn07XG5cbmNvbnN0IHRyYW5zZm9ybU1vZGVsID0gKGRpciwgbm9kZSwgY29udGV4dCkgPT4ge1xyXG4gICAgY29uc3QgeyBleHAsIGFyZyB9ID0gZGlyO1xyXG4gICAgaWYgKCFleHApIHtcclxuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcig0MSAvKiBYX1ZfTU9ERUxfTk9fRVhQUkVTU0lPTiAqLywgZGlyLmxvYykpO1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVUcmFuc2Zvcm1Qcm9wcygpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmF3RXhwID0gZXhwLmxvYy5zb3VyY2U7XHJcbiAgICBjb25zdCBleHBTdHJpbmcgPSBleHAudHlwZSA9PT0gNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLyA/IGV4cC5jb250ZW50IDogcmF3RXhwO1xyXG4gICAgLy8gaW0gU0ZDIDxzY3JpcHQgc2V0dXA+IGlubGluZSBtb2RlLCB0aGUgZXhwIG1heSBoYXZlIGJlZW4gdHJhbnNmb3JtZWQgaW50b1xyXG4gICAgLy8gX3VucmVmKGV4cClcclxuICAgIGNvbnRleHQuYmluZGluZ01ldGFkYXRhW3Jhd0V4cF07XHJcbiAgICBjb25zdCBtYXliZVJlZiA9ICF0cnVlICAgIC8qIFNFVFVQX0NPTlNUICovO1xyXG4gICAgaWYgKCFleHBTdHJpbmcudHJpbSgpIHx8XHJcbiAgICAgICAgKCFpc01lbWJlckV4cHJlc3Npb24oZXhwU3RyaW5nKSAmJiAhbWF5YmVSZWYpKSB7XHJcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoNDIgLyogWF9WX01PREVMX01BTEZPUk1FRF9FWFBSRVNTSU9OICovLCBleHAubG9jKSk7XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVRyYW5zZm9ybVByb3BzKCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBwcm9wTmFtZSA9IGFyZyA/IGFyZyA6IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oJ21vZGVsVmFsdWUnLCB0cnVlKTtcclxuICAgIGNvbnN0IGV2ZW50TmFtZSA9IGFyZ1xyXG4gICAgICAgID8gaXNTdGF0aWNFeHAoYXJnKVxyXG4gICAgICAgICAgICA/IGBvblVwZGF0ZToke2FyZy5jb250ZW50fWBcclxuICAgICAgICAgICAgOiBjcmVhdGVDb21wb3VuZEV4cHJlc3Npb24oWydcIm9uVXBkYXRlOlwiICsgJywgYXJnXSlcclxuICAgICAgICA6IGBvblVwZGF0ZTptb2RlbFZhbHVlYDtcclxuICAgIGxldCBhc3NpZ25tZW50RXhwO1xyXG4gICAgY29uc3QgZXZlbnRBcmcgPSBjb250ZXh0LmlzVFMgPyBgKCRldmVudDogYW55KWAgOiBgJGV2ZW50YDtcclxuICAgIHtcclxuICAgICAgICBhc3NpZ25tZW50RXhwID0gY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uKFtcclxuICAgICAgICAgICAgYCR7ZXZlbnRBcmd9ID0+ICgoYCxcclxuICAgICAgICAgICAgZXhwLFxyXG4gICAgICAgICAgICBgKSA9ICRldmVudClgXHJcbiAgICAgICAgXSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBwcm9wcyA9IFtcclxuICAgICAgICAvLyBtb2RlbFZhbHVlOiBmb29cclxuICAgICAgICBjcmVhdGVPYmplY3RQcm9wZXJ0eShwcm9wTmFtZSwgZGlyLmV4cCksXHJcbiAgICAgICAgLy8gXCJvblVwZGF0ZTptb2RlbFZhbHVlXCI6ICRldmVudCA9PiAoZm9vID0gJGV2ZW50KVxyXG4gICAgICAgIGNyZWF0ZU9iamVjdFByb3BlcnR5KGV2ZW50TmFtZSwgYXNzaWdubWVudEV4cClcclxuICAgIF07XHJcbiAgICAvLyBtb2RlbE1vZGlmaWVyczogeyBmb286IHRydWUsIFwiYmFyLWJhelwiOiB0cnVlIH1cclxuICAgIGlmIChkaXIubW9kaWZpZXJzLmxlbmd0aCAmJiBub2RlLnRhZ1R5cGUgPT09IDEgLyogQ09NUE9ORU5UICovKSB7XHJcbiAgICAgICAgY29uc3QgbW9kaWZpZXJzID0gZGlyLm1vZGlmaWVyc1xyXG4gICAgICAgICAgICAubWFwKG0gPT4gKGlzU2ltcGxlSWRlbnRpZmllcihtKSA/IG0gOiBKU09OLnN0cmluZ2lmeShtKSkgKyBgOiB0cnVlYClcclxuICAgICAgICAgICAgLmpvaW4oYCwgYCk7XHJcbiAgICAgICAgY29uc3QgbW9kaWZpZXJzS2V5ID0gYXJnXHJcbiAgICAgICAgICAgID8gaXNTdGF0aWNFeHAoYXJnKVxyXG4gICAgICAgICAgICAgICAgPyBgJHthcmcuY29udGVudH1Nb2RpZmllcnNgXHJcbiAgICAgICAgICAgICAgICA6IGNyZWF0ZUNvbXBvdW5kRXhwcmVzc2lvbihbYXJnLCAnICsgXCJNb2RpZmllcnNcIiddKVxyXG4gICAgICAgICAgICA6IGBtb2RlbE1vZGlmaWVyc2A7XHJcbiAgICAgICAgcHJvcHMucHVzaChjcmVhdGVPYmplY3RQcm9wZXJ0eShtb2RpZmllcnNLZXksIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYHsgJHttb2RpZmllcnN9IH1gLCBmYWxzZSwgZGlyLmxvYywgMiAvKiBDQU5fSE9JU1QgKi8pKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY3JlYXRlVHJhbnNmb3JtUHJvcHMocHJvcHMpO1xyXG59O1xyXG5mdW5jdGlvbiBjcmVhdGVUcmFuc2Zvcm1Qcm9wcyhwcm9wcyA9IFtdKSB7XHJcbiAgICByZXR1cm4geyBwcm9wcyB9O1xyXG59XG5cbmNvbnN0IHZhbGlkRGl2aXNpb25DaGFyUkUgPSAvW1xcdykuK1xcLV8kXFxdXS87XHJcbmNvbnN0IHRyYW5zZm9ybUZpbHRlciA9IChub2RlLCBjb250ZXh0KSA9PiB7XHJcbiAgICBpZiAoIWlzQ29tcGF0RW5hYmxlZChcIkNPTVBJTEVSX0ZJTFRFUlwiIC8qIENPTVBJTEVSX0ZJTFRFUlMgKi8sIGNvbnRleHQpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gNSAvKiBJTlRFUlBPTEFUSU9OICovKSB7XHJcbiAgICAgICAgLy8gZmlsdGVyIHJld3JpdGUgaXMgYXBwbGllZCBiZWZvcmUgZXhwcmVzc2lvbiB0cmFuc2Zvcm0gc28gb25seVxyXG4gICAgICAgIC8vIHNpbXBsZSBleHByZXNzaW9ucyBhcmUgcG9zc2libGUgYXQgdGhpcyBzdGFnZVxyXG4gICAgICAgIHJld3JpdGVGaWx0ZXIobm9kZS5jb250ZW50LCBjb250ZXh0KTtcclxuICAgIH1cclxuICAgIGlmIChub2RlLnR5cGUgPT09IDEgLyogRUxFTUVOVCAqLykge1xyXG4gICAgICAgIG5vZGUucHJvcHMuZm9yRWFjaCgocHJvcCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAocHJvcC50eXBlID09PSA3IC8qIERJUkVDVElWRSAqLyAmJlxyXG4gICAgICAgICAgICAgICAgcHJvcC5uYW1lICE9PSAnZm9yJyAmJlxyXG4gICAgICAgICAgICAgICAgcHJvcC5leHApIHtcclxuICAgICAgICAgICAgICAgIHJld3JpdGVGaWx0ZXIocHJvcC5leHAsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uIHJld3JpdGVGaWx0ZXIobm9kZSwgY29udGV4dCkge1xyXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLykge1xyXG4gICAgICAgIHBhcnNlRmlsdGVyKG5vZGUsIGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGlsZCAhPT0gJ29iamVjdCcpXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8pIHtcclxuICAgICAgICAgICAgICAgIHBhcnNlRmlsdGVyKGNoaWxkLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjaGlsZC50eXBlID09PSA4IC8qIENPTVBPVU5EX0VYUFJFU1NJT04gKi8pIHtcclxuICAgICAgICAgICAgICAgIHJld3JpdGVGaWx0ZXIobm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGQudHlwZSA9PT0gNSAvKiBJTlRFUlBPTEFUSU9OICovKSB7XHJcbiAgICAgICAgICAgICAgICByZXdyaXRlRmlsdGVyKGNoaWxkLmNvbnRlbnQsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHBhcnNlRmlsdGVyKG5vZGUsIGNvbnRleHQpIHtcclxuICAgIGNvbnN0IGV4cCA9IG5vZGUuY29udGVudDtcclxuICAgIGxldCBpblNpbmdsZSA9IGZhbHNlO1xyXG4gICAgbGV0IGluRG91YmxlID0gZmFsc2U7XHJcbiAgICBsZXQgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlO1xyXG4gICAgbGV0IGluUmVnZXggPSBmYWxzZTtcclxuICAgIGxldCBjdXJseSA9IDA7XHJcbiAgICBsZXQgc3F1YXJlID0gMDtcclxuICAgIGxldCBwYXJlbiA9IDA7XHJcbiAgICBsZXQgbGFzdEZpbHRlckluZGV4ID0gMDtcclxuICAgIGxldCBjLCBwcmV2LCBpLCBleHByZXNzaW9uLCBmaWx0ZXJzID0gW107XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgZXhwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgcHJldiA9IGM7XHJcbiAgICAgICAgYyA9IGV4cC5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgIGlmIChpblNpbmdsZSkge1xyXG4gICAgICAgICAgICBpZiAoYyA9PT0gMHgyNyAmJiBwcmV2ICE9PSAweDVjKVxyXG4gICAgICAgICAgICAgICAgaW5TaW5nbGUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaW5Eb3VibGUpIHtcclxuICAgICAgICAgICAgaWYgKGMgPT09IDB4MjIgJiYgcHJldiAhPT0gMHg1YylcclxuICAgICAgICAgICAgICAgIGluRG91YmxlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGluVGVtcGxhdGVTdHJpbmcpIHtcclxuICAgICAgICAgICAgaWYgKGMgPT09IDB4NjAgJiYgcHJldiAhPT0gMHg1YylcclxuICAgICAgICAgICAgICAgIGluVGVtcGxhdGVTdHJpbmcgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaW5SZWdleCkge1xyXG4gICAgICAgICAgICBpZiAoYyA9PT0gMHgyZiAmJiBwcmV2ICE9PSAweDVjKVxyXG4gICAgICAgICAgICAgICAgaW5SZWdleCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjID09PSAweDdjICYmIC8vIHBpcGVcclxuICAgICAgICAgICAgZXhwLmNoYXJDb2RlQXQoaSArIDEpICE9PSAweDdjICYmXHJcbiAgICAgICAgICAgIGV4cC5jaGFyQ29kZUF0KGkgLSAxKSAhPT0gMHg3YyAmJlxyXG4gICAgICAgICAgICAhY3VybHkgJiZcclxuICAgICAgICAgICAgIXNxdWFyZSAmJlxyXG4gICAgICAgICAgICAhcGFyZW4pIHtcclxuICAgICAgICAgICAgaWYgKGV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gZmlyc3QgZmlsdGVyLCBlbmQgb2YgZXhwcmVzc2lvblxyXG4gICAgICAgICAgICAgICAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XHJcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uID0gZXhwLnNsaWNlKDAsIGkpLnRyaW0oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHB1c2hGaWx0ZXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc3dpdGNoIChjKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDB4MjI6XHJcbiAgICAgICAgICAgICAgICAgICAgaW5Eb3VibGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBcIlxyXG4gICAgICAgICAgICAgICAgY2FzZSAweDI3OlxyXG4gICAgICAgICAgICAgICAgICAgIGluU2luZ2xlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gJ1xyXG4gICAgICAgICAgICAgICAgY2FzZSAweDYwOlxyXG4gICAgICAgICAgICAgICAgICAgIGluVGVtcGxhdGVTdHJpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBgXHJcbiAgICAgICAgICAgICAgICBjYXNlIDB4Mjg6XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW4rKztcclxuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gKFxyXG4gICAgICAgICAgICAgICAgY2FzZSAweDI5OlxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVuLS07XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIClcclxuICAgICAgICAgICAgICAgIGNhc2UgMHg1YjpcclxuICAgICAgICAgICAgICAgICAgICBzcXVhcmUrKztcclxuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gW1xyXG4gICAgICAgICAgICAgICAgY2FzZSAweDVkOlxyXG4gICAgICAgICAgICAgICAgICAgIHNxdWFyZS0tO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBdXHJcbiAgICAgICAgICAgICAgICBjYXNlIDB4N2I6XHJcbiAgICAgICAgICAgICAgICAgICAgY3VybHkrKztcclxuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8ge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAweDdkOlxyXG4gICAgICAgICAgICAgICAgICAgIGN1cmx5LS07XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYyA9PT0gMHgyZikge1xyXG4gICAgICAgICAgICAgICAgLy8gL1xyXG4gICAgICAgICAgICAgICAgbGV0IGogPSBpIC0gMTtcclxuICAgICAgICAgICAgICAgIGxldCBwO1xyXG4gICAgICAgICAgICAgICAgLy8gZmluZCBmaXJzdCBub24td2hpdGVzcGFjZSBwcmV2IGNoYXJcclxuICAgICAgICAgICAgICAgIGZvciAoOyBqID49IDA7IGotLSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHAgPSBleHAuY2hhckF0KGopO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwICE9PSAnICcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFwIHx8ICF2YWxpZERpdmlzaW9uQ2hhclJFLnRlc3QocCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpblJlZ2V4ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBleHByZXNzaW9uID0gZXhwLnNsaWNlKDAsIGkpLnRyaW0oKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGxhc3RGaWx0ZXJJbmRleCAhPT0gMCkge1xyXG4gICAgICAgIHB1c2hGaWx0ZXIoKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHB1c2hGaWx0ZXIoKSB7XHJcbiAgICAgICAgZmlsdGVycy5wdXNoKGV4cC5zbGljZShsYXN0RmlsdGVySW5kZXgsIGkpLnRyaW0oKSk7XHJcbiAgICAgICAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XHJcbiAgICB9XHJcbiAgICBpZiAoZmlsdGVycy5sZW5ndGgpIHtcclxuICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgd2FybkRlcHJlY2F0aW9uKFwiQ09NUElMRVJfRklMVEVSXCIgLyogQ09NUElMRVJfRklMVEVSUyAqLywgY29udGV4dCwgbm9kZS5sb2MpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBmaWx0ZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGV4cHJlc3Npb24gPSB3cmFwRmlsdGVyKGV4cHJlc3Npb24sIGZpbHRlcnNbaV0sIGNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBub2RlLmNvbnRlbnQgPSBleHByZXNzaW9uO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHdyYXBGaWx0ZXIoZXhwLCBmaWx0ZXIsIGNvbnRleHQpIHtcclxuICAgIGNvbnRleHQuaGVscGVyKFJFU09MVkVfRklMVEVSKTtcclxuICAgIGNvbnN0IGkgPSBmaWx0ZXIuaW5kZXhPZignKCcpO1xyXG4gICAgaWYgKGkgPCAwKSB7XHJcbiAgICAgICAgY29udGV4dC5maWx0ZXJzLmFkZChmaWx0ZXIpO1xyXG4gICAgICAgIHJldHVybiBgJHt0b1ZhbGlkQXNzZXRJZChmaWx0ZXIsICdmaWx0ZXInKX0oJHtleHB9KWA7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBuYW1lID0gZmlsdGVyLnNsaWNlKDAsIGkpO1xyXG4gICAgICAgIGNvbnN0IGFyZ3MgPSBmaWx0ZXIuc2xpY2UoaSArIDEpO1xyXG4gICAgICAgIGNvbnRleHQuZmlsdGVycy5hZGQobmFtZSk7XHJcbiAgICAgICAgcmV0dXJuIGAke3RvVmFsaWRBc3NldElkKG5hbWUsICdmaWx0ZXInKX0oJHtleHB9JHthcmdzICE9PSAnKScgPyAnLCcgKyBhcmdzIDogYXJnc31gO1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IHNlZW4kMSA9IG5ldyBXZWFrU2V0KCk7XHJcbmNvbnN0IHRyYW5zZm9ybU1lbW8gPSAobm9kZSwgY29udGV4dCkgPT4ge1xyXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMSAvKiBFTEVNRU5UICovKSB7XHJcbiAgICAgICAgY29uc3QgZGlyID0gZmluZERpcihub2RlLCAnbWVtbycpO1xyXG4gICAgICAgIGlmICghZGlyIHx8IHNlZW4kMS5oYXMobm9kZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZWVuJDEuYWRkKG5vZGUpO1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvZGVnZW5Ob2RlID0gbm9kZS5jb2RlZ2VuTm9kZSB8fFxyXG4gICAgICAgICAgICAgICAgY29udGV4dC5jdXJyZW50Tm9kZS5jb2RlZ2VuTm9kZTtcclxuICAgICAgICAgICAgaWYgKGNvZGVnZW5Ob2RlICYmIGNvZGVnZW5Ob2RlLnR5cGUgPT09IDEzIC8qIFZOT0RFX0NBTEwgKi8pIHtcclxuICAgICAgICAgICAgICAgIC8vIG5vbi1jb21wb25lbnQgc3ViIHRyZWUgc2hvdWxkIGJlIHR1cm5lZCBpbnRvIGEgYmxvY2tcclxuICAgICAgICAgICAgICAgIGlmIChub2RlLnRhZ1R5cGUgIT09IDEgLyogQ09NUE9ORU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFrZUJsb2NrKGNvZGVnZW5Ob2RlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG5vZGUuY29kZWdlbk5vZGUgPSBjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlcihXSVRIX01FTU8pLCBbXHJcbiAgICAgICAgICAgICAgICAgICAgZGlyLmV4cCxcclxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVGdW5jdGlvbkV4cHJlc3Npb24odW5kZWZpbmVkLCBjb2RlZ2VuTm9kZSksXHJcbiAgICAgICAgICAgICAgICAgICAgYF9jYWNoZWAsXHJcbiAgICAgICAgICAgICAgICAgICAgU3RyaW5nKGNvbnRleHQuY2FjaGVkKyspXHJcbiAgICAgICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn07XG5cbmZ1bmN0aW9uIGdldEJhc2VUcmFuc2Zvcm1QcmVzZXQocHJlZml4SWRlbnRpZmllcnMpIHtcclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgW1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm1PbmNlLFxyXG4gICAgICAgICAgICB0cmFuc2Zvcm1JZixcclxuICAgICAgICAgICAgdHJhbnNmb3JtTWVtbyxcclxuICAgICAgICAgICAgdHJhbnNmb3JtRm9yLFxyXG4gICAgICAgICAgICAuLi4oW3RyYW5zZm9ybUZpbHRlcl0gKSxcclxuICAgICAgICAgICAgLi4uKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxyXG4gICAgICAgICAgICAgICAgICAgID8gW3RyYW5zZm9ybUV4cHJlc3Npb25dXHJcbiAgICAgICAgICAgICAgICAgICAgOiBbXSksXHJcbiAgICAgICAgICAgIHRyYW5zZm9ybVNsb3RPdXRsZXQsXHJcbiAgICAgICAgICAgIHRyYW5zZm9ybUVsZW1lbnQsXHJcbiAgICAgICAgICAgIHRyYWNrU2xvdFNjb3BlcyxcclxuICAgICAgICAgICAgdHJhbnNmb3JtVGV4dFxyXG4gICAgICAgIF0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBvbjogdHJhbnNmb3JtT24sXHJcbiAgICAgICAgICAgIGJpbmQ6IHRyYW5zZm9ybUJpbmQsXHJcbiAgICAgICAgICAgIG1vZGVsOiB0cmFuc2Zvcm1Nb2RlbFxyXG4gICAgICAgIH1cclxuICAgIF07XHJcbn1cclxuLy8gd2UgbmFtZSBpdCBgYmFzZUNvbXBpbGVgIHNvIHRoYXQgaGlnaGVyIG9yZGVyIGNvbXBpbGVycyBsaWtlXHJcbi8vIEB2dWUvY29tcGlsZXItZG9tIGNhbiBleHBvcnQgYGNvbXBpbGVgIHdoaWxlIHJlLWV4cG9ydGluZyBldmVyeXRoaW5nIGVsc2UuXHJcbmZ1bmN0aW9uIGJhc2VDb21waWxlKHRlbXBsYXRlLCBvcHRpb25zID0ge30pIHtcclxuICAgIGNvbnN0IG9uRXJyb3IgPSBvcHRpb25zLm9uRXJyb3IgfHwgZGVmYXVsdE9uRXJyb3I7XHJcbiAgICBjb25zdCBpc01vZHVsZU1vZGUgPSBvcHRpb25zLm1vZGUgPT09ICdtb2R1bGUnO1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMucHJlZml4SWRlbnRpZmllcnMgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgb25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDQ2IC8qIFhfUFJFRklYX0lEX05PVF9TVVBQT1JURUQgKi8pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNNb2R1bGVNb2RlKSB7XHJcbiAgICAgICAgICAgIG9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcig0NyAvKiBYX01PRFVMRV9NT0RFX05PVF9TVVBQT1JURUQgKi8pKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBwcmVmaXhJZGVudGlmaWVycyA9ICF0cnVlIDtcclxuICAgIGlmIChvcHRpb25zLmNhY2hlSGFuZGxlcnMpIHtcclxuICAgICAgICBvbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoNDggLyogWF9DQUNIRV9IQU5ETEVSX05PVF9TVVBQT1JURUQgKi8pKTtcclxuICAgIH1cclxuICAgIGlmIChvcHRpb25zLnNjb3BlSWQgJiYgIWlzTW9kdWxlTW9kZSkge1xyXG4gICAgICAgIG9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcig0OSAvKiBYX1NDT1BFX0lEX05PVF9TVVBQT1JURUQgKi8pKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGFzdCA9IGlzU3RyaW5nKHRlbXBsYXRlKSA/IGJhc2VQYXJzZSh0ZW1wbGF0ZSwgb3B0aW9ucykgOiB0ZW1wbGF0ZTtcclxuICAgIGNvbnN0IFtub2RlVHJhbnNmb3JtcywgZGlyZWN0aXZlVHJhbnNmb3Jtc10gPSBnZXRCYXNlVHJhbnNmb3JtUHJlc2V0KCk7XHJcbiAgICB0cmFuc2Zvcm0oYXN0LCBleHRlbmQoe30sIG9wdGlvbnMsIHtcclxuICAgICAgICBwcmVmaXhJZGVudGlmaWVycyxcclxuICAgICAgICBub2RlVHJhbnNmb3JtczogW1xyXG4gICAgICAgICAgICAuLi5ub2RlVHJhbnNmb3JtcyxcclxuICAgICAgICAgICAgLi4uKG9wdGlvbnMubm9kZVRyYW5zZm9ybXMgfHwgW10pIC8vIHVzZXIgdHJhbnNmb3Jtc1xyXG4gICAgICAgIF0sXHJcbiAgICAgICAgZGlyZWN0aXZlVHJhbnNmb3JtczogZXh0ZW5kKHt9LCBkaXJlY3RpdmVUcmFuc2Zvcm1zLCBvcHRpb25zLmRpcmVjdGl2ZVRyYW5zZm9ybXMgfHwge30gLy8gdXNlciB0cmFuc2Zvcm1zXHJcbiAgICAgICAgKVxyXG4gICAgfSkpO1xyXG4gICAgcmV0dXJuIGdlbmVyYXRlKGFzdCwgZXh0ZW5kKHt9LCBvcHRpb25zLCB7XHJcbiAgICAgICAgcHJlZml4SWRlbnRpZmllcnNcclxuICAgIH0pKTtcclxufVxuXG5jb25zdCBub29wRGlyZWN0aXZlVHJhbnNmb3JtID0gKCkgPT4gKHsgcHJvcHM6IFtdIH0pO1xuXG5leHBvcnQgeyBCQVNFX1RSQU5TSVRJT04sIENBTUVMSVpFLCBDQVBJVEFMSVpFLCBDUkVBVEVfQkxPQ0ssIENSRUFURV9DT01NRU5ULCBDUkVBVEVfRUxFTUVOVF9CTE9DSywgQ1JFQVRFX0VMRU1FTlRfVk5PREUsIENSRUFURV9TTE9UUywgQ1JFQVRFX1NUQVRJQywgQ1JFQVRFX1RFWFQsIENSRUFURV9WTk9ERSwgRlJBR01FTlQsIEdVQVJEX1JFQUNUSVZFX1BST1BTLCBJU19NRU1PX1NBTUUsIElTX1JFRiwgS0VFUF9BTElWRSwgTUVSR0VfUFJPUFMsIE5PUk1BTElaRV9DTEFTUywgTk9STUFMSVpFX1BST1BTLCBOT1JNQUxJWkVfU1RZTEUsIE9QRU5fQkxPQ0ssIFBPUF9TQ09QRV9JRCwgUFVTSF9TQ09QRV9JRCwgUkVOREVSX0xJU1QsIFJFTkRFUl9TTE9ULCBSRVNPTFZFX0NPTVBPTkVOVCwgUkVTT0xWRV9ESVJFQ1RJVkUsIFJFU09MVkVfRFlOQU1JQ19DT01QT05FTlQsIFJFU09MVkVfRklMVEVSLCBTRVRfQkxPQ0tfVFJBQ0tJTkcsIFNVU1BFTlNFLCBURUxFUE9SVCwgVE9fRElTUExBWV9TVFJJTkcsIFRPX0hBTkRMRVJTLCBUT19IQU5ETEVSX0tFWSwgVU5SRUYsIFdJVEhfQ1RYLCBXSVRIX0RJUkVDVElWRVMsIFdJVEhfTUVNTywgYWR2YW5jZVBvc2l0aW9uV2l0aENsb25lLCBhZHZhbmNlUG9zaXRpb25XaXRoTXV0YXRpb24sIGFzc2VydCwgYmFzZUNvbXBpbGUsIGJhc2VQYXJzZSwgYnVpbGREaXJlY3RpdmVBcmdzLCBidWlsZFByb3BzLCBidWlsZFNsb3RzLCBjaGVja0NvbXBhdEVuYWJsZWQsIGNyZWF0ZUFycmF5RXhwcmVzc2lvbiwgY3JlYXRlQXNzaWdubWVudEV4cHJlc3Npb24sIGNyZWF0ZUJsb2NrU3RhdGVtZW50LCBjcmVhdGVDYWNoZUV4cHJlc3Npb24sIGNyZWF0ZUNhbGxFeHByZXNzaW9uLCBjcmVhdGVDb21waWxlckVycm9yLCBjcmVhdGVDb21wb3VuZEV4cHJlc3Npb24sIGNyZWF0ZUNvbmRpdGlvbmFsRXhwcmVzc2lvbiwgY3JlYXRlRm9yTG9vcFBhcmFtcywgY3JlYXRlRnVuY3Rpb25FeHByZXNzaW9uLCBjcmVhdGVJZlN0YXRlbWVudCwgY3JlYXRlSW50ZXJwb2xhdGlvbiwgY3JlYXRlT2JqZWN0RXhwcmVzc2lvbiwgY3JlYXRlT2JqZWN0UHJvcGVydHksIGNyZWF0ZVJldHVyblN0YXRlbWVudCwgY3JlYXRlUm9vdCwgY3JlYXRlU2VxdWVuY2VFeHByZXNzaW9uLCBjcmVhdGVTaW1wbGVFeHByZXNzaW9uLCBjcmVhdGVTdHJ1Y3R1cmFsRGlyZWN0aXZlVHJhbnNmb3JtLCBjcmVhdGVUZW1wbGF0ZUxpdGVyYWwsIGNyZWF0ZVRyYW5zZm9ybUNvbnRleHQsIGNyZWF0ZVZOb2RlQ2FsbCwgZXh0cmFjdElkZW50aWZpZXJzLCBmaW5kRGlyLCBmaW5kUHJvcCwgZ2VuZXJhdGUsIGdldEJhc2VUcmFuc2Zvcm1QcmVzZXQsIGdldENvbnN0YW50VHlwZSwgZ2V0SW5uZXJSYW5nZSwgZ2V0TWVtb2VkVk5vZGVDYWxsLCBnZXRWTm9kZUJsb2NrSGVscGVyLCBnZXRWTm9kZUhlbHBlciwgaGFzRHluYW1pY0tleVZCaW5kLCBoYXNTY29wZVJlZiwgaGVscGVyTmFtZU1hcCwgaW5qZWN0UHJvcCwgaXNCdWlsdEluVHlwZSwgaXNDb3JlQ29tcG9uZW50LCBpc0Z1bmN0aW9uVHlwZSwgaXNJbkRlc3RydWN0dXJlQXNzaWdubWVudCwgaXNNZW1iZXJFeHByZXNzaW9uLCBpc01lbWJlckV4cHJlc3Npb25Ccm93c2VyLCBpc01lbWJlckV4cHJlc3Npb25Ob2RlLCBpc1JlZmVyZW5jZWRJZGVudGlmaWVyLCBpc1NpbXBsZUlkZW50aWZpZXIsIGlzU2xvdE91dGxldCwgaXNTdGF0aWNBcmdPZiwgaXNTdGF0aWNFeHAsIGlzU3RhdGljUHJvcGVydHksIGlzU3RhdGljUHJvcGVydHlLZXksIGlzVGVtcGxhdGVOb2RlLCBpc1RleHQsIGlzVlNsb3QsIGxvY1N0dWIsIG1ha2VCbG9jaywgbm9vcERpcmVjdGl2ZVRyYW5zZm9ybSwgcHJvY2Vzc0V4cHJlc3Npb24sIHByb2Nlc3NGb3IsIHByb2Nlc3NJZiwgcHJvY2Vzc1Nsb3RPdXRsZXQsIHJlZ2lzdGVyUnVudGltZUhlbHBlcnMsIHJlc29sdmVDb21wb25lbnRUeXBlLCB0b1ZhbGlkQXNzZXRJZCwgdHJhY2tTbG90U2NvcGVzLCB0cmFja1ZGb3JTbG90U2NvcGVzLCB0cmFuc2Zvcm0sIHRyYW5zZm9ybUJpbmQsIHRyYW5zZm9ybUVsZW1lbnQsIHRyYW5zZm9ybUV4cHJlc3Npb24sIHRyYW5zZm9ybU1vZGVsLCB0cmFuc2Zvcm1PbiwgdHJhdmVyc2VOb2RlLCB3YWxrQmxvY2tEZWNsYXJhdGlvbnMsIHdhbGtGdW5jdGlvblBhcmFtcywgd2Fsa0lkZW50aWZpZXJzLCB3YXJuRGVwcmVjYXRpb24gfTtcbiIsImltcG9ydCB7IHJlZ2lzdGVyUnVudGltZUhlbHBlcnMsIGlzQnVpbHRJblR5cGUsIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24sIGNyZWF0ZUNvbXBpbGVyRXJyb3IsIGNyZWF0ZU9iamVjdFByb3BlcnR5LCBnZXRDb25zdGFudFR5cGUsIGNyZWF0ZUNhbGxFeHByZXNzaW9uLCBUT19ESVNQTEFZX1NUUklORywgdHJhbnNmb3JtTW9kZWwgYXMgdHJhbnNmb3JtTW9kZWwkMSwgZmluZFByb3AsIGhhc0R5bmFtaWNLZXlWQmluZCwgdHJhbnNmb3JtT24gYXMgdHJhbnNmb3JtT24kMSwgY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uLCBpc1N0YXRpY0V4cCwgY2hlY2tDb21wYXRFbmFibGVkLCBub29wRGlyZWN0aXZlVHJhbnNmb3JtLCBiYXNlQ29tcGlsZSwgYmFzZVBhcnNlIH0gZnJvbSAnQHZ1ZS9jb21waWxlci1jb3JlJztcbmV4cG9ydCAqIGZyb20gJ0B2dWUvY29tcGlsZXItY29yZSc7XG5pbXBvcnQgeyBpc1ZvaWRUYWcsIGlzSFRNTFRhZywgaXNTVkdUYWcsIG1ha2VNYXAsIHBhcnNlU3RyaW5nU3R5bGUsIGNhcGl0YWxpemUsIGV4dGVuZCB9IGZyb20gJ0B2dWUvc2hhcmVkJztcblxuY29uc3QgVl9NT0RFTF9SQURJTyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgdk1vZGVsUmFkaW9gIDogYGApO1xyXG5jb25zdCBWX01PREVMX0NIRUNLQk9YID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGB2TW9kZWxDaGVja2JveGAgOiBgYCk7XHJcbmNvbnN0IFZfTU9ERUxfVEVYVCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgdk1vZGVsVGV4dGAgOiBgYCk7XHJcbmNvbnN0IFZfTU9ERUxfU0VMRUNUID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGB2TW9kZWxTZWxlY3RgIDogYGApO1xyXG5jb25zdCBWX01PREVMX0RZTkFNSUMgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHZNb2RlbER5bmFtaWNgIDogYGApO1xyXG5jb25zdCBWX09OX1dJVEhfTU9ESUZJRVJTID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGB2T25Nb2RpZmllcnNHdWFyZGAgOiBgYCk7XHJcbmNvbnN0IFZfT05fV0lUSF9LRVlTID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGB2T25LZXlzR3VhcmRgIDogYGApO1xyXG5jb25zdCBWX1NIT1cgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHZTaG93YCA6IGBgKTtcclxuY29uc3QgVFJBTlNJVElPTiA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgVHJhbnNpdGlvbmAgOiBgYCk7XHJcbmNvbnN0IFRSQU5TSVRJT05fR1JPVVAgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYFRyYW5zaXRpb25Hcm91cGAgOiBgYCk7XHJcbnJlZ2lzdGVyUnVudGltZUhlbHBlcnMoe1xyXG4gICAgW1ZfTU9ERUxfUkFESU9dOiBgdk1vZGVsUmFkaW9gLFxyXG4gICAgW1ZfTU9ERUxfQ0hFQ0tCT1hdOiBgdk1vZGVsQ2hlY2tib3hgLFxyXG4gICAgW1ZfTU9ERUxfVEVYVF06IGB2TW9kZWxUZXh0YCxcclxuICAgIFtWX01PREVMX1NFTEVDVF06IGB2TW9kZWxTZWxlY3RgLFxyXG4gICAgW1ZfTU9ERUxfRFlOQU1JQ106IGB2TW9kZWxEeW5hbWljYCxcclxuICAgIFtWX09OX1dJVEhfTU9ESUZJRVJTXTogYHdpdGhNb2RpZmllcnNgLFxyXG4gICAgW1ZfT05fV0lUSF9LRVlTXTogYHdpdGhLZXlzYCxcclxuICAgIFtWX1NIT1ddOiBgdlNob3dgLFxyXG4gICAgW1RSQU5TSVRJT05dOiBgVHJhbnNpdGlvbmAsXHJcbiAgICBbVFJBTlNJVElPTl9HUk9VUF06IGBUcmFuc2l0aW9uR3JvdXBgXHJcbn0pO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgKi9cclxubGV0IGRlY29kZXI7XHJcbmZ1bmN0aW9uIGRlY29kZUh0bWxCcm93c2VyKHJhdywgYXNBdHRyID0gZmFsc2UpIHtcclxuICAgIGlmICghZGVjb2Rlcikge1xyXG4gICAgICAgIGRlY29kZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgIH1cclxuICAgIGlmIChhc0F0dHIpIHtcclxuICAgICAgICBkZWNvZGVyLmlubmVySFRNTCA9IGA8ZGl2IGZvbz1cIiR7cmF3LnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKX1cIj5gO1xyXG4gICAgICAgIHJldHVybiBkZWNvZGVyLmNoaWxkcmVuWzBdLmdldEF0dHJpYnV0ZSgnZm9vJyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBkZWNvZGVyLmlubmVySFRNTCA9IHJhdztcclxuICAgICAgICByZXR1cm4gZGVjb2Rlci50ZXh0Q29udGVudDtcclxuICAgIH1cclxufVxuXG5jb25zdCBpc1Jhd1RleHRDb250YWluZXIgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoJ3N0eWxlLGlmcmFtZSxzY3JpcHQsbm9zY3JpcHQnLCB0cnVlKTtcclxuY29uc3QgcGFyc2VyT3B0aW9ucyA9IHtcclxuICAgIGlzVm9pZFRhZyxcclxuICAgIGlzTmF0aXZlVGFnOiB0YWcgPT4gaXNIVE1MVGFnKHRhZykgfHwgaXNTVkdUYWcodGFnKSxcclxuICAgIGlzUHJlVGFnOiB0YWcgPT4gdGFnID09PSAncHJlJyxcclxuICAgIGRlY29kZUVudGl0aWVzOiBkZWNvZGVIdG1sQnJvd3NlciAsXHJcbiAgICBpc0J1aWx0SW5Db21wb25lbnQ6ICh0YWcpID0+IHtcclxuICAgICAgICBpZiAoaXNCdWlsdEluVHlwZSh0YWcsIGBUcmFuc2l0aW9uYCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFRSQU5TSVRJT047XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzQnVpbHRJblR5cGUodGFnLCBgVHJhbnNpdGlvbkdyb3VwYCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFRSQU5TSVRJT05fR1JPVVA7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3BhcnNpbmcuaHRtbCN0cmVlLWNvbnN0cnVjdGlvbi1kaXNwYXRjaGVyXHJcbiAgICBnZXROYW1lc3BhY2UodGFnLCBwYXJlbnQpIHtcclxuICAgICAgICBsZXQgbnMgPSBwYXJlbnQgPyBwYXJlbnQubnMgOiAwIC8qIEhUTUwgKi87XHJcbiAgICAgICAgaWYgKHBhcmVudCAmJiBucyA9PT0gMiAvKiBNQVRIX01MICovKSB7XHJcbiAgICAgICAgICAgIGlmIChwYXJlbnQudGFnID09PSAnYW5ub3RhdGlvbi14bWwnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGFnID09PSAnc3ZnJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIFNWRyAqLztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQucHJvcHMuc29tZShhID0+IGEudHlwZSA9PT0gNiAvKiBBVFRSSUJVVEUgKi8gJiZcclxuICAgICAgICAgICAgICAgICAgICBhLm5hbWUgPT09ICdlbmNvZGluZycgJiZcclxuICAgICAgICAgICAgICAgICAgICBhLnZhbHVlICE9IG51bGwgJiZcclxuICAgICAgICAgICAgICAgICAgICAoYS52YWx1ZS5jb250ZW50ID09PSAndGV4dC9odG1sJyB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhLnZhbHVlLmNvbnRlbnQgPT09ICdhcHBsaWNhdGlvbi94aHRtbCt4bWwnKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBucyA9IDAgLyogSFRNTCAqLztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICgvXm0oPzpbaW9uc118dGV4dCkkLy50ZXN0KHBhcmVudC50YWcpICYmXHJcbiAgICAgICAgICAgICAgICB0YWcgIT09ICdtZ2x5cGgnICYmXHJcbiAgICAgICAgICAgICAgICB0YWcgIT09ICdtYWxpZ25tYXJrJykge1xyXG4gICAgICAgICAgICAgICAgbnMgPSAwIC8qIEhUTUwgKi87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocGFyZW50ICYmIG5zID09PSAxIC8qIFNWRyAqLykge1xyXG4gICAgICAgICAgICBpZiAocGFyZW50LnRhZyA9PT0gJ2ZvcmVpZ25PYmplY3QnIHx8XHJcbiAgICAgICAgICAgICAgICBwYXJlbnQudGFnID09PSAnZGVzYycgfHxcclxuICAgICAgICAgICAgICAgIHBhcmVudC50YWcgPT09ICd0aXRsZScpIHtcclxuICAgICAgICAgICAgICAgIG5zID0gMCAvKiBIVE1MICovO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChucyA9PT0gMCAvKiBIVE1MICovKSB7XHJcbiAgICAgICAgICAgIGlmICh0YWcgPT09ICdzdmcnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBTVkcgKi87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRhZyA9PT0gJ21hdGgnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMiAvKiBNQVRIX01MICovO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBucztcclxuICAgIH0sXHJcbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9wYXJzaW5nLmh0bWwjcGFyc2luZy1odG1sLWZyYWdtZW50c1xyXG4gICAgZ2V0VGV4dE1vZGUoeyB0YWcsIG5zIH0pIHtcclxuICAgICAgICBpZiAobnMgPT09IDAgLyogSFRNTCAqLykge1xyXG4gICAgICAgICAgICBpZiAodGFnID09PSAndGV4dGFyZWEnIHx8IHRhZyA9PT0gJ3RpdGxlJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogUkNEQVRBICovO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpc1Jhd1RleHRDb250YWluZXIodGFnKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDIgLyogUkFXVEVYVCAqLztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gMCAvKiBEQVRBICovO1xyXG4gICAgfVxyXG59O1xuXG4vLyBQYXJzZSBpbmxpbmUgQ1NTIHN0cmluZ3MgZm9yIHN0YXRpYyBzdHlsZSBhdHRyaWJ1dGVzIGludG8gYW4gb2JqZWN0LlxyXG4vLyBUaGlzIGlzIGEgTm9kZVRyYW5zZm9ybSBzaW5jZSBpdCB3b3JrcyBvbiB0aGUgc3RhdGljIGBzdHlsZWAgYXR0cmlidXRlIGFuZFxyXG4vLyBjb252ZXJ0cyBpdCBpbnRvIGEgZHluYW1pYyBlcXVpdmFsZW50OlxyXG4vLyBzdHlsZT1cImNvbG9yOiByZWRcIiAtPiA6c3R5bGU9J3sgXCJjb2xvclwiOiBcInJlZFwiIH0nXHJcbi8vIEl0IGlzIHRoZW4gcHJvY2Vzc2VkIGJ5IGB0cmFuc2Zvcm1FbGVtZW50YCBhbmQgaW5jbHVkZWQgaW4gdGhlIGdlbmVyYXRlZFxyXG4vLyBwcm9wcy5cclxuY29uc3QgdHJhbnNmb3JtU3R5bGUgPSBub2RlID0+IHtcclxuICAgIGlmIChub2RlLnR5cGUgPT09IDEgLyogRUxFTUVOVCAqLykge1xyXG4gICAgICAgIG5vZGUucHJvcHMuZm9yRWFjaCgocCwgaSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAocC50eXBlID09PSA2IC8qIEFUVFJJQlVURSAqLyAmJiBwLm5hbWUgPT09ICdzdHlsZScgJiYgcC52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gcmVwbGFjZSBwIHdpdGggYW4gZXhwcmVzc2lvbiBub2RlXHJcbiAgICAgICAgICAgICAgICBub2RlLnByb3BzW2ldID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IDcgLyogRElSRUNUSVZFICovLFxyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGBiaW5kYCxcclxuICAgICAgICAgICAgICAgICAgICBhcmc6IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYHN0eWxlYCwgdHJ1ZSwgcC5sb2MpLFxyXG4gICAgICAgICAgICAgICAgICAgIGV4cDogcGFyc2VJbmxpbmVDU1MocC52YWx1ZS5jb250ZW50LCBwLmxvYyksXHJcbiAgICAgICAgICAgICAgICAgICAgbW9kaWZpZXJzOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICBsb2M6IHAubG9jXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IHBhcnNlSW5saW5lQ1NTID0gKGNzc1RleHQsIGxvYykgPT4ge1xyXG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IHBhcnNlU3RyaW5nU3R5bGUoY3NzVGV4dCk7XHJcbiAgICByZXR1cm4gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihKU09OLnN0cmluZ2lmeShub3JtYWxpemVkKSwgZmFsc2UsIGxvYywgMyAvKiBDQU5fU1RSSU5HSUZZICovKTtcclxufTtcblxuZnVuY3Rpb24gY3JlYXRlRE9NQ29tcGlsZXJFcnJvcihjb2RlLCBsb2MpIHtcclxuICAgIHJldHVybiBjcmVhdGVDb21waWxlckVycm9yKGNvZGUsIGxvYywgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8ICF0cnVlID8gRE9NRXJyb3JNZXNzYWdlcyA6IHVuZGVmaW5lZCk7XHJcbn1cclxuY29uc3QgRE9NRXJyb3JNZXNzYWdlcyA9IHtcclxuICAgIFs1MCAvKiBYX1ZfSFRNTF9OT19FWFBSRVNTSU9OICovXTogYHYtaHRtbCBpcyBtaXNzaW5nIGV4cHJlc3Npb24uYCxcclxuICAgIFs1MSAvKiBYX1ZfSFRNTF9XSVRIX0NISUxEUkVOICovXTogYHYtaHRtbCB3aWxsIG92ZXJyaWRlIGVsZW1lbnQgY2hpbGRyZW4uYCxcclxuICAgIFs1MiAvKiBYX1ZfVEVYVF9OT19FWFBSRVNTSU9OICovXTogYHYtdGV4dCBpcyBtaXNzaW5nIGV4cHJlc3Npb24uYCxcclxuICAgIFs1MyAvKiBYX1ZfVEVYVF9XSVRIX0NISUxEUkVOICovXTogYHYtdGV4dCB3aWxsIG92ZXJyaWRlIGVsZW1lbnQgY2hpbGRyZW4uYCxcclxuICAgIFs1NCAvKiBYX1ZfTU9ERUxfT05fSU5WQUxJRF9FTEVNRU5UICovXTogYHYtbW9kZWwgY2FuIG9ubHkgYmUgdXNlZCBvbiA8aW5wdXQ+LCA8dGV4dGFyZWE+IGFuZCA8c2VsZWN0PiBlbGVtZW50cy5gLFxyXG4gICAgWzU1IC8qIFhfVl9NT0RFTF9BUkdfT05fRUxFTUVOVCAqL106IGB2LW1vZGVsIGFyZ3VtZW50IGlzIG5vdCBzdXBwb3J0ZWQgb24gcGxhaW4gZWxlbWVudHMuYCxcclxuICAgIFs1NiAvKiBYX1ZfTU9ERUxfT05fRklMRV9JTlBVVF9FTEVNRU5UICovXTogYHYtbW9kZWwgY2Fubm90IGJlIHVzZWQgb24gZmlsZSBpbnB1dHMgc2luY2UgdGhleSBhcmUgcmVhZC1vbmx5LiBVc2UgYSB2LW9uOmNoYW5nZSBsaXN0ZW5lciBpbnN0ZWFkLmAsXHJcbiAgICBbNTcgLyogWF9WX01PREVMX1VOTkVDRVNTQVJZX1ZBTFVFICovXTogYFVubmVjZXNzYXJ5IHZhbHVlIGJpbmRpbmcgdXNlZCBhbG9uZ3NpZGUgdi1tb2RlbC4gSXQgd2lsbCBpbnRlcmZlcmUgd2l0aCB2LW1vZGVsJ3MgYmVoYXZpb3IuYCxcclxuICAgIFs1OCAvKiBYX1ZfU0hPV19OT19FWFBSRVNTSU9OICovXTogYHYtc2hvdyBpcyBtaXNzaW5nIGV4cHJlc3Npb24uYCxcclxuICAgIFs1OSAvKiBYX1RSQU5TSVRJT05fSU5WQUxJRF9DSElMRFJFTiAqL106IGA8VHJhbnNpdGlvbj4gZXhwZWN0cyBleGFjdGx5IG9uZSBjaGlsZCBlbGVtZW50IG9yIGNvbXBvbmVudC5gLFxyXG4gICAgWzYwIC8qIFhfSUdOT1JFRF9TSURFX0VGRkVDVF9UQUcgKi9dOiBgVGFncyB3aXRoIHNpZGUgZWZmZWN0ICg8c2NyaXB0PiBhbmQgPHN0eWxlPikgYXJlIGlnbm9yZWQgaW4gY2xpZW50IGNvbXBvbmVudCB0ZW1wbGF0ZXMuYFxyXG59O1xuXG5jb25zdCB0cmFuc2Zvcm1WSHRtbCA9IChkaXIsIG5vZGUsIGNvbnRleHQpID0+IHtcclxuICAgIGNvbnN0IHsgZXhwLCBsb2MgfSA9IGRpcjtcclxuICAgIGlmICghZXhwKSB7XHJcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoNTAgLyogWF9WX0hUTUxfTk9fRVhQUkVTU0lPTiAqLywgbG9jKSk7XHJcbiAgICB9XHJcbiAgICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGgpIHtcclxuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlRE9NQ29tcGlsZXJFcnJvcig1MSAvKiBYX1ZfSFRNTF9XSVRIX0NISUxEUkVOICovLCBsb2MpKTtcclxuICAgICAgICBub2RlLmNoaWxkcmVuLmxlbmd0aCA9IDA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHByb3BzOiBbXHJcbiAgICAgICAgICAgIGNyZWF0ZU9iamVjdFByb3BlcnR5KGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYGlubmVySFRNTGAsIHRydWUsIGxvYyksIGV4cCB8fCBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKCcnLCB0cnVlKSlcclxuICAgICAgICBdXHJcbiAgICB9O1xyXG59O1xuXG5jb25zdCB0cmFuc2Zvcm1WVGV4dCA9IChkaXIsIG5vZGUsIGNvbnRleHQpID0+IHtcclxuICAgIGNvbnN0IHsgZXhwLCBsb2MgfSA9IGRpcjtcclxuICAgIGlmICghZXhwKSB7XHJcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoNTIgLyogWF9WX1RFWFRfTk9fRVhQUkVTU0lPTiAqLywgbG9jKSk7XHJcbiAgICB9XHJcbiAgICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGgpIHtcclxuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlRE9NQ29tcGlsZXJFcnJvcig1MyAvKiBYX1ZfVEVYVF9XSVRIX0NISUxEUkVOICovLCBsb2MpKTtcclxuICAgICAgICBub2RlLmNoaWxkcmVuLmxlbmd0aCA9IDA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHByb3BzOiBbXHJcbiAgICAgICAgICAgIGNyZWF0ZU9iamVjdFByb3BlcnR5KGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYHRleHRDb250ZW50YCwgdHJ1ZSksIGV4cFxyXG4gICAgICAgICAgICAgICAgPyBnZXRDb25zdGFudFR5cGUoZXhwLCBjb250ZXh0KSA+IDBcclxuICAgICAgICAgICAgICAgICAgICA/IGV4cFxyXG4gICAgICAgICAgICAgICAgICAgIDogY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXJTdHJpbmcoVE9fRElTUExBWV9TVFJJTkcpLCBbZXhwXSwgbG9jKVxyXG4gICAgICAgICAgICAgICAgOiBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKCcnLCB0cnVlKSlcclxuICAgICAgICBdXHJcbiAgICB9O1xyXG59O1xuXG5jb25zdCB0cmFuc2Zvcm1Nb2RlbCA9IChkaXIsIG5vZGUsIGNvbnRleHQpID0+IHtcclxuICAgIGNvbnN0IGJhc2VSZXN1bHQgPSB0cmFuc2Zvcm1Nb2RlbCQxKGRpciwgbm9kZSwgY29udGV4dCk7XHJcbiAgICAvLyBiYXNlIHRyYW5zZm9ybSBoYXMgZXJyb3JzIE9SIGNvbXBvbmVudCB2LW1vZGVsIChvbmx5IG5lZWQgcHJvcHMpXHJcbiAgICBpZiAoIWJhc2VSZXN1bHQucHJvcHMubGVuZ3RoIHx8IG5vZGUudGFnVHlwZSA9PT0gMSAvKiBDT01QT05FTlQgKi8pIHtcclxuICAgICAgICByZXR1cm4gYmFzZVJlc3VsdDtcclxuICAgIH1cclxuICAgIGlmIChkaXIuYXJnKSB7XHJcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoNTUgLyogWF9WX01PREVMX0FSR19PTl9FTEVNRU5UICovLCBkaXIuYXJnLmxvYykpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY2hlY2tEdXBsaWNhdGVkVmFsdWUoKSB7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBmaW5kUHJvcChub2RlLCAndmFsdWUnKTtcclxuICAgICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoNTcgLyogWF9WX01PREVMX1VOTkVDRVNTQVJZX1ZBTFVFICovLCB2YWx1ZS5sb2MpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCB7IHRhZyB9ID0gbm9kZTtcclxuICAgIGNvbnN0IGlzQ3VzdG9tRWxlbWVudCA9IGNvbnRleHQuaXNDdXN0b21FbGVtZW50KHRhZyk7XHJcbiAgICBpZiAodGFnID09PSAnaW5wdXQnIHx8XHJcbiAgICAgICAgdGFnID09PSAndGV4dGFyZWEnIHx8XHJcbiAgICAgICAgdGFnID09PSAnc2VsZWN0JyB8fFxyXG4gICAgICAgIGlzQ3VzdG9tRWxlbWVudCkge1xyXG4gICAgICAgIGxldCBkaXJlY3RpdmVUb1VzZSA9IFZfTU9ERUxfVEVYVDtcclxuICAgICAgICBsZXQgaXNJbnZhbGlkVHlwZSA9IGZhbHNlO1xyXG4gICAgICAgIGlmICh0YWcgPT09ICdpbnB1dCcgfHwgaXNDdXN0b21FbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBmaW5kUHJvcChub2RlLCBgdHlwZWApO1xyXG4gICAgICAgICAgICBpZiAodHlwZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUudHlwZSA9PT0gNyAvKiBESVJFQ1RJVkUgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyA6dHlwZT1cImZvb1wiXHJcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aXZlVG9Vc2UgPSBWX01PREVMX0RZTkFNSUM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlLnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0eXBlLnZhbHVlLmNvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncmFkaW8nOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aXZlVG9Vc2UgPSBWX01PREVMX1JBRElPO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NoZWNrYm94JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGl2ZVRvVXNlID0gVl9NT0RFTF9DSEVDS0JPWDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdmaWxlJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzSW52YWxpZFR5cGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoNTYgLyogWF9WX01PREVMX09OX0ZJTEVfSU5QVVRfRUxFTUVOVCAqLywgZGlyLmxvYykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0ZXh0IHR5cGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBjaGVja0R1cGxpY2F0ZWRWYWx1ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGhhc0R5bmFtaWNLZXlWQmluZChub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gZWxlbWVudCBoYXMgYmluZGluZ3Mgd2l0aCBkeW5hbWljIGtleXMsIHdoaWNoIGNhbiBwb3NzaWJseSBjb250YWluXHJcbiAgICAgICAgICAgICAgICAvLyBcInR5cGVcIi5cclxuICAgICAgICAgICAgICAgIGRpcmVjdGl2ZVRvVXNlID0gVl9NT0RFTF9EWU5BTUlDO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gdGV4dCB0eXBlXHJcbiAgICAgICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgY2hlY2tEdXBsaWNhdGVkVmFsdWUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0YWcgPT09ICdzZWxlY3QnKSB7XHJcbiAgICAgICAgICAgIGRpcmVjdGl2ZVRvVXNlID0gVl9NT0RFTF9TRUxFQ1Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB0ZXh0YXJlYVxyXG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgY2hlY2tEdXBsaWNhdGVkVmFsdWUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaW5qZWN0IHJ1bnRpbWUgZGlyZWN0aXZlXHJcbiAgICAgICAgLy8gYnkgcmV0dXJuaW5nIHRoZSBoZWxwZXIgc3ltYm9sIHZpYSBuZWVkUnVudGltZVxyXG4gICAgICAgIC8vIHRoZSBpbXBvcnQgd2lsbCByZXBsYWNlZCBhIHJlc29sdmVEaXJlY3RpdmUgY2FsbC5cclxuICAgICAgICBpZiAoIWlzSW52YWxpZFR5cGUpIHtcclxuICAgICAgICAgICAgYmFzZVJlc3VsdC5uZWVkUnVudGltZSA9IGNvbnRleHQuaGVscGVyKGRpcmVjdGl2ZVRvVXNlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlRE9NQ29tcGlsZXJFcnJvcig1NCAvKiBYX1ZfTU9ERUxfT05fSU5WQUxJRF9FTEVNRU5UICovLCBkaXIubG9jKSk7XHJcbiAgICB9XHJcbiAgICAvLyBuYXRpdmUgdm1vZGVsIGRvZXNuJ3QgbmVlZCB0aGUgYG1vZGVsVmFsdWVgIHByb3BzIHNpbmNlIHRoZXkgYXJlIGFsc29cclxuICAgIC8vIHBhc3NlZCB0byB0aGUgcnVudGltZSBhcyBgYmluZGluZy52YWx1ZWAuIHJlbW92aW5nIGl0IHJlZHVjZXMgY29kZSBzaXplLlxyXG4gICAgYmFzZVJlc3VsdC5wcm9wcyA9IGJhc2VSZXN1bHQucHJvcHMuZmlsdGVyKHAgPT4gIShwLmtleS50eXBlID09PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovICYmXHJcbiAgICAgICAgcC5rZXkuY29udGVudCA9PT0gJ21vZGVsVmFsdWUnKSk7XHJcbiAgICByZXR1cm4gYmFzZVJlc3VsdDtcclxufTtcblxuY29uc3QgaXNFdmVudE9wdGlvbk1vZGlmaWVyID0gLyojX19QVVJFX18qLyBtYWtlTWFwKGBwYXNzaXZlLG9uY2UsY2FwdHVyZWApO1xyXG5jb25zdCBpc05vbktleU1vZGlmaWVyID0gLyojX19QVVJFX18qLyBtYWtlTWFwKFxyXG4vLyBldmVudCBwcm9wYWdhdGlvbiBtYW5hZ2VtZW50XHJcbmBzdG9wLHByZXZlbnQsc2VsZixgICtcclxuICAgIC8vIHN5c3RlbSBtb2RpZmllcnMgKyBleGFjdFxyXG4gICAgYGN0cmwsc2hpZnQsYWx0LG1ldGEsZXhhY3QsYCArXHJcbiAgICAvLyBtb3VzZVxyXG4gICAgYG1pZGRsZWApO1xyXG4vLyBsZWZ0ICYgcmlnaHQgY291bGQgYmUgbW91c2Ugb3Iga2V5IG1vZGlmaWVycyBiYXNlZCBvbiBldmVudCB0eXBlXHJcbmNvbnN0IG1heWJlS2V5TW9kaWZpZXIgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoJ2xlZnQscmlnaHQnKTtcclxuY29uc3QgaXNLZXlib2FyZEV2ZW50ID0gLyojX19QVVJFX18qLyBtYWtlTWFwKGBvbmtleXVwLG9ua2V5ZG93bixvbmtleXByZXNzYCwgdHJ1ZSk7XHJcbmNvbnN0IHJlc29sdmVNb2RpZmllcnMgPSAoa2V5LCBtb2RpZmllcnMsIGNvbnRleHQsIGxvYykgPT4ge1xyXG4gICAgY29uc3Qga2V5TW9kaWZpZXJzID0gW107XHJcbiAgICBjb25zdCBub25LZXlNb2RpZmllcnMgPSBbXTtcclxuICAgIGNvbnN0IGV2ZW50T3B0aW9uTW9kaWZpZXJzID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1vZGlmaWVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IG1vZGlmaWVyID0gbW9kaWZpZXJzW2ldO1xyXG4gICAgICAgIGlmIChtb2RpZmllciA9PT0gJ25hdGl2ZScgJiZcclxuICAgICAgICAgICAgY2hlY2tDb21wYXRFbmFibGVkKFwiQ09NUElMRVJfVl9PTl9OQVRJVkVcIiAvKiBDT01QSUxFUl9WX09OX05BVElWRSAqLywgY29udGV4dCwgbG9jKSkge1xyXG4gICAgICAgICAgICBldmVudE9wdGlvbk1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNFdmVudE9wdGlvbk1vZGlmaWVyKG1vZGlmaWVyKSkge1xyXG4gICAgICAgICAgICAvLyBldmVudE9wdGlvbk1vZGlmaWVyczogbW9kaWZpZXJzIGZvciBhZGRFdmVudExpc3RlbmVyKCkgb3B0aW9ucyxcclxuICAgICAgICAgICAgLy8gZS5nLiAucGFzc2l2ZSAmIC5jYXB0dXJlXHJcbiAgICAgICAgICAgIGV2ZW50T3B0aW9uTW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gcnVudGltZU1vZGlmaWVyczogbW9kaWZpZXJzIHRoYXQgbmVlZHMgcnVudGltZSBndWFyZHNcclxuICAgICAgICAgICAgaWYgKG1heWJlS2V5TW9kaWZpZXIobW9kaWZpZXIpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNTdGF0aWNFeHAoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0tleWJvYXJkRXZlbnQoa2V5LmNvbnRlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleU1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vbktleU1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBrZXlNb2RpZmllcnMucHVzaChtb2RpZmllcik7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9uS2V5TW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTm9uS2V5TW9kaWZpZXIobW9kaWZpZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9uS2V5TW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAga2V5TW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBrZXlNb2RpZmllcnMsXHJcbiAgICAgICAgbm9uS2V5TW9kaWZpZXJzLFxyXG4gICAgICAgIGV2ZW50T3B0aW9uTW9kaWZpZXJzXHJcbiAgICB9O1xyXG59O1xyXG5jb25zdCB0cmFuc2Zvcm1DbGljayA9IChrZXksIGV2ZW50KSA9PiB7XHJcbiAgICBjb25zdCBpc1N0YXRpY0NsaWNrID0gaXNTdGF0aWNFeHAoa2V5KSAmJiBrZXkuY29udGVudC50b0xvd2VyQ2FzZSgpID09PSAnb25jbGljayc7XHJcbiAgICByZXR1cm4gaXNTdGF0aWNDbGlja1xyXG4gICAgICAgID8gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihldmVudCwgdHJ1ZSlcclxuICAgICAgICA6IGtleS50eXBlICE9PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovXHJcbiAgICAgICAgICAgID8gY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uKFtcclxuICAgICAgICAgICAgICAgIGAoYCxcclxuICAgICAgICAgICAgICAgIGtleSxcclxuICAgICAgICAgICAgICAgIGApID09PSBcIm9uQ2xpY2tcIiA/IFwiJHtldmVudH1cIiA6IChgLFxyXG4gICAgICAgICAgICAgICAga2V5LFxyXG4gICAgICAgICAgICAgICAgYClgXHJcbiAgICAgICAgICAgIF0pXHJcbiAgICAgICAgICAgIDoga2V5O1xyXG59O1xyXG5jb25zdCB0cmFuc2Zvcm1PbiA9IChkaXIsIG5vZGUsIGNvbnRleHQpID0+IHtcclxuICAgIHJldHVybiB0cmFuc2Zvcm1PbiQxKGRpciwgbm9kZSwgY29udGV4dCwgYmFzZVJlc3VsdCA9PiB7XHJcbiAgICAgICAgY29uc3QgeyBtb2RpZmllcnMgfSA9IGRpcjtcclxuICAgICAgICBpZiAoIW1vZGlmaWVycy5sZW5ndGgpXHJcbiAgICAgICAgICAgIHJldHVybiBiYXNlUmVzdWx0O1xyXG4gICAgICAgIGxldCB7IGtleSwgdmFsdWU6IGhhbmRsZXJFeHAgfSA9IGJhc2VSZXN1bHQucHJvcHNbMF07XHJcbiAgICAgICAgY29uc3QgeyBrZXlNb2RpZmllcnMsIG5vbktleU1vZGlmaWVycywgZXZlbnRPcHRpb25Nb2RpZmllcnMgfSA9IHJlc29sdmVNb2RpZmllcnMoa2V5LCBtb2RpZmllcnMsIGNvbnRleHQsIGRpci5sb2MpO1xyXG4gICAgICAgIC8vIG5vcm1hbGl6ZSBjbGljay5yaWdodCBhbmQgY2xpY2subWlkZGxlIHNpbmNlIHRoZXkgZG9uJ3QgYWN0dWFsbHkgZmlyZVxyXG4gICAgICAgIGlmIChub25LZXlNb2RpZmllcnMuaW5jbHVkZXMoJ3JpZ2h0JykpIHtcclxuICAgICAgICAgICAga2V5ID0gdHJhbnNmb3JtQ2xpY2soa2V5LCBgb25Db250ZXh0bWVudWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobm9uS2V5TW9kaWZpZXJzLmluY2x1ZGVzKCdtaWRkbGUnKSkge1xyXG4gICAgICAgICAgICBrZXkgPSB0cmFuc2Zvcm1DbGljayhrZXksIGBvbk1vdXNldXBgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5vbktleU1vZGlmaWVycy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgaGFuZGxlckV4cCA9IGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKFZfT05fV0lUSF9NT0RJRklFUlMpLCBbXHJcbiAgICAgICAgICAgICAgICBoYW5kbGVyRXhwLFxyXG4gICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkobm9uS2V5TW9kaWZpZXJzKVxyXG4gICAgICAgICAgICBdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGtleU1vZGlmaWVycy5sZW5ndGggJiZcclxuICAgICAgICAgICAgLy8gaWYgZXZlbnQgbmFtZSBpcyBkeW5hbWljLCBhbHdheXMgd3JhcCB3aXRoIGtleXMgZ3VhcmRcclxuICAgICAgICAgICAgKCFpc1N0YXRpY0V4cChrZXkpIHx8IGlzS2V5Ym9hcmRFdmVudChrZXkuY29udGVudCkpKSB7XHJcbiAgICAgICAgICAgIGhhbmRsZXJFeHAgPSBjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlcihWX09OX1dJVEhfS0VZUyksIFtcclxuICAgICAgICAgICAgICAgIGhhbmRsZXJFeHAsXHJcbiAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShrZXlNb2RpZmllcnMpXHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZXZlbnRPcHRpb25Nb2RpZmllcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVyUG9zdGZpeCA9IGV2ZW50T3B0aW9uTW9kaWZpZXJzLm1hcChjYXBpdGFsaXplKS5qb2luKCcnKTtcclxuICAgICAgICAgICAga2V5ID0gaXNTdGF0aWNFeHAoa2V5KVxyXG4gICAgICAgICAgICAgICAgPyBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGAke2tleS5jb250ZW50fSR7bW9kaWZpZXJQb3N0Zml4fWAsIHRydWUpXHJcbiAgICAgICAgICAgICAgICA6IGNyZWF0ZUNvbXBvdW5kRXhwcmVzc2lvbihbYChgLCBrZXksIGApICsgXCIke21vZGlmaWVyUG9zdGZpeH1cImBdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcHJvcHM6IFtjcmVhdGVPYmplY3RQcm9wZXJ0eShrZXksIGhhbmRsZXJFeHApXVxyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxufTtcblxuY29uc3QgdHJhbnNmb3JtU2hvdyA9IChkaXIsIG5vZGUsIGNvbnRleHQpID0+IHtcclxuICAgIGNvbnN0IHsgZXhwLCBsb2MgfSA9IGRpcjtcclxuICAgIGlmICghZXhwKSB7XHJcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoNTggLyogWF9WX1NIT1dfTk9fRVhQUkVTU0lPTiAqLywgbG9jKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHByb3BzOiBbXSxcclxuICAgICAgICBuZWVkUnVudGltZTogY29udGV4dC5oZWxwZXIoVl9TSE9XKVxyXG4gICAgfTtcclxufTtcblxuY29uc3QgdHJhbnNmb3JtVHJhbnNpdGlvbiA9IChub2RlLCBjb250ZXh0KSA9PiB7XHJcbiAgICBpZiAobm9kZS50eXBlID09PSAxIC8qIEVMRU1FTlQgKi8gJiZcclxuICAgICAgICBub2RlLnRhZ1R5cGUgPT09IDEgLyogQ09NUE9ORU5UICovKSB7XHJcbiAgICAgICAgY29uc3QgY29tcG9uZW50ID0gY29udGV4dC5pc0J1aWx0SW5Db21wb25lbnQobm9kZS50YWcpO1xyXG4gICAgICAgIGlmIChjb21wb25lbnQgPT09IFRSQU5TSVRJT04pIHtcclxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghbm9kZS5jaGlsZHJlbi5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyB3YXJuIG11bHRpcGxlIHRyYW5zaXRpb24gY2hpbGRyZW5cclxuICAgICAgICAgICAgICAgIGlmIChoYXNNdWx0aXBsZUNoaWxkcmVuKG5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoNTkgLyogWF9UUkFOU0lUSU9OX0lOVkFMSURfQ0hJTERSRU4gKi8sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IG5vZGUuY2hpbGRyZW5bMF0ubG9jLnN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IG5vZGUuY2hpbGRyZW5bbm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxXS5sb2MuZW5kLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6ICcnXHJcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgaXQncyBzIHNpbmdsZSBjaGlsZCB3LyB2LXNob3dcclxuICAgICAgICAgICAgICAgIC8vIGlmIHllcywgaW5qZWN0IFwicGVyc2lzdGVkOiB0cnVlXCIgdG8gdGhlIHRyYW5zaXRpb24gcHJvcHNcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gbm9kZS5jaGlsZHJlblswXTtcclxuICAgICAgICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSAxIC8qIEVMRU1FTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHAgb2YgY2hpbGQucHJvcHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHAudHlwZSA9PT0gNyAvKiBESVJFQ1RJVkUgKi8gJiYgcC5uYW1lID09PSAnc2hvdycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucHJvcHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogNiAvKiBBVFRSSUJVVEUgKi8sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3BlcnNpc3RlZCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2M6IG5vZGUubG9jXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uIGhhc011bHRpcGxlQ2hpbGRyZW4obm9kZSkge1xyXG4gICAgLy8gIzEzNTIgZmlsdGVyIG91dCBwb3RlbnRpYWwgY29tbWVudCBub2Rlcy5cclxuICAgIGNvbnN0IGNoaWxkcmVuID0gKG5vZGUuY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuLmZpbHRlcihjID0+IGMudHlwZSAhPT0gMyAvKiBDT01NRU5UICovICYmXHJcbiAgICAgICAgIShjLnR5cGUgPT09IDIgLyogVEVYVCAqLyAmJiAhYy5jb250ZW50LnRyaW0oKSkpKTtcclxuICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5bMF07XHJcbiAgICByZXR1cm4gKGNoaWxkcmVuLmxlbmd0aCAhPT0gMSB8fFxyXG4gICAgICAgIGNoaWxkLnR5cGUgPT09IDExIC8qIEZPUiAqLyB8fFxyXG4gICAgICAgIChjaGlsZC50eXBlID09PSA5IC8qIElGICovICYmIGNoaWxkLmJyYW5jaGVzLnNvbWUoaGFzTXVsdGlwbGVDaGlsZHJlbikpKTtcclxufVxuXG5jb25zdCBpZ25vcmVTaWRlRWZmZWN0VGFncyA9IChub2RlLCBjb250ZXh0KSA9PiB7XHJcbiAgICBpZiAobm9kZS50eXBlID09PSAxIC8qIEVMRU1FTlQgKi8gJiZcclxuICAgICAgICBub2RlLnRhZ1R5cGUgPT09IDAgLyogRUxFTUVOVCAqLyAmJlxyXG4gICAgICAgIChub2RlLnRhZyA9PT0gJ3NjcmlwdCcgfHwgbm9kZS50YWcgPT09ICdzdHlsZScpKSB7XHJcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoNjAgLyogWF9JR05PUkVEX1NJREVfRUZGRUNUX1RBRyAqLywgbm9kZS5sb2MpKTtcclxuICAgICAgICBjb250ZXh0LnJlbW92ZU5vZGUoKTtcclxuICAgIH1cclxufTtcblxuY29uc3QgRE9NTm9kZVRyYW5zZm9ybXMgPSBbXHJcbiAgICB0cmFuc2Zvcm1TdHlsZSxcclxuICAgIC4uLigocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBbdHJhbnNmb3JtVHJhbnNpdGlvbl0gOiBbXSlcclxuXTtcclxuY29uc3QgRE9NRGlyZWN0aXZlVHJhbnNmb3JtcyA9IHtcclxuICAgIGNsb2FrOiBub29wRGlyZWN0aXZlVHJhbnNmb3JtLFxyXG4gICAgaHRtbDogdHJhbnNmb3JtVkh0bWwsXHJcbiAgICB0ZXh0OiB0cmFuc2Zvcm1WVGV4dCxcclxuICAgIG1vZGVsOiB0cmFuc2Zvcm1Nb2RlbCxcclxuICAgIG9uOiB0cmFuc2Zvcm1PbixcclxuICAgIHNob3c6IHRyYW5zZm9ybVNob3dcclxufTtcclxuZnVuY3Rpb24gY29tcGlsZSh0ZW1wbGF0ZSwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICByZXR1cm4gYmFzZUNvbXBpbGUodGVtcGxhdGUsIGV4dGVuZCh7fSwgcGFyc2VyT3B0aW9ucywgb3B0aW9ucywge1xyXG4gICAgICAgIG5vZGVUcmFuc2Zvcm1zOiBbXHJcbiAgICAgICAgICAgIC8vIGlnbm9yZSA8c2NyaXB0PiBhbmQgPHRhZz5cclxuICAgICAgICAgICAgLy8gdGhpcyBpcyBub3QgcHV0IGluc2lkZSBET01Ob2RlVHJhbnNmb3JtcyBiZWNhdXNlIHRoYXQgbGlzdCBpcyB1c2VkXHJcbiAgICAgICAgICAgIC8vIGJ5IGNvbXBpbGVyLXNzciB0byBnZW5lcmF0ZSB2bm9kZSBmYWxsYmFjayBicmFuY2hlc1xyXG4gICAgICAgICAgICBpZ25vcmVTaWRlRWZmZWN0VGFncyxcclxuICAgICAgICAgICAgLi4uRE9NTm9kZVRyYW5zZm9ybXMsXHJcbiAgICAgICAgICAgIC4uLihvcHRpb25zLm5vZGVUcmFuc2Zvcm1zIHx8IFtdKVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgZGlyZWN0aXZlVHJhbnNmb3JtczogZXh0ZW5kKHt9LCBET01EaXJlY3RpdmVUcmFuc2Zvcm1zLCBvcHRpb25zLmRpcmVjdGl2ZVRyYW5zZm9ybXMgfHwge30pLFxyXG4gICAgICAgIHRyYW5zZm9ybUhvaXN0OiBudWxsIFxyXG4gICAgfSkpO1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlKHRlbXBsYXRlLCBvcHRpb25zID0ge30pIHtcclxuICAgIHJldHVybiBiYXNlUGFyc2UodGVtcGxhdGUsIGV4dGVuZCh7fSwgcGFyc2VyT3B0aW9ucywgb3B0aW9ucykpO1xyXG59XG5cbmV4cG9ydCB7IERPTURpcmVjdGl2ZVRyYW5zZm9ybXMsIERPTU5vZGVUcmFuc2Zvcm1zLCBUUkFOU0lUSU9OLCBUUkFOU0lUSU9OX0dST1VQLCBWX01PREVMX0NIRUNLQk9YLCBWX01PREVMX0RZTkFNSUMsIFZfTU9ERUxfUkFESU8sIFZfTU9ERUxfU0VMRUNULCBWX01PREVMX1RFWFQsIFZfT05fV0lUSF9LRVlTLCBWX09OX1dJVEhfTU9ESUZJRVJTLCBWX1NIT1csIGNvbXBpbGUsIGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IsIHBhcnNlLCBwYXJzZXJPcHRpb25zLCB0cmFuc2Zvcm1TdHlsZSB9O1xuIiwiZXhwb3J0IGNvbnN0IEhPT0tfU0VUVVAgPSAnZGV2dG9vbHMtcGx1Z2luOnNldHVwJztcbmV4cG9ydCBjb25zdCBIT09LX1BMVUdJTl9TRVRUSU5HU19TRVQgPSAncGx1Z2luOnNldHRpbmdzOnNldCc7XG4iLCJleHBvcnQgZnVuY3Rpb24gZ2V0RGV2dG9vbHNHbG9iYWxIb29rKCkge1xuICAgIHJldHVybiBnZXRUYXJnZXQoKS5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFRhcmdldCgpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgPyB3aW5kb3dcbiAgICAgICAgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgPyBnbG9iYWxcbiAgICAgICAgICAgIDoge307XG59XG5leHBvcnQgY29uc3QgaXNQcm94eUF2YWlsYWJsZSA9IHR5cGVvZiBQcm94eSA9PT0gJ2Z1bmN0aW9uJztcbiIsImltcG9ydCB7IGdldFRhcmdldCwgZ2V0RGV2dG9vbHNHbG9iYWxIb29rLCBpc1Byb3h5QXZhaWxhYmxlIH0gZnJvbSAnLi9lbnYnO1xuaW1wb3J0IHsgSE9PS19TRVRVUCB9IGZyb20gJy4vY29uc3QnO1xuaW1wb3J0IHsgQXBpUHJveHkgfSBmcm9tICcuL3Byb3h5JztcbmV4cG9ydCAqIGZyb20gJy4vYXBpJztcbmV4cG9ydCAqIGZyb20gJy4vcGx1Z2luJztcbmV4cG9ydCAqIGZyb20gJy4vdGltZSc7XG5leHBvcnQgZnVuY3Rpb24gc2V0dXBEZXZ0b29sc1BsdWdpbihwbHVnaW5EZXNjcmlwdG9yLCBzZXR1cEZuKSB7XG4gICAgY29uc3QgZGVzY3JpcHRvciA9IHBsdWdpbkRlc2NyaXB0b3I7XG4gICAgY29uc3QgdGFyZ2V0ID0gZ2V0VGFyZ2V0KCk7XG4gICAgY29uc3QgaG9vayA9IGdldERldnRvb2xzR2xvYmFsSG9vaygpO1xuICAgIGNvbnN0IGVuYWJsZVByb3h5ID0gaXNQcm94eUF2YWlsYWJsZSAmJiBkZXNjcmlwdG9yLmVuYWJsZUVhcmx5UHJveHk7XG4gICAgaWYgKGhvb2sgJiYgKHRhcmdldC5fX1ZVRV9ERVZUT09MU19QTFVHSU5fQVBJX0FWQUlMQUJMRV9fIHx8ICFlbmFibGVQcm94eSkpIHtcbiAgICAgICAgaG9vay5lbWl0KEhPT0tfU0VUVVAsIHBsdWdpbkRlc2NyaXB0b3IsIHNldHVwRm4pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgcHJveHkgPSBlbmFibGVQcm94eSA/IG5ldyBBcGlQcm94eShkZXNjcmlwdG9yLCBob29rKSA6IG51bGw7XG4gICAgICAgIGNvbnN0IGxpc3QgPSB0YXJnZXQuX19WVUVfREVWVE9PTFNfUExVR0lOU19fID0gdGFyZ2V0Ll9fVlVFX0RFVlRPT0xTX1BMVUdJTlNfXyB8fCBbXTtcbiAgICAgICAgbGlzdC5wdXNoKHtcbiAgICAgICAgICAgIHBsdWdpbkRlc2NyaXB0b3I6IGRlc2NyaXB0b3IsXG4gICAgICAgICAgICBzZXR1cEZuLFxuICAgICAgICAgICAgcHJveHksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocHJveHkpXG4gICAgICAgICAgICBzZXR1cEZuKHByb3h5LnByb3hpZWRUYXJnZXQpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IEhPT0tfUExVR0lOX1NFVFRJTkdTX1NFVCB9IGZyb20gJy4vY29uc3QnO1xuaW1wb3J0IHsgbm93IH0gZnJvbSAnLi90aW1lJztcbmV4cG9ydCBjbGFzcyBBcGlQcm94eSB7XG4gICAgY29uc3RydWN0b3IocGx1Z2luLCBob29rKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy50YXJnZXRRdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLm9uUXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XG4gICAgICAgIHRoaXMuaG9vayA9IGhvb2s7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRTZXR0aW5ncyA9IHt9O1xuICAgICAgICBpZiAocGx1Z2luLnNldHRpbmdzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlkIGluIHBsdWdpbi5zZXR0aW5ncykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBwbHVnaW4uc2V0dGluZ3NbaWRdO1xuICAgICAgICAgICAgICAgIGRlZmF1bHRTZXR0aW5nc1tpZF0gPSBpdGVtLmRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsb2NhbFNldHRpbmdzU2F2ZUlkID0gYF9fdnVlLWRldnRvb2xzLXBsdWdpbi1zZXR0aW5nc19fJHtwbHVnaW4uaWR9YDtcbiAgICAgICAgbGV0IGN1cnJlbnRTZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRTZXR0aW5ncyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByYXcgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShsb2NhbFNldHRpbmdzU2F2ZUlkKTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKHJhdyk7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGN1cnJlbnRTZXR0aW5ncywgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIG5vb3BcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZhbGxiYWNrcyA9IHtcbiAgICAgICAgICAgIGdldFNldHRpbmdzKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50U2V0dGluZ3M7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0U2V0dGluZ3ModmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShsb2NhbFNldHRpbmdzU2F2ZUlkLCBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBub29wXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnRTZXR0aW5ncyA9IHZhbHVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5vdygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm93KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBpZiAoaG9vaykge1xuICAgICAgICAgICAgaG9vay5vbihIT09LX1BMVUdJTl9TRVRUSU5HU19TRVQsIChwbHVnaW5JZCwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocGx1Z2luSWQgPT09IHRoaXMucGx1Z2luLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmFsbGJhY2tzLnNldFNldHRpbmdzKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByb3hpZWRPbiA9IG5ldyBQcm94eSh7fSwge1xuICAgICAgICAgICAgZ2V0OiAoX3RhcmdldCwgcHJvcCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50YXJnZXQub25bcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25RdWV1ZS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IHByb3AsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnByb3hpZWRUYXJnZXQgPSBuZXcgUHJveHkoe30sIHtcbiAgICAgICAgICAgIGdldDogKF90YXJnZXQsIHByb3ApID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0W3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwcm9wID09PSAnb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3hpZWRPbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoT2JqZWN0LmtleXModGhpcy5mYWxsYmFja3MpLmluY2x1ZGVzKHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50YXJnZXRRdWV1ZS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IHByb3AsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlOiAoKSA9PiB7IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZhbGxiYWNrc1twcm9wXSguLi5hcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0UXVldWUucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogcHJvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBzZXRSZWFsVGFyZ2V0KHRhcmdldCkge1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMub25RdWV1ZSkge1xuICAgICAgICAgICAgdGhpcy50YXJnZXQub25baXRlbS5tZXRob2RdKC4uLml0ZW0uYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMudGFyZ2V0UXVldWUpIHtcbiAgICAgICAgICAgIGl0ZW0ucmVzb2x2ZShhd2FpdCB0aGlzLnRhcmdldFtpdGVtLm1ldGhvZF0oLi4uaXRlbS5hcmdzKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJsZXQgc3VwcG9ydGVkO1xubGV0IHBlcmY7XG5leHBvcnQgZnVuY3Rpb24gaXNQZXJmb3JtYW5jZVN1cHBvcnRlZCgpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKHN1cHBvcnRlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBzdXBwb3J0ZWQ7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucGVyZm9ybWFuY2UpIHtcbiAgICAgICAgc3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgcGVyZiA9IHdpbmRvdy5wZXJmb3JtYW5jZTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgKChfYSA9IGdsb2JhbC5wZXJmX2hvb2tzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGVyZm9ybWFuY2UpKSB7XG4gICAgICAgIHN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgIHBlcmYgPSBnbG9iYWwucGVyZl9ob29rcy5wZXJmb3JtYW5jZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN1cHBvcnRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gc3VwcG9ydGVkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG5vdygpIHtcbiAgICByZXR1cm4gaXNQZXJmb3JtYW5jZVN1cHBvcnRlZCgpID8gcGVyZi5ub3coKSA6IERhdGUubm93KCk7XG59XG4iLCJpbXBvcnQgeyBleHRlbmQsIGlzQXJyYXksIGlzTWFwLCBpc0ludGVnZXJLZXksIGhhc093biwgaXNTeW1ib2wsIGlzT2JqZWN0LCBoYXNDaGFuZ2VkLCBtYWtlTWFwLCBjYXBpdGFsaXplLCB0b1Jhd1R5cGUsIGRlZiwgaXNGdW5jdGlvbiwgTk9PUCB9IGZyb20gJ0B2dWUvc2hhcmVkJztcblxuZnVuY3Rpb24gd2Fybihtc2csIC4uLmFyZ3MpIHtcclxuICAgIGNvbnNvbGUud2FybihgW1Z1ZSB3YXJuXSAke21zZ31gLCAuLi5hcmdzKTtcclxufVxuXG5sZXQgYWN0aXZlRWZmZWN0U2NvcGU7XHJcbmNsYXNzIEVmZmVjdFNjb3BlIHtcclxuICAgIGNvbnN0cnVjdG9yKGRldGFjaGVkID0gZmFsc2UpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAaW50ZXJuYWxcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGludGVybmFsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5lZmZlY3RzID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGludGVybmFsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jbGVhbnVwcyA9IFtdO1xyXG4gICAgICAgIGlmICghZGV0YWNoZWQgJiYgYWN0aXZlRWZmZWN0U2NvcGUpIHtcclxuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBhY3RpdmVFZmZlY3RTY29wZTtcclxuICAgICAgICAgICAgdGhpcy5pbmRleCA9XHJcbiAgICAgICAgICAgICAgICAoYWN0aXZlRWZmZWN0U2NvcGUuc2NvcGVzIHx8IChhY3RpdmVFZmZlY3RTY29wZS5zY29wZXMgPSBbXSkpLnB1c2godGhpcykgLSAxO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJ1bihmbikge1xyXG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSkge1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50RWZmZWN0U2NvcGUgPSBhY3RpdmVFZmZlY3RTY29wZTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGFjdGl2ZUVmZmVjdFNjb3BlID0gdGhpcztcclxuICAgICAgICAgICAgICAgIHJldHVybiBmbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAgYWN0aXZlRWZmZWN0U2NvcGUgPSBjdXJyZW50RWZmZWN0U2NvcGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYGNhbm5vdCBydW4gYW4gaW5hY3RpdmUgZWZmZWN0IHNjb3BlLmApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gbm9uLWRldGFjaGVkIHNjb3Blc1xyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIG9uKCkge1xyXG4gICAgICAgIGFjdGl2ZUVmZmVjdFNjb3BlID0gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gbm9uLWRldGFjaGVkIHNjb3Blc1xyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIG9mZigpIHtcclxuICAgICAgICBhY3RpdmVFZmZlY3RTY29wZSA9IHRoaXMucGFyZW50O1xyXG4gICAgfVxyXG4gICAgc3RvcChmcm9tUGFyZW50KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlKSB7XHJcbiAgICAgICAgICAgIGxldCBpLCBsO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5lZmZlY3RzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lZmZlY3RzW2ldLnN0b3AoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5jbGVhbnVwcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2xlYW51cHNbaV0oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5zY29wZXMpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLnNjb3Blcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjb3Blc1tpXS5zdG9wKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIG5lc3RlZCBzY29wZSwgZGVyZWZlcmVuY2UgZnJvbSBwYXJlbnQgdG8gYXZvaWQgbWVtb3J5IGxlYWtzXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudCAmJiAhZnJvbVBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgLy8gb3B0aW1pemVkIE8oMSkgcmVtb3ZhbFxyXG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdCA9IHRoaXMucGFyZW50LnNjb3Blcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgIGlmIChsYXN0ICYmIGxhc3QgIT09IHRoaXMpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5zY29wZXNbdGhpcy5pbmRleF0gPSBsYXN0O1xyXG4gICAgICAgICAgICAgICAgICAgIGxhc3QuaW5kZXggPSB0aGlzLmluZGV4O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGVmZmVjdFNjb3BlKGRldGFjaGVkKSB7XHJcbiAgICByZXR1cm4gbmV3IEVmZmVjdFNjb3BlKGRldGFjaGVkKTtcclxufVxyXG5mdW5jdGlvbiByZWNvcmRFZmZlY3RTY29wZShlZmZlY3QsIHNjb3BlID0gYWN0aXZlRWZmZWN0U2NvcGUpIHtcclxuICAgIGlmIChzY29wZSAmJiBzY29wZS5hY3RpdmUpIHtcclxuICAgICAgICBzY29wZS5lZmZlY3RzLnB1c2goZWZmZWN0KTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRDdXJyZW50U2NvcGUoKSB7XHJcbiAgICByZXR1cm4gYWN0aXZlRWZmZWN0U2NvcGU7XHJcbn1cclxuZnVuY3Rpb24gb25TY29wZURpc3Bvc2UoZm4pIHtcclxuICAgIGlmIChhY3RpdmVFZmZlY3RTY29wZSkge1xyXG4gICAgICAgIGFjdGl2ZUVmZmVjdFNjb3BlLmNsZWFudXBzLnB1c2goZm4pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgd2Fybihgb25TY29wZURpc3Bvc2UoKSBpcyBjYWxsZWQgd2hlbiB0aGVyZSBpcyBubyBhY3RpdmUgZWZmZWN0IHNjb3BlYCArXHJcbiAgICAgICAgICAgIGAgdG8gYmUgYXNzb2NpYXRlZCB3aXRoLmApO1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IGNyZWF0ZURlcCA9IChlZmZlY3RzKSA9PiB7XHJcbiAgICBjb25zdCBkZXAgPSBuZXcgU2V0KGVmZmVjdHMpO1xyXG4gICAgZGVwLncgPSAwO1xyXG4gICAgZGVwLm4gPSAwO1xyXG4gICAgcmV0dXJuIGRlcDtcclxufTtcclxuY29uc3Qgd2FzVHJhY2tlZCA9IChkZXApID0+IChkZXAudyAmIHRyYWNrT3BCaXQpID4gMDtcclxuY29uc3QgbmV3VHJhY2tlZCA9IChkZXApID0+IChkZXAubiAmIHRyYWNrT3BCaXQpID4gMDtcclxuY29uc3QgaW5pdERlcE1hcmtlcnMgPSAoeyBkZXBzIH0pID0+IHtcclxuICAgIGlmIChkZXBzLmxlbmd0aCkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVwcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBkZXBzW2ldLncgfD0gdHJhY2tPcEJpdDsgLy8gc2V0IHdhcyB0cmFja2VkXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5jb25zdCBmaW5hbGl6ZURlcE1hcmtlcnMgPSAoZWZmZWN0KSA9PiB7XHJcbiAgICBjb25zdCB7IGRlcHMgfSA9IGVmZmVjdDtcclxuICAgIGlmIChkZXBzLmxlbmd0aCkge1xyXG4gICAgICAgIGxldCBwdHIgPSAwO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVwcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBkZXAgPSBkZXBzW2ldO1xyXG4gICAgICAgICAgICBpZiAod2FzVHJhY2tlZChkZXApICYmICFuZXdUcmFja2VkKGRlcCkpIHtcclxuICAgICAgICAgICAgICAgIGRlcC5kZWxldGUoZWZmZWN0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRlcHNbcHRyKytdID0gZGVwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGNsZWFyIGJpdHNcclxuICAgICAgICAgICAgZGVwLncgJj0gfnRyYWNrT3BCaXQ7XHJcbiAgICAgICAgICAgIGRlcC5uICY9IH50cmFja09wQml0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZXBzLmxlbmd0aCA9IHB0cjtcclxuICAgIH1cclxufTtcblxuY29uc3QgdGFyZ2V0TWFwID0gbmV3IFdlYWtNYXAoKTtcclxuLy8gVGhlIG51bWJlciBvZiBlZmZlY3RzIGN1cnJlbnRseSBiZWluZyB0cmFja2VkIHJlY3Vyc2l2ZWx5LlxyXG5sZXQgZWZmZWN0VHJhY2tEZXB0aCA9IDA7XHJcbmxldCB0cmFja09wQml0ID0gMTtcclxuLyoqXHJcbiAqIFRoZSBiaXR3aXNlIHRyYWNrIG1hcmtlcnMgc3VwcG9ydCBhdCBtb3N0IDMwIGxldmVscyBvZiByZWN1cnNpb24uXHJcbiAqIFRoaXMgdmFsdWUgaXMgY2hvc2VuIHRvIGVuYWJsZSBtb2Rlcm4gSlMgZW5naW5lcyB0byB1c2UgYSBTTUkgb24gYWxsIHBsYXRmb3Jtcy5cclxuICogV2hlbiByZWN1cnNpb24gZGVwdGggaXMgZ3JlYXRlciwgZmFsbCBiYWNrIHRvIHVzaW5nIGEgZnVsbCBjbGVhbnVwLlxyXG4gKi9cclxuY29uc3QgbWF4TWFya2VyQml0cyA9IDMwO1xyXG5sZXQgYWN0aXZlRWZmZWN0O1xyXG5jb25zdCBJVEVSQVRFX0tFWSA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyAnaXRlcmF0ZScgOiAnJyk7XHJcbmNvbnN0IE1BUF9LRVlfSVRFUkFURV9LRVkgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gJ01hcCBrZXkgaXRlcmF0ZScgOiAnJyk7XHJcbmNsYXNzIFJlYWN0aXZlRWZmZWN0IHtcclxuICAgIGNvbnN0cnVjdG9yKGZuLCBzY2hlZHVsZXIgPSBudWxsLCBzY29wZSkge1xyXG4gICAgICAgIHRoaXMuZm4gPSBmbjtcclxuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcclxuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5kZXBzID0gW107XHJcbiAgICAgICAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgcmVjb3JkRWZmZWN0U2NvcGUodGhpcywgc2NvcGUpO1xyXG4gICAgfVxyXG4gICAgcnVuKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5hY3RpdmUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm4oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHBhcmVudCA9IGFjdGl2ZUVmZmVjdDtcclxuICAgICAgICBsZXQgbGFzdFNob3VsZFRyYWNrID0gc2hvdWxkVHJhY2s7XHJcbiAgICAgICAgd2hpbGUgKHBhcmVudCkge1xyXG4gICAgICAgICAgICBpZiAocGFyZW50ID09PSB0aGlzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBhY3RpdmVFZmZlY3Q7XHJcbiAgICAgICAgICAgIGFjdGl2ZUVmZmVjdCA9IHRoaXM7XHJcbiAgICAgICAgICAgIHNob3VsZFRyYWNrID0gdHJ1ZTtcclxuICAgICAgICAgICAgdHJhY2tPcEJpdCA9IDEgPDwgKytlZmZlY3RUcmFja0RlcHRoO1xyXG4gICAgICAgICAgICBpZiAoZWZmZWN0VHJhY2tEZXB0aCA8PSBtYXhNYXJrZXJCaXRzKSB7XHJcbiAgICAgICAgICAgICAgICBpbml0RGVwTWFya2Vycyh0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNsZWFudXBFZmZlY3QodGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm4oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgIGlmIChlZmZlY3RUcmFja0RlcHRoIDw9IG1heE1hcmtlckJpdHMpIHtcclxuICAgICAgICAgICAgICAgIGZpbmFsaXplRGVwTWFya2Vycyh0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0cmFja09wQml0ID0gMSA8PCAtLWVmZmVjdFRyYWNrRGVwdGg7XHJcbiAgICAgICAgICAgIGFjdGl2ZUVmZmVjdCA9IHRoaXMucGFyZW50O1xyXG4gICAgICAgICAgICBzaG91bGRUcmFjayA9IGxhc3RTaG91bGRUcmFjaztcclxuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRlZmVyU3RvcCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdG9wKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdG9wKCkge1xyXG4gICAgICAgIC8vIHN0b3BwZWQgd2hpbGUgcnVubmluZyBpdHNlbGYgLSBkZWZlciB0aGUgY2xlYW51cFxyXG4gICAgICAgIGlmIChhY3RpdmVFZmZlY3QgPT09IHRoaXMpIHtcclxuICAgICAgICAgICAgdGhpcy5kZWZlclN0b3AgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmFjdGl2ZSkge1xyXG4gICAgICAgICAgICBjbGVhbnVwRWZmZWN0KHRoaXMpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vblN0b3ApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub25TdG9wKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY2xlYW51cEVmZmVjdChlZmZlY3QpIHtcclxuICAgIGNvbnN0IHsgZGVwcyB9ID0gZWZmZWN0O1xyXG4gICAgaWYgKGRlcHMubGVuZ3RoKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZXBzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGRlcHNbaV0uZGVsZXRlKGVmZmVjdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlcHMubGVuZ3RoID0gMDtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBlZmZlY3QoZm4sIG9wdGlvbnMpIHtcclxuICAgIGlmIChmbi5lZmZlY3QpIHtcclxuICAgICAgICBmbiA9IGZuLmVmZmVjdC5mbjtcclxuICAgIH1cclxuICAgIGNvbnN0IF9lZmZlY3QgPSBuZXcgUmVhY3RpdmVFZmZlY3QoZm4pO1xyXG4gICAgaWYgKG9wdGlvbnMpIHtcclxuICAgICAgICBleHRlbmQoX2VmZmVjdCwgb3B0aW9ucyk7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuc2NvcGUpXHJcbiAgICAgICAgICAgIHJlY29yZEVmZmVjdFNjb3BlKF9lZmZlY3QsIG9wdGlvbnMuc2NvcGUpO1xyXG4gICAgfVxyXG4gICAgaWYgKCFvcHRpb25zIHx8ICFvcHRpb25zLmxhenkpIHtcclxuICAgICAgICBfZWZmZWN0LnJ1bigpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcnVubmVyID0gX2VmZmVjdC5ydW4uYmluZChfZWZmZWN0KTtcclxuICAgIHJ1bm5lci5lZmZlY3QgPSBfZWZmZWN0O1xyXG4gICAgcmV0dXJuIHJ1bm5lcjtcclxufVxyXG5mdW5jdGlvbiBzdG9wKHJ1bm5lcikge1xyXG4gICAgcnVubmVyLmVmZmVjdC5zdG9wKCk7XHJcbn1cclxubGV0IHNob3VsZFRyYWNrID0gdHJ1ZTtcclxuY29uc3QgdHJhY2tTdGFjayA9IFtdO1xyXG5mdW5jdGlvbiBwYXVzZVRyYWNraW5nKCkge1xyXG4gICAgdHJhY2tTdGFjay5wdXNoKHNob3VsZFRyYWNrKTtcclxuICAgIHNob3VsZFRyYWNrID0gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gZW5hYmxlVHJhY2tpbmcoKSB7XHJcbiAgICB0cmFja1N0YWNrLnB1c2goc2hvdWxkVHJhY2spO1xyXG4gICAgc2hvdWxkVHJhY2sgPSB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIHJlc2V0VHJhY2tpbmcoKSB7XHJcbiAgICBjb25zdCBsYXN0ID0gdHJhY2tTdGFjay5wb3AoKTtcclxuICAgIHNob3VsZFRyYWNrID0gbGFzdCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGxhc3Q7XHJcbn1cclxuZnVuY3Rpb24gdHJhY2sodGFyZ2V0LCB0eXBlLCBrZXkpIHtcclxuICAgIGlmIChzaG91bGRUcmFjayAmJiBhY3RpdmVFZmZlY3QpIHtcclxuICAgICAgICBsZXQgZGVwc01hcCA9IHRhcmdldE1hcC5nZXQodGFyZ2V0KTtcclxuICAgICAgICBpZiAoIWRlcHNNYXApIHtcclxuICAgICAgICAgICAgdGFyZ2V0TWFwLnNldCh0YXJnZXQsIChkZXBzTWFwID0gbmV3IE1hcCgpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBkZXAgPSBkZXBzTWFwLmdldChrZXkpO1xyXG4gICAgICAgIGlmICghZGVwKSB7XHJcbiAgICAgICAgICAgIGRlcHNNYXAuc2V0KGtleSwgKGRlcCA9IGNyZWF0ZURlcCgpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGV2ZW50SW5mbyA9IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxyXG4gICAgICAgICAgICA/IHsgZWZmZWN0OiBhY3RpdmVFZmZlY3QsIHRhcmdldCwgdHlwZSwga2V5IH1cclxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgdHJhY2tFZmZlY3RzKGRlcCwgZXZlbnRJbmZvKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB0cmFja0VmZmVjdHMoZGVwLCBkZWJ1Z2dlckV2ZW50RXh0cmFJbmZvKSB7XHJcbiAgICBsZXQgc2hvdWxkVHJhY2sgPSBmYWxzZTtcclxuICAgIGlmIChlZmZlY3RUcmFja0RlcHRoIDw9IG1heE1hcmtlckJpdHMpIHtcclxuICAgICAgICBpZiAoIW5ld1RyYWNrZWQoZGVwKSkge1xyXG4gICAgICAgICAgICBkZXAubiB8PSB0cmFja09wQml0OyAvLyBzZXQgbmV3bHkgdHJhY2tlZFxyXG4gICAgICAgICAgICBzaG91bGRUcmFjayA9ICF3YXNUcmFja2VkKGRlcCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gRnVsbCBjbGVhbnVwIG1vZGUuXHJcbiAgICAgICAgc2hvdWxkVHJhY2sgPSAhZGVwLmhhcyhhY3RpdmVFZmZlY3QpO1xyXG4gICAgfVxyXG4gICAgaWYgKHNob3VsZFRyYWNrKSB7XHJcbiAgICAgICAgZGVwLmFkZChhY3RpdmVFZmZlY3QpO1xyXG4gICAgICAgIGFjdGl2ZUVmZmVjdC5kZXBzLnB1c2goZGVwKTtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGFjdGl2ZUVmZmVjdC5vblRyYWNrKSB7XHJcbiAgICAgICAgICAgIGFjdGl2ZUVmZmVjdC5vblRyYWNrKE9iamVjdC5hc3NpZ24oeyBlZmZlY3Q6IGFjdGl2ZUVmZmVjdCB9LCBkZWJ1Z2dlckV2ZW50RXh0cmFJbmZvKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHRyaWdnZXIodGFyZ2V0LCB0eXBlLCBrZXksIG5ld1ZhbHVlLCBvbGRWYWx1ZSwgb2xkVGFyZ2V0KSB7XHJcbiAgICBjb25zdCBkZXBzTWFwID0gdGFyZ2V0TWFwLmdldCh0YXJnZXQpO1xyXG4gICAgaWYgKCFkZXBzTWFwKSB7XHJcbiAgICAgICAgLy8gbmV2ZXIgYmVlbiB0cmFja2VkXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgbGV0IGRlcHMgPSBbXTtcclxuICAgIGlmICh0eXBlID09PSBcImNsZWFyXCIgLyogQ0xFQVIgKi8pIHtcclxuICAgICAgICAvLyBjb2xsZWN0aW9uIGJlaW5nIGNsZWFyZWRcclxuICAgICAgICAvLyB0cmlnZ2VyIGFsbCBlZmZlY3RzIGZvciB0YXJnZXRcclxuICAgICAgICBkZXBzID0gWy4uLmRlcHNNYXAudmFsdWVzKCldO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoa2V5ID09PSAnbGVuZ3RoJyAmJiBpc0FycmF5KHRhcmdldCkpIHtcclxuICAgICAgICBkZXBzTWFwLmZvckVhY2goKGRlcCwga2V5KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdsZW5ndGgnIHx8IGtleSA+PSBuZXdWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgZGVwcy5wdXNoKGRlcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIHNjaGVkdWxlIHJ1bnMgZm9yIFNFVCB8IEFERCB8IERFTEVURVxyXG4gICAgICAgIGlmIChrZXkgIT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICBkZXBzLnB1c2goZGVwc01hcC5nZXQoa2V5KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGFsc28gcnVuIGZvciBpdGVyYXRpb24ga2V5IG9uIEFERCB8IERFTEVURSB8IE1hcC5TRVRcclxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSBcImFkZFwiIC8qIEFERCAqLzpcclxuICAgICAgICAgICAgICAgIGlmICghaXNBcnJheSh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVwcy5wdXNoKGRlcHNNYXAuZ2V0KElURVJBVEVfS0VZKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTWFwKHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVwcy5wdXNoKGRlcHNNYXAuZ2V0KE1BUF9LRVlfSVRFUkFURV9LRVkpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0ludGVnZXJLZXkoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5ldyBpbmRleCBhZGRlZCB0byBhcnJheSAtPiBsZW5ndGggY2hhbmdlc1xyXG4gICAgICAgICAgICAgICAgICAgIGRlcHMucHVzaChkZXBzTWFwLmdldCgnbGVuZ3RoJykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJkZWxldGVcIiAvKiBERUxFVEUgKi86XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzQXJyYXkodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlcHMucHVzaChkZXBzTWFwLmdldChJVEVSQVRFX0tFWSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc01hcCh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcHMucHVzaChkZXBzTWFwLmdldChNQVBfS0VZX0lURVJBVEVfS0VZKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJzZXRcIiAvKiBTRVQgKi86XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNNYXAodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlcHMucHVzaChkZXBzTWFwLmdldChJVEVSQVRFX0tFWSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgZXZlbnRJbmZvID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXHJcbiAgICAgICAgPyB7IHRhcmdldCwgdHlwZSwga2V5LCBuZXdWYWx1ZSwgb2xkVmFsdWUsIG9sZFRhcmdldCB9XHJcbiAgICAgICAgOiB1bmRlZmluZWQ7XHJcbiAgICBpZiAoZGVwcy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICBpZiAoZGVwc1swXSkge1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRWZmZWN0cyhkZXBzWzBdLCBldmVudEluZm8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdHJpZ2dlckVmZmVjdHMoZGVwc1swXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBlZmZlY3RzID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCBkZXAgb2YgZGVwcykge1xyXG4gICAgICAgICAgICBpZiAoZGVwKSB7XHJcbiAgICAgICAgICAgICAgICBlZmZlY3RzLnB1c2goLi4uZGVwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHRyaWdnZXJFZmZlY3RzKGNyZWF0ZURlcChlZmZlY3RzKSwgZXZlbnRJbmZvKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRyaWdnZXJFZmZlY3RzKGNyZWF0ZURlcChlZmZlY3RzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHRyaWdnZXJFZmZlY3RzKGRlcCwgZGVidWdnZXJFdmVudEV4dHJhSW5mbykge1xyXG4gICAgLy8gc3ByZWFkIGludG8gYXJyYXkgZm9yIHN0YWJpbGl6YXRpb25cclxuICAgIGNvbnN0IGVmZmVjdHMgPSBpc0FycmF5KGRlcCkgPyBkZXAgOiBbLi4uZGVwXTtcclxuICAgIGZvciAoY29uc3QgZWZmZWN0IG9mIGVmZmVjdHMpIHtcclxuICAgICAgICBpZiAoZWZmZWN0LmNvbXB1dGVkKSB7XHJcbiAgICAgICAgICAgIHRyaWdnZXJFZmZlY3QoZWZmZWN0LCBkZWJ1Z2dlckV2ZW50RXh0cmFJbmZvKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IGVmZmVjdCBvZiBlZmZlY3RzKSB7XHJcbiAgICAgICAgaWYgKCFlZmZlY3QuY29tcHV0ZWQpIHtcclxuICAgICAgICAgICAgdHJpZ2dlckVmZmVjdChlZmZlY3QsIGRlYnVnZ2VyRXZlbnRFeHRyYUluZm8pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB0cmlnZ2VyRWZmZWN0KGVmZmVjdCwgZGVidWdnZXJFdmVudEV4dHJhSW5mbykge1xyXG4gICAgaWYgKGVmZmVjdCAhPT0gYWN0aXZlRWZmZWN0IHx8IGVmZmVjdC5hbGxvd1JlY3Vyc2UpIHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGVmZmVjdC5vblRyaWdnZXIpIHtcclxuICAgICAgICAgICAgZWZmZWN0Lm9uVHJpZ2dlcihleHRlbmQoeyBlZmZlY3QgfSwgZGVidWdnZXJFdmVudEV4dHJhSW5mbykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZWZmZWN0LnNjaGVkdWxlcikge1xyXG4gICAgICAgICAgICBlZmZlY3Quc2NoZWR1bGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBlZmZlY3QucnVuKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmNvbnN0IGlzTm9uVHJhY2thYmxlS2V5cyA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChgX19wcm90b19fLF9fdl9pc1JlZixfX2lzVnVlYCk7XHJcbmNvbnN0IGJ1aWx0SW5TeW1ib2xzID0gbmV3IFNldChcclxuLyojX19QVVJFX18qL1xyXG5PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhTeW1ib2wpXHJcbiAgICAvLyBpb3MxMC54IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKFN5bWJvbCkgY2FuIGVudW1lcmF0ZSAnYXJndW1lbnRzJyBhbmQgJ2NhbGxlcidcclxuICAgIC8vIGJ1dCBhY2Nlc3NpbmcgdGhlbSBvbiBTeW1ib2wgbGVhZHMgdG8gVHlwZUVycm9yIGJlY2F1c2UgU3ltYm9sIGlzIGEgc3RyaWN0IG1vZGVcclxuICAgIC8vIGZ1bmN0aW9uXHJcbiAgICAuZmlsdGVyKGtleSA9PiBrZXkgIT09ICdhcmd1bWVudHMnICYmIGtleSAhPT0gJ2NhbGxlcicpXHJcbiAgICAubWFwKGtleSA9PiBTeW1ib2xba2V5XSlcclxuICAgIC5maWx0ZXIoaXNTeW1ib2wpKTtcclxuY29uc3QgZ2V0ID0gLyojX19QVVJFX18qLyBjcmVhdGVHZXR0ZXIoKTtcclxuY29uc3Qgc2hhbGxvd0dldCA9IC8qI19fUFVSRV9fKi8gY3JlYXRlR2V0dGVyKGZhbHNlLCB0cnVlKTtcclxuY29uc3QgcmVhZG9ubHlHZXQgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZUdldHRlcih0cnVlKTtcclxuY29uc3Qgc2hhbGxvd1JlYWRvbmx5R2V0ID0gLyojX19QVVJFX18qLyBjcmVhdGVHZXR0ZXIodHJ1ZSwgdHJ1ZSk7XHJcbmNvbnN0IGFycmF5SW5zdHJ1bWVudGF0aW9ucyA9IC8qI19fUFVSRV9fKi8gY3JlYXRlQXJyYXlJbnN0cnVtZW50YXRpb25zKCk7XHJcbmZ1bmN0aW9uIGNyZWF0ZUFycmF5SW5zdHJ1bWVudGF0aW9ucygpIHtcclxuICAgIGNvbnN0IGluc3RydW1lbnRhdGlvbnMgPSB7fTtcclxuICAgIFsnaW5jbHVkZXMnLCAnaW5kZXhPZicsICdsYXN0SW5kZXhPZiddLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICBpbnN0cnVtZW50YXRpb25zW2tleV0gPSBmdW5jdGlvbiAoLi4uYXJncykge1xyXG4gICAgICAgICAgICBjb25zdCBhcnIgPSB0b1Jhdyh0aGlzKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdHJhY2soYXJyLCBcImdldFwiIC8qIEdFVCAqLywgaSArICcnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyB3ZSBydW4gdGhlIG1ldGhvZCB1c2luZyB0aGUgb3JpZ2luYWwgYXJncyBmaXJzdCAod2hpY2ggbWF5IGJlIHJlYWN0aXZlKVxyXG4gICAgICAgICAgICBjb25zdCByZXMgPSBhcnJba2V5XSguLi5hcmdzKTtcclxuICAgICAgICAgICAgaWYgKHJlcyA9PT0gLTEgfHwgcmVzID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhhdCBkaWRuJ3Qgd29yaywgcnVuIGl0IGFnYWluIHVzaW5nIHJhdyB2YWx1ZXMuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyW2tleV0oLi4uYXJncy5tYXAodG9SYXcpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcbiAgICBbJ3B1c2gnLCAncG9wJywgJ3NoaWZ0JywgJ3Vuc2hpZnQnLCAnc3BsaWNlJ10uZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgIGluc3RydW1lbnRhdGlvbnNba2V5XSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XHJcbiAgICAgICAgICAgIHBhdXNlVHJhY2tpbmcoKTtcclxuICAgICAgICAgICAgY29uc3QgcmVzID0gdG9SYXcodGhpcylba2V5XS5hcHBseSh0aGlzLCBhcmdzKTtcclxuICAgICAgICAgICAgcmVzZXRUcmFja2luZygpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBpbnN0cnVtZW50YXRpb25zO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUdldHRlcihpc1JlYWRvbmx5ID0gZmFsc2UsIHNoYWxsb3cgPSBmYWxzZSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGdldCh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpIHtcclxuICAgICAgICBpZiAoa2V5ID09PSBcIl9fdl9pc1JlYWN0aXZlXCIgLyogSVNfUkVBQ1RJVkUgKi8pIHtcclxuICAgICAgICAgICAgcmV0dXJuICFpc1JlYWRvbmx5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwiX192X2lzUmVhZG9ubHlcIiAvKiBJU19SRUFET05MWSAqLykge1xyXG4gICAgICAgICAgICByZXR1cm4gaXNSZWFkb25seTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBcIl9fdl9pc1NoYWxsb3dcIiAvKiBJU19TSEFMTE9XICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzaGFsbG93O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwiX192X3Jhd1wiIC8qIFJBVyAqLyAmJlxyXG4gICAgICAgICAgICByZWNlaXZlciA9PT1cclxuICAgICAgICAgICAgICAgIChpc1JlYWRvbmx5XHJcbiAgICAgICAgICAgICAgICAgICAgPyBzaGFsbG93XHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc2hhbGxvd1JlYWRvbmx5TWFwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcmVhZG9ubHlNYXBcclxuICAgICAgICAgICAgICAgICAgICA6IHNoYWxsb3dcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBzaGFsbG93UmVhY3RpdmVNYXBcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiByZWFjdGl2ZU1hcCkuZ2V0KHRhcmdldCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0SXNBcnJheSA9IGlzQXJyYXkodGFyZ2V0KTtcclxuICAgICAgICBpZiAoIWlzUmVhZG9ubHkgJiYgdGFyZ2V0SXNBcnJheSAmJiBoYXNPd24oYXJyYXlJbnN0cnVtZW50YXRpb25zLCBrZXkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldChhcnJheUluc3RydW1lbnRhdGlvbnMsIGtleSwgcmVjZWl2ZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXMgPSBSZWZsZWN0LmdldCh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpO1xyXG4gICAgICAgIGlmIChpc1N5bWJvbChrZXkpID8gYnVpbHRJblN5bWJvbHMuaGFzKGtleSkgOiBpc05vblRyYWNrYWJsZUtleXMoa2V5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWlzUmVhZG9ubHkpIHtcclxuICAgICAgICAgICAgdHJhY2sodGFyZ2V0LCBcImdldFwiIC8qIEdFVCAqLywga2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNoYWxsb3cpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzUmVmKHJlcykpIHtcclxuICAgICAgICAgICAgLy8gcmVmIHVud3JhcHBpbmcgLSBza2lwIHVud3JhcCBmb3IgQXJyYXkgKyBpbnRlZ2VyIGtleS5cclxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldElzQXJyYXkgJiYgaXNJbnRlZ2VyS2V5KGtleSkgPyByZXMgOiByZXMudmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc09iamVjdChyZXMpKSB7XHJcbiAgICAgICAgICAgIC8vIENvbnZlcnQgcmV0dXJuZWQgdmFsdWUgaW50byBhIHByb3h5IGFzIHdlbGwuIHdlIGRvIHRoZSBpc09iamVjdCBjaGVja1xyXG4gICAgICAgICAgICAvLyBoZXJlIHRvIGF2b2lkIGludmFsaWQgdmFsdWUgd2FybmluZy4gQWxzbyBuZWVkIHRvIGxhenkgYWNjZXNzIHJlYWRvbmx5XHJcbiAgICAgICAgICAgIC8vIGFuZCByZWFjdGl2ZSBoZXJlIHRvIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY3kuXHJcbiAgICAgICAgICAgIHJldHVybiBpc1JlYWRvbmx5ID8gcmVhZG9ubHkocmVzKSA6IHJlYWN0aXZlKHJlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9O1xyXG59XHJcbmNvbnN0IHNldCA9IC8qI19fUFVSRV9fKi8gY3JlYXRlU2V0dGVyKCk7XHJcbmNvbnN0IHNoYWxsb3dTZXQgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZVNldHRlcih0cnVlKTtcclxuZnVuY3Rpb24gY3JlYXRlU2V0dGVyKHNoYWxsb3cgPSBmYWxzZSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHNldCh0YXJnZXQsIGtleSwgdmFsdWUsIHJlY2VpdmVyKSB7XHJcbiAgICAgICAgbGV0IG9sZFZhbHVlID0gdGFyZ2V0W2tleV07XHJcbiAgICAgICAgaWYgKGlzUmVhZG9ubHkob2xkVmFsdWUpICYmIGlzUmVmKG9sZFZhbHVlKSAmJiAhaXNSZWYodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFzaGFsbG93ICYmICFpc1JlYWRvbmx5KHZhbHVlKSkge1xyXG4gICAgICAgICAgICBpZiAoIWlzU2hhbGxvdyh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gdG9SYXcodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgb2xkVmFsdWUgPSB0b1JhdyhvbGRWYWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFpc0FycmF5KHRhcmdldCkgJiYgaXNSZWYob2xkVmFsdWUpICYmICFpc1JlZih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIG9sZFZhbHVlLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBoYWRLZXkgPSBpc0FycmF5KHRhcmdldCkgJiYgaXNJbnRlZ2VyS2V5KGtleSlcclxuICAgICAgICAgICAgPyBOdW1iZXIoa2V5KSA8IHRhcmdldC5sZW5ndGhcclxuICAgICAgICAgICAgOiBoYXNPd24odGFyZ2V0LCBrZXkpO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFJlZmxlY3Quc2V0KHRhcmdldCwga2V5LCB2YWx1ZSwgcmVjZWl2ZXIpO1xyXG4gICAgICAgIC8vIGRvbid0IHRyaWdnZXIgaWYgdGFyZ2V0IGlzIHNvbWV0aGluZyB1cCBpbiB0aGUgcHJvdG90eXBlIGNoYWluIG9mIG9yaWdpbmFsXHJcbiAgICAgICAgaWYgKHRhcmdldCA9PT0gdG9SYXcocmVjZWl2ZXIpKSB7XHJcbiAgICAgICAgICAgIGlmICghaGFkS2V5KSB7XHJcbiAgICAgICAgICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJhZGRcIiAvKiBBREQgKi8sIGtleSwgdmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGhhc0NoYW5nZWQodmFsdWUsIG9sZFZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgdHJpZ2dlcih0YXJnZXQsIFwic2V0XCIgLyogU0VUICovLCBrZXksIHZhbHVlLCBvbGRWYWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBrZXkpIHtcclxuICAgIGNvbnN0IGhhZEtleSA9IGhhc093bih0YXJnZXQsIGtleSk7XHJcbiAgICBjb25zdCBvbGRWYWx1ZSA9IHRhcmdldFtrZXldO1xyXG4gICAgY29uc3QgcmVzdWx0ID0gUmVmbGVjdC5kZWxldGVQcm9wZXJ0eSh0YXJnZXQsIGtleSk7XHJcbiAgICBpZiAocmVzdWx0ICYmIGhhZEtleSkge1xyXG4gICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImRlbGV0ZVwiIC8qIERFTEVURSAqLywga2V5LCB1bmRlZmluZWQsIG9sZFZhbHVlKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gaGFzKHRhcmdldCwga2V5KSB7XHJcbiAgICBjb25zdCByZXN1bHQgPSBSZWZsZWN0Lmhhcyh0YXJnZXQsIGtleSk7XHJcbiAgICBpZiAoIWlzU3ltYm9sKGtleSkgfHwgIWJ1aWx0SW5TeW1ib2xzLmhhcyhrZXkpKSB7XHJcbiAgICAgICAgdHJhY2sodGFyZ2V0LCBcImhhc1wiIC8qIEhBUyAqLywga2V5KTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gb3duS2V5cyh0YXJnZXQpIHtcclxuICAgIHRyYWNrKHRhcmdldCwgXCJpdGVyYXRlXCIgLyogSVRFUkFURSAqLywgaXNBcnJheSh0YXJnZXQpID8gJ2xlbmd0aCcgOiBJVEVSQVRFX0tFWSk7XHJcbiAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKHRhcmdldCk7XHJcbn1cclxuY29uc3QgbXV0YWJsZUhhbmRsZXJzID0ge1xyXG4gICAgZ2V0LFxyXG4gICAgc2V0LFxyXG4gICAgZGVsZXRlUHJvcGVydHksXHJcbiAgICBoYXMsXHJcbiAgICBvd25LZXlzXHJcbn07XHJcbmNvbnN0IHJlYWRvbmx5SGFuZGxlcnMgPSB7XHJcbiAgICBnZXQ6IHJlYWRvbmx5R2V0LFxyXG4gICAgc2V0KHRhcmdldCwga2V5KSB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICB3YXJuKGBTZXQgb3BlcmF0aW9uIG9uIGtleSBcIiR7U3RyaW5nKGtleSl9XCIgZmFpbGVkOiB0YXJnZXQgaXMgcmVhZG9ubHkuYCwgdGFyZ2V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9LFxyXG4gICAgZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBrZXkpIHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYERlbGV0ZSBvcGVyYXRpb24gb24ga2V5IFwiJHtTdHJpbmcoa2V5KX1cIiBmYWlsZWQ6IHRhcmdldCBpcyByZWFkb25seS5gLCB0YXJnZXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxufTtcclxuY29uc3Qgc2hhbGxvd1JlYWN0aXZlSGFuZGxlcnMgPSAvKiNfX1BVUkVfXyovIGV4dGVuZCh7fSwgbXV0YWJsZUhhbmRsZXJzLCB7XHJcbiAgICBnZXQ6IHNoYWxsb3dHZXQsXHJcbiAgICBzZXQ6IHNoYWxsb3dTZXRcclxufSk7XHJcbi8vIFByb3BzIGhhbmRsZXJzIGFyZSBzcGVjaWFsIGluIHRoZSBzZW5zZSB0aGF0IGl0IHNob3VsZCBub3QgdW53cmFwIHRvcC1sZXZlbFxyXG4vLyByZWZzIChpbiBvcmRlciB0byBhbGxvdyByZWZzIHRvIGJlIGV4cGxpY2l0bHkgcGFzc2VkIGRvd24pLCBidXQgc2hvdWxkXHJcbi8vIHJldGFpbiB0aGUgcmVhY3Rpdml0eSBvZiB0aGUgbm9ybWFsIHJlYWRvbmx5IG9iamVjdC5cclxuY29uc3Qgc2hhbGxvd1JlYWRvbmx5SGFuZGxlcnMgPSAvKiNfX1BVUkVfXyovIGV4dGVuZCh7fSwgcmVhZG9ubHlIYW5kbGVycywge1xyXG4gICAgZ2V0OiBzaGFsbG93UmVhZG9ubHlHZXRcclxufSk7XG5cbmNvbnN0IHRvU2hhbGxvdyA9ICh2YWx1ZSkgPT4gdmFsdWU7XHJcbmNvbnN0IGdldFByb3RvID0gKHYpID0+IFJlZmxlY3QuZ2V0UHJvdG90eXBlT2Yodik7XHJcbmZ1bmN0aW9uIGdldCQxKHRhcmdldCwga2V5LCBpc1JlYWRvbmx5ID0gZmFsc2UsIGlzU2hhbGxvdyA9IGZhbHNlKSB7XHJcbiAgICAvLyAjMTc3MjogcmVhZG9ubHkocmVhY3RpdmUoTWFwKSkgc2hvdWxkIHJldHVybiByZWFkb25seSArIHJlYWN0aXZlIHZlcnNpb25cclxuICAgIC8vIG9mIHRoZSB2YWx1ZVxyXG4gICAgdGFyZ2V0ID0gdGFyZ2V0W1wiX192X3Jhd1wiIC8qIFJBVyAqL107XHJcbiAgICBjb25zdCByYXdUYXJnZXQgPSB0b1Jhdyh0YXJnZXQpO1xyXG4gICAgY29uc3QgcmF3S2V5ID0gdG9SYXcoa2V5KTtcclxuICAgIGlmICghaXNSZWFkb25seSkge1xyXG4gICAgICAgIGlmIChrZXkgIT09IHJhd0tleSkge1xyXG4gICAgICAgICAgICB0cmFjayhyYXdUYXJnZXQsIFwiZ2V0XCIgLyogR0VUICovLCBrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cmFjayhyYXdUYXJnZXQsIFwiZ2V0XCIgLyogR0VUICovLCByYXdLZXkpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyBoYXMgfSA9IGdldFByb3RvKHJhd1RhcmdldCk7XHJcbiAgICBjb25zdCB3cmFwID0gaXNTaGFsbG93ID8gdG9TaGFsbG93IDogaXNSZWFkb25seSA/IHRvUmVhZG9ubHkgOiB0b1JlYWN0aXZlO1xyXG4gICAgaWYgKGhhcy5jYWxsKHJhd1RhcmdldCwga2V5KSkge1xyXG4gICAgICAgIHJldHVybiB3cmFwKHRhcmdldC5nZXQoa2V5KSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChoYXMuY2FsbChyYXdUYXJnZXQsIHJhd0tleSkpIHtcclxuICAgICAgICByZXR1cm4gd3JhcCh0YXJnZXQuZ2V0KHJhd0tleSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodGFyZ2V0ICE9PSByYXdUYXJnZXQpIHtcclxuICAgICAgICAvLyAjMzYwMiByZWFkb25seShyZWFjdGl2ZShNYXApKVxyXG4gICAgICAgIC8vIGVuc3VyZSB0aGF0IHRoZSBuZXN0ZWQgcmVhY3RpdmUgYE1hcGAgY2FuIGRvIHRyYWNraW5nIGZvciBpdHNlbGZcclxuICAgICAgICB0YXJnZXQuZ2V0KGtleSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaGFzJDEoa2V5LCBpc1JlYWRvbmx5ID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IHRhcmdldCA9IHRoaXNbXCJfX3ZfcmF3XCIgLyogUkFXICovXTtcclxuICAgIGNvbnN0IHJhd1RhcmdldCA9IHRvUmF3KHRhcmdldCk7XHJcbiAgICBjb25zdCByYXdLZXkgPSB0b1JhdyhrZXkpO1xyXG4gICAgaWYgKCFpc1JlYWRvbmx5KSB7XHJcbiAgICAgICAgaWYgKGtleSAhPT0gcmF3S2V5KSB7XHJcbiAgICAgICAgICAgIHRyYWNrKHJhd1RhcmdldCwgXCJoYXNcIiAvKiBIQVMgKi8sIGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyYWNrKHJhd1RhcmdldCwgXCJoYXNcIiAvKiBIQVMgKi8sIHJhd0tleSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ga2V5ID09PSByYXdLZXlcclxuICAgICAgICA/IHRhcmdldC5oYXMoa2V5KVxyXG4gICAgICAgIDogdGFyZ2V0LmhhcyhrZXkpIHx8IHRhcmdldC5oYXMocmF3S2V5KTtcclxufVxyXG5mdW5jdGlvbiBzaXplKHRhcmdldCwgaXNSZWFkb25seSA9IGZhbHNlKSB7XHJcbiAgICB0YXJnZXQgPSB0YXJnZXRbXCJfX3ZfcmF3XCIgLyogUkFXICovXTtcclxuICAgICFpc1JlYWRvbmx5ICYmIHRyYWNrKHRvUmF3KHRhcmdldCksIFwiaXRlcmF0ZVwiIC8qIElURVJBVEUgKi8sIElURVJBVEVfS0VZKTtcclxuICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsICdzaXplJywgdGFyZ2V0KTtcclxufVxyXG5mdW5jdGlvbiBhZGQodmFsdWUpIHtcclxuICAgIHZhbHVlID0gdG9SYXcodmFsdWUpO1xyXG4gICAgY29uc3QgdGFyZ2V0ID0gdG9SYXcodGhpcyk7XHJcbiAgICBjb25zdCBwcm90byA9IGdldFByb3RvKHRhcmdldCk7XHJcbiAgICBjb25zdCBoYWRLZXkgPSBwcm90by5oYXMuY2FsbCh0YXJnZXQsIHZhbHVlKTtcclxuICAgIGlmICghaGFkS2V5KSB7XHJcbiAgICAgICAgdGFyZ2V0LmFkZCh2YWx1ZSk7XHJcbiAgICAgICAgdHJpZ2dlcih0YXJnZXQsIFwiYWRkXCIgLyogQUREICovLCB2YWx1ZSwgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuZnVuY3Rpb24gc2V0JDEoa2V5LCB2YWx1ZSkge1xyXG4gICAgdmFsdWUgPSB0b1Jhdyh2YWx1ZSk7XHJcbiAgICBjb25zdCB0YXJnZXQgPSB0b1Jhdyh0aGlzKTtcclxuICAgIGNvbnN0IHsgaGFzLCBnZXQgfSA9IGdldFByb3RvKHRhcmdldCk7XHJcbiAgICBsZXQgaGFkS2V5ID0gaGFzLmNhbGwodGFyZ2V0LCBrZXkpO1xyXG4gICAgaWYgKCFoYWRLZXkpIHtcclxuICAgICAgICBrZXkgPSB0b1JhdyhrZXkpO1xyXG4gICAgICAgIGhhZEtleSA9IGhhcy5jYWxsKHRhcmdldCwga2V5KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGNoZWNrSWRlbnRpdHlLZXlzKHRhcmdldCwgaGFzLCBrZXkpO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgb2xkVmFsdWUgPSBnZXQuY2FsbCh0YXJnZXQsIGtleSk7XHJcbiAgICB0YXJnZXQuc2V0KGtleSwgdmFsdWUpO1xyXG4gICAgaWYgKCFoYWRLZXkpIHtcclxuICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJhZGRcIiAvKiBBREQgKi8sIGtleSwgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaGFzQ2hhbmdlZCh2YWx1ZSwgb2xkVmFsdWUpKSB7XHJcbiAgICAgICAgdHJpZ2dlcih0YXJnZXQsIFwic2V0XCIgLyogU0VUICovLCBrZXksIHZhbHVlLCBvbGRWYWx1ZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxufVxyXG5mdW5jdGlvbiBkZWxldGVFbnRyeShrZXkpIHtcclxuICAgIGNvbnN0IHRhcmdldCA9IHRvUmF3KHRoaXMpO1xyXG4gICAgY29uc3QgeyBoYXMsIGdldCB9ID0gZ2V0UHJvdG8odGFyZ2V0KTtcclxuICAgIGxldCBoYWRLZXkgPSBoYXMuY2FsbCh0YXJnZXQsIGtleSk7XHJcbiAgICBpZiAoIWhhZEtleSkge1xyXG4gICAgICAgIGtleSA9IHRvUmF3KGtleSk7XHJcbiAgICAgICAgaGFkS2V5ID0gaGFzLmNhbGwodGFyZ2V0LCBrZXkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgY2hlY2tJZGVudGl0eUtleXModGFyZ2V0LCBoYXMsIGtleSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBvbGRWYWx1ZSA9IGdldCA/IGdldC5jYWxsKHRhcmdldCwga2V5KSA6IHVuZGVmaW5lZDtcclxuICAgIC8vIGZvcndhcmQgdGhlIG9wZXJhdGlvbiBiZWZvcmUgcXVldWVpbmcgcmVhY3Rpb25zXHJcbiAgICBjb25zdCByZXN1bHQgPSB0YXJnZXQuZGVsZXRlKGtleSk7XHJcbiAgICBpZiAoaGFkS2V5KSB7XHJcbiAgICAgICAgdHJpZ2dlcih0YXJnZXQsIFwiZGVsZXRlXCIgLyogREVMRVRFICovLCBrZXksIHVuZGVmaW5lZCwgb2xkVmFsdWUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBjbGVhcigpIHtcclxuICAgIGNvbnN0IHRhcmdldCA9IHRvUmF3KHRoaXMpO1xyXG4gICAgY29uc3QgaGFkSXRlbXMgPSB0YXJnZXQuc2l6ZSAhPT0gMDtcclxuICAgIGNvbnN0IG9sZFRhcmdldCA9IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxyXG4gICAgICAgID8gaXNNYXAodGFyZ2V0KVxyXG4gICAgICAgICAgICA/IG5ldyBNYXAodGFyZ2V0KVxyXG4gICAgICAgICAgICA6IG5ldyBTZXQodGFyZ2V0KVxyXG4gICAgICAgIDogdW5kZWZpbmVkO1xyXG4gICAgLy8gZm9yd2FyZCB0aGUgb3BlcmF0aW9uIGJlZm9yZSBxdWV1ZWluZyByZWFjdGlvbnNcclxuICAgIGNvbnN0IHJlc3VsdCA9IHRhcmdldC5jbGVhcigpO1xyXG4gICAgaWYgKGhhZEl0ZW1zKSB7XHJcbiAgICAgICAgdHJpZ2dlcih0YXJnZXQsIFwiY2xlYXJcIiAvKiBDTEVBUiAqLywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG9sZFRhcmdldCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUZvckVhY2goaXNSZWFkb25seSwgaXNTaGFsbG93KSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFjaywgdGhpc0FyZykge1xyXG4gICAgICAgIGNvbnN0IG9ic2VydmVkID0gdGhpcztcclxuICAgICAgICBjb25zdCB0YXJnZXQgPSBvYnNlcnZlZFtcIl9fdl9yYXdcIiAvKiBSQVcgKi9dO1xyXG4gICAgICAgIGNvbnN0IHJhd1RhcmdldCA9IHRvUmF3KHRhcmdldCk7XHJcbiAgICAgICAgY29uc3Qgd3JhcCA9IGlzU2hhbGxvdyA/IHRvU2hhbGxvdyA6IGlzUmVhZG9ubHkgPyB0b1JlYWRvbmx5IDogdG9SZWFjdGl2ZTtcclxuICAgICAgICAhaXNSZWFkb25seSAmJiB0cmFjayhyYXdUYXJnZXQsIFwiaXRlcmF0ZVwiIC8qIElURVJBVEUgKi8sIElURVJBVEVfS0VZKTtcclxuICAgICAgICByZXR1cm4gdGFyZ2V0LmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcclxuICAgICAgICAgICAgLy8gaW1wb3J0YW50OiBtYWtlIHN1cmUgdGhlIGNhbGxiYWNrIGlzXHJcbiAgICAgICAgICAgIC8vIDEuIGludm9rZWQgd2l0aCB0aGUgcmVhY3RpdmUgbWFwIGFzIGB0aGlzYCBhbmQgM3JkIGFyZ1xyXG4gICAgICAgICAgICAvLyAyLiB0aGUgdmFsdWUgcmVjZWl2ZWQgc2hvdWxkIGJlIGEgY29ycmVzcG9uZGluZyByZWFjdGl2ZS9yZWFkb25seS5cclxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgd3JhcCh2YWx1ZSksIHdyYXAoa2V5KSwgb2JzZXJ2ZWQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVJdGVyYWJsZU1ldGhvZChtZXRob2QsIGlzUmVhZG9ubHksIGlzU2hhbGxvdykge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpc1tcIl9fdl9yYXdcIiAvKiBSQVcgKi9dO1xyXG4gICAgICAgIGNvbnN0IHJhd1RhcmdldCA9IHRvUmF3KHRhcmdldCk7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0SXNNYXAgPSBpc01hcChyYXdUYXJnZXQpO1xyXG4gICAgICAgIGNvbnN0IGlzUGFpciA9IG1ldGhvZCA9PT0gJ2VudHJpZXMnIHx8IChtZXRob2QgPT09IFN5bWJvbC5pdGVyYXRvciAmJiB0YXJnZXRJc01hcCk7XHJcbiAgICAgICAgY29uc3QgaXNLZXlPbmx5ID0gbWV0aG9kID09PSAna2V5cycgJiYgdGFyZ2V0SXNNYXA7XHJcbiAgICAgICAgY29uc3QgaW5uZXJJdGVyYXRvciA9IHRhcmdldFttZXRob2RdKC4uLmFyZ3MpO1xyXG4gICAgICAgIGNvbnN0IHdyYXAgPSBpc1NoYWxsb3cgPyB0b1NoYWxsb3cgOiBpc1JlYWRvbmx5ID8gdG9SZWFkb25seSA6IHRvUmVhY3RpdmU7XHJcbiAgICAgICAgIWlzUmVhZG9ubHkgJiZcclxuICAgICAgICAgICAgdHJhY2socmF3VGFyZ2V0LCBcIml0ZXJhdGVcIiAvKiBJVEVSQVRFICovLCBpc0tleU9ubHkgPyBNQVBfS0VZX0lURVJBVEVfS0VZIDogSVRFUkFURV9LRVkpO1xyXG4gICAgICAgIC8vIHJldHVybiBhIHdyYXBwZWQgaXRlcmF0b3Igd2hpY2ggcmV0dXJucyBvYnNlcnZlZCB2ZXJzaW9ucyBvZiB0aGVcclxuICAgICAgICAvLyB2YWx1ZXMgZW1pdHRlZCBmcm9tIHRoZSByZWFsIGl0ZXJhdG9yXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgLy8gaXRlcmF0b3IgcHJvdG9jb2xcclxuICAgICAgICAgICAgbmV4dCgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGlubmVySXRlcmF0b3IubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvbmVcclxuICAgICAgICAgICAgICAgICAgICA/IHsgdmFsdWUsIGRvbmUgfVxyXG4gICAgICAgICAgICAgICAgICAgIDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaXNQYWlyID8gW3dyYXAodmFsdWVbMF0pLCB3cmFwKHZhbHVlWzFdKV0gOiB3cmFwKHZhbHVlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8vIGl0ZXJhYmxlIHByb3RvY29sXHJcbiAgICAgICAgICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVSZWFkb25seU1ldGhvZCh0eXBlKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGFyZ3NbMF0gPyBgb24ga2V5IFwiJHthcmdzWzBdfVwiIGAgOiBgYDtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKGAke2NhcGl0YWxpemUodHlwZSl9IG9wZXJhdGlvbiAke2tleX1mYWlsZWQ6IHRhcmdldCBpcyByZWFkb25seS5gLCB0b1Jhdyh0aGlzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0eXBlID09PSBcImRlbGV0ZVwiIC8qIERFTEVURSAqLyA/IGZhbHNlIDogdGhpcztcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlSW5zdHJ1bWVudGF0aW9ucygpIHtcclxuICAgIGNvbnN0IG11dGFibGVJbnN0cnVtZW50YXRpb25zID0ge1xyXG4gICAgICAgIGdldChrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdldCQxKHRoaXMsIGtleSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXQgc2l6ZSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNpemUodGhpcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBoYXM6IGhhcyQxLFxyXG4gICAgICAgIGFkZCxcclxuICAgICAgICBzZXQ6IHNldCQxLFxyXG4gICAgICAgIGRlbGV0ZTogZGVsZXRlRW50cnksXHJcbiAgICAgICAgY2xlYXIsXHJcbiAgICAgICAgZm9yRWFjaDogY3JlYXRlRm9yRWFjaChmYWxzZSwgZmFsc2UpXHJcbiAgICB9O1xyXG4gICAgY29uc3Qgc2hhbGxvd0luc3RydW1lbnRhdGlvbnMgPSB7XHJcbiAgICAgICAgZ2V0KGtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2V0JDEodGhpcywga2V5LCBmYWxzZSwgdHJ1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXQgc2l6ZSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNpemUodGhpcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBoYXM6IGhhcyQxLFxyXG4gICAgICAgIGFkZCxcclxuICAgICAgICBzZXQ6IHNldCQxLFxyXG4gICAgICAgIGRlbGV0ZTogZGVsZXRlRW50cnksXHJcbiAgICAgICAgY2xlYXIsXHJcbiAgICAgICAgZm9yRWFjaDogY3JlYXRlRm9yRWFjaChmYWxzZSwgdHJ1ZSlcclxuICAgIH07XHJcbiAgICBjb25zdCByZWFkb25seUluc3RydW1lbnRhdGlvbnMgPSB7XHJcbiAgICAgICAgZ2V0KGtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2V0JDEodGhpcywga2V5LCB0cnVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldCBzaXplKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc2l6ZSh0aGlzLCB0cnVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGhhcyhrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhhcyQxLmNhbGwodGhpcywga2V5LCB0cnVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFkZDogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJhZGRcIiAvKiBBREQgKi8pLFxyXG4gICAgICAgIHNldDogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJzZXRcIiAvKiBTRVQgKi8pLFxyXG4gICAgICAgIGRlbGV0ZTogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJkZWxldGVcIiAvKiBERUxFVEUgKi8pLFxyXG4gICAgICAgIGNsZWFyOiBjcmVhdGVSZWFkb25seU1ldGhvZChcImNsZWFyXCIgLyogQ0xFQVIgKi8pLFxyXG4gICAgICAgIGZvckVhY2g6IGNyZWF0ZUZvckVhY2godHJ1ZSwgZmFsc2UpXHJcbiAgICB9O1xyXG4gICAgY29uc3Qgc2hhbGxvd1JlYWRvbmx5SW5zdHJ1bWVudGF0aW9ucyA9IHtcclxuICAgICAgICBnZXQoa2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnZXQkMSh0aGlzLCBrZXksIHRydWUsIHRydWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0IHNpemUoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzaXplKHRoaXMsIHRydWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaGFzKGtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaGFzJDEuY2FsbCh0aGlzLCBrZXksIHRydWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWRkOiBjcmVhdGVSZWFkb25seU1ldGhvZChcImFkZFwiIC8qIEFERCAqLyksXHJcbiAgICAgICAgc2V0OiBjcmVhdGVSZWFkb25seU1ldGhvZChcInNldFwiIC8qIFNFVCAqLyksXHJcbiAgICAgICAgZGVsZXRlOiBjcmVhdGVSZWFkb25seU1ldGhvZChcImRlbGV0ZVwiIC8qIERFTEVURSAqLyksXHJcbiAgICAgICAgY2xlYXI6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiY2xlYXJcIiAvKiBDTEVBUiAqLyksXHJcbiAgICAgICAgZm9yRWFjaDogY3JlYXRlRm9yRWFjaCh0cnVlLCB0cnVlKVxyXG4gICAgfTtcclxuICAgIGNvbnN0IGl0ZXJhdG9yTWV0aG9kcyA9IFsna2V5cycsICd2YWx1ZXMnLCAnZW50cmllcycsIFN5bWJvbC5pdGVyYXRvcl07XHJcbiAgICBpdGVyYXRvck1ldGhvZHMuZm9yRWFjaChtZXRob2QgPT4ge1xyXG4gICAgICAgIG11dGFibGVJbnN0cnVtZW50YXRpb25zW21ldGhvZF0gPSBjcmVhdGVJdGVyYWJsZU1ldGhvZChtZXRob2QsIGZhbHNlLCBmYWxzZSk7XHJcbiAgICAgICAgcmVhZG9ubHlJbnN0cnVtZW50YXRpb25zW21ldGhvZF0gPSBjcmVhdGVJdGVyYWJsZU1ldGhvZChtZXRob2QsIHRydWUsIGZhbHNlKTtcclxuICAgICAgICBzaGFsbG93SW5zdHJ1bWVudGF0aW9uc1ttZXRob2RdID0gY3JlYXRlSXRlcmFibGVNZXRob2QobWV0aG9kLCBmYWxzZSwgdHJ1ZSk7XHJcbiAgICAgICAgc2hhbGxvd1JlYWRvbmx5SW5zdHJ1bWVudGF0aW9uc1ttZXRob2RdID0gY3JlYXRlSXRlcmFibGVNZXRob2QobWV0aG9kLCB0cnVlLCB0cnVlKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIFtcclxuICAgICAgICBtdXRhYmxlSW5zdHJ1bWVudGF0aW9ucyxcclxuICAgICAgICByZWFkb25seUluc3RydW1lbnRhdGlvbnMsXHJcbiAgICAgICAgc2hhbGxvd0luc3RydW1lbnRhdGlvbnMsXHJcbiAgICAgICAgc2hhbGxvd1JlYWRvbmx5SW5zdHJ1bWVudGF0aW9uc1xyXG4gICAgXTtcclxufVxyXG5jb25zdCBbbXV0YWJsZUluc3RydW1lbnRhdGlvbnMsIHJlYWRvbmx5SW5zdHJ1bWVudGF0aW9ucywgc2hhbGxvd0luc3RydW1lbnRhdGlvbnMsIHNoYWxsb3dSZWFkb25seUluc3RydW1lbnRhdGlvbnNdID0gLyogI19fUFVSRV9fKi8gY3JlYXRlSW5zdHJ1bWVudGF0aW9ucygpO1xyXG5mdW5jdGlvbiBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIoaXNSZWFkb25seSwgc2hhbGxvdykge1xyXG4gICAgY29uc3QgaW5zdHJ1bWVudGF0aW9ucyA9IHNoYWxsb3dcclxuICAgICAgICA/IGlzUmVhZG9ubHlcclxuICAgICAgICAgICAgPyBzaGFsbG93UmVhZG9ubHlJbnN0cnVtZW50YXRpb25zXHJcbiAgICAgICAgICAgIDogc2hhbGxvd0luc3RydW1lbnRhdGlvbnNcclxuICAgICAgICA6IGlzUmVhZG9ubHlcclxuICAgICAgICAgICAgPyByZWFkb25seUluc3RydW1lbnRhdGlvbnNcclxuICAgICAgICAgICAgOiBtdXRhYmxlSW5zdHJ1bWVudGF0aW9ucztcclxuICAgIHJldHVybiAodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSA9PiB7XHJcbiAgICAgICAgaWYgKGtleSA9PT0gXCJfX3ZfaXNSZWFjdGl2ZVwiIC8qIElTX1JFQUNUSVZFICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhaXNSZWFkb25seTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBcIl9fdl9pc1JlYWRvbmx5XCIgLyogSVNfUkVBRE9OTFkgKi8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlzUmVhZG9ubHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfcmF3XCIgLyogUkFXICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBSZWZsZWN0LmdldChoYXNPd24oaW5zdHJ1bWVudGF0aW9ucywga2V5KSAmJiBrZXkgaW4gdGFyZ2V0XHJcbiAgICAgICAgICAgID8gaW5zdHJ1bWVudGF0aW9uc1xyXG4gICAgICAgICAgICA6IHRhcmdldCwga2V5LCByZWNlaXZlcik7XHJcbiAgICB9O1xyXG59XHJcbmNvbnN0IG11dGFibGVDb2xsZWN0aW9uSGFuZGxlcnMgPSB7XHJcbiAgICBnZXQ6IC8qI19fUFVSRV9fKi8gY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKGZhbHNlLCBmYWxzZSlcclxufTtcclxuY29uc3Qgc2hhbGxvd0NvbGxlY3Rpb25IYW5kbGVycyA9IHtcclxuICAgIGdldDogLyojX19QVVJFX18qLyBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIoZmFsc2UsIHRydWUpXHJcbn07XHJcbmNvbnN0IHJlYWRvbmx5Q29sbGVjdGlvbkhhbmRsZXJzID0ge1xyXG4gICAgZ2V0OiAvKiNfX1BVUkVfXyovIGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcih0cnVlLCBmYWxzZSlcclxufTtcclxuY29uc3Qgc2hhbGxvd1JlYWRvbmx5Q29sbGVjdGlvbkhhbmRsZXJzID0ge1xyXG4gICAgZ2V0OiAvKiNfX1BVUkVfXyovIGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcih0cnVlLCB0cnVlKVxyXG59O1xyXG5mdW5jdGlvbiBjaGVja0lkZW50aXR5S2V5cyh0YXJnZXQsIGhhcywga2V5KSB7XHJcbiAgICBjb25zdCByYXdLZXkgPSB0b1JhdyhrZXkpO1xyXG4gICAgaWYgKHJhd0tleSAhPT0ga2V5ICYmIGhhcy5jYWxsKHRhcmdldCwgcmF3S2V5KSkge1xyXG4gICAgICAgIGNvbnN0IHR5cGUgPSB0b1Jhd1R5cGUodGFyZ2V0KTtcclxuICAgICAgICBjb25zb2xlLndhcm4oYFJlYWN0aXZlICR7dHlwZX0gY29udGFpbnMgYm90aCB0aGUgcmF3IGFuZCByZWFjdGl2ZSBgICtcclxuICAgICAgICAgICAgYHZlcnNpb25zIG9mIHRoZSBzYW1lIG9iamVjdCR7dHlwZSA9PT0gYE1hcGAgPyBgIGFzIGtleXNgIDogYGB9LCBgICtcclxuICAgICAgICAgICAgYHdoaWNoIGNhbiBsZWFkIHRvIGluY29uc2lzdGVuY2llcy4gYCArXHJcbiAgICAgICAgICAgIGBBdm9pZCBkaWZmZXJlbnRpYXRpbmcgYmV0d2VlbiB0aGUgcmF3IGFuZCByZWFjdGl2ZSB2ZXJzaW9ucyBgICtcclxuICAgICAgICAgICAgYG9mIGFuIG9iamVjdCBhbmQgb25seSB1c2UgdGhlIHJlYWN0aXZlIHZlcnNpb24gaWYgcG9zc2libGUuYCk7XHJcbiAgICB9XHJcbn1cblxuY29uc3QgcmVhY3RpdmVNYXAgPSBuZXcgV2Vha01hcCgpO1xyXG5jb25zdCBzaGFsbG93UmVhY3RpdmVNYXAgPSBuZXcgV2Vha01hcCgpO1xyXG5jb25zdCByZWFkb25seU1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbmNvbnN0IHNoYWxsb3dSZWFkb25seU1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbmZ1bmN0aW9uIHRhcmdldFR5cGVNYXAocmF3VHlwZSkge1xyXG4gICAgc3dpdGNoIChyYXdUeXBlKSB7XHJcbiAgICAgICAgY2FzZSAnT2JqZWN0JzpcclxuICAgICAgICBjYXNlICdBcnJheSc6XHJcbiAgICAgICAgICAgIHJldHVybiAxIC8qIENPTU1PTiAqLztcclxuICAgICAgICBjYXNlICdNYXAnOlxyXG4gICAgICAgIGNhc2UgJ1NldCc6XHJcbiAgICAgICAgY2FzZSAnV2Vha01hcCc6XHJcbiAgICAgICAgY2FzZSAnV2Vha1NldCc6XHJcbiAgICAgICAgICAgIHJldHVybiAyIC8qIENPTExFQ1RJT04gKi87XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIDAgLyogSU5WQUxJRCAqLztcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRUYXJnZXRUeXBlKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdmFsdWVbXCJfX3Zfc2tpcFwiIC8qIFNLSVAgKi9dIHx8ICFPYmplY3QuaXNFeHRlbnNpYmxlKHZhbHVlKVxyXG4gICAgICAgID8gMCAvKiBJTlZBTElEICovXHJcbiAgICAgICAgOiB0YXJnZXRUeXBlTWFwKHRvUmF3VHlwZSh2YWx1ZSkpO1xyXG59XHJcbmZ1bmN0aW9uIHJlYWN0aXZlKHRhcmdldCkge1xyXG4gICAgLy8gaWYgdHJ5aW5nIHRvIG9ic2VydmUgYSByZWFkb25seSBwcm94eSwgcmV0dXJuIHRoZSByZWFkb25seSB2ZXJzaW9uLlxyXG4gICAgaWYgKGlzUmVhZG9ubHkodGFyZ2V0KSkge1xyXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY3JlYXRlUmVhY3RpdmVPYmplY3QodGFyZ2V0LCBmYWxzZSwgbXV0YWJsZUhhbmRsZXJzLCBtdXRhYmxlQ29sbGVjdGlvbkhhbmRsZXJzLCByZWFjdGl2ZU1hcCk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybiBhIHNoYWxsb3dseS1yZWFjdGl2ZSBjb3B5IG9mIHRoZSBvcmlnaW5hbCBvYmplY3QsIHdoZXJlIG9ubHkgdGhlIHJvb3RcclxuICogbGV2ZWwgcHJvcGVydGllcyBhcmUgcmVhY3RpdmUuIEl0IGFsc28gZG9lcyBub3QgYXV0by11bndyYXAgcmVmcyAoZXZlbiBhdCB0aGVcclxuICogcm9vdCBsZXZlbCkuXHJcbiAqL1xyXG5mdW5jdGlvbiBzaGFsbG93UmVhY3RpdmUodGFyZ2V0KSB7XHJcbiAgICByZXR1cm4gY3JlYXRlUmVhY3RpdmVPYmplY3QodGFyZ2V0LCBmYWxzZSwgc2hhbGxvd1JlYWN0aXZlSGFuZGxlcnMsIHNoYWxsb3dDb2xsZWN0aW9uSGFuZGxlcnMsIHNoYWxsb3dSZWFjdGl2ZU1hcCk7XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSByZWFkb25seSBjb3B5IG9mIHRoZSBvcmlnaW5hbCBvYmplY3QuIE5vdGUgdGhlIHJldHVybmVkIGNvcHkgaXMgbm90XHJcbiAqIG1hZGUgcmVhY3RpdmUsIGJ1dCBgcmVhZG9ubHlgIGNhbiBiZSBjYWxsZWQgb24gYW4gYWxyZWFkeSByZWFjdGl2ZSBvYmplY3QuXHJcbiAqL1xyXG5mdW5jdGlvbiByZWFkb25seSh0YXJnZXQpIHtcclxuICAgIHJldHVybiBjcmVhdGVSZWFjdGl2ZU9iamVjdCh0YXJnZXQsIHRydWUsIHJlYWRvbmx5SGFuZGxlcnMsIHJlYWRvbmx5Q29sbGVjdGlvbkhhbmRsZXJzLCByZWFkb25seU1hcCk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSByZWFjdGl2ZS1jb3B5IG9mIHRoZSBvcmlnaW5hbCBvYmplY3QsIHdoZXJlIG9ubHkgdGhlIHJvb3QgbGV2ZWxcclxuICogcHJvcGVydGllcyBhcmUgcmVhZG9ubHksIGFuZCBkb2VzIE5PVCB1bndyYXAgcmVmcyBub3IgcmVjdXJzaXZlbHkgY29udmVydFxyXG4gKiByZXR1cm5lZCBwcm9wZXJ0aWVzLlxyXG4gKiBUaGlzIGlzIHVzZWQgZm9yIGNyZWF0aW5nIHRoZSBwcm9wcyBwcm94eSBvYmplY3QgZm9yIHN0YXRlZnVsIGNvbXBvbmVudHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBzaGFsbG93UmVhZG9ubHkodGFyZ2V0KSB7XHJcbiAgICByZXR1cm4gY3JlYXRlUmVhY3RpdmVPYmplY3QodGFyZ2V0LCB0cnVlLCBzaGFsbG93UmVhZG9ubHlIYW5kbGVycywgc2hhbGxvd1JlYWRvbmx5Q29sbGVjdGlvbkhhbmRsZXJzLCBzaGFsbG93UmVhZG9ubHlNYXApO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KHRhcmdldCwgaXNSZWFkb25seSwgYmFzZUhhbmRsZXJzLCBjb2xsZWN0aW9uSGFuZGxlcnMsIHByb3h5TWFwKSB7XHJcbiAgICBpZiAoIWlzT2JqZWN0KHRhcmdldCkpIHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgdmFsdWUgY2Fubm90IGJlIG1hZGUgcmVhY3RpdmU6ICR7U3RyaW5nKHRhcmdldCl9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICB9XHJcbiAgICAvLyB0YXJnZXQgaXMgYWxyZWFkeSBhIFByb3h5LCByZXR1cm4gaXQuXHJcbiAgICAvLyBleGNlcHRpb246IGNhbGxpbmcgcmVhZG9ubHkoKSBvbiBhIHJlYWN0aXZlIG9iamVjdFxyXG4gICAgaWYgKHRhcmdldFtcIl9fdl9yYXdcIiAvKiBSQVcgKi9dICYmXHJcbiAgICAgICAgIShpc1JlYWRvbmx5ICYmIHRhcmdldFtcIl9fdl9pc1JlYWN0aXZlXCIgLyogSVNfUkVBQ1RJVkUgKi9dKSkge1xyXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICB9XHJcbiAgICAvLyB0YXJnZXQgYWxyZWFkeSBoYXMgY29ycmVzcG9uZGluZyBQcm94eVxyXG4gICAgY29uc3QgZXhpc3RpbmdQcm94eSA9IHByb3h5TWFwLmdldCh0YXJnZXQpO1xyXG4gICAgaWYgKGV4aXN0aW5nUHJveHkpIHtcclxuICAgICAgICByZXR1cm4gZXhpc3RpbmdQcm94eTtcclxuICAgIH1cclxuICAgIC8vIG9ubHkgc3BlY2lmaWMgdmFsdWUgdHlwZXMgY2FuIGJlIG9ic2VydmVkLlxyXG4gICAgY29uc3QgdGFyZ2V0VHlwZSA9IGdldFRhcmdldFR5cGUodGFyZ2V0KTtcclxuICAgIGlmICh0YXJnZXRUeXBlID09PSAwIC8qIElOVkFMSUQgKi8pIHtcclxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgfVxyXG4gICAgY29uc3QgcHJveHkgPSBuZXcgUHJveHkodGFyZ2V0LCB0YXJnZXRUeXBlID09PSAyIC8qIENPTExFQ1RJT04gKi8gPyBjb2xsZWN0aW9uSGFuZGxlcnMgOiBiYXNlSGFuZGxlcnMpO1xyXG4gICAgcHJveHlNYXAuc2V0KHRhcmdldCwgcHJveHkpO1xyXG4gICAgcmV0dXJuIHByb3h5O1xyXG59XHJcbmZ1bmN0aW9uIGlzUmVhY3RpdmUodmFsdWUpIHtcclxuICAgIGlmIChpc1JlYWRvbmx5KHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiBpc1JlYWN0aXZlKHZhbHVlW1wiX192X3Jhd1wiIC8qIFJBVyAqL10pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlW1wiX192X2lzUmVhY3RpdmVcIiAvKiBJU19SRUFDVElWRSAqL10pO1xyXG59XHJcbmZ1bmN0aW9uIGlzUmVhZG9ubHkodmFsdWUpIHtcclxuICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZVtcIl9fdl9pc1JlYWRvbmx5XCIgLyogSVNfUkVBRE9OTFkgKi9dKTtcclxufVxyXG5mdW5jdGlvbiBpc1NoYWxsb3codmFsdWUpIHtcclxuICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZVtcIl9fdl9pc1NoYWxsb3dcIiAvKiBJU19TSEFMTE9XICovXSk7XHJcbn1cclxuZnVuY3Rpb24gaXNQcm94eSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIGlzUmVhY3RpdmUodmFsdWUpIHx8IGlzUmVhZG9ubHkodmFsdWUpO1xyXG59XHJcbmZ1bmN0aW9uIHRvUmF3KG9ic2VydmVkKSB7XHJcbiAgICBjb25zdCByYXcgPSBvYnNlcnZlZCAmJiBvYnNlcnZlZFtcIl9fdl9yYXdcIiAvKiBSQVcgKi9dO1xyXG4gICAgcmV0dXJuIHJhdyA/IHRvUmF3KHJhdykgOiBvYnNlcnZlZDtcclxufVxyXG5mdW5jdGlvbiBtYXJrUmF3KHZhbHVlKSB7XHJcbiAgICBkZWYodmFsdWUsIFwiX192X3NraXBcIiAvKiBTS0lQICovLCB0cnVlKTtcclxuICAgIHJldHVybiB2YWx1ZTtcclxufVxyXG5jb25zdCB0b1JlYWN0aXZlID0gKHZhbHVlKSA9PiBpc09iamVjdCh2YWx1ZSkgPyByZWFjdGl2ZSh2YWx1ZSkgOiB2YWx1ZTtcclxuY29uc3QgdG9SZWFkb25seSA9ICh2YWx1ZSkgPT4gaXNPYmplY3QodmFsdWUpID8gcmVhZG9ubHkodmFsdWUpIDogdmFsdWU7XG5cbmZ1bmN0aW9uIHRyYWNrUmVmVmFsdWUocmVmKSB7XHJcbiAgICBpZiAoc2hvdWxkVHJhY2sgJiYgYWN0aXZlRWZmZWN0KSB7XHJcbiAgICAgICAgcmVmID0gdG9SYXcocmVmKTtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHRyYWNrRWZmZWN0cyhyZWYuZGVwIHx8IChyZWYuZGVwID0gY3JlYXRlRGVwKCkpLCB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHJlZixcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwiZ2V0XCIgLyogR0VUICovLFxyXG4gICAgICAgICAgICAgICAga2V5OiAndmFsdWUnXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdHJhY2tFZmZlY3RzKHJlZi5kZXAgfHwgKHJlZi5kZXAgPSBjcmVhdGVEZXAoKSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB0cmlnZ2VyUmVmVmFsdWUocmVmLCBuZXdWYWwpIHtcclxuICAgIHJlZiA9IHRvUmF3KHJlZik7XHJcbiAgICBpZiAocmVmLmRlcCkge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgdHJpZ2dlckVmZmVjdHMocmVmLmRlcCwge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiByZWYsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcInNldFwiIC8qIFNFVCAqLyxcclxuICAgICAgICAgICAgICAgIGtleTogJ3ZhbHVlJyxcclxuICAgICAgICAgICAgICAgIG5ld1ZhbHVlOiBuZXdWYWxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0cmlnZ2VyRWZmZWN0cyhyZWYuZGVwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaXNSZWYocikge1xyXG4gICAgcmV0dXJuICEhKHIgJiYgci5fX3ZfaXNSZWYgPT09IHRydWUpO1xyXG59XHJcbmZ1bmN0aW9uIHJlZih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIGNyZWF0ZVJlZih2YWx1ZSwgZmFsc2UpO1xyXG59XHJcbmZ1bmN0aW9uIHNoYWxsb3dSZWYodmFsdWUpIHtcclxuICAgIHJldHVybiBjcmVhdGVSZWYodmFsdWUsIHRydWUpO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVJlZihyYXdWYWx1ZSwgc2hhbGxvdykge1xyXG4gICAgaWYgKGlzUmVmKHJhd1ZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiByYXdWYWx1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgUmVmSW1wbChyYXdWYWx1ZSwgc2hhbGxvdyk7XHJcbn1cclxuY2xhc3MgUmVmSW1wbCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSwgX192X2lzU2hhbGxvdykge1xyXG4gICAgICAgIHRoaXMuX192X2lzU2hhbGxvdyA9IF9fdl9pc1NoYWxsb3c7XHJcbiAgICAgICAgdGhpcy5kZXAgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5fX3ZfaXNSZWYgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX3Jhd1ZhbHVlID0gX192X2lzU2hhbGxvdyA/IHZhbHVlIDogdG9SYXcodmFsdWUpO1xyXG4gICAgICAgIHRoaXMuX3ZhbHVlID0gX192X2lzU2hhbGxvdyA/IHZhbHVlIDogdG9SZWFjdGl2ZSh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBnZXQgdmFsdWUoKSB7XHJcbiAgICAgICAgdHJhY2tSZWZWYWx1ZSh0aGlzKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XHJcbiAgICB9XHJcbiAgICBzZXQgdmFsdWUobmV3VmFsKSB7XHJcbiAgICAgICAgbmV3VmFsID0gdGhpcy5fX3ZfaXNTaGFsbG93ID8gbmV3VmFsIDogdG9SYXcobmV3VmFsKTtcclxuICAgICAgICBpZiAoaGFzQ2hhbmdlZChuZXdWYWwsIHRoaXMuX3Jhd1ZhbHVlKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9yYXdWYWx1ZSA9IG5ld1ZhbDtcclxuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSB0aGlzLl9fdl9pc1NoYWxsb3cgPyBuZXdWYWwgOiB0b1JlYWN0aXZlKG5ld1ZhbCk7XHJcbiAgICAgICAgICAgIHRyaWdnZXJSZWZWYWx1ZSh0aGlzLCBuZXdWYWwpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB0cmlnZ2VyUmVmKHJlZikge1xyXG4gICAgdHJpZ2dlclJlZlZhbHVlKHJlZiwgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gcmVmLnZhbHVlIDogdm9pZCAwKTtcclxufVxyXG5mdW5jdGlvbiB1bnJlZihyZWYpIHtcclxuICAgIHJldHVybiBpc1JlZihyZWYpID8gcmVmLnZhbHVlIDogcmVmO1xyXG59XHJcbmNvbnN0IHNoYWxsb3dVbndyYXBIYW5kbGVycyA9IHtcclxuICAgIGdldDogKHRhcmdldCwga2V5LCByZWNlaXZlcikgPT4gdW5yZWYoUmVmbGVjdC5nZXQodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSksXHJcbiAgICBzZXQ6ICh0YXJnZXQsIGtleSwgdmFsdWUsIHJlY2VpdmVyKSA9PiB7XHJcbiAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0YXJnZXRba2V5XTtcclxuICAgICAgICBpZiAoaXNSZWYob2xkVmFsdWUpICYmICFpc1JlZih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgb2xkVmFsdWUudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5zZXQodGFyZ2V0LCBrZXksIHZhbHVlLCByZWNlaXZlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5mdW5jdGlvbiBwcm94eVJlZnMob2JqZWN0V2l0aFJlZnMpIHtcclxuICAgIHJldHVybiBpc1JlYWN0aXZlKG9iamVjdFdpdGhSZWZzKVxyXG4gICAgICAgID8gb2JqZWN0V2l0aFJlZnNcclxuICAgICAgICA6IG5ldyBQcm94eShvYmplY3RXaXRoUmVmcywgc2hhbGxvd1Vud3JhcEhhbmRsZXJzKTtcclxufVxyXG5jbGFzcyBDdXN0b21SZWZJbXBsIHtcclxuICAgIGNvbnN0cnVjdG9yKGZhY3RvcnkpIHtcclxuICAgICAgICB0aGlzLmRlcCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLl9fdl9pc1JlZiA9IHRydWU7XHJcbiAgICAgICAgY29uc3QgeyBnZXQsIHNldCB9ID0gZmFjdG9yeSgoKSA9PiB0cmFja1JlZlZhbHVlKHRoaXMpLCAoKSA9PiB0cmlnZ2VyUmVmVmFsdWUodGhpcykpO1xyXG4gICAgICAgIHRoaXMuX2dldCA9IGdldDtcclxuICAgICAgICB0aGlzLl9zZXQgPSBzZXQ7XHJcbiAgICB9XHJcbiAgICBnZXQgdmFsdWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldCgpO1xyXG4gICAgfVxyXG4gICAgc2V0IHZhbHVlKG5ld1ZhbCkge1xyXG4gICAgICAgIHRoaXMuX3NldChuZXdWYWwpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGN1c3RvbVJlZihmYWN0b3J5KSB7XHJcbiAgICByZXR1cm4gbmV3IEN1c3RvbVJlZkltcGwoZmFjdG9yeSk7XHJcbn1cclxuZnVuY3Rpb24gdG9SZWZzKG9iamVjdCkge1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaXNQcm94eShvYmplY3QpKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKGB0b1JlZnMoKSBleHBlY3RzIGEgcmVhY3RpdmUgb2JqZWN0IGJ1dCByZWNlaXZlZCBhIHBsYWluIG9uZS5gKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHJldCA9IGlzQXJyYXkob2JqZWN0KSA/IG5ldyBBcnJheShvYmplY3QubGVuZ3RoKSA6IHt9O1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqZWN0KSB7XHJcbiAgICAgICAgcmV0W2tleV0gPSB0b1JlZihvYmplY3QsIGtleSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG59XHJcbmNsYXNzIE9iamVjdFJlZkltcGwge1xyXG4gICAgY29uc3RydWN0b3IoX29iamVjdCwgX2tleSwgX2RlZmF1bHRWYWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX29iamVjdCA9IF9vYmplY3Q7XHJcbiAgICAgICAgdGhpcy5fa2V5ID0gX2tleTtcclxuICAgICAgICB0aGlzLl9kZWZhdWx0VmFsdWUgPSBfZGVmYXVsdFZhbHVlO1xyXG4gICAgICAgIHRoaXMuX192X2lzUmVmID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGdldCB2YWx1ZSgpIHtcclxuICAgICAgICBjb25zdCB2YWwgPSB0aGlzLl9vYmplY3RbdGhpcy5fa2V5XTtcclxuICAgICAgICByZXR1cm4gdmFsID09PSB1bmRlZmluZWQgPyB0aGlzLl9kZWZhdWx0VmFsdWUgOiB2YWw7XHJcbiAgICB9XHJcbiAgICBzZXQgdmFsdWUobmV3VmFsKSB7XHJcbiAgICAgICAgdGhpcy5fb2JqZWN0W3RoaXMuX2tleV0gPSBuZXdWYWw7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdG9SZWYob2JqZWN0LCBrZXksIGRlZmF1bHRWYWx1ZSkge1xyXG4gICAgY29uc3QgdmFsID0gb2JqZWN0W2tleV07XHJcbiAgICByZXR1cm4gaXNSZWYodmFsKVxyXG4gICAgICAgID8gdmFsXHJcbiAgICAgICAgOiBuZXcgT2JqZWN0UmVmSW1wbChvYmplY3QsIGtleSwgZGVmYXVsdFZhbHVlKTtcclxufVxuXG5jbGFzcyBDb21wdXRlZFJlZkltcGwge1xyXG4gICAgY29uc3RydWN0b3IoZ2V0dGVyLCBfc2V0dGVyLCBpc1JlYWRvbmx5LCBpc1NTUikge1xyXG4gICAgICAgIHRoaXMuX3NldHRlciA9IF9zZXR0ZXI7XHJcbiAgICAgICAgdGhpcy5kZXAgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5fX3ZfaXNSZWYgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmVmZmVjdCA9IG5ldyBSZWFjdGl2ZUVmZmVjdChnZXR0ZXIsICgpID0+IHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9kaXJ0eSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlydHkgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdHJpZ2dlclJlZlZhbHVlKHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5lZmZlY3QuY29tcHV0ZWQgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuZWZmZWN0LmFjdGl2ZSA9IHRoaXMuX2NhY2hlYWJsZSA9ICFpc1NTUjtcclxuICAgICAgICB0aGlzW1wiX192X2lzUmVhZG9ubHlcIiAvKiBJU19SRUFET05MWSAqL10gPSBpc1JlYWRvbmx5O1xyXG4gICAgfVxyXG4gICAgZ2V0IHZhbHVlKCkge1xyXG4gICAgICAgIC8vIHRoZSBjb21wdXRlZCByZWYgbWF5IGdldCB3cmFwcGVkIGJ5IG90aGVyIHByb3hpZXMgZS5nLiByZWFkb25seSgpICMzMzc2XHJcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRvUmF3KHRoaXMpO1xyXG4gICAgICAgIHRyYWNrUmVmVmFsdWUoc2VsZik7XHJcbiAgICAgICAgaWYgKHNlbGYuX2RpcnR5IHx8ICFzZWxmLl9jYWNoZWFibGUpIHtcclxuICAgICAgICAgICAgc2VsZi5fZGlydHkgPSBmYWxzZTtcclxuICAgICAgICAgICAgc2VsZi5fdmFsdWUgPSBzZWxmLmVmZmVjdC5ydW4oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNlbGYuX3ZhbHVlO1xyXG4gICAgfVxyXG4gICAgc2V0IHZhbHVlKG5ld1ZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fc2V0dGVyKG5ld1ZhbHVlKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjb21wdXRlZChnZXR0ZXJPck9wdGlvbnMsIGRlYnVnT3B0aW9ucywgaXNTU1IgPSBmYWxzZSkge1xyXG4gICAgbGV0IGdldHRlcjtcclxuICAgIGxldCBzZXR0ZXI7XHJcbiAgICBjb25zdCBvbmx5R2V0dGVyID0gaXNGdW5jdGlvbihnZXR0ZXJPck9wdGlvbnMpO1xyXG4gICAgaWYgKG9ubHlHZXR0ZXIpIHtcclxuICAgICAgICBnZXR0ZXIgPSBnZXR0ZXJPck9wdGlvbnM7XHJcbiAgICAgICAgc2V0dGVyID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXHJcbiAgICAgICAgICAgID8gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdXcml0ZSBvcGVyYXRpb24gZmFpbGVkOiBjb21wdXRlZCB2YWx1ZSBpcyByZWFkb25seScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIDogTk9PUDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGdldHRlciA9IGdldHRlck9yT3B0aW9ucy5nZXQ7XHJcbiAgICAgICAgc2V0dGVyID0gZ2V0dGVyT3JPcHRpb25zLnNldDtcclxuICAgIH1cclxuICAgIGNvbnN0IGNSZWYgPSBuZXcgQ29tcHV0ZWRSZWZJbXBsKGdldHRlciwgc2V0dGVyLCBvbmx5R2V0dGVyIHx8ICFzZXR0ZXIsIGlzU1NSKTtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgZGVidWdPcHRpb25zICYmICFpc1NTUikge1xyXG4gICAgICAgIGNSZWYuZWZmZWN0Lm9uVHJhY2sgPSBkZWJ1Z09wdGlvbnMub25UcmFjaztcclxuICAgICAgICBjUmVmLmVmZmVjdC5vblRyaWdnZXIgPSBkZWJ1Z09wdGlvbnMub25UcmlnZ2VyO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNSZWY7XHJcbn1cblxudmFyIF9hO1xyXG5jb25zdCB0aWNrID0gLyojX19QVVJFX18qLyBQcm9taXNlLnJlc29sdmUoKTtcclxuY29uc3QgcXVldWUgPSBbXTtcclxubGV0IHF1ZXVlZCA9IGZhbHNlO1xyXG5jb25zdCBzY2hlZHVsZXIgPSAoZm4pID0+IHtcclxuICAgIHF1ZXVlLnB1c2goZm4pO1xyXG4gICAgaWYgKCFxdWV1ZWQpIHtcclxuICAgICAgICBxdWV1ZWQgPSB0cnVlO1xyXG4gICAgICAgIHRpY2sudGhlbihmbHVzaCk7XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IGZsdXNoID0gKCkgPT4ge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHF1ZXVlW2ldKCk7XHJcbiAgICB9XHJcbiAgICBxdWV1ZS5sZW5ndGggPSAwO1xyXG4gICAgcXVldWVkID0gZmFsc2U7XHJcbn07XHJcbmNsYXNzIERlZmVycmVkQ29tcHV0ZWRSZWZJbXBsIHtcclxuICAgIGNvbnN0cnVjdG9yKGdldHRlcikge1xyXG4gICAgICAgIHRoaXMuZGVwID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9fdl9pc1JlZiA9IHRydWU7XHJcbiAgICAgICAgdGhpc1tfYV0gPSB0cnVlO1xyXG4gICAgICAgIGxldCBjb21wYXJlVGFyZ2V0O1xyXG4gICAgICAgIGxldCBoYXNDb21wYXJlVGFyZ2V0ID0gZmFsc2U7XHJcbiAgICAgICAgbGV0IHNjaGVkdWxlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZWZmZWN0ID0gbmV3IFJlYWN0aXZlRWZmZWN0KGdldHRlciwgKGNvbXB1dGVkVHJpZ2dlcikgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5kZXApIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb21wdXRlZFRyaWdnZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb21wYXJlVGFyZ2V0ID0gdGhpcy5fdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzQ29tcGFyZVRhcmdldCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghc2NoZWR1bGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWVUb0NvbXBhcmUgPSBoYXNDb21wYXJlVGFyZ2V0ID8gY29tcGFyZVRhcmdldCA6IHRoaXMuX3ZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHNjaGVkdWxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzQ29tcGFyZVRhcmdldCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHNjaGVkdWxlcigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmVmZmVjdC5hY3RpdmUgJiYgdGhpcy5fZ2V0KCkgIT09IHZhbHVlVG9Db21wYXJlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyUmVmVmFsdWUodGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgc2NoZWR1bGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBjaGFpbmVkIHVwc3RyZWFtIGNvbXB1dGVkcyBhcmUgbm90aWZpZWQgc3luY2hyb25vdXNseSB0byBlbnN1cmVcclxuICAgICAgICAgICAgICAgIC8vIHZhbHVlIGludmFsaWRhdGlvbiBpbiBjYXNlIG9mIHN5bmMgYWNjZXNzOyBub3JtYWwgZWZmZWN0cyBhcmVcclxuICAgICAgICAgICAgICAgIC8vIGRlZmVycmVkIHRvIGJlIHRyaWdnZXJlZCBpbiBzY2hlZHVsZXIuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGUgb2YgdGhpcy5kZXApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZS5jb21wdXRlZCBpbnN0YW5jZW9mIERlZmVycmVkQ29tcHV0ZWRSZWZJbXBsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2NoZWR1bGVyKHRydWUgLyogY29tcHV0ZWRUcmlnZ2VyICovKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fZGlydHkgPSB0cnVlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuZWZmZWN0LmNvbXB1dGVkID0gdGhpcztcclxuICAgIH1cclxuICAgIF9nZXQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2RpcnR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5fdmFsdWUgPSB0aGlzLmVmZmVjdC5ydW4oKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcclxuICAgIH1cclxuICAgIGdldCB2YWx1ZSgpIHtcclxuICAgICAgICB0cmFja1JlZlZhbHVlKHRoaXMpO1xyXG4gICAgICAgIC8vIHRoZSBjb21wdXRlZCByZWYgbWF5IGdldCB3cmFwcGVkIGJ5IG90aGVyIHByb3hpZXMgZS5nLiByZWFkb25seSgpICMzMzc2XHJcbiAgICAgICAgcmV0dXJuIHRvUmF3KHRoaXMpLl9nZXQoKTtcclxuICAgIH1cclxufVxyXG5fYSA9IFwiX192X2lzUmVhZG9ubHlcIiAvKiBJU19SRUFET05MWSAqLztcclxuZnVuY3Rpb24gZGVmZXJyZWRDb21wdXRlZChnZXR0ZXIpIHtcclxuICAgIHJldHVybiBuZXcgRGVmZXJyZWRDb21wdXRlZFJlZkltcGwoZ2V0dGVyKTtcclxufVxuXG5leHBvcnQgeyBFZmZlY3RTY29wZSwgSVRFUkFURV9LRVksIFJlYWN0aXZlRWZmZWN0LCBjb21wdXRlZCwgY3VzdG9tUmVmLCBkZWZlcnJlZENvbXB1dGVkLCBlZmZlY3QsIGVmZmVjdFNjb3BlLCBlbmFibGVUcmFja2luZywgZ2V0Q3VycmVudFNjb3BlLCBpc1Byb3h5LCBpc1JlYWN0aXZlLCBpc1JlYWRvbmx5LCBpc1JlZiwgaXNTaGFsbG93LCBtYXJrUmF3LCBvblNjb3BlRGlzcG9zZSwgcGF1c2VUcmFja2luZywgcHJveHlSZWZzLCByZWFjdGl2ZSwgcmVhZG9ubHksIHJlZiwgcmVzZXRUcmFja2luZywgc2hhbGxvd1JlYWN0aXZlLCBzaGFsbG93UmVhZG9ubHksIHNoYWxsb3dSZWYsIHN0b3AsIHRvUmF3LCB0b1JlZiwgdG9SZWZzLCB0cmFjaywgdHJpZ2dlciwgdHJpZ2dlclJlZiwgdW5yZWYgfTtcbiIsImltcG9ydCB7IHBhdXNlVHJhY2tpbmcsIHJlc2V0VHJhY2tpbmcsIGlzUmVmLCB0b1JhdywgaXNTaGFsbG93IGFzIGlzU2hhbGxvdyQxLCBpc1JlYWN0aXZlLCBSZWFjdGl2ZUVmZmVjdCwgcmVmLCBzaGFsbG93UmVhZG9ubHksIHRyYWNrLCByZWFjdGl2ZSwgc2hhbGxvd1JlYWN0aXZlLCB0cmlnZ2VyLCBpc1Byb3h5LCBFZmZlY3RTY29wZSwgbWFya1JhdywgcHJveHlSZWZzLCBjb21wdXRlZCBhcyBjb21wdXRlZCQxLCBpc1JlYWRvbmx5IH0gZnJvbSAnQHZ1ZS9yZWFjdGl2aXR5JztcbmV4cG9ydCB7IEVmZmVjdFNjb3BlLCBSZWFjdGl2ZUVmZmVjdCwgY3VzdG9tUmVmLCBlZmZlY3QsIGVmZmVjdFNjb3BlLCBnZXRDdXJyZW50U2NvcGUsIGlzUHJveHksIGlzUmVhY3RpdmUsIGlzUmVhZG9ubHksIGlzUmVmLCBpc1NoYWxsb3csIG1hcmtSYXcsIG9uU2NvcGVEaXNwb3NlLCBwcm94eVJlZnMsIHJlYWN0aXZlLCByZWFkb25seSwgcmVmLCBzaGFsbG93UmVhY3RpdmUsIHNoYWxsb3dSZWFkb25seSwgc2hhbGxvd1JlZiwgc3RvcCwgdG9SYXcsIHRvUmVmLCB0b1JlZnMsIHRyaWdnZXJSZWYsIHVucmVmIH0gZnJvbSAnQHZ1ZS9yZWFjdGl2aXR5JztcbmltcG9ydCB7IGlzU3RyaW5nLCBpc0Z1bmN0aW9uLCBpc1Byb21pc2UsIGlzQXJyYXksIE5PT1AsIGdldEdsb2JhbFRoaXMsIGV4dGVuZCwgRU1QVFlfT0JKLCB0b0hhbmRsZXJLZXksIHRvTnVtYmVyLCBoeXBoZW5hdGUsIGNhbWVsaXplLCBpc09uLCBoYXNPd24sIGlzTW9kZWxMaXN0ZW5lciwgaGFzQ2hhbmdlZCwgcmVtb3ZlLCBpc09iamVjdCwgaXNTZXQsIGlzTWFwLCBpc1BsYWluT2JqZWN0LCBpbnZva2VBcnJheUZucywgaXNCdWlsdEluRGlyZWN0aXZlLCBjYXBpdGFsaXplLCBpc0dsb2JhbGx5V2hpdGVsaXN0ZWQsIGRlZiwgaXNSZXNlcnZlZFByb3AsIEVNUFRZX0FSUiwgdG9SYXdUeXBlLCBtYWtlTWFwLCBOTywgbm9ybWFsaXplQ2xhc3MsIG5vcm1hbGl6ZVN0eWxlIH0gZnJvbSAnQHZ1ZS9zaGFyZWQnO1xuZXhwb3J0IHsgY2FtZWxpemUsIGNhcGl0YWxpemUsIG5vcm1hbGl6ZUNsYXNzLCBub3JtYWxpemVQcm9wcywgbm9ybWFsaXplU3R5bGUsIHRvRGlzcGxheVN0cmluZywgdG9IYW5kbGVyS2V5IH0gZnJvbSAnQHZ1ZS9zaGFyZWQnO1xuXG5jb25zdCBzdGFjayA9IFtdO1xyXG5mdW5jdGlvbiBwdXNoV2FybmluZ0NvbnRleHQodm5vZGUpIHtcclxuICAgIHN0YWNrLnB1c2godm5vZGUpO1xyXG59XHJcbmZ1bmN0aW9uIHBvcFdhcm5pbmdDb250ZXh0KCkge1xyXG4gICAgc3RhY2sucG9wKCk7XHJcbn1cclxuZnVuY3Rpb24gd2Fybihtc2csIC4uLmFyZ3MpIHtcclxuICAgIC8vIGF2b2lkIHByb3BzIGZvcm1hdHRpbmcgb3Igd2FybiBoYW5kbGVyIHRyYWNraW5nIGRlcHMgdGhhdCBtaWdodCBiZSBtdXRhdGVkXHJcbiAgICAvLyBkdXJpbmcgcGF0Y2gsIGxlYWRpbmcgdG8gaW5maW5pdGUgcmVjdXJzaW9uLlxyXG4gICAgcGF1c2VUcmFja2luZygpO1xyXG4gICAgY29uc3QgaW5zdGFuY2UgPSBzdGFjay5sZW5ndGggPyBzdGFja1tzdGFjay5sZW5ndGggLSAxXS5jb21wb25lbnQgOiBudWxsO1xyXG4gICAgY29uc3QgYXBwV2FybkhhbmRsZXIgPSBpbnN0YW5jZSAmJiBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZy53YXJuSGFuZGxlcjtcclxuICAgIGNvbnN0IHRyYWNlID0gZ2V0Q29tcG9uZW50VHJhY2UoKTtcclxuICAgIGlmIChhcHBXYXJuSGFuZGxlcikge1xyXG4gICAgICAgIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhhcHBXYXJuSGFuZGxlciwgaW5zdGFuY2UsIDExIC8qIEFQUF9XQVJOX0hBTkRMRVIgKi8sIFtcclxuICAgICAgICAgICAgbXNnICsgYXJncy5qb2luKCcnKSxcclxuICAgICAgICAgICAgaW5zdGFuY2UgJiYgaW5zdGFuY2UucHJveHksXHJcbiAgICAgICAgICAgIHRyYWNlXHJcbiAgICAgICAgICAgICAgICAubWFwKCh7IHZub2RlIH0pID0+IGBhdCA8JHtmb3JtYXRDb21wb25lbnROYW1lKGluc3RhbmNlLCB2bm9kZS50eXBlKX0+YClcclxuICAgICAgICAgICAgICAgIC5qb2luKCdcXG4nKSxcclxuICAgICAgICAgICAgdHJhY2VcclxuICAgICAgICBdKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IHdhcm5BcmdzID0gW2BbVnVlIHdhcm5dOiAke21zZ31gLCAuLi5hcmdzXTtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgICBpZiAodHJhY2UubGVuZ3RoICYmXHJcbiAgICAgICAgICAgIC8vIGF2b2lkIHNwYW1taW5nIGNvbnNvbGUgZHVyaW5nIHRlc3RzXHJcbiAgICAgICAgICAgICFmYWxzZSkge1xyXG4gICAgICAgICAgICB3YXJuQXJncy5wdXNoKGBcXG5gLCAuLi5mb3JtYXRUcmFjZSh0cmFjZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zb2xlLndhcm4oLi4ud2FybkFyZ3MpO1xyXG4gICAgfVxyXG4gICAgcmVzZXRUcmFja2luZygpO1xyXG59XHJcbmZ1bmN0aW9uIGdldENvbXBvbmVudFRyYWNlKCkge1xyXG4gICAgbGV0IGN1cnJlbnRWTm9kZSA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xyXG4gICAgaWYgKCFjdXJyZW50Vk5vZGUpIHtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgICAvLyB3ZSBjYW4ndCBqdXN0IHVzZSB0aGUgc3RhY2sgYmVjYXVzZSBpdCB3aWxsIGJlIGluY29tcGxldGUgZHVyaW5nIHVwZGF0ZXNcclxuICAgIC8vIHRoYXQgZGlkIG5vdCBzdGFydCBmcm9tIHRoZSByb290LiBSZS1jb25zdHJ1Y3QgdGhlIHBhcmVudCBjaGFpbiB1c2luZ1xyXG4gICAgLy8gaW5zdGFuY2UgcGFyZW50IHBvaW50ZXJzLlxyXG4gICAgY29uc3Qgbm9ybWFsaXplZFN0YWNrID0gW107XHJcbiAgICB3aGlsZSAoY3VycmVudFZOb2RlKSB7XHJcbiAgICAgICAgY29uc3QgbGFzdCA9IG5vcm1hbGl6ZWRTdGFja1swXTtcclxuICAgICAgICBpZiAobGFzdCAmJiBsYXN0LnZub2RlID09PSBjdXJyZW50Vk5vZGUpIHtcclxuICAgICAgICAgICAgbGFzdC5yZWN1cnNlQ291bnQrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRTdGFjay5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHZub2RlOiBjdXJyZW50Vk5vZGUsXHJcbiAgICAgICAgICAgICAgICByZWN1cnNlQ291bnQ6IDBcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHBhcmVudEluc3RhbmNlID0gY3VycmVudFZOb2RlLmNvbXBvbmVudCAmJiBjdXJyZW50Vk5vZGUuY29tcG9uZW50LnBhcmVudDtcclxuICAgICAgICBjdXJyZW50Vk5vZGUgPSBwYXJlbnRJbnN0YW5jZSAmJiBwYXJlbnRJbnN0YW5jZS52bm9kZTtcclxuICAgIH1cclxuICAgIHJldHVybiBub3JtYWxpemVkU3RhY2s7XHJcbn1cclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuZnVuY3Rpb24gZm9ybWF0VHJhY2UodHJhY2UpIHtcclxuICAgIGNvbnN0IGxvZ3MgPSBbXTtcclxuICAgIHRyYWNlLmZvckVhY2goKGVudHJ5LCBpKSA9PiB7XHJcbiAgICAgICAgbG9ncy5wdXNoKC4uLihpID09PSAwID8gW10gOiBbYFxcbmBdKSwgLi4uZm9ybWF0VHJhY2VFbnRyeShlbnRyeSkpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gbG9ncztcclxufVxyXG5mdW5jdGlvbiBmb3JtYXRUcmFjZUVudHJ5KHsgdm5vZGUsIHJlY3Vyc2VDb3VudCB9KSB7XHJcbiAgICBjb25zdCBwb3N0Zml4ID0gcmVjdXJzZUNvdW50ID4gMCA/IGAuLi4gKCR7cmVjdXJzZUNvdW50fSByZWN1cnNpdmUgY2FsbHMpYCA6IGBgO1xyXG4gICAgY29uc3QgaXNSb290ID0gdm5vZGUuY29tcG9uZW50ID8gdm5vZGUuY29tcG9uZW50LnBhcmVudCA9PSBudWxsIDogZmFsc2U7XHJcbiAgICBjb25zdCBvcGVuID0gYCBhdCA8JHtmb3JtYXRDb21wb25lbnROYW1lKHZub2RlLmNvbXBvbmVudCwgdm5vZGUudHlwZSwgaXNSb290KX1gO1xyXG4gICAgY29uc3QgY2xvc2UgPSBgPmAgKyBwb3N0Zml4O1xyXG4gICAgcmV0dXJuIHZub2RlLnByb3BzXHJcbiAgICAgICAgPyBbb3BlbiwgLi4uZm9ybWF0UHJvcHModm5vZGUucHJvcHMpLCBjbG9zZV1cclxuICAgICAgICA6IFtvcGVuICsgY2xvc2VdO1xyXG59XHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbmZ1bmN0aW9uIGZvcm1hdFByb3BzKHByb3BzKSB7XHJcbiAgICBjb25zdCByZXMgPSBbXTtcclxuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhwcm9wcyk7XHJcbiAgICBrZXlzLnNsaWNlKDAsIDMpLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICByZXMucHVzaCguLi5mb3JtYXRQcm9wKGtleSwgcHJvcHNba2V5XSkpO1xyXG4gICAgfSk7XHJcbiAgICBpZiAoa2V5cy5sZW5ndGggPiAzKSB7XHJcbiAgICAgICAgcmVzLnB1c2goYCAuLi5gKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuZnVuY3Rpb24gZm9ybWF0UHJvcChrZXksIHZhbHVlLCByYXcpIHtcclxuICAgIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcclxuICAgICAgICB2YWx1ZSA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcclxuICAgICAgICByZXR1cm4gcmF3ID8gdmFsdWUgOiBbYCR7a2V5fT0ke3ZhbHVlfWBdO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fFxyXG4gICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nIHx8XHJcbiAgICAgICAgdmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiByYXcgPyB2YWx1ZSA6IFtgJHtrZXl9PSR7dmFsdWV9YF07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc1JlZih2YWx1ZSkpIHtcclxuICAgICAgICB2YWx1ZSA9IGZvcm1hdFByb3Aoa2V5LCB0b1Jhdyh2YWx1ZS52YWx1ZSksIHRydWUpO1xyXG4gICAgICAgIHJldHVybiByYXcgPyB2YWx1ZSA6IFtgJHtrZXl9PVJlZjxgLCB2YWx1ZSwgYD5gXTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIFtgJHtrZXl9PWZuJHt2YWx1ZS5uYW1lID8gYDwke3ZhbHVlLm5hbWV9PmAgOiBgYH1gXTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhbHVlID0gdG9SYXcodmFsdWUpO1xyXG4gICAgICAgIHJldHVybiByYXcgPyB2YWx1ZSA6IFtgJHtrZXl9PWAsIHZhbHVlXTtcclxuICAgIH1cclxufVxuXG5jb25zdCBFcnJvclR5cGVTdHJpbmdzID0ge1xyXG4gICAgW1wic3BcIiAvKiBTRVJWRVJfUFJFRkVUQ0ggKi9dOiAnc2VydmVyUHJlZmV0Y2ggaG9vaycsXHJcbiAgICBbXCJiY1wiIC8qIEJFRk9SRV9DUkVBVEUgKi9dOiAnYmVmb3JlQ3JlYXRlIGhvb2snLFxyXG4gICAgW1wiY1wiIC8qIENSRUFURUQgKi9dOiAnY3JlYXRlZCBob29rJyxcclxuICAgIFtcImJtXCIgLyogQkVGT1JFX01PVU5UICovXTogJ2JlZm9yZU1vdW50IGhvb2snLFxyXG4gICAgW1wibVwiIC8qIE1PVU5URUQgKi9dOiAnbW91bnRlZCBob29rJyxcclxuICAgIFtcImJ1XCIgLyogQkVGT1JFX1VQREFURSAqL106ICdiZWZvcmVVcGRhdGUgaG9vaycsXHJcbiAgICBbXCJ1XCIgLyogVVBEQVRFRCAqL106ICd1cGRhdGVkJyxcclxuICAgIFtcImJ1bVwiIC8qIEJFRk9SRV9VTk1PVU5UICovXTogJ2JlZm9yZVVubW91bnQgaG9vaycsXHJcbiAgICBbXCJ1bVwiIC8qIFVOTU9VTlRFRCAqL106ICd1bm1vdW50ZWQgaG9vaycsXHJcbiAgICBbXCJhXCIgLyogQUNUSVZBVEVEICovXTogJ2FjdGl2YXRlZCBob29rJyxcclxuICAgIFtcImRhXCIgLyogREVBQ1RJVkFURUQgKi9dOiAnZGVhY3RpdmF0ZWQgaG9vaycsXHJcbiAgICBbXCJlY1wiIC8qIEVSUk9SX0NBUFRVUkVEICovXTogJ2Vycm9yQ2FwdHVyZWQgaG9vaycsXHJcbiAgICBbXCJydGNcIiAvKiBSRU5ERVJfVFJBQ0tFRCAqL106ICdyZW5kZXJUcmFja2VkIGhvb2snLFxyXG4gICAgW1wicnRnXCIgLyogUkVOREVSX1RSSUdHRVJFRCAqL106ICdyZW5kZXJUcmlnZ2VyZWQgaG9vaycsXHJcbiAgICBbMCAvKiBTRVRVUF9GVU5DVElPTiAqL106ICdzZXR1cCBmdW5jdGlvbicsXHJcbiAgICBbMSAvKiBSRU5ERVJfRlVOQ1RJT04gKi9dOiAncmVuZGVyIGZ1bmN0aW9uJyxcclxuICAgIFsyIC8qIFdBVENIX0dFVFRFUiAqL106ICd3YXRjaGVyIGdldHRlcicsXHJcbiAgICBbMyAvKiBXQVRDSF9DQUxMQkFDSyAqL106ICd3YXRjaGVyIGNhbGxiYWNrJyxcclxuICAgIFs0IC8qIFdBVENIX0NMRUFOVVAgKi9dOiAnd2F0Y2hlciBjbGVhbnVwIGZ1bmN0aW9uJyxcclxuICAgIFs1IC8qIE5BVElWRV9FVkVOVF9IQU5ETEVSICovXTogJ25hdGl2ZSBldmVudCBoYW5kbGVyJyxcclxuICAgIFs2IC8qIENPTVBPTkVOVF9FVkVOVF9IQU5ETEVSICovXTogJ2NvbXBvbmVudCBldmVudCBoYW5kbGVyJyxcclxuICAgIFs3IC8qIFZOT0RFX0hPT0sgKi9dOiAndm5vZGUgaG9vaycsXHJcbiAgICBbOCAvKiBESVJFQ1RJVkVfSE9PSyAqL106ICdkaXJlY3RpdmUgaG9vaycsXHJcbiAgICBbOSAvKiBUUkFOU0lUSU9OX0hPT0sgKi9dOiAndHJhbnNpdGlvbiBob29rJyxcclxuICAgIFsxMCAvKiBBUFBfRVJST1JfSEFORExFUiAqL106ICdhcHAgZXJyb3JIYW5kbGVyJyxcclxuICAgIFsxMSAvKiBBUFBfV0FSTl9IQU5ETEVSICovXTogJ2FwcCB3YXJuSGFuZGxlcicsXHJcbiAgICBbMTIgLyogRlVOQ1RJT05fUkVGICovXTogJ3JlZiBmdW5jdGlvbicsXHJcbiAgICBbMTMgLyogQVNZTkNfQ09NUE9ORU5UX0xPQURFUiAqL106ICdhc3luYyBjb21wb25lbnQgbG9hZGVyJyxcclxuICAgIFsxNCAvKiBTQ0hFRFVMRVIgKi9dOiAnc2NoZWR1bGVyIGZsdXNoLiBUaGlzIGlzIGxpa2VseSBhIFZ1ZSBpbnRlcm5hbHMgYnVnLiAnICtcclxuICAgICAgICAnUGxlYXNlIG9wZW4gYW4gaXNzdWUgYXQgaHR0cHM6Ly9uZXctaXNzdWUudnVlanMub3JnLz9yZXBvPXZ1ZWpzL2NvcmUnXHJcbn07XHJcbmZ1bmN0aW9uIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhmbiwgaW5zdGFuY2UsIHR5cGUsIGFyZ3MpIHtcclxuICAgIGxldCByZXM7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJlcyA9IGFyZ3MgPyBmbiguLi5hcmdzKSA6IGZuKCk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgaGFuZGxlRXJyb3IoZXJyLCBpbnN0YW5jZSwgdHlwZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbmZ1bmN0aW9uIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGZuLCBpbnN0YW5jZSwgdHlwZSwgYXJncykge1xyXG4gICAgaWYgKGlzRnVuY3Rpb24oZm4pKSB7XHJcbiAgICAgICAgY29uc3QgcmVzID0gY2FsbFdpdGhFcnJvckhhbmRsaW5nKGZuLCBpbnN0YW5jZSwgdHlwZSwgYXJncyk7XHJcbiAgICAgICAgaWYgKHJlcyAmJiBpc1Byb21pc2UocmVzKSkge1xyXG4gICAgICAgICAgICByZXMuY2F0Y2goZXJyID0+IHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIHR5cGUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhbHVlcy5wdXNoKGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGZuW2ldLCBpbnN0YW5jZSwgdHlwZSwgYXJncykpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlcztcclxufVxyXG5mdW5jdGlvbiBoYW5kbGVFcnJvcihlcnIsIGluc3RhbmNlLCB0eXBlLCB0aHJvd0luRGV2ID0gdHJ1ZSkge1xyXG4gICAgY29uc3QgY29udGV4dFZOb2RlID0gaW5zdGFuY2UgPyBpbnN0YW5jZS52bm9kZSA6IG51bGw7XHJcbiAgICBpZiAoaW5zdGFuY2UpIHtcclxuICAgICAgICBsZXQgY3VyID0gaW5zdGFuY2UucGFyZW50O1xyXG4gICAgICAgIC8vIHRoZSBleHBvc2VkIGluc3RhbmNlIGlzIHRoZSByZW5kZXIgcHJveHkgdG8ga2VlcCBpdCBjb25zaXN0ZW50IHdpdGggMi54XHJcbiAgICAgICAgY29uc3QgZXhwb3NlZEluc3RhbmNlID0gaW5zdGFuY2UucHJveHk7XHJcbiAgICAgICAgLy8gaW4gcHJvZHVjdGlvbiB0aGUgaG9vayByZWNlaXZlcyBvbmx5IHRoZSBlcnJvciBjb2RlXHJcbiAgICAgICAgY29uc3QgZXJyb3JJbmZvID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gRXJyb3JUeXBlU3RyaW5nc1t0eXBlXSA6IHR5cGU7XHJcbiAgICAgICAgd2hpbGUgKGN1cikge1xyXG4gICAgICAgICAgICBjb25zdCBlcnJvckNhcHR1cmVkSG9va3MgPSBjdXIuZWM7XHJcbiAgICAgICAgICAgIGlmIChlcnJvckNhcHR1cmVkSG9va3MpIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXJyb3JDYXB0dXJlZEhvb2tzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yQ2FwdHVyZWRIb29rc1tpXShlcnIsIGV4cG9zZWRJbnN0YW5jZSwgZXJyb3JJbmZvKSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdXIgPSBjdXIucGFyZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBhcHAtbGV2ZWwgaGFuZGxpbmdcclxuICAgICAgICBjb25zdCBhcHBFcnJvckhhbmRsZXIgPSBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZy5lcnJvckhhbmRsZXI7XHJcbiAgICAgICAgaWYgKGFwcEVycm9ySGFuZGxlcikge1xyXG4gICAgICAgICAgICBjYWxsV2l0aEVycm9ySGFuZGxpbmcoYXBwRXJyb3JIYW5kbGVyLCBudWxsLCAxMCAvKiBBUFBfRVJST1JfSEFORExFUiAqLywgW2VyciwgZXhwb3NlZEluc3RhbmNlLCBlcnJvckluZm9dKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGxvZ0Vycm9yKGVyciwgdHlwZSwgY29udGV4dFZOb2RlLCB0aHJvd0luRGV2KTtcclxufVxyXG5mdW5jdGlvbiBsb2dFcnJvcihlcnIsIHR5cGUsIGNvbnRleHRWTm9kZSwgdGhyb3dJbkRldiA9IHRydWUpIHtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICBjb25zdCBpbmZvID0gRXJyb3JUeXBlU3RyaW5nc1t0eXBlXTtcclxuICAgICAgICBpZiAoY29udGV4dFZOb2RlKSB7XHJcbiAgICAgICAgICAgIHB1c2hXYXJuaW5nQ29udGV4dChjb250ZXh0Vk5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3YXJuKGBVbmhhbmRsZWQgZXJyb3Ike2luZm8gPyBgIGR1cmluZyBleGVjdXRpb24gb2YgJHtpbmZvfWAgOiBgYH1gKTtcclxuICAgICAgICBpZiAoY29udGV4dFZOb2RlKSB7XHJcbiAgICAgICAgICAgIHBvcFdhcm5pbmdDb250ZXh0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNyYXNoIGluIGRldiBieSBkZWZhdWx0IHNvIGl0J3MgbW9yZSBub3RpY2VhYmxlXHJcbiAgICAgICAgaWYgKHRocm93SW5EZXYpIHtcclxuICAgICAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIHJlY292ZXIgaW4gcHJvZCB0byByZWR1Y2UgdGhlIGltcGFjdCBvbiBlbmQtdXNlclxyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcclxuICAgIH1cclxufVxuXG5sZXQgaXNGbHVzaGluZyA9IGZhbHNlO1xyXG5sZXQgaXNGbHVzaFBlbmRpbmcgPSBmYWxzZTtcclxuY29uc3QgcXVldWUgPSBbXTtcclxubGV0IGZsdXNoSW5kZXggPSAwO1xyXG5jb25zdCBwZW5kaW5nUHJlRmx1c2hDYnMgPSBbXTtcclxubGV0IGFjdGl2ZVByZUZsdXNoQ2JzID0gbnVsbDtcclxubGV0IHByZUZsdXNoSW5kZXggPSAwO1xyXG5jb25zdCBwZW5kaW5nUG9zdEZsdXNoQ2JzID0gW107XHJcbmxldCBhY3RpdmVQb3N0Rmx1c2hDYnMgPSBudWxsO1xyXG5sZXQgcG9zdEZsdXNoSW5kZXggPSAwO1xyXG5jb25zdCByZXNvbHZlZFByb21pc2UgPSAvKiNfX1BVUkVfXyovIFByb21pc2UucmVzb2x2ZSgpO1xyXG5sZXQgY3VycmVudEZsdXNoUHJvbWlzZSA9IG51bGw7XHJcbmxldCBjdXJyZW50UHJlRmx1c2hQYXJlbnRKb2IgPSBudWxsO1xyXG5jb25zdCBSRUNVUlNJT05fTElNSVQgPSAxMDA7XHJcbmZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XHJcbiAgICBjb25zdCBwID0gY3VycmVudEZsdXNoUHJvbWlzZSB8fCByZXNvbHZlZFByb21pc2U7XHJcbiAgICByZXR1cm4gZm4gPyBwLnRoZW4odGhpcyA/IGZuLmJpbmQodGhpcykgOiBmbikgOiBwO1xyXG59XHJcbi8vICMyNzY4XHJcbi8vIFVzZSBiaW5hcnktc2VhcmNoIHRvIGZpbmQgYSBzdWl0YWJsZSBwb3NpdGlvbiBpbiB0aGUgcXVldWUsXHJcbi8vIHNvIHRoYXQgdGhlIHF1ZXVlIG1haW50YWlucyB0aGUgaW5jcmVhc2luZyBvcmRlciBvZiBqb2IncyBpZCxcclxuLy8gd2hpY2ggY2FuIHByZXZlbnQgdGhlIGpvYiBmcm9tIGJlaW5nIHNraXBwZWQgYW5kIGFsc28gY2FuIGF2b2lkIHJlcGVhdGVkIHBhdGNoaW5nLlxyXG5mdW5jdGlvbiBmaW5kSW5zZXJ0aW9uSW5kZXgoaWQpIHtcclxuICAgIC8vIHRoZSBzdGFydCBpbmRleCBzaG91bGQgYmUgYGZsdXNoSW5kZXggKyAxYFxyXG4gICAgbGV0IHN0YXJ0ID0gZmx1c2hJbmRleCArIDE7XHJcbiAgICBsZXQgZW5kID0gcXVldWUubGVuZ3RoO1xyXG4gICAgd2hpbGUgKHN0YXJ0IDwgZW5kKSB7XHJcbiAgICAgICAgY29uc3QgbWlkZGxlID0gKHN0YXJ0ICsgZW5kKSA+Pj4gMTtcclxuICAgICAgICBjb25zdCBtaWRkbGVKb2JJZCA9IGdldElkKHF1ZXVlW21pZGRsZV0pO1xyXG4gICAgICAgIG1pZGRsZUpvYklkIDwgaWQgPyAoc3RhcnQgPSBtaWRkbGUgKyAxKSA6IChlbmQgPSBtaWRkbGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHN0YXJ0O1xyXG59XHJcbmZ1bmN0aW9uIHF1ZXVlSm9iKGpvYikge1xyXG4gICAgLy8gdGhlIGRlZHVwZSBzZWFyY2ggdXNlcyB0aGUgc3RhcnRJbmRleCBhcmd1bWVudCBvZiBBcnJheS5pbmNsdWRlcygpXHJcbiAgICAvLyBieSBkZWZhdWx0IHRoZSBzZWFyY2ggaW5kZXggaW5jbHVkZXMgdGhlIGN1cnJlbnQgam9iIHRoYXQgaXMgYmVpbmcgcnVuXHJcbiAgICAvLyBzbyBpdCBjYW5ub3QgcmVjdXJzaXZlbHkgdHJpZ2dlciBpdHNlbGYgYWdhaW4uXHJcbiAgICAvLyBpZiB0aGUgam9iIGlzIGEgd2F0Y2goKSBjYWxsYmFjaywgdGhlIHNlYXJjaCB3aWxsIHN0YXJ0IHdpdGggYSArMSBpbmRleCB0b1xyXG4gICAgLy8gYWxsb3cgaXQgcmVjdXJzaXZlbHkgdHJpZ2dlciBpdHNlbGYgLSBpdCBpcyB0aGUgdXNlcidzIHJlc3BvbnNpYmlsaXR5IHRvXHJcbiAgICAvLyBlbnN1cmUgaXQgZG9lc24ndCBlbmQgdXAgaW4gYW4gaW5maW5pdGUgbG9vcC5cclxuICAgIGlmICgoIXF1ZXVlLmxlbmd0aCB8fFxyXG4gICAgICAgICFxdWV1ZS5pbmNsdWRlcyhqb2IsIGlzRmx1c2hpbmcgJiYgam9iLmFsbG93UmVjdXJzZSA/IGZsdXNoSW5kZXggKyAxIDogZmx1c2hJbmRleCkpICYmXHJcbiAgICAgICAgam9iICE9PSBjdXJyZW50UHJlRmx1c2hQYXJlbnRKb2IpIHtcclxuICAgICAgICBpZiAoam9iLmlkID09IG51bGwpIHtcclxuICAgICAgICAgICAgcXVldWUucHVzaChqb2IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcXVldWUuc3BsaWNlKGZpbmRJbnNlcnRpb25JbmRleChqb2IuaWQpLCAwLCBqb2IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBxdWV1ZUZsdXNoKCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcXVldWVGbHVzaCgpIHtcclxuICAgIGlmICghaXNGbHVzaGluZyAmJiAhaXNGbHVzaFBlbmRpbmcpIHtcclxuICAgICAgICBpc0ZsdXNoUGVuZGluZyA9IHRydWU7XHJcbiAgICAgICAgY3VycmVudEZsdXNoUHJvbWlzZSA9IHJlc29sdmVkUHJvbWlzZS50aGVuKGZsdXNoSm9icyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaW52YWxpZGF0ZUpvYihqb2IpIHtcclxuICAgIGNvbnN0IGkgPSBxdWV1ZS5pbmRleE9mKGpvYik7XHJcbiAgICBpZiAoaSA+IGZsdXNoSW5kZXgpIHtcclxuICAgICAgICBxdWV1ZS5zcGxpY2UoaSwgMSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcXVldWVDYihjYiwgYWN0aXZlUXVldWUsIHBlbmRpbmdRdWV1ZSwgaW5kZXgpIHtcclxuICAgIGlmICghaXNBcnJheShjYikpIHtcclxuICAgICAgICBpZiAoIWFjdGl2ZVF1ZXVlIHx8XHJcbiAgICAgICAgICAgICFhY3RpdmVRdWV1ZS5pbmNsdWRlcyhjYiwgY2IuYWxsb3dSZWN1cnNlID8gaW5kZXggKyAxIDogaW5kZXgpKSB7XHJcbiAgICAgICAgICAgIHBlbmRpbmdRdWV1ZS5wdXNoKGNiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBpZiBjYiBpcyBhbiBhcnJheSwgaXQgaXMgYSBjb21wb25lbnQgbGlmZWN5Y2xlIGhvb2sgd2hpY2ggY2FuIG9ubHkgYmVcclxuICAgICAgICAvLyB0cmlnZ2VyZWQgYnkgYSBqb2IsIHdoaWNoIGlzIGFscmVhZHkgZGVkdXBlZCBpbiB0aGUgbWFpbiBxdWV1ZSwgc29cclxuICAgICAgICAvLyB3ZSBjYW4gc2tpcCBkdXBsaWNhdGUgY2hlY2sgaGVyZSB0byBpbXByb3ZlIHBlcmZcclxuICAgICAgICBwZW5kaW5nUXVldWUucHVzaCguLi5jYik7XHJcbiAgICB9XHJcbiAgICBxdWV1ZUZsdXNoKCk7XHJcbn1cclxuZnVuY3Rpb24gcXVldWVQcmVGbHVzaENiKGNiKSB7XHJcbiAgICBxdWV1ZUNiKGNiLCBhY3RpdmVQcmVGbHVzaENicywgcGVuZGluZ1ByZUZsdXNoQ2JzLCBwcmVGbHVzaEluZGV4KTtcclxufVxyXG5mdW5jdGlvbiBxdWV1ZVBvc3RGbHVzaENiKGNiKSB7XHJcbiAgICBxdWV1ZUNiKGNiLCBhY3RpdmVQb3N0Rmx1c2hDYnMsIHBlbmRpbmdQb3N0Rmx1c2hDYnMsIHBvc3RGbHVzaEluZGV4KTtcclxufVxyXG5mdW5jdGlvbiBmbHVzaFByZUZsdXNoQ2JzKHNlZW4sIHBhcmVudEpvYiA9IG51bGwpIHtcclxuICAgIGlmIChwZW5kaW5nUHJlRmx1c2hDYnMubGVuZ3RoKSB7XHJcbiAgICAgICAgY3VycmVudFByZUZsdXNoUGFyZW50Sm9iID0gcGFyZW50Sm9iO1xyXG4gICAgICAgIGFjdGl2ZVByZUZsdXNoQ2JzID0gWy4uLm5ldyBTZXQocGVuZGluZ1ByZUZsdXNoQ2JzKV07XHJcbiAgICAgICAgcGVuZGluZ1ByZUZsdXNoQ2JzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICBzZWVuID0gc2VlbiB8fCBuZXcgTWFwKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAocHJlRmx1c2hJbmRleCA9IDA7IHByZUZsdXNoSW5kZXggPCBhY3RpdmVQcmVGbHVzaENicy5sZW5ndGg7IHByZUZsdXNoSW5kZXgrKykge1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgICAgICBjaGVja1JlY3Vyc2l2ZVVwZGF0ZXMoc2VlbiwgYWN0aXZlUHJlRmx1c2hDYnNbcHJlRmx1c2hJbmRleF0pKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhY3RpdmVQcmVGbHVzaENic1twcmVGbHVzaEluZGV4XSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhY3RpdmVQcmVGbHVzaENicyA9IG51bGw7XHJcbiAgICAgICAgcHJlRmx1c2hJbmRleCA9IDA7XHJcbiAgICAgICAgY3VycmVudFByZUZsdXNoUGFyZW50Sm9iID0gbnVsbDtcclxuICAgICAgICAvLyByZWN1cnNpdmVseSBmbHVzaCB1bnRpbCBpdCBkcmFpbnNcclxuICAgICAgICBmbHVzaFByZUZsdXNoQ2JzKHNlZW4sIHBhcmVudEpvYik7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZmx1c2hQb3N0Rmx1c2hDYnMoc2Vlbikge1xyXG4gICAgLy8gZmx1c2ggYW55IHByZSBjYnMgcXVldWVkIGR1cmluZyB0aGUgZmx1c2ggKGUuZy4gcHJlIHdhdGNoZXJzKVxyXG4gICAgZmx1c2hQcmVGbHVzaENicygpO1xyXG4gICAgaWYgKHBlbmRpbmdQb3N0Rmx1c2hDYnMubGVuZ3RoKSB7XHJcbiAgICAgICAgY29uc3QgZGVkdXBlZCA9IFsuLi5uZXcgU2V0KHBlbmRpbmdQb3N0Rmx1c2hDYnMpXTtcclxuICAgICAgICBwZW5kaW5nUG9zdEZsdXNoQ2JzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgLy8gIzE5NDcgYWxyZWFkeSBoYXMgYWN0aXZlIHF1ZXVlLCBuZXN0ZWQgZmx1c2hQb3N0Rmx1c2hDYnMgY2FsbFxyXG4gICAgICAgIGlmIChhY3RpdmVQb3N0Rmx1c2hDYnMpIHtcclxuICAgICAgICAgICAgYWN0aXZlUG9zdEZsdXNoQ2JzLnB1c2goLi4uZGVkdXBlZCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgYWN0aXZlUG9zdEZsdXNoQ2JzID0gZGVkdXBlZDtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHNlZW4gPSBzZWVuIHx8IG5ldyBNYXAoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYWN0aXZlUG9zdEZsdXNoQ2JzLnNvcnQoKGEsIGIpID0+IGdldElkKGEpIC0gZ2V0SWQoYikpO1xyXG4gICAgICAgIGZvciAocG9zdEZsdXNoSW5kZXggPSAwOyBwb3N0Rmx1c2hJbmRleCA8IGFjdGl2ZVBvc3RGbHVzaENicy5sZW5ndGg7IHBvc3RGbHVzaEluZGV4KyspIHtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgY2hlY2tSZWN1cnNpdmVVcGRhdGVzKHNlZW4sIGFjdGl2ZVBvc3RGbHVzaENic1twb3N0Rmx1c2hJbmRleF0pKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhY3RpdmVQb3N0Rmx1c2hDYnNbcG9zdEZsdXNoSW5kZXhdKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFjdGl2ZVBvc3RGbHVzaENicyA9IG51bGw7XHJcbiAgICAgICAgcG9zdEZsdXNoSW5kZXggPSAwO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IGdldElkID0gKGpvYikgPT4gam9iLmlkID09IG51bGwgPyBJbmZpbml0eSA6IGpvYi5pZDtcclxuZnVuY3Rpb24gZmx1c2hKb2JzKHNlZW4pIHtcclxuICAgIGlzRmx1c2hQZW5kaW5nID0gZmFsc2U7XHJcbiAgICBpc0ZsdXNoaW5nID0gdHJ1ZTtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICBzZWVuID0gc2VlbiB8fCBuZXcgTWFwKCk7XHJcbiAgICB9XHJcbiAgICBmbHVzaFByZUZsdXNoQ2JzKHNlZW4pO1xyXG4gICAgLy8gU29ydCBxdWV1ZSBiZWZvcmUgZmx1c2guXHJcbiAgICAvLyBUaGlzIGVuc3VyZXMgdGhhdDpcclxuICAgIC8vIDEuIENvbXBvbmVudHMgYXJlIHVwZGF0ZWQgZnJvbSBwYXJlbnQgdG8gY2hpbGQuIChiZWNhdXNlIHBhcmVudCBpcyBhbHdheXNcclxuICAgIC8vICAgIGNyZWF0ZWQgYmVmb3JlIHRoZSBjaGlsZCBzbyBpdHMgcmVuZGVyIGVmZmVjdCB3aWxsIGhhdmUgc21hbGxlclxyXG4gICAgLy8gICAgcHJpb3JpdHkgbnVtYmVyKVxyXG4gICAgLy8gMi4gSWYgYSBjb21wb25lbnQgaXMgdW5tb3VudGVkIGR1cmluZyBhIHBhcmVudCBjb21wb25lbnQncyB1cGRhdGUsXHJcbiAgICAvLyAgICBpdHMgdXBkYXRlIGNhbiBiZSBza2lwcGVkLlxyXG4gICAgcXVldWUuc29ydCgoYSwgYikgPT4gZ2V0SWQoYSkgLSBnZXRJZChiKSk7XHJcbiAgICAvLyBjb25kaXRpb25hbCB1c2FnZSBvZiBjaGVja1JlY3Vyc2l2ZVVwZGF0ZSBtdXN0IGJlIGRldGVybWluZWQgb3V0IG9mXHJcbiAgICAvLyB0cnkgLi4uIGNhdGNoIGJsb2NrIHNpbmNlIFJvbGx1cCBieSBkZWZhdWx0IGRlLW9wdGltaXplcyB0cmVlc2hha2luZ1xyXG4gICAgLy8gaW5zaWRlIHRyeS1jYXRjaC4gVGhpcyBjYW4gbGVhdmUgYWxsIHdhcm5pbmcgY29kZSB1bnNoYWtlZC4gQWx0aG91Z2hcclxuICAgIC8vIHRoZXkgd291bGQgZ2V0IGV2ZW50dWFsbHkgc2hha2VuIGJ5IGEgbWluaWZpZXIgbGlrZSB0ZXJzZXIsIHNvbWUgbWluaWZpZXJzXHJcbiAgICAvLyB3b3VsZCBmYWlsIHRvIGRvIHRoYXQgKGUuZy4gaHR0cHM6Ly9naXRodWIuY29tL2V2YW53L2VzYnVpbGQvaXNzdWVzLzE2MTApXHJcbiAgICBjb25zdCBjaGVjayA9IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxyXG4gICAgICAgID8gKGpvYikgPT4gY2hlY2tSZWN1cnNpdmVVcGRhdGVzKHNlZW4sIGpvYilcclxuICAgICAgICA6IE5PT1A7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGZvciAoZmx1c2hJbmRleCA9IDA7IGZsdXNoSW5kZXggPCBxdWV1ZS5sZW5ndGg7IGZsdXNoSW5kZXgrKykge1xyXG4gICAgICAgICAgICBjb25zdCBqb2IgPSBxdWV1ZVtmbHVzaEluZGV4XTtcclxuICAgICAgICAgICAgaWYgKGpvYiAmJiBqb2IuYWN0aXZlICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBjaGVjayhqb2IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhgcnVubmluZzpgLCBqb2IuaWQpXHJcbiAgICAgICAgICAgICAgICBjYWxsV2l0aEVycm9ySGFuZGxpbmcoam9iLCBudWxsLCAxNCAvKiBTQ0hFRFVMRVIgKi8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgZmx1c2hJbmRleCA9IDA7XHJcbiAgICAgICAgcXVldWUubGVuZ3RoID0gMDtcclxuICAgICAgICBmbHVzaFBvc3RGbHVzaENicyhzZWVuKTtcclxuICAgICAgICBpc0ZsdXNoaW5nID0gZmFsc2U7XHJcbiAgICAgICAgY3VycmVudEZsdXNoUHJvbWlzZSA9IG51bGw7XHJcbiAgICAgICAgLy8gc29tZSBwb3N0Rmx1c2hDYiBxdWV1ZWQgam9icyFcclxuICAgICAgICAvLyBrZWVwIGZsdXNoaW5nIHVudGlsIGl0IGRyYWlucy5cclxuICAgICAgICBpZiAocXVldWUubGVuZ3RoIHx8XHJcbiAgICAgICAgICAgIHBlbmRpbmdQcmVGbHVzaENicy5sZW5ndGggfHxcclxuICAgICAgICAgICAgcGVuZGluZ1Bvc3RGbHVzaENicy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgZmx1c2hKb2JzKHNlZW4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjaGVja1JlY3Vyc2l2ZVVwZGF0ZXMoc2VlbiwgZm4pIHtcclxuICAgIGlmICghc2Vlbi5oYXMoZm4pKSB7XHJcbiAgICAgICAgc2Vlbi5zZXQoZm4sIDEpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3QgY291bnQgPSBzZWVuLmdldChmbik7XHJcbiAgICAgICAgaWYgKGNvdW50ID4gUkVDVVJTSU9OX0xJTUlUKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gZm4ub3duZXJJbnN0YW5jZTtcclxuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50TmFtZSA9IGluc3RhbmNlICYmIGdldENvbXBvbmVudE5hbWUoaW5zdGFuY2UudHlwZSk7XHJcbiAgICAgICAgICAgIHdhcm4oYE1heGltdW0gcmVjdXJzaXZlIHVwZGF0ZXMgZXhjZWVkZWQke2NvbXBvbmVudE5hbWUgPyBgIGluIGNvbXBvbmVudCA8JHtjb21wb25lbnROYW1lfT5gIDogYGB9LiBgICtcclxuICAgICAgICAgICAgICAgIGBUaGlzIG1lYW5zIHlvdSBoYXZlIGEgcmVhY3RpdmUgZWZmZWN0IHRoYXQgaXMgbXV0YXRpbmcgaXRzIG93biBgICtcclxuICAgICAgICAgICAgICAgIGBkZXBlbmRlbmNpZXMgYW5kIHRodXMgcmVjdXJzaXZlbHkgdHJpZ2dlcmluZyBpdHNlbGYuIFBvc3NpYmxlIHNvdXJjZXMgYCArXHJcbiAgICAgICAgICAgICAgICBgaW5jbHVkZSBjb21wb25lbnQgdGVtcGxhdGUsIHJlbmRlciBmdW5jdGlvbiwgdXBkYXRlZCBob29rIG9yIGAgK1xyXG4gICAgICAgICAgICAgICAgYHdhdGNoZXIgc291cmNlIGZ1bmN0aW9uLmApO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHNlZW4uc2V0KGZuLCBjb3VudCArIDEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgKi9cclxubGV0IGlzSG1yVXBkYXRpbmcgPSBmYWxzZTtcclxuY29uc3QgaG1yRGlydHlDb21wb25lbnRzID0gbmV3IFNldCgpO1xyXG4vLyBFeHBvc2UgdGhlIEhNUiBydW50aW1lIG9uIHRoZSBnbG9iYWwgb2JqZWN0XHJcbi8vIFRoaXMgbWFrZXMgaXQgZW50aXJlbHkgdHJlZS1zaGFrYWJsZSB3aXRob3V0IHBvbGx1dGluZyB0aGUgZXhwb3J0cyBhbmQgbWFrZXNcclxuLy8gaXQgZWFzaWVyIHRvIGJlIHVzZWQgaW4gdG9vbGluZ3MgbGlrZSB2dWUtbG9hZGVyXHJcbi8vIE5vdGU6IGZvciBhIGNvbXBvbmVudCB0byBiZSBlbGlnaWJsZSBmb3IgSE1SIGl0IGFsc28gbmVlZHMgdGhlIF9faG1ySWQgb3B0aW9uXHJcbi8vIHRvIGJlIHNldCBzbyB0aGF0IGl0cyBpbnN0YW5jZXMgY2FuIGJlIHJlZ2lzdGVyZWQgLyByZW1vdmVkLlxyXG5pZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICBnZXRHbG9iYWxUaGlzKCkuX19WVUVfSE1SX1JVTlRJTUVfXyA9IHtcclxuICAgICAgICBjcmVhdGVSZWNvcmQ6IHRyeVdyYXAoY3JlYXRlUmVjb3JkKSxcclxuICAgICAgICByZXJlbmRlcjogdHJ5V3JhcChyZXJlbmRlciksXHJcbiAgICAgICAgcmVsb2FkOiB0cnlXcmFwKHJlbG9hZClcclxuICAgIH07XHJcbn1cclxuY29uc3QgbWFwID0gbmV3IE1hcCgpO1xyXG5mdW5jdGlvbiByZWdpc3RlckhNUihpbnN0YW5jZSkge1xyXG4gICAgY29uc3QgaWQgPSBpbnN0YW5jZS50eXBlLl9faG1ySWQ7XHJcbiAgICBsZXQgcmVjb3JkID0gbWFwLmdldChpZCk7XHJcbiAgICBpZiAoIXJlY29yZCkge1xyXG4gICAgICAgIGNyZWF0ZVJlY29yZChpZCwgaW5zdGFuY2UudHlwZSk7XHJcbiAgICAgICAgcmVjb3JkID0gbWFwLmdldChpZCk7XHJcbiAgICB9XHJcbiAgICByZWNvcmQuaW5zdGFuY2VzLmFkZChpbnN0YW5jZSk7XHJcbn1cclxuZnVuY3Rpb24gdW5yZWdpc3RlckhNUihpbnN0YW5jZSkge1xyXG4gICAgbWFwLmdldChpbnN0YW5jZS50eXBlLl9faG1ySWQpLmluc3RhbmNlcy5kZWxldGUoaW5zdGFuY2UpO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVJlY29yZChpZCwgaW5pdGlhbERlZikge1xyXG4gICAgaWYgKG1hcC5oYXMoaWQpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgbWFwLnNldChpZCwge1xyXG4gICAgICAgIGluaXRpYWxEZWY6IG5vcm1hbGl6ZUNsYXNzQ29tcG9uZW50KGluaXRpYWxEZWYpLFxyXG4gICAgICAgIGluc3RhbmNlczogbmV3IFNldCgpXHJcbiAgICB9KTtcclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZUNsYXNzQ29tcG9uZW50KGNvbXBvbmVudCkge1xyXG4gICAgcmV0dXJuIGlzQ2xhc3NDb21wb25lbnQoY29tcG9uZW50KSA/IGNvbXBvbmVudC5fX3ZjY09wdHMgOiBjb21wb25lbnQ7XHJcbn1cclxuZnVuY3Rpb24gcmVyZW5kZXIoaWQsIG5ld1JlbmRlcikge1xyXG4gICAgY29uc3QgcmVjb3JkID0gbWFwLmdldChpZCk7XHJcbiAgICBpZiAoIXJlY29yZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIC8vIHVwZGF0ZSBpbml0aWFsIHJlY29yZCAoZm9yIG5vdC15ZXQtcmVuZGVyZWQgY29tcG9uZW50KVxyXG4gICAgcmVjb3JkLmluaXRpYWxEZWYucmVuZGVyID0gbmV3UmVuZGVyO1xyXG4gICAgWy4uLnJlY29yZC5pbnN0YW5jZXNdLmZvckVhY2goaW5zdGFuY2UgPT4ge1xyXG4gICAgICAgIGlmIChuZXdSZW5kZXIpIHtcclxuICAgICAgICAgICAgaW5zdGFuY2UucmVuZGVyID0gbmV3UmVuZGVyO1xyXG4gICAgICAgICAgICBub3JtYWxpemVDbGFzc0NvbXBvbmVudChpbnN0YW5jZS50eXBlKS5yZW5kZXIgPSBuZXdSZW5kZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluc3RhbmNlLnJlbmRlckNhY2hlID0gW107XHJcbiAgICAgICAgLy8gdGhpcyBmbGFnIGZvcmNlcyBjaGlsZCBjb21wb25lbnRzIHdpdGggc2xvdCBjb250ZW50IHRvIHVwZGF0ZVxyXG4gICAgICAgIGlzSG1yVXBkYXRpbmcgPSB0cnVlO1xyXG4gICAgICAgIGluc3RhbmNlLnVwZGF0ZSgpO1xyXG4gICAgICAgIGlzSG1yVXBkYXRpbmcgPSBmYWxzZTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHJlbG9hZChpZCwgbmV3Q29tcCkge1xyXG4gICAgY29uc3QgcmVjb3JkID0gbWFwLmdldChpZCk7XHJcbiAgICBpZiAoIXJlY29yZClcclxuICAgICAgICByZXR1cm47XHJcbiAgICBuZXdDb21wID0gbm9ybWFsaXplQ2xhc3NDb21wb25lbnQobmV3Q29tcCk7XHJcbiAgICAvLyB1cGRhdGUgaW5pdGlhbCBkZWYgKGZvciBub3QteWV0LXJlbmRlcmVkIGNvbXBvbmVudHMpXHJcbiAgICB1cGRhdGVDb21wb25lbnREZWYocmVjb3JkLmluaXRpYWxEZWYsIG5ld0NvbXApO1xyXG4gICAgLy8gY3JlYXRlIGEgc25hcHNob3Qgd2hpY2ggYXZvaWRzIHRoZSBzZXQgYmVpbmcgbXV0YXRlZCBkdXJpbmcgdXBkYXRlc1xyXG4gICAgY29uc3QgaW5zdGFuY2VzID0gWy4uLnJlY29yZC5pbnN0YW5jZXNdO1xyXG4gICAgZm9yIChjb25zdCBpbnN0YW5jZSBvZiBpbnN0YW5jZXMpIHtcclxuICAgICAgICBjb25zdCBvbGRDb21wID0gbm9ybWFsaXplQ2xhc3NDb21wb25lbnQoaW5zdGFuY2UudHlwZSk7XHJcbiAgICAgICAgaWYgKCFobXJEaXJ0eUNvbXBvbmVudHMuaGFzKG9sZENvbXApKSB7XHJcbiAgICAgICAgICAgIC8vIDEuIFVwZGF0ZSBleGlzdGluZyBjb21wIGRlZmluaXRpb24gdG8gbWF0Y2ggbmV3IG9uZVxyXG4gICAgICAgICAgICBpZiAob2xkQ29tcCAhPT0gcmVjb3JkLmluaXRpYWxEZWYpIHtcclxuICAgICAgICAgICAgICAgIHVwZGF0ZUNvbXBvbmVudERlZihvbGRDb21wLCBuZXdDb21wKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyAyLiBtYXJrIGRlZmluaXRpb24gZGlydHkuIFRoaXMgZm9yY2VzIHRoZSByZW5kZXJlciB0byByZXBsYWNlIHRoZVxyXG4gICAgICAgICAgICAvLyBjb21wb25lbnQgb24gcGF0Y2guXHJcbiAgICAgICAgICAgIGhtckRpcnR5Q29tcG9uZW50cy5hZGQob2xkQ29tcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDMuIGludmFsaWRhdGUgb3B0aW9ucyByZXNvbHV0aW9uIGNhY2hlXHJcbiAgICAgICAgaW5zdGFuY2UuYXBwQ29udGV4dC5vcHRpb25zQ2FjaGUuZGVsZXRlKGluc3RhbmNlLnR5cGUpO1xyXG4gICAgICAgIC8vIDQuIGFjdHVhbGx5IHVwZGF0ZVxyXG4gICAgICAgIGlmIChpbnN0YW5jZS5jZVJlbG9hZCkge1xyXG4gICAgICAgICAgICAvLyBjdXN0b20gZWxlbWVudFxyXG4gICAgICAgICAgICBobXJEaXJ0eUNvbXBvbmVudHMuYWRkKG9sZENvbXApO1xyXG4gICAgICAgICAgICBpbnN0YW5jZS5jZVJlbG9hZChuZXdDb21wLnN0eWxlcyk7XHJcbiAgICAgICAgICAgIGhtckRpcnR5Q29tcG9uZW50cy5kZWxldGUob2xkQ29tcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGluc3RhbmNlLnBhcmVudCkge1xyXG4gICAgICAgICAgICAvLyA0LiBGb3JjZSB0aGUgcGFyZW50IGluc3RhbmNlIHRvIHJlLXJlbmRlci4gVGhpcyB3aWxsIGNhdXNlIGFsbCB1cGRhdGVkXHJcbiAgICAgICAgICAgIC8vIGNvbXBvbmVudHMgdG8gYmUgdW5tb3VudGVkIGFuZCByZS1tb3VudGVkLiBRdWV1ZSB0aGUgdXBkYXRlIHNvIHRoYXQgd2VcclxuICAgICAgICAgICAgLy8gZG9uJ3QgZW5kIHVwIGZvcmNpbmcgdGhlIHNhbWUgcGFyZW50IHRvIHJlLXJlbmRlciBtdWx0aXBsZSB0aW1lcy5cclxuICAgICAgICAgICAgcXVldWVKb2IoaW5zdGFuY2UucGFyZW50LnVwZGF0ZSk7XHJcbiAgICAgICAgICAgIC8vIGluc3RhbmNlIGlzIHRoZSBpbm5lciBjb21wb25lbnQgb2YgYW4gYXN5bmMgY3VzdG9tIGVsZW1lbnRcclxuICAgICAgICAgICAgLy8gaW52b2tlIHRvIHJlc2V0IHN0eWxlc1xyXG4gICAgICAgICAgICBpZiAoaW5zdGFuY2UucGFyZW50LnR5cGUuX19hc3luY0xvYWRlciAmJlxyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UucGFyZW50LmNlUmVsb2FkKSB7XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5wYXJlbnQuY2VSZWxvYWQobmV3Q29tcC5zdHlsZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGluc3RhbmNlLmFwcENvbnRleHQucmVsb2FkKSB7XHJcbiAgICAgICAgICAgIC8vIHJvb3QgaW5zdGFuY2UgbW91bnRlZCB2aWEgY3JlYXRlQXBwKCkgaGFzIGEgcmVsb2FkIG1ldGhvZFxyXG4gICAgICAgICAgICBpbnN0YW5jZS5hcHBDb250ZXh0LnJlbG9hZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAvLyByb290IGluc3RhbmNlIGluc2lkZSB0cmVlIGNyZWF0ZWQgdmlhIHJhdyByZW5kZXIoKS4gRm9yY2UgcmVsb2FkLlxyXG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1tITVJdIFJvb3Qgb3IgbWFudWFsbHkgbW91bnRlZCBpbnN0YW5jZSBtb2RpZmllZC4gRnVsbCByZWxvYWQgcmVxdWlyZWQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gNS4gbWFrZSBzdXJlIHRvIGNsZWFudXAgZGlydHkgaG1yIGNvbXBvbmVudHMgYWZ0ZXIgdXBkYXRlXHJcbiAgICBxdWV1ZVBvc3RGbHVzaENiKCgpID0+IHtcclxuICAgICAgICBmb3IgKGNvbnN0IGluc3RhbmNlIG9mIGluc3RhbmNlcykge1xyXG4gICAgICAgICAgICBobXJEaXJ0eUNvbXBvbmVudHMuZGVsZXRlKG5vcm1hbGl6ZUNsYXNzQ29tcG9uZW50KGluc3RhbmNlLnR5cGUpKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiB1cGRhdGVDb21wb25lbnREZWYob2xkQ29tcCwgbmV3Q29tcCkge1xyXG4gICAgZXh0ZW5kKG9sZENvbXAsIG5ld0NvbXApO1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2xkQ29tcCkge1xyXG4gICAgICAgIGlmIChrZXkgIT09ICdfX2ZpbGUnICYmICEoa2V5IGluIG5ld0NvbXApKSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBvbGRDb21wW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHRyeVdyYXAoZm4pIHtcclxuICAgIHJldHVybiAoaWQsIGFyZykgPT4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmbihpZCwgYXJnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBbSE1SXSBTb21ldGhpbmcgd2VudCB3cm9uZyBkdXJpbmcgVnVlIGNvbXBvbmVudCBob3QtcmVsb2FkLiBgICtcclxuICAgICAgICAgICAgICAgIGBGdWxsIHJlbG9hZCByZXF1aXJlZC5gKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XG5cbmxldCBkZXZ0b29scztcclxubGV0IGJ1ZmZlciA9IFtdO1xyXG5sZXQgZGV2dG9vbHNOb3RJbnN0YWxsZWQgPSBmYWxzZTtcclxuZnVuY3Rpb24gZW1pdChldmVudCwgLi4uYXJncykge1xyXG4gICAgaWYgKGRldnRvb2xzKSB7XHJcbiAgICAgICAgZGV2dG9vbHMuZW1pdChldmVudCwgLi4uYXJncyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICghZGV2dG9vbHNOb3RJbnN0YWxsZWQpIHtcclxuICAgICAgICBidWZmZXIucHVzaCh7IGV2ZW50LCBhcmdzIH0pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHNldERldnRvb2xzSG9vayhob29rLCB0YXJnZXQpIHtcclxuICAgIHZhciBfYSwgX2I7XHJcbiAgICBkZXZ0b29scyA9IGhvb2s7XHJcbiAgICBpZiAoZGV2dG9vbHMpIHtcclxuICAgICAgICBkZXZ0b29scy5lbmFibGVkID0gdHJ1ZTtcclxuICAgICAgICBidWZmZXIuZm9yRWFjaCgoeyBldmVudCwgYXJncyB9KSA9PiBkZXZ0b29scy5lbWl0KGV2ZW50LCAuLi5hcmdzKSk7XHJcbiAgICAgICAgYnVmZmVyID0gW107XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChcclxuICAgIC8vIGhhbmRsZSBsYXRlIGRldnRvb2xzIGluamVjdGlvbiAtIG9ubHkgZG8gdGhpcyBpZiB3ZSBhcmUgaW4gYW4gYWN0dWFsXHJcbiAgICAvLyBicm93c2VyIGVudmlyb25tZW50IHRvIGF2b2lkIHRoZSB0aW1lciBoYW5kbGUgc3RhbGxpbmcgdGVzdCBydW5uZXIgZXhpdFxyXG4gICAgLy8gKCM0ODE1KVxyXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgICAvLyBzb21lIGVudnMgbW9jayB3aW5kb3cgYnV0IG5vdCBmdWxseVxyXG4gICAgICAgIHdpbmRvdy5IVE1MRWxlbWVudCAmJlxyXG4gICAgICAgIC8vIGFsc28gZXhjbHVkZSBqc2RvbVxyXG4gICAgICAgICEoKF9iID0gKF9hID0gd2luZG93Lm5hdmlnYXRvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVzZXJBZ2VudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmluY2x1ZGVzKCdqc2RvbScpKSkge1xyXG4gICAgICAgIGNvbnN0IHJlcGxheSA9ICh0YXJnZXQuX19WVUVfREVWVE9PTFNfSE9PS19SRVBMQVlfXyA9XHJcbiAgICAgICAgICAgIHRhcmdldC5fX1ZVRV9ERVZUT09MU19IT09LX1JFUExBWV9fIHx8IFtdKTtcclxuICAgICAgICByZXBsYXkucHVzaCgobmV3SG9vaykgPT4ge1xyXG4gICAgICAgICAgICBzZXREZXZ0b29sc0hvb2sobmV3SG9vaywgdGFyZ2V0KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBjbGVhciBidWZmZXIgYWZ0ZXIgM3MgLSB0aGUgdXNlciBwcm9iYWJseSBkb2Vzbid0IGhhdmUgZGV2dG9vbHMgaW5zdGFsbGVkXHJcbiAgICAgICAgLy8gYXQgYWxsLCBhbmQga2VlcGluZyB0aGUgYnVmZmVyIHdpbGwgY2F1c2UgbWVtb3J5IGxlYWtzICgjNDczOClcclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKCFkZXZ0b29scykge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0Ll9fVlVFX0RFVlRPT0xTX0hPT0tfUkVQTEFZX18gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgZGV2dG9vbHNOb3RJbnN0YWxsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgYnVmZmVyID0gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCAzMDAwKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIG5vbi1icm93c2VyIGVudiwgYXNzdW1lIG5vdCBpbnN0YWxsZWRcclxuICAgICAgICBkZXZ0b29sc05vdEluc3RhbGxlZCA9IHRydWU7XHJcbiAgICAgICAgYnVmZmVyID0gW107XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZGV2dG9vbHNJbml0QXBwKGFwcCwgdmVyc2lvbikge1xyXG4gICAgZW1pdChcImFwcDppbml0XCIgLyogQVBQX0lOSVQgKi8sIGFwcCwgdmVyc2lvbiwge1xyXG4gICAgICAgIEZyYWdtZW50LFxyXG4gICAgICAgIFRleHQsXHJcbiAgICAgICAgQ29tbWVudCxcclxuICAgICAgICBTdGF0aWNcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGRldnRvb2xzVW5tb3VudEFwcChhcHApIHtcclxuICAgIGVtaXQoXCJhcHA6dW5tb3VudFwiIC8qIEFQUF9VTk1PVU5UICovLCBhcHApO1xyXG59XHJcbmNvbnN0IGRldnRvb2xzQ29tcG9uZW50QWRkZWQgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZURldnRvb2xzQ29tcG9uZW50SG9vayhcImNvbXBvbmVudDphZGRlZFwiIC8qIENPTVBPTkVOVF9BRERFRCAqLyk7XHJcbmNvbnN0IGRldnRvb2xzQ29tcG9uZW50VXBkYXRlZCA9IFxyXG4vKiNfX1BVUkVfXyovIGNyZWF0ZURldnRvb2xzQ29tcG9uZW50SG9vayhcImNvbXBvbmVudDp1cGRhdGVkXCIgLyogQ09NUE9ORU5UX1VQREFURUQgKi8pO1xyXG5jb25zdCBkZXZ0b29sc0NvbXBvbmVudFJlbW92ZWQgPSBcclxuLyojX19QVVJFX18qLyBjcmVhdGVEZXZ0b29sc0NvbXBvbmVudEhvb2soXCJjb21wb25lbnQ6cmVtb3ZlZFwiIC8qIENPTVBPTkVOVF9SRU1PVkVEICovKTtcclxuZnVuY3Rpb24gY3JlYXRlRGV2dG9vbHNDb21wb25lbnRIb29rKGhvb2spIHtcclxuICAgIHJldHVybiAoY29tcG9uZW50KSA9PiB7XHJcbiAgICAgICAgZW1pdChob29rLCBjb21wb25lbnQuYXBwQ29udGV4dC5hcHAsIGNvbXBvbmVudC51aWQsIGNvbXBvbmVudC5wYXJlbnQgPyBjb21wb25lbnQucGFyZW50LnVpZCA6IHVuZGVmaW5lZCwgY29tcG9uZW50KTtcclxuICAgIH07XHJcbn1cclxuY29uc3QgZGV2dG9vbHNQZXJmU3RhcnQgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZURldnRvb2xzUGVyZm9ybWFuY2VIb29rKFwicGVyZjpzdGFydFwiIC8qIFBFUkZPUk1BTkNFX1NUQVJUICovKTtcclxuY29uc3QgZGV2dG9vbHNQZXJmRW5kID0gLyojX19QVVJFX18qLyBjcmVhdGVEZXZ0b29sc1BlcmZvcm1hbmNlSG9vayhcInBlcmY6ZW5kXCIgLyogUEVSRk9STUFOQ0VfRU5EICovKTtcclxuZnVuY3Rpb24gY3JlYXRlRGV2dG9vbHNQZXJmb3JtYW5jZUhvb2soaG9vaykge1xyXG4gICAgcmV0dXJuIChjb21wb25lbnQsIHR5cGUsIHRpbWUpID0+IHtcclxuICAgICAgICBlbWl0KGhvb2ssIGNvbXBvbmVudC5hcHBDb250ZXh0LmFwcCwgY29tcG9uZW50LnVpZCwgY29tcG9uZW50LCB0eXBlLCB0aW1lKTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gZGV2dG9vbHNDb21wb25lbnRFbWl0KGNvbXBvbmVudCwgZXZlbnQsIHBhcmFtcykge1xyXG4gICAgZW1pdChcImNvbXBvbmVudDplbWl0XCIgLyogQ09NUE9ORU5UX0VNSVQgKi8sIGNvbXBvbmVudC5hcHBDb250ZXh0LmFwcCwgY29tcG9uZW50LCBldmVudCwgcGFyYW1zKTtcclxufVxuXG5mdW5jdGlvbiBlbWl0JDEoaW5zdGFuY2UsIGV2ZW50LCAuLi5yYXdBcmdzKSB7XHJcbiAgICBpZiAoaW5zdGFuY2UuaXNVbm1vdW50ZWQpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgY29uc3QgcHJvcHMgPSBpbnN0YW5jZS52bm9kZS5wcm9wcyB8fCBFTVBUWV9PQko7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgY29uc3QgeyBlbWl0c09wdGlvbnMsIHByb3BzT3B0aW9uczogW3Byb3BzT3B0aW9uc10gfSA9IGluc3RhbmNlO1xyXG4gICAgICAgIGlmIChlbWl0c09wdGlvbnMpIHtcclxuICAgICAgICAgICAgaWYgKCEoZXZlbnQgaW4gZW1pdHNPcHRpb25zKSAmJlxyXG4gICAgICAgICAgICAgICAgIShmYWxzZSApKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXByb3BzT3B0aW9ucyB8fCAhKHRvSGFuZGxlcktleShldmVudCkgaW4gcHJvcHNPcHRpb25zKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYENvbXBvbmVudCBlbWl0dGVkIGV2ZW50IFwiJHtldmVudH1cIiBidXQgaXQgaXMgbmVpdGhlciBkZWNsYXJlZCBpbiBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYHRoZSBlbWl0cyBvcHRpb24gbm9yIGFzIGFuIFwiJHt0b0hhbmRsZXJLZXkoZXZlbnQpfVwiIHByb3AuYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2YWxpZGF0b3IgPSBlbWl0c09wdGlvbnNbZXZlbnRdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsaWRhdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzVmFsaWQgPSB2YWxpZGF0b3IoLi4ucmF3QXJncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oYEludmFsaWQgZXZlbnQgYXJndW1lbnRzOiBldmVudCB2YWxpZGF0aW9uIGZhaWxlZCBmb3IgZXZlbnQgXCIke2V2ZW50fVwiLmApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGxldCBhcmdzID0gcmF3QXJncztcclxuICAgIGNvbnN0IGlzTW9kZWxMaXN0ZW5lciA9IGV2ZW50LnN0YXJ0c1dpdGgoJ3VwZGF0ZTonKTtcclxuICAgIC8vIGZvciB2LW1vZGVsIHVwZGF0ZTp4eHggZXZlbnRzLCBhcHBseSBtb2RpZmllcnMgb24gYXJnc1xyXG4gICAgY29uc3QgbW9kZWxBcmcgPSBpc01vZGVsTGlzdGVuZXIgJiYgZXZlbnQuc2xpY2UoNyk7XHJcbiAgICBpZiAobW9kZWxBcmcgJiYgbW9kZWxBcmcgaW4gcHJvcHMpIHtcclxuICAgICAgICBjb25zdCBtb2RpZmllcnNLZXkgPSBgJHttb2RlbEFyZyA9PT0gJ21vZGVsVmFsdWUnID8gJ21vZGVsJyA6IG1vZGVsQXJnfU1vZGlmaWVyc2A7XHJcbiAgICAgICAgY29uc3QgeyBudW1iZXIsIHRyaW0gfSA9IHByb3BzW21vZGlmaWVyc0tleV0gfHwgRU1QVFlfT0JKO1xyXG4gICAgICAgIGlmICh0cmltKSB7XHJcbiAgICAgICAgICAgIGFyZ3MgPSByYXdBcmdzLm1hcChhID0+IGEudHJpbSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG51bWJlcikge1xyXG4gICAgICAgICAgICBhcmdzID0gcmF3QXJncy5tYXAodG9OdW1iZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XHJcbiAgICAgICAgZGV2dG9vbHNDb21wb25lbnRFbWl0KGluc3RhbmNlLCBldmVudCwgYXJncyk7XHJcbiAgICB9XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgY29uc3QgbG93ZXJDYXNlRXZlbnQgPSBldmVudC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIGlmIChsb3dlckNhc2VFdmVudCAhPT0gZXZlbnQgJiYgcHJvcHNbdG9IYW5kbGVyS2V5KGxvd2VyQ2FzZUV2ZW50KV0pIHtcclxuICAgICAgICAgICAgd2FybihgRXZlbnQgXCIke2xvd2VyQ2FzZUV2ZW50fVwiIGlzIGVtaXR0ZWQgaW4gY29tcG9uZW50IGAgK1xyXG4gICAgICAgICAgICAgICAgYCR7Zm9ybWF0Q29tcG9uZW50TmFtZShpbnN0YW5jZSwgaW5zdGFuY2UudHlwZSl9IGJ1dCB0aGUgaGFuZGxlciBpcyByZWdpc3RlcmVkIGZvciBcIiR7ZXZlbnR9XCIuIGAgK1xyXG4gICAgICAgICAgICAgICAgYE5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIHlvdSBjYW5ub3QgdXNlIGAgK1xyXG4gICAgICAgICAgICAgICAgYHYtb24gdG8gbGlzdGVuIHRvIGNhbWVsQ2FzZSBldmVudHMgd2hlbiB1c2luZyBpbi1ET00gdGVtcGxhdGVzLiBgICtcclxuICAgICAgICAgICAgICAgIGBZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcIiR7aHlwaGVuYXRlKGV2ZW50KX1cIiBpbnN0ZWFkIG9mIFwiJHtldmVudH1cIi5gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBsZXQgaGFuZGxlck5hbWU7XHJcbiAgICBsZXQgaGFuZGxlciA9IHByb3BzWyhoYW5kbGVyTmFtZSA9IHRvSGFuZGxlcktleShldmVudCkpXSB8fFxyXG4gICAgICAgIC8vIGFsc28gdHJ5IGNhbWVsQ2FzZSBldmVudCBoYW5kbGVyICgjMjI0OSlcclxuICAgICAgICBwcm9wc1soaGFuZGxlck5hbWUgPSB0b0hhbmRsZXJLZXkoY2FtZWxpemUoZXZlbnQpKSldO1xyXG4gICAgLy8gZm9yIHYtbW9kZWwgdXBkYXRlOnh4eCBldmVudHMsIGFsc28gdHJpZ2dlciBrZWJhYi1jYXNlIGVxdWl2YWxlbnRcclxuICAgIC8vIGZvciBwcm9wcyBwYXNzZWQgdmlhIGtlYmFiLWNhc2VcclxuICAgIGlmICghaGFuZGxlciAmJiBpc01vZGVsTGlzdGVuZXIpIHtcclxuICAgICAgICBoYW5kbGVyID0gcHJvcHNbKGhhbmRsZXJOYW1lID0gdG9IYW5kbGVyS2V5KGh5cGhlbmF0ZShldmVudCkpKV07XHJcbiAgICB9XHJcbiAgICBpZiAoaGFuZGxlcikge1xyXG4gICAgICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGhhbmRsZXIsIGluc3RhbmNlLCA2IC8qIENPTVBPTkVOVF9FVkVOVF9IQU5ETEVSICovLCBhcmdzKTtcclxuICAgIH1cclxuICAgIGNvbnN0IG9uY2VIYW5kbGVyID0gcHJvcHNbaGFuZGxlck5hbWUgKyBgT25jZWBdO1xyXG4gICAgaWYgKG9uY2VIYW5kbGVyKSB7XHJcbiAgICAgICAgaWYgKCFpbnN0YW5jZS5lbWl0dGVkKSB7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLmVtaXR0ZWQgPSB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaW5zdGFuY2UuZW1pdHRlZFtoYW5kbGVyTmFtZV0pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbnN0YW5jZS5lbWl0dGVkW2hhbmRsZXJOYW1lXSA9IHRydWU7XHJcbiAgICAgICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcob25jZUhhbmRsZXIsIGluc3RhbmNlLCA2IC8qIENPTVBPTkVOVF9FVkVOVF9IQU5ETEVSICovLCBhcmdzKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBub3JtYWxpemVFbWl0c09wdGlvbnMoY29tcCwgYXBwQ29udGV4dCwgYXNNaXhpbiA9IGZhbHNlKSB7XHJcbiAgICBjb25zdCBjYWNoZSA9IGFwcENvbnRleHQuZW1pdHNDYWNoZTtcclxuICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChjb21wKTtcclxuICAgIGlmIChjYWNoZWQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiBjYWNoZWQ7XHJcbiAgICB9XHJcbiAgICBjb25zdCByYXcgPSBjb21wLmVtaXRzO1xyXG4gICAgbGV0IG5vcm1hbGl6ZWQgPSB7fTtcclxuICAgIC8vIGFwcGx5IG1peGluL2V4dGVuZHMgcHJvcHNcclxuICAgIGxldCBoYXNFeHRlbmRzID0gZmFsc2U7XHJcbiAgICBpZiAoX19WVUVfT1BUSU9OU19BUElfXyAmJiAhaXNGdW5jdGlvbihjb21wKSkge1xyXG4gICAgICAgIGNvbnN0IGV4dGVuZEVtaXRzID0gKHJhdykgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkRnJvbUV4dGVuZCA9IG5vcm1hbGl6ZUVtaXRzT3B0aW9ucyhyYXcsIGFwcENvbnRleHQsIHRydWUpO1xyXG4gICAgICAgICAgICBpZiAobm9ybWFsaXplZEZyb21FeHRlbmQpIHtcclxuICAgICAgICAgICAgICAgIGhhc0V4dGVuZHMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgZXh0ZW5kKG5vcm1hbGl6ZWQsIG5vcm1hbGl6ZWRGcm9tRXh0ZW5kKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKCFhc01peGluICYmIGFwcENvbnRleHQubWl4aW5zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBhcHBDb250ZXh0Lm1peGlucy5mb3JFYWNoKGV4dGVuZEVtaXRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbXAuZXh0ZW5kcykge1xyXG4gICAgICAgICAgICBleHRlbmRFbWl0cyhjb21wLmV4dGVuZHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29tcC5taXhpbnMpIHtcclxuICAgICAgICAgICAgY29tcC5taXhpbnMuZm9yRWFjaChleHRlbmRFbWl0cyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCFyYXcgJiYgIWhhc0V4dGVuZHMpIHtcclxuICAgICAgICBjYWNoZS5zZXQoY29tcCwgbnVsbCk7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNBcnJheShyYXcpKSB7XHJcbiAgICAgICAgcmF3LmZvckVhY2goa2V5ID0+IChub3JtYWxpemVkW2tleV0gPSBudWxsKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBleHRlbmQobm9ybWFsaXplZCwgcmF3KTtcclxuICAgIH1cclxuICAgIGNhY2hlLnNldChjb21wLCBub3JtYWxpemVkKTtcclxuICAgIHJldHVybiBub3JtYWxpemVkO1xyXG59XHJcbi8vIENoZWNrIGlmIGFuIGluY29taW5nIHByb3Aga2V5IGlzIGEgZGVjbGFyZWQgZW1pdCBldmVudCBsaXN0ZW5lci5cclxuLy8gZS5nLiBXaXRoIGBlbWl0czogeyBjbGljazogbnVsbCB9YCwgcHJvcHMgbmFtZWQgYG9uQ2xpY2tgIGFuZCBgb25jbGlja2AgYXJlXHJcbi8vIGJvdGggY29uc2lkZXJlZCBtYXRjaGVkIGxpc3RlbmVycy5cclxuZnVuY3Rpb24gaXNFbWl0TGlzdGVuZXIob3B0aW9ucywga2V5KSB7XHJcbiAgICBpZiAoIW9wdGlvbnMgfHwgIWlzT24oa2V5KSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGtleSA9IGtleS5zbGljZSgyKS5yZXBsYWNlKC9PbmNlJC8sICcnKTtcclxuICAgIHJldHVybiAoaGFzT3duKG9wdGlvbnMsIGtleVswXS50b0xvd2VyQ2FzZSgpICsga2V5LnNsaWNlKDEpKSB8fFxyXG4gICAgICAgIGhhc093bihvcHRpb25zLCBoeXBoZW5hdGUoa2V5KSkgfHxcclxuICAgICAgICBoYXNPd24ob3B0aW9ucywga2V5KSk7XHJcbn1cblxuLyoqXHJcbiAqIG1hcmsgdGhlIGN1cnJlbnQgcmVuZGVyaW5nIGluc3RhbmNlIGZvciBhc3NldCByZXNvbHV0aW9uIChlLmcuXHJcbiAqIHJlc29sdmVDb21wb25lbnQsIHJlc29sdmVEaXJlY3RpdmUpIGR1cmluZyByZW5kZXJcclxuICovXHJcbmxldCBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPSBudWxsO1xyXG5sZXQgY3VycmVudFNjb3BlSWQgPSBudWxsO1xyXG4vKipcclxuICogTm90ZTogcmVuZGVyaW5nIGNhbGxzIG1heWJlIG5lc3RlZC4gVGhlIGZ1bmN0aW9uIHJldHVybnMgdGhlIHBhcmVudCByZW5kZXJpbmdcclxuICogaW5zdGFuY2UgaWYgcHJlc2VudCwgd2hpY2ggc2hvdWxkIGJlIHJlc3RvcmVkIGFmdGVyIHRoZSByZW5kZXIgaXMgZG9uZTpcclxuICpcclxuICogYGBganNcclxuICogY29uc3QgcHJldiA9IHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShpKVxyXG4gKiAvLyAuLi5yZW5kZXJcclxuICogc2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlKHByZXYpXHJcbiAqIGBgYFxyXG4gKi9cclxuZnVuY3Rpb24gc2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlKGluc3RhbmNlKSB7XHJcbiAgICBjb25zdCBwcmV2ID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xyXG4gICAgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID0gaW5zdGFuY2U7XHJcbiAgICBjdXJyZW50U2NvcGVJZCA9IChpbnN0YW5jZSAmJiBpbnN0YW5jZS50eXBlLl9fc2NvcGVJZCkgfHwgbnVsbDtcclxuICAgIHJldHVybiBwcmV2O1xyXG59XHJcbi8qKlxyXG4gKiBTZXQgc2NvcGUgaWQgd2hlbiBjcmVhdGluZyBob2lzdGVkIHZub2Rlcy5cclxuICogQHByaXZhdGUgY29tcGlsZXIgaGVscGVyXHJcbiAqL1xyXG5mdW5jdGlvbiBwdXNoU2NvcGVJZChpZCkge1xyXG4gICAgY3VycmVudFNjb3BlSWQgPSBpZDtcclxufVxyXG4vKipcclxuICogVGVjaG5pY2FsbHkgd2Ugbm8gbG9uZ2VyIG5lZWQgdGhpcyBhZnRlciAzLjAuOCBidXQgd2UgbmVlZCB0byBrZWVwIHRoZSBzYW1lXHJcbiAqIEFQSSBmb3IgYmFja3dhcmRzIGNvbXBhdCB3LyBjb2RlIGdlbmVyYXRlZCBieSBjb21waWxlcnMuXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBwb3BTY29wZUlkKCkge1xyXG4gICAgY3VycmVudFNjb3BlSWQgPSBudWxsO1xyXG59XHJcbi8qKlxyXG4gKiBPbmx5IGZvciBiYWNrd2FyZHMgY29tcGF0XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jb25zdCB3aXRoU2NvcGVJZCA9IChfaWQpID0+IHdpdGhDdHg7XHJcbi8qKlxyXG4gKiBXcmFwIGEgc2xvdCBmdW5jdGlvbiB0byBtZW1vaXplIGN1cnJlbnQgcmVuZGVyaW5nIGluc3RhbmNlXHJcbiAqIEBwcml2YXRlIGNvbXBpbGVyIGhlbHBlclxyXG4gKi9cclxuZnVuY3Rpb24gd2l0aEN0eChmbiwgY3R4ID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlLCBpc05vblNjb3BlZFNsb3QgLy8gZmFsc2Ugb25seVxyXG4pIHtcclxuICAgIGlmICghY3R4KVxyXG4gICAgICAgIHJldHVybiBmbjtcclxuICAgIC8vIGFscmVhZHkgbm9ybWFsaXplZFxyXG4gICAgaWYgKGZuLl9uKSB7XHJcbiAgICAgICAgcmV0dXJuIGZuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmVuZGVyRm5XaXRoQ29udGV4dCA9ICguLi5hcmdzKSA9PiB7XHJcbiAgICAgICAgLy8gSWYgYSB1c2VyIGNhbGxzIGEgY29tcGlsZWQgc2xvdCBpbnNpZGUgYSB0ZW1wbGF0ZSBleHByZXNzaW9uICgjMTc0NSksIGl0XHJcbiAgICAgICAgLy8gY2FuIG1lc3MgdXAgYmxvY2sgdHJhY2tpbmcsIHNvIGJ5IGRlZmF1bHQgd2UgZGlzYWJsZSBibG9jayB0cmFja2luZyBhbmRcclxuICAgICAgICAvLyBmb3JjZSBiYWlsIG91dCB3aGVuIGludm9raW5nIGEgY29tcGlsZWQgc2xvdCAoaW5kaWNhdGVkIGJ5IHRoZSAuX2QgZmxhZykuXHJcbiAgICAgICAgLy8gVGhpcyBpc24ndCBuZWNlc3NhcnkgaWYgcmVuZGVyaW5nIGEgY29tcGlsZWQgYDxzbG90PmAsIHNvIHdlIGZsaXAgdGhlXHJcbiAgICAgICAgLy8gLl9kIGZsYWcgb2ZmIHdoZW4gaW52b2tpbmcgdGhlIHdyYXBwZWQgZm4gaW5zaWRlIGByZW5kZXJTbG90YC5cclxuICAgICAgICBpZiAocmVuZGVyRm5XaXRoQ29udGV4dC5fZCkge1xyXG4gICAgICAgICAgICBzZXRCbG9ja1RyYWNraW5nKC0xKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcHJldkluc3RhbmNlID0gc2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlKGN0eCk7XHJcbiAgICAgICAgY29uc3QgcmVzID0gZm4oLi4uYXJncyk7XHJcbiAgICAgICAgc2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlKHByZXZJbnN0YW5jZSk7XHJcbiAgICAgICAgaWYgKHJlbmRlckZuV2l0aENvbnRleHQuX2QpIHtcclxuICAgICAgICAgICAgc2V0QmxvY2tUcmFja2luZygxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgICAgICAgICAgZGV2dG9vbHNDb21wb25lbnRVcGRhdGVkKGN0eCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9O1xyXG4gICAgLy8gbWFyayBub3JtYWxpemVkIHRvIGF2b2lkIGR1cGxpY2F0ZWQgd3JhcHBpbmdcclxuICAgIHJlbmRlckZuV2l0aENvbnRleHQuX24gPSB0cnVlO1xyXG4gICAgLy8gbWFyayB0aGlzIGFzIGNvbXBpbGVkIGJ5IGRlZmF1bHRcclxuICAgIC8vIHRoaXMgaXMgdXNlZCBpbiB2bm9kZS50cyAtPiBub3JtYWxpemVDaGlsZHJlbigpIHRvIHNldCB0aGUgc2xvdFxyXG4gICAgLy8gcmVuZGVyaW5nIGZsYWcuXHJcbiAgICByZW5kZXJGbldpdGhDb250ZXh0Ll9jID0gdHJ1ZTtcclxuICAgIC8vIGRpc2FibGUgYmxvY2sgdHJhY2tpbmcgYnkgZGVmYXVsdFxyXG4gICAgcmVuZGVyRm5XaXRoQ29udGV4dC5fZCA9IHRydWU7XHJcbiAgICByZXR1cm4gcmVuZGVyRm5XaXRoQ29udGV4dDtcclxufVxuXG4vKipcclxuICogZGV2IG9ubHkgZmxhZyB0byB0cmFjayB3aGV0aGVyICRhdHRycyB3YXMgdXNlZCBkdXJpbmcgcmVuZGVyLlxyXG4gKiBJZiAkYXR0cnMgd2FzIHVzZWQgZHVyaW5nIHJlbmRlciB0aGVuIHRoZSB3YXJuaW5nIGZvciBmYWlsZWQgYXR0cnNcclxuICogZmFsbHRocm91Z2ggY2FuIGJlIHN1cHByZXNzZWQuXHJcbiAqL1xyXG5sZXQgYWNjZXNzZWRBdHRycyA9IGZhbHNlO1xyXG5mdW5jdGlvbiBtYXJrQXR0cnNBY2Nlc3NlZCgpIHtcclxuICAgIGFjY2Vzc2VkQXR0cnMgPSB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIHJlbmRlckNvbXBvbmVudFJvb3QoaW5zdGFuY2UpIHtcclxuICAgIGNvbnN0IHsgdHlwZTogQ29tcG9uZW50LCB2bm9kZSwgcHJveHksIHdpdGhQcm94eSwgcHJvcHMsIHByb3BzT3B0aW9uczogW3Byb3BzT3B0aW9uc10sIHNsb3RzLCBhdHRycywgZW1pdCwgcmVuZGVyLCByZW5kZXJDYWNoZSwgZGF0YSwgc2V0dXBTdGF0ZSwgY3R4LCBpbmhlcml0QXR0cnMgfSA9IGluc3RhbmNlO1xyXG4gICAgbGV0IHJlc3VsdDtcclxuICAgIGxldCBmYWxsdGhyb3VnaEF0dHJzO1xyXG4gICAgY29uc3QgcHJldiA9IHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShpbnN0YW5jZSk7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgYWNjZXNzZWRBdHRycyA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgdHJ5IHtcclxuICAgICAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgNCAvKiBTVEFURUZVTF9DT01QT05FTlQgKi8pIHtcclxuICAgICAgICAgICAgLy8gd2l0aFByb3h5IGlzIGEgcHJveHkgd2l0aCBhIGRpZmZlcmVudCBgaGFzYCB0cmFwIG9ubHkgZm9yXHJcbiAgICAgICAgICAgIC8vIHJ1bnRpbWUtY29tcGlsZWQgcmVuZGVyIGZ1bmN0aW9ucyB1c2luZyBgd2l0aGAgYmxvY2suXHJcbiAgICAgICAgICAgIGNvbnN0IHByb3h5VG9Vc2UgPSB3aXRoUHJveHkgfHwgcHJveHk7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IG5vcm1hbGl6ZVZOb2RlKHJlbmRlci5jYWxsKHByb3h5VG9Vc2UsIHByb3h5VG9Vc2UsIHJlbmRlckNhY2hlLCBwcm9wcywgc2V0dXBTdGF0ZSwgZGF0YSwgY3R4KSk7XHJcbiAgICAgICAgICAgIGZhbGx0aHJvdWdoQXR0cnMgPSBhdHRycztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGZ1bmN0aW9uYWxcclxuICAgICAgICAgICAgY29uc3QgcmVuZGVyID0gQ29tcG9uZW50O1xyXG4gICAgICAgICAgICAvLyBpbiBkZXYsIG1hcmsgYXR0cnMgYWNjZXNzZWQgaWYgb3B0aW9uYWwgcHJvcHMgKGF0dHJzID09PSBwcm9wcylcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBhdHRycyA9PT0gcHJvcHMpIHtcclxuICAgICAgICAgICAgICAgIG1hcmtBdHRyc0FjY2Vzc2VkKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzdWx0ID0gbm9ybWFsaXplVk5vZGUocmVuZGVyLmxlbmd0aCA+IDFcclxuICAgICAgICAgICAgICAgID8gcmVuZGVyKHByb3BzLCAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcclxuICAgICAgICAgICAgICAgICAgICA/IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGF0dHJzKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFya0F0dHJzQWNjZXNzZWQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhdHRycztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2xvdHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtaXRcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgOiB7IGF0dHJzLCBzbG90cywgZW1pdCB9KVxyXG4gICAgICAgICAgICAgICAgOiByZW5kZXIocHJvcHMsIG51bGwgLyogd2Uga25vdyBpdCBkb2Vzbid0IG5lZWQgaXQgKi8pKTtcclxuICAgICAgICAgICAgZmFsbHRocm91Z2hBdHRycyA9IENvbXBvbmVudC5wcm9wc1xyXG4gICAgICAgICAgICAgICAgPyBhdHRyc1xyXG4gICAgICAgICAgICAgICAgOiBnZXRGdW5jdGlvbmFsRmFsbHRocm91Z2goYXR0cnMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNhdGNoIChlcnIpIHtcclxuICAgICAgICBibG9ja1N0YWNrLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgaGFuZGxlRXJyb3IoZXJyLCBpbnN0YW5jZSwgMSAvKiBSRU5ERVJfRlVOQ1RJT04gKi8pO1xyXG4gICAgICAgIHJlc3VsdCA9IGNyZWF0ZVZOb2RlKENvbW1lbnQpO1xyXG4gICAgfVxyXG4gICAgLy8gYXR0ciBtZXJnaW5nXHJcbiAgICAvLyBpbiBkZXYgbW9kZSwgY29tbWVudHMgYXJlIHByZXNlcnZlZCwgYW5kIGl0J3MgcG9zc2libGUgZm9yIGEgdGVtcGxhdGVcclxuICAgIC8vIHRvIGhhdmUgY29tbWVudHMgYWxvbmcgc2lkZSB0aGUgcm9vdCBlbGVtZW50IHdoaWNoIG1ha2VzIGl0IGEgZnJhZ21lbnRcclxuICAgIGxldCByb290ID0gcmVzdWx0O1xyXG4gICAgbGV0IHNldFJvb3QgPSB1bmRlZmluZWQ7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgcmVzdWx0LnBhdGNoRmxhZyA+IDAgJiZcclxuICAgICAgICByZXN1bHQucGF0Y2hGbGFnICYgMjA0OCAvKiBERVZfUk9PVF9GUkFHTUVOVCAqLykge1xyXG4gICAgICAgIFtyb290LCBzZXRSb290XSA9IGdldENoaWxkUm9vdChyZXN1bHQpO1xyXG4gICAgfVxyXG4gICAgaWYgKGZhbGx0aHJvdWdoQXR0cnMgJiYgaW5oZXJpdEF0dHJzICE9PSBmYWxzZSkge1xyXG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhmYWxsdGhyb3VnaEF0dHJzKTtcclxuICAgICAgICBjb25zdCB7IHNoYXBlRmxhZyB9ID0gcm9vdDtcclxuICAgICAgICBpZiAoa2V5cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmICgxIC8qIEVMRU1FTlQgKi8gfCA2IC8qIENPTVBPTkVOVCAqLykpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwcm9wc09wdGlvbnMgJiYga2V5cy5zb21lKGlzTW9kZWxMaXN0ZW5lcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBhIHYtbW9kZWwgbGlzdGVuZXIgKG9uVXBkYXRlOnh4eCkgaGFzIGEgY29ycmVzcG9uZGluZyBkZWNsYXJlZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHByb3AsIGl0IGluZGljYXRlcyB0aGlzIGNvbXBvbmVudCBleHBlY3RzIHRvIGhhbmRsZSB2LW1vZGVsIGFuZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGl0IHNob3VsZCBub3QgZmFsbHRocm91Z2guXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVsYXRlZDogIzE1NDMsICMxNjQzLCAjMTk4OVxyXG4gICAgICAgICAgICAgICAgICAgIGZhbGx0aHJvdWdoQXR0cnMgPSBmaWx0ZXJNb2RlbExpc3RlbmVycyhmYWxsdGhyb3VnaEF0dHJzLCBwcm9wc09wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcm9vdCA9IGNsb25lVk5vZGUocm9vdCwgZmFsbHRocm91Z2hBdHRycyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFhY2Nlc3NlZEF0dHJzICYmIHJvb3QudHlwZSAhPT0gQ29tbWVudCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYWxsQXR0cnMgPSBPYmplY3Qua2V5cyhhdHRycyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBldmVudEF0dHJzID0gW107XHJcbiAgICAgICAgICAgICAgICBjb25zdCBleHRyYUF0dHJzID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGFsbEF0dHJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGFsbEF0dHJzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc09uKGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlIHYtbW9kZWwgaGFuZGxlcnMgd2hlbiB0aGV5IGZhaWwgdG8gZmFsbHRocm91Z2hcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc01vZGVsTGlzdGVuZXIoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGBvbmAsIGxvd2VyY2FzZSBmaXJzdCBsZXR0ZXIgdG8gcmVmbGVjdCBldmVudCBjYXNpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFjY3VyYXRlbHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50QXR0cnMucHVzaChrZXlbMl0udG9Mb3dlckNhc2UoKSArIGtleS5zbGljZSgzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhQXR0cnMucHVzaChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChleHRyYUF0dHJzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYEV4dHJhbmVvdXMgbm9uLXByb3BzIGF0dHJpYnV0ZXMgKGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgJHtleHRyYUF0dHJzLmpvaW4oJywgJyl9KSBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYHdlcmUgcGFzc2VkIHRvIGNvbXBvbmVudCBidXQgY291bGQgbm90IGJlIGF1dG9tYXRpY2FsbHkgaW5oZXJpdGVkIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgYmVjYXVzZSBjb21wb25lbnQgcmVuZGVycyBmcmFnbWVudCBvciB0ZXh0IHJvb3Qgbm9kZXMuYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRBdHRycy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKGBFeHRyYW5lb3VzIG5vbi1lbWl0cyBldmVudCBsaXN0ZW5lcnMgKGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgJHtldmVudEF0dHJzLmpvaW4oJywgJyl9KSBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYHdlcmUgcGFzc2VkIHRvIGNvbXBvbmVudCBidXQgY291bGQgbm90IGJlIGF1dG9tYXRpY2FsbHkgaW5oZXJpdGVkIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgYmVjYXVzZSBjb21wb25lbnQgcmVuZGVycyBmcmFnbWVudCBvciB0ZXh0IHJvb3Qgbm9kZXMuIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgSWYgdGhlIGxpc3RlbmVyIGlzIGludGVuZGVkIHRvIGJlIGEgY29tcG9uZW50IGN1c3RvbSBldmVudCBsaXN0ZW5lciBvbmx5LCBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYGRlY2xhcmUgaXQgdXNpbmcgdGhlIFwiZW1pdHNcIiBvcHRpb24uYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBpbmhlcml0IGRpcmVjdGl2ZXNcclxuICAgIGlmICh2bm9kZS5kaXJzKSB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaXNFbGVtZW50Um9vdChyb290KSkge1xyXG4gICAgICAgICAgICB3YXJuKGBSdW50aW1lIGRpcmVjdGl2ZSB1c2VkIG9uIGNvbXBvbmVudCB3aXRoIG5vbi1lbGVtZW50IHJvb3Qgbm9kZS4gYCArXHJcbiAgICAgICAgICAgICAgICBgVGhlIGRpcmVjdGl2ZXMgd2lsbCBub3QgZnVuY3Rpb24gYXMgaW50ZW5kZWQuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNsb25lIGJlZm9yZSBtdXRhdGluZyBzaW5jZSB0aGUgcm9vdCBtYXkgYmUgYSBob2lzdGVkIHZub2RlXHJcbiAgICAgICAgcm9vdCA9IGNsb25lVk5vZGUocm9vdCk7XHJcbiAgICAgICAgcm9vdC5kaXJzID0gcm9vdC5kaXJzID8gcm9vdC5kaXJzLmNvbmNhdCh2bm9kZS5kaXJzKSA6IHZub2RlLmRpcnM7XHJcbiAgICB9XHJcbiAgICAvLyBpbmhlcml0IHRyYW5zaXRpb24gZGF0YVxyXG4gICAgaWYgKHZub2RlLnRyYW5zaXRpb24pIHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFpc0VsZW1lbnRSb290KHJvb3QpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYENvbXBvbmVudCBpbnNpZGUgPFRyYW5zaXRpb24+IHJlbmRlcnMgbm9uLWVsZW1lbnQgcm9vdCBub2RlIGAgK1xyXG4gICAgICAgICAgICAgICAgYHRoYXQgY2Fubm90IGJlIGFuaW1hdGVkLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByb290LnRyYW5zaXRpb24gPSB2bm9kZS50cmFuc2l0aW9uO1xyXG4gICAgfVxyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBzZXRSb290KSB7XHJcbiAgICAgICAgc2V0Um9vdChyb290KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJlc3VsdCA9IHJvb3Q7XHJcbiAgICB9XHJcbiAgICBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UocHJldik7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbi8qKlxyXG4gKiBkZXYgb25seVxyXG4gKiBJbiBkZXYgbW9kZSwgdGVtcGxhdGUgcm9vdCBsZXZlbCBjb21tZW50cyBhcmUgcmVuZGVyZWQsIHdoaWNoIHR1cm5zIHRoZVxyXG4gKiB0ZW1wbGF0ZSBpbnRvIGEgZnJhZ21lbnQgcm9vdCwgYnV0IHdlIG5lZWQgdG8gbG9jYXRlIHRoZSBzaW5nbGUgZWxlbWVudFxyXG4gKiByb290IGZvciBhdHRycyBhbmQgc2NvcGUgaWQgcHJvY2Vzc2luZy5cclxuICovXHJcbmNvbnN0IGdldENoaWxkUm9vdCA9ICh2bm9kZSkgPT4ge1xyXG4gICAgY29uc3QgcmF3Q2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcclxuICAgIGNvbnN0IGR5bmFtaWNDaGlsZHJlbiA9IHZub2RlLmR5bmFtaWNDaGlsZHJlbjtcclxuICAgIGNvbnN0IGNoaWxkUm9vdCA9IGZpbHRlclNpbmdsZVJvb3QocmF3Q2hpbGRyZW4pO1xyXG4gICAgaWYgKCFjaGlsZFJvb3QpIHtcclxuICAgICAgICByZXR1cm4gW3Zub2RlLCB1bmRlZmluZWRdO1xyXG4gICAgfVxyXG4gICAgY29uc3QgaW5kZXggPSByYXdDaGlsZHJlbi5pbmRleE9mKGNoaWxkUm9vdCk7XHJcbiAgICBjb25zdCBkeW5hbWljSW5kZXggPSBkeW5hbWljQ2hpbGRyZW4gPyBkeW5hbWljQ2hpbGRyZW4uaW5kZXhPZihjaGlsZFJvb3QpIDogLTE7XHJcbiAgICBjb25zdCBzZXRSb290ID0gKHVwZGF0ZWRSb290KSA9PiB7XHJcbiAgICAgICAgcmF3Q2hpbGRyZW5baW5kZXhdID0gdXBkYXRlZFJvb3Q7XHJcbiAgICAgICAgaWYgKGR5bmFtaWNDaGlsZHJlbikge1xyXG4gICAgICAgICAgICBpZiAoZHluYW1pY0luZGV4ID4gLTEpIHtcclxuICAgICAgICAgICAgICAgIGR5bmFtaWNDaGlsZHJlbltkeW5hbWljSW5kZXhdID0gdXBkYXRlZFJvb3Q7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodXBkYXRlZFJvb3QucGF0Y2hGbGFnID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdm5vZGUuZHluYW1pY0NoaWxkcmVuID0gWy4uLmR5bmFtaWNDaGlsZHJlbiwgdXBkYXRlZFJvb3RdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBbbm9ybWFsaXplVk5vZGUoY2hpbGRSb290KSwgc2V0Um9vdF07XHJcbn07XHJcbmZ1bmN0aW9uIGZpbHRlclNpbmdsZVJvb3QoY2hpbGRyZW4pIHtcclxuICAgIGxldCBzaW5nbGVSb290O1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XHJcbiAgICAgICAgaWYgKGlzVk5vZGUoY2hpbGQpKSB7XHJcbiAgICAgICAgICAgIC8vIGlnbm9yZSB1c2VyIGNvbW1lbnRcclxuICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgIT09IENvbW1lbnQgfHwgY2hpbGQuY2hpbGRyZW4gPT09ICd2LWlmJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNpbmdsZVJvb3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBoYXMgbW9yZSB0aGFuIDEgbm9uLWNvbW1lbnQgY2hpbGQsIHJldHVybiBub3dcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzaW5nbGVSb290ID0gY2hpbGQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc2luZ2xlUm9vdDtcclxufVxyXG5jb25zdCBnZXRGdW5jdGlvbmFsRmFsbHRocm91Z2ggPSAoYXR0cnMpID0+IHtcclxuICAgIGxldCByZXM7XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRycykge1xyXG4gICAgICAgIGlmIChrZXkgPT09ICdjbGFzcycgfHwga2V5ID09PSAnc3R5bGUnIHx8IGlzT24oa2V5KSkge1xyXG4gICAgICAgICAgICAocmVzIHx8IChyZXMgPSB7fSkpW2tleV0gPSBhdHRyc1trZXldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbn07XHJcbmNvbnN0IGZpbHRlck1vZGVsTGlzdGVuZXJzID0gKGF0dHJzLCBwcm9wcykgPT4ge1xyXG4gICAgY29uc3QgcmVzID0ge307XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRycykge1xyXG4gICAgICAgIGlmICghaXNNb2RlbExpc3RlbmVyKGtleSkgfHwgIShrZXkuc2xpY2UoOSkgaW4gcHJvcHMpKSB7XHJcbiAgICAgICAgICAgIHJlc1trZXldID0gYXR0cnNba2V5XTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzO1xyXG59O1xyXG5jb25zdCBpc0VsZW1lbnRSb290ID0gKHZub2RlKSA9PiB7XHJcbiAgICByZXR1cm4gKHZub2RlLnNoYXBlRmxhZyAmICg2IC8qIENPTVBPTkVOVCAqLyB8IDEgLyogRUxFTUVOVCAqLykgfHxcclxuICAgICAgICB2bm9kZS50eXBlID09PSBDb21tZW50IC8vIHBvdGVudGlhbCB2LWlmIGJyYW5jaCBzd2l0Y2hcclxuICAgICk7XHJcbn07XHJcbmZ1bmN0aW9uIHNob3VsZFVwZGF0ZUNvbXBvbmVudChwcmV2Vk5vZGUsIG5leHRWTm9kZSwgb3B0aW1pemVkKSB7XHJcbiAgICBjb25zdCB7IHByb3BzOiBwcmV2UHJvcHMsIGNoaWxkcmVuOiBwcmV2Q2hpbGRyZW4sIGNvbXBvbmVudCB9ID0gcHJldlZOb2RlO1xyXG4gICAgY29uc3QgeyBwcm9wczogbmV4dFByb3BzLCBjaGlsZHJlbjogbmV4dENoaWxkcmVuLCBwYXRjaEZsYWcgfSA9IG5leHRWTm9kZTtcclxuICAgIGNvbnN0IGVtaXRzID0gY29tcG9uZW50LmVtaXRzT3B0aW9ucztcclxuICAgIC8vIFBhcmVudCBjb21wb25lbnQncyByZW5kZXIgZnVuY3Rpb24gd2FzIGhvdC11cGRhdGVkLiBTaW5jZSB0aGlzIG1heSBoYXZlXHJcbiAgICAvLyBjYXVzZWQgdGhlIGNoaWxkIGNvbXBvbmVudCdzIHNsb3RzIGNvbnRlbnQgdG8gaGF2ZSBjaGFuZ2VkLCB3ZSBuZWVkIHRvXHJcbiAgICAvLyBmb3JjZSB0aGUgY2hpbGQgdG8gdXBkYXRlIGFzIHdlbGwuXHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIChwcmV2Q2hpbGRyZW4gfHwgbmV4dENoaWxkcmVuKSAmJiBpc0htclVwZGF0aW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICAvLyBmb3JjZSBjaGlsZCB1cGRhdGUgZm9yIHJ1bnRpbWUgZGlyZWN0aXZlIG9yIHRyYW5zaXRpb24gb24gY29tcG9uZW50IHZub2RlLlxyXG4gICAgaWYgKG5leHRWTm9kZS5kaXJzIHx8IG5leHRWTm9kZS50cmFuc2l0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAob3B0aW1pemVkICYmIHBhdGNoRmxhZyA+PSAwKSB7XHJcbiAgICAgICAgaWYgKHBhdGNoRmxhZyAmIDEwMjQgLyogRFlOQU1JQ19TTE9UUyAqLykge1xyXG4gICAgICAgICAgICAvLyBzbG90IGNvbnRlbnQgdGhhdCByZWZlcmVuY2VzIHZhbHVlcyB0aGF0IG1pZ2h0IGhhdmUgY2hhbmdlZCxcclxuICAgICAgICAgICAgLy8gZS5nLiBpbiBhIHYtZm9yXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocGF0Y2hGbGFnICYgMTYgLyogRlVMTF9QUk9QUyAqLykge1xyXG4gICAgICAgICAgICBpZiAoIXByZXZQcm9wcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICEhbmV4dFByb3BzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHByZXNlbmNlIG9mIHRoaXMgZmxhZyBpbmRpY2F0ZXMgcHJvcHMgYXJlIGFsd2F5cyBub24tbnVsbFxyXG4gICAgICAgICAgICByZXR1cm4gaGFzUHJvcHNDaGFuZ2VkKHByZXZQcm9wcywgbmV4dFByb3BzLCBlbWl0cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHBhdGNoRmxhZyAmIDggLyogUFJPUFMgKi8pIHtcclxuICAgICAgICAgICAgY29uc3QgZHluYW1pY1Byb3BzID0gbmV4dFZOb2RlLmR5bmFtaWNQcm9wcztcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkeW5hbWljUHJvcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGR5bmFtaWNQcm9wc1tpXTtcclxuICAgICAgICAgICAgICAgIGlmIChuZXh0UHJvcHNba2V5XSAhPT0gcHJldlByb3BzW2tleV0gJiZcclxuICAgICAgICAgICAgICAgICAgICAhaXNFbWl0TGlzdGVuZXIoZW1pdHMsIGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIHRoaXMgcGF0aCBpcyBvbmx5IHRha2VuIGJ5IG1hbnVhbGx5IHdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9uc1xyXG4gICAgICAgIC8vIHNvIHByZXNlbmNlIG9mIGFueSBjaGlsZHJlbiBsZWFkcyB0byBhIGZvcmNlZCB1cGRhdGVcclxuICAgICAgICBpZiAocHJldkNoaWxkcmVuIHx8IG5leHRDaGlsZHJlbikge1xyXG4gICAgICAgICAgICBpZiAoIW5leHRDaGlsZHJlbiB8fCAhbmV4dENoaWxkcmVuLiRzdGFibGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcmV2UHJvcHMgPT09IG5leHRQcm9wcykge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghcHJldlByb3BzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhIW5leHRQcm9wcztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFuZXh0UHJvcHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBoYXNQcm9wc0NoYW5nZWQocHJldlByb3BzLCBuZXh0UHJvcHMsIGVtaXRzKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBoYXNQcm9wc0NoYW5nZWQocHJldlByb3BzLCBuZXh0UHJvcHMsIGVtaXRzT3B0aW9ucykge1xyXG4gICAgY29uc3QgbmV4dEtleXMgPSBPYmplY3Qua2V5cyhuZXh0UHJvcHMpO1xyXG4gICAgaWYgKG5leHRLZXlzLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMocHJldlByb3BzKS5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV4dEtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBuZXh0S2V5c1tpXTtcclxuICAgICAgICBpZiAobmV4dFByb3BzW2tleV0gIT09IHByZXZQcm9wc1trZXldICYmXHJcbiAgICAgICAgICAgICFpc0VtaXRMaXN0ZW5lcihlbWl0c09wdGlvbnMsIGtleSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIHVwZGF0ZUhPQ0hvc3RFbCh7IHZub2RlLCBwYXJlbnQgfSwgZWwgLy8gSG9zdE5vZGVcclxuKSB7XHJcbiAgICB3aGlsZSAocGFyZW50ICYmIHBhcmVudC5zdWJUcmVlID09PSB2bm9kZSkge1xyXG4gICAgICAgICh2bm9kZSA9IHBhcmVudC52bm9kZSkuZWwgPSBlbDtcclxuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IGlzU3VzcGVuc2UgPSAodHlwZSkgPT4gdHlwZS5fX2lzU3VzcGVuc2U7XHJcbi8vIFN1c3BlbnNlIGV4cG9zZXMgYSBjb21wb25lbnQtbGlrZSBBUEksIGFuZCBpcyB0cmVhdGVkIGxpa2UgYSBjb21wb25lbnRcclxuLy8gaW4gdGhlIGNvbXBpbGVyLCBidXQgaW50ZXJuYWxseSBpdCdzIGEgc3BlY2lhbCBidWlsdC1pbiB0eXBlIHRoYXQgaG9va3NcclxuLy8gZGlyZWN0bHkgaW50byB0aGUgcmVuZGVyZXIuXHJcbmNvbnN0IFN1c3BlbnNlSW1wbCA9IHtcclxuICAgIG5hbWU6ICdTdXNwZW5zZScsXHJcbiAgICAvLyBJbiBvcmRlciB0byBtYWtlIFN1c3BlbnNlIHRyZWUtc2hha2FibGUsIHdlIG5lZWQgdG8gYXZvaWQgaW1wb3J0aW5nIGl0XHJcbiAgICAvLyBkaXJlY3RseSBpbiB0aGUgcmVuZGVyZXIuIFRoZSByZW5kZXJlciBjaGVja3MgZm9yIHRoZSBfX2lzU3VzcGVuc2UgZmxhZ1xyXG4gICAgLy8gb24gYSB2bm9kZSdzIHR5cGUgYW5kIGNhbGxzIHRoZSBgcHJvY2Vzc2AgbWV0aG9kLCBwYXNzaW5nIGluIHJlbmRlcmVyXHJcbiAgICAvLyBpbnRlcm5hbHMuXHJcbiAgICBfX2lzU3VzcGVuc2U6IHRydWUsXHJcbiAgICBwcm9jZXNzKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgXHJcbiAgICAvLyBwbGF0Zm9ybS1zcGVjaWZpYyBpbXBsIHBhc3NlZCBmcm9tIHJlbmRlcmVyXHJcbiAgICByZW5kZXJlckludGVybmFscykge1xyXG4gICAgICAgIGlmIChuMSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIG1vdW50U3VzcGVuc2UobjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHBhdGNoU3VzcGVuc2UobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgaHlkcmF0ZTogaHlkcmF0ZVN1c3BlbnNlLFxyXG4gICAgY3JlYXRlOiBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5LFxyXG4gICAgbm9ybWFsaXplOiBub3JtYWxpemVTdXNwZW5zZUNoaWxkcmVuXHJcbn07XHJcbi8vIEZvcmNlLWNhc3RlZCBwdWJsaWMgdHlwaW5nIGZvciBoIGFuZCBUU1ggcHJvcHMgaW5mZXJlbmNlXHJcbmNvbnN0IFN1c3BlbnNlID0gKFN1c3BlbnNlSW1wbCApO1xyXG5mdW5jdGlvbiB0cmlnZ2VyRXZlbnQodm5vZGUsIG5hbWUpIHtcclxuICAgIGNvbnN0IGV2ZW50TGlzdGVuZXIgPSB2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wc1tuYW1lXTtcclxuICAgIGlmIChpc0Z1bmN0aW9uKGV2ZW50TGlzdGVuZXIpKSB7XHJcbiAgICAgICAgZXZlbnRMaXN0ZW5lcigpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIG1vdW50U3VzcGVuc2Uodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzKSB7XHJcbiAgICBjb25zdCB7IHA6IHBhdGNoLCBvOiB7IGNyZWF0ZUVsZW1lbnQgfSB9ID0gcmVuZGVyZXJJbnRlcm5hbHM7XHJcbiAgICBjb25zdCBoaWRkZW5Db250YWluZXIgPSBjcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgIGNvbnN0IHN1c3BlbnNlID0gKHZub2RlLnN1c3BlbnNlID0gY3JlYXRlU3VzcGVuc2VCb3VuZGFyeSh2bm9kZSwgcGFyZW50U3VzcGVuc2UsIHBhcmVudENvbXBvbmVudCwgY29udGFpbmVyLCBoaWRkZW5Db250YWluZXIsIGFuY2hvciwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscykpO1xyXG4gICAgLy8gc3RhcnQgbW91bnRpbmcgdGhlIGNvbnRlbnQgc3VidHJlZSBpbiBhbiBvZmYtZG9tIGNvbnRhaW5lclxyXG4gICAgcGF0Y2gobnVsbCwgKHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggPSB2bm9kZS5zc0NvbnRlbnQpLCBoaWRkZW5Db250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgc3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMpO1xyXG4gICAgLy8gbm93IGNoZWNrIGlmIHdlIGhhdmUgZW5jb3VudGVyZWQgYW55IGFzeW5jIGRlcHNcclxuICAgIGlmIChzdXNwZW5zZS5kZXBzID4gMCkge1xyXG4gICAgICAgIC8vIGhhcyBhc3luY1xyXG4gICAgICAgIC8vIGludm9rZSBAZmFsbGJhY2sgZXZlbnRcclxuICAgICAgICB0cmlnZ2VyRXZlbnQodm5vZGUsICdvblBlbmRpbmcnKTtcclxuICAgICAgICB0cmlnZ2VyRXZlbnQodm5vZGUsICdvbkZhbGxiYWNrJyk7XHJcbiAgICAgICAgLy8gbW91bnQgdGhlIGZhbGxiYWNrIHRyZWVcclxuICAgICAgICBwYXRjaChudWxsLCB2bm9kZS5zc0ZhbGxiYWNrLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBudWxsLCAvLyBmYWxsYmFjayB0cmVlIHdpbGwgbm90IGhhdmUgc3VzcGVuc2UgY29udGV4dFxyXG4gICAgICAgIGlzU1ZHLCBzbG90U2NvcGVJZHMpO1xyXG4gICAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgdm5vZGUuc3NGYWxsYmFjayk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBTdXNwZW5zZSBoYXMgbm8gYXN5bmMgZGVwcy4gSnVzdCByZXNvbHZlLlxyXG4gICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBwYXRjaFN1c3BlbnNlKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCB7IHA6IHBhdGNoLCB1bTogdW5tb3VudCwgbzogeyBjcmVhdGVFbGVtZW50IH0gfSkge1xyXG4gICAgY29uc3Qgc3VzcGVuc2UgPSAobjIuc3VzcGVuc2UgPSBuMS5zdXNwZW5zZSk7XHJcbiAgICBzdXNwZW5zZS52bm9kZSA9IG4yO1xyXG4gICAgbjIuZWwgPSBuMS5lbDtcclxuICAgIGNvbnN0IG5ld0JyYW5jaCA9IG4yLnNzQ29udGVudDtcclxuICAgIGNvbnN0IG5ld0ZhbGxiYWNrID0gbjIuc3NGYWxsYmFjaztcclxuICAgIGNvbnN0IHsgYWN0aXZlQnJhbmNoLCBwZW5kaW5nQnJhbmNoLCBpc0luRmFsbGJhY2ssIGlzSHlkcmF0aW5nIH0gPSBzdXNwZW5zZTtcclxuICAgIGlmIChwZW5kaW5nQnJhbmNoKSB7XHJcbiAgICAgICAgc3VzcGVuc2UucGVuZGluZ0JyYW5jaCA9IG5ld0JyYW5jaDtcclxuICAgICAgICBpZiAoaXNTYW1lVk5vZGVUeXBlKG5ld0JyYW5jaCwgcGVuZGluZ0JyYW5jaCkpIHtcclxuICAgICAgICAgICAgLy8gc2FtZSByb290IHR5cGUgYnV0IGNvbnRlbnQgbWF5IGhhdmUgY2hhbmdlZC5cclxuICAgICAgICAgICAgcGF0Y2gocGVuZGluZ0JyYW5jaCwgbmV3QnJhbmNoLCBzdXNwZW5zZS5oaWRkZW5Db250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgc3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgIGlmIChzdXNwZW5zZS5kZXBzIDw9IDApIHtcclxuICAgICAgICAgICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc0luRmFsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIHBhdGNoKGFjdGl2ZUJyYW5jaCwgbmV3RmFsbGJhY2ssIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIG51bGwsIC8vIGZhbGxiYWNrIHRyZWUgd2lsbCBub3QgaGF2ZSBzdXNwZW5zZSBjb250ZXh0XHJcbiAgICAgICAgICAgICAgICBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBuZXdGYWxsYmFjayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHRvZ2dsZWQgYmVmb3JlIHBlbmRpbmcgdHJlZSBpcyByZXNvbHZlZFxyXG4gICAgICAgICAgICBzdXNwZW5zZS5wZW5kaW5nSWQrKztcclxuICAgICAgICAgICAgaWYgKGlzSHlkcmF0aW5nKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiB0b2dnbGVkIGJlZm9yZSBoeWRyYXRpb24gaXMgZmluaXNoZWQsIHRoZSBjdXJyZW50IERPTSB0cmVlIGlzXHJcbiAgICAgICAgICAgICAgICAvLyBubyBsb25nZXIgdmFsaWQuIHNldCBpdCBhcyB0aGUgYWN0aXZlIGJyYW5jaCBzbyBpdCB3aWxsIGJlIHVubW91bnRlZFxyXG4gICAgICAgICAgICAgICAgLy8gd2hlbiByZXNvbHZlZFxyXG4gICAgICAgICAgICAgICAgc3VzcGVuc2UuaXNIeWRyYXRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCA9IHBlbmRpbmdCcmFuY2g7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB1bm1vdW50KHBlbmRpbmdCcmFuY2gsIHBhcmVudENvbXBvbmVudCwgc3VzcGVuc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGluY3JlbWVudCBwZW5kaW5nIElELiB0aGlzIGlzIHVzZWQgdG8gaW52YWxpZGF0ZSBhc3luYyBjYWxsYmFja3NcclxuICAgICAgICAgICAgLy8gcmVzZXQgc3VzcGVuc2Ugc3RhdGVcclxuICAgICAgICAgICAgc3VzcGVuc2UuZGVwcyA9IDA7XHJcbiAgICAgICAgICAgIC8vIGRpc2NhcmQgZWZmZWN0cyBmcm9tIHBlbmRpbmcgYnJhbmNoXHJcbiAgICAgICAgICAgIHN1c3BlbnNlLmVmZmVjdHMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgLy8gZGlzY2FyZCBwcmV2aW91cyBjb250YWluZXJcclxuICAgICAgICAgICAgc3VzcGVuc2UuaGlkZGVuQ29udGFpbmVyID0gY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgICAgIGlmIChpc0luRmFsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIC8vIGFscmVhZHkgaW4gZmFsbGJhY2sgc3RhdGVcclxuICAgICAgICAgICAgICAgIHBhdGNoKG51bGwsIG5ld0JyYW5jaCwgc3VzcGVuc2UuaGlkZGVuQ29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN1c3BlbnNlLmRlcHMgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoKGFjdGl2ZUJyYW5jaCwgbmV3RmFsbGJhY2ssIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIG51bGwsIC8vIGZhbGxiYWNrIHRyZWUgd2lsbCBub3QgaGF2ZSBzdXNwZW5zZSBjb250ZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIG5ld0ZhbGxiYWNrKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChhY3RpdmVCcmFuY2ggJiYgaXNTYW1lVk5vZGVUeXBlKG5ld0JyYW5jaCwgYWN0aXZlQnJhbmNoKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gdG9nZ2xlZCBcImJhY2tcIiB0byBjdXJyZW50IGFjdGl2ZSBicmFuY2hcclxuICAgICAgICAgICAgICAgIHBhdGNoKGFjdGl2ZUJyYW5jaCwgbmV3QnJhbmNoLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIC8vIGZvcmNlIHJlc29sdmVcclxuICAgICAgICAgICAgICAgIHN1c3BlbnNlLnJlc29sdmUodHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBzd2l0Y2hlZCB0byBhIDNyZCBicmFuY2hcclxuICAgICAgICAgICAgICAgIHBhdGNoKG51bGwsIG5ld0JyYW5jaCwgc3VzcGVuc2UuaGlkZGVuQ29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN1c3BlbnNlLmRlcHMgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmIChhY3RpdmVCcmFuY2ggJiYgaXNTYW1lVk5vZGVUeXBlKG5ld0JyYW5jaCwgYWN0aXZlQnJhbmNoKSkge1xyXG4gICAgICAgICAgICAvLyByb290IGRpZCBub3QgY2hhbmdlLCBqdXN0IG5vcm1hbCBwYXRjaFxyXG4gICAgICAgICAgICBwYXRjaChhY3RpdmVCcmFuY2gsIG5ld0JyYW5jaCwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgc3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgbmV3QnJhbmNoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHJvb3Qgbm9kZSB0b2dnbGVkXHJcbiAgICAgICAgICAgIC8vIGludm9rZSBAcGVuZGluZyBldmVudFxyXG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQobjIsICdvblBlbmRpbmcnKTtcclxuICAgICAgICAgICAgLy8gbW91bnQgcGVuZGluZyBicmFuY2ggaW4gb2ZmLWRvbSBjb250YWluZXJcclxuICAgICAgICAgICAgc3VzcGVuc2UucGVuZGluZ0JyYW5jaCA9IG5ld0JyYW5jaDtcclxuICAgICAgICAgICAgc3VzcGVuc2UucGVuZGluZ0lkKys7XHJcbiAgICAgICAgICAgIHBhdGNoKG51bGwsIG5ld0JyYW5jaCwgc3VzcGVuc2UuaGlkZGVuQ29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICBpZiAoc3VzcGVuc2UuZGVwcyA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpbmNvbWluZyBicmFuY2ggaGFzIG5vIGFzeW5jIGRlcHMsIHJlc29sdmUgbm93LlxyXG4gICAgICAgICAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyB0aW1lb3V0LCBwZW5kaW5nSWQgfSA9IHN1c3BlbnNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRpbWVvdXQgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdXNwZW5zZS5wZW5kaW5nSWQgPT09IHBlbmRpbmdJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VzcGVuc2UuZmFsbGJhY2sobmV3RmFsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgdGltZW91dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aW1lb3V0ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3VzcGVuc2UuZmFsbGJhY2sobmV3RmFsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmxldCBoYXNXYXJuZWQgPSBmYWxzZTtcclxuZnVuY3Rpb24gY3JlYXRlU3VzcGVuc2VCb3VuZGFyeSh2bm9kZSwgcGFyZW50LCBwYXJlbnRDb21wb25lbnQsIGNvbnRhaW5lciwgaGlkZGVuQ29udGFpbmVyLCBhbmNob3IsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMsIGlzSHlkcmF0aW5nID0gZmFsc2UpIHtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhZmFsc2UgJiYgIWhhc1dhcm5lZCkge1xyXG4gICAgICAgIGhhc1dhcm5lZCA9IHRydWU7XHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZSBgY29uc29sZS5pbmZvYCBjYW5ub3QgYmUgbnVsbCBlcnJvclxyXG4gICAgICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKGA8U3VzcGVuc2U+IGlzIGFuIGV4cGVyaW1lbnRhbCBmZWF0dXJlIGFuZCBpdHMgQVBJIHdpbGwgbGlrZWx5IGNoYW5nZS5gKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgcDogcGF0Y2gsIG06IG1vdmUsIHVtOiB1bm1vdW50LCBuOiBuZXh0LCBvOiB7IHBhcmVudE5vZGUsIHJlbW92ZSB9IH0gPSByZW5kZXJlckludGVybmFscztcclxuICAgIGNvbnN0IHRpbWVvdXQgPSB0b051bWJlcih2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wcy50aW1lb3V0KTtcclxuICAgIGNvbnN0IHN1c3BlbnNlID0ge1xyXG4gICAgICAgIHZub2RlLFxyXG4gICAgICAgIHBhcmVudCxcclxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXHJcbiAgICAgICAgaXNTVkcsXHJcbiAgICAgICAgY29udGFpbmVyLFxyXG4gICAgICAgIGhpZGRlbkNvbnRhaW5lcixcclxuICAgICAgICBhbmNob3IsXHJcbiAgICAgICAgZGVwczogMCxcclxuICAgICAgICBwZW5kaW5nSWQ6IDAsXHJcbiAgICAgICAgdGltZW91dDogdHlwZW9mIHRpbWVvdXQgPT09ICdudW1iZXInID8gdGltZW91dCA6IC0xLFxyXG4gICAgICAgIGFjdGl2ZUJyYW5jaDogbnVsbCxcclxuICAgICAgICBwZW5kaW5nQnJhbmNoOiBudWxsLFxyXG4gICAgICAgIGlzSW5GYWxsYmFjazogdHJ1ZSxcclxuICAgICAgICBpc0h5ZHJhdGluZyxcclxuICAgICAgICBpc1VubW91bnRlZDogZmFsc2UsXHJcbiAgICAgICAgZWZmZWN0czogW10sXHJcbiAgICAgICAgcmVzb2x2ZShyZXN1bWUgPSBmYWxzZSkge1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VtZSAmJiAhc3VzcGVuc2UucGVuZGluZ0JyYW5jaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgc3VzcGVuc2UucmVzb2x2ZSgpIGlzIGNhbGxlZCB3aXRob3V0IGEgcGVuZGluZyBicmFuY2guYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoc3VzcGVuc2UuaXNVbm1vdW50ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHN1c3BlbnNlLnJlc29sdmUoKSBpcyBjYWxsZWQgb24gYW4gYWxyZWFkeSB1bm1vdW50ZWQgc3VzcGVuc2UgYm91bmRhcnkuYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgeyB2bm9kZSwgYWN0aXZlQnJhbmNoLCBwZW5kaW5nQnJhbmNoLCBwZW5kaW5nSWQsIGVmZmVjdHMsIHBhcmVudENvbXBvbmVudCwgY29udGFpbmVyIH0gPSBzdXNwZW5zZTtcclxuICAgICAgICAgICAgaWYgKHN1c3BlbnNlLmlzSHlkcmF0aW5nKSB7XHJcbiAgICAgICAgICAgICAgICBzdXNwZW5zZS5pc0h5ZHJhdGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFyZXN1bWUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRlbGF5RW50ZXIgPSBhY3RpdmVCcmFuY2ggJiZcclxuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nQnJhbmNoLnRyYW5zaXRpb24gJiZcclxuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nQnJhbmNoLnRyYW5zaXRpb24ubW9kZSA9PT0gJ291dC1pbic7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGVsYXlFbnRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZUJyYW5jaC50cmFuc2l0aW9uLmFmdGVyTGVhdmUgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZW5kaW5nSWQgPT09IHN1c3BlbnNlLnBlbmRpbmdJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW92ZShwZW5kaW5nQnJhbmNoLCBjb250YWluZXIsIGFuY2hvciwgMCAvKiBFTlRFUiAqLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBpbml0aWFsIGFuY2hvciBvbiBtb3VudFxyXG4gICAgICAgICAgICAgICAgbGV0IHsgYW5jaG9yIH0gPSBzdXNwZW5zZTtcclxuICAgICAgICAgICAgICAgIC8vIHVubW91bnQgY3VycmVudCBhY3RpdmUgdHJlZVxyXG4gICAgICAgICAgICAgICAgaWYgKGFjdGl2ZUJyYW5jaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBmYWxsYmFjayB0cmVlIHdhcyBtb3VudGVkLCBpdCBtYXkgaGF2ZSBiZWVuIG1vdmVkXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYXMgcGFydCBvZiBhIHBhcmVudCBzdXNwZW5zZS4gZ2V0IHRoZSBsYXRlc3QgYW5jaG9yIGZvciBpbnNlcnRpb25cclxuICAgICAgICAgICAgICAgICAgICBhbmNob3IgPSBuZXh0KGFjdGl2ZUJyYW5jaCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdW5tb3VudChhY3RpdmVCcmFuY2gsIHBhcmVudENvbXBvbmVudCwgc3VzcGVuc2UsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFkZWxheUVudGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbW92ZSBjb250ZW50IGZyb20gb2ZmLWRvbSBjb250YWluZXIgdG8gYWN0dWFsIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgICAgIG1vdmUocGVuZGluZ0JyYW5jaCwgY29udGFpbmVyLCBhbmNob3IsIDAgLyogRU5URVIgKi8pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgcGVuZGluZ0JyYW5jaCk7XHJcbiAgICAgICAgICAgIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggPSBudWxsO1xyXG4gICAgICAgICAgICBzdXNwZW5zZS5pc0luRmFsbGJhY2sgPSBmYWxzZTtcclxuICAgICAgICAgICAgLy8gZmx1c2ggYnVmZmVyZWQgZWZmZWN0c1xyXG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGVyZSBpcyBhIHBlbmRpbmcgcGFyZW50IHN1c3BlbnNlXHJcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSBzdXNwZW5zZS5wYXJlbnQ7XHJcbiAgICAgICAgICAgIGxldCBoYXNVbnJlc29sdmVkQW5jZXN0b3IgPSBmYWxzZTtcclxuICAgICAgICAgICAgd2hpbGUgKHBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudC5wZW5kaW5nQnJhbmNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZm91bmQgYSBwZW5kaW5nIHBhcmVudCBzdXNwZW5zZSwgbWVyZ2UgYnVmZmVyZWQgcG9zdCBqb2JzXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaW50byB0aGF0IHBhcmVudFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5lZmZlY3RzLnB1c2goLi4uZWZmZWN0cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzVW5yZXNvbHZlZEFuY2VzdG9yID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gbm8gcGVuZGluZyBwYXJlbnQgc3VzcGVuc2UsIGZsdXNoIGFsbCBqb2JzXHJcbiAgICAgICAgICAgIGlmICghaGFzVW5yZXNvbHZlZEFuY2VzdG9yKSB7XHJcbiAgICAgICAgICAgICAgICBxdWV1ZVBvc3RGbHVzaENiKGVmZmVjdHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN1c3BlbnNlLmVmZmVjdHMgPSBbXTtcclxuICAgICAgICAgICAgLy8gaW52b2tlIEByZXNvbHZlIGV2ZW50XHJcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudCh2bm9kZSwgJ29uUmVzb2x2ZScpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZmFsbGJhY2soZmFsbGJhY2tWTm9kZSkge1xyXG4gICAgICAgICAgICBpZiAoIXN1c3BlbnNlLnBlbmRpbmdCcmFuY2gpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCB7IHZub2RlLCBhY3RpdmVCcmFuY2gsIHBhcmVudENvbXBvbmVudCwgY29udGFpbmVyLCBpc1NWRyB9ID0gc3VzcGVuc2U7XHJcbiAgICAgICAgICAgIC8vIGludm9rZSBAZmFsbGJhY2sgZXZlbnRcclxuICAgICAgICAgICAgdHJpZ2dlckV2ZW50KHZub2RlLCAnb25GYWxsYmFjaycpO1xyXG4gICAgICAgICAgICBjb25zdCBhbmNob3IgPSBuZXh0KGFjdGl2ZUJyYW5jaCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vdW50RmFsbGJhY2sgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXN1c3BlbnNlLmlzSW5GYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIG1vdW50IHRoZSBmYWxsYmFjayB0cmVlXHJcbiAgICAgICAgICAgICAgICBwYXRjaChudWxsLCBmYWxsYmFja1ZOb2RlLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBudWxsLCAvLyBmYWxsYmFjayB0cmVlIHdpbGwgbm90IGhhdmUgc3VzcGVuc2UgY29udGV4dFxyXG4gICAgICAgICAgICAgICAgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgZmFsbGJhY2tWTm9kZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbnN0IGRlbGF5RW50ZXIgPSBmYWxsYmFja1ZOb2RlLnRyYW5zaXRpb24gJiYgZmFsbGJhY2tWTm9kZS50cmFuc2l0aW9uLm1vZGUgPT09ICdvdXQtaW4nO1xyXG4gICAgICAgICAgICBpZiAoZGVsYXlFbnRlcikge1xyXG4gICAgICAgICAgICAgICAgYWN0aXZlQnJhbmNoLnRyYW5zaXRpb24uYWZ0ZXJMZWF2ZSA9IG1vdW50RmFsbGJhY2s7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3VzcGVuc2UuaXNJbkZhbGxiYWNrID0gdHJ1ZTtcclxuICAgICAgICAgICAgLy8gdW5tb3VudCBjdXJyZW50IGFjdGl2ZSBicmFuY2hcclxuICAgICAgICAgICAgdW5tb3VudChhY3RpdmVCcmFuY2gsIHBhcmVudENvbXBvbmVudCwgbnVsbCwgLy8gbm8gc3VzcGVuc2Ugc28gdW5tb3VudCBob29rcyBmaXJlIG5vd1xyXG4gICAgICAgICAgICB0cnVlIC8vIHNob3VsZFJlbW92ZVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBpZiAoIWRlbGF5RW50ZXIpIHtcclxuICAgICAgICAgICAgICAgIG1vdW50RmFsbGJhY2soKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbW92ZShjb250YWluZXIsIGFuY2hvciwgdHlwZSkge1xyXG4gICAgICAgICAgICBzdXNwZW5zZS5hY3RpdmVCcmFuY2ggJiZcclxuICAgICAgICAgICAgICAgIG1vdmUoc3VzcGVuc2UuYWN0aXZlQnJhbmNoLCBjb250YWluZXIsIGFuY2hvciwgdHlwZSk7XHJcbiAgICAgICAgICAgIHN1c3BlbnNlLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG5leHQoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdXNwZW5zZS5hY3RpdmVCcmFuY2ggJiYgbmV4dChzdXNwZW5zZS5hY3RpdmVCcmFuY2gpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVnaXN0ZXJEZXAoaW5zdGFuY2UsIHNldHVwUmVuZGVyRWZmZWN0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzSW5QZW5kaW5nU3VzcGVuc2UgPSAhIXN1c3BlbnNlLnBlbmRpbmdCcmFuY2g7XHJcbiAgICAgICAgICAgIGlmIChpc0luUGVuZGluZ1N1c3BlbnNlKSB7XHJcbiAgICAgICAgICAgICAgICBzdXNwZW5zZS5kZXBzKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgaHlkcmF0ZWRFbCA9IGluc3RhbmNlLnZub2RlLmVsO1xyXG4gICAgICAgICAgICBpbnN0YW5jZVxyXG4gICAgICAgICAgICAgICAgLmFzeW5jRGVwLmNhdGNoKGVyciA9PiB7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcihlcnIsIGluc3RhbmNlLCAwIC8qIFNFVFVQX0ZVTkNUSU9OICovKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC50aGVuKGFzeW5jU2V0dXBSZXN1bHQgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gcmV0cnkgd2hlbiB0aGUgc2V0dXAoKSBwcm9taXNlIHJlc29sdmVzLlxyXG4gICAgICAgICAgICAgICAgLy8gY29tcG9uZW50IG1heSBoYXZlIGJlZW4gdW5tb3VudGVkIGJlZm9yZSByZXNvbHZlLlxyXG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLmlzVW5tb3VudGVkIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgc3VzcGVuc2UuaXNVbm1vdW50ZWQgfHxcclxuICAgICAgICAgICAgICAgICAgICBzdXNwZW5zZS5wZW5kaW5nSWQgIT09IGluc3RhbmNlLnN1c3BlbnNlSWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyByZXRyeSBmcm9tIHRoaXMgY29tcG9uZW50XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5hc3luY1Jlc29sdmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgdm5vZGUgfSA9IGluc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHB1c2hXYXJuaW5nQ29udGV4dCh2bm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVTZXR1cFJlc3VsdChpbnN0YW5jZSwgYXN5bmNTZXR1cFJlc3VsdCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGh5ZHJhdGVkRWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB2bm9kZSBtYXkgaGF2ZSBiZWVuIHJlcGxhY2VkIGlmIGFuIHVwZGF0ZSBoYXBwZW5lZCBiZWZvcmUgdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYXN5bmMgZGVwIGlzIHJlc29sdmVkLlxyXG4gICAgICAgICAgICAgICAgICAgIHZub2RlLmVsID0gaHlkcmF0ZWRFbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gIWh5ZHJhdGVkRWwgJiYgaW5zdGFuY2Uuc3ViVHJlZS5lbDtcclxuICAgICAgICAgICAgICAgIHNldHVwUmVuZGVyRWZmZWN0KGluc3RhbmNlLCB2bm9kZSwgXHJcbiAgICAgICAgICAgICAgICAvLyBjb21wb25lbnQgbWF5IGhhdmUgYmVlbiBtb3ZlZCBiZWZvcmUgcmVzb2x2ZS5cclxuICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgbm90IGEgaHlkcmF0aW9uLCBpbnN0YW5jZS5zdWJUcmVlIHdpbGwgYmUgdGhlIGNvbW1lbnRcclxuICAgICAgICAgICAgICAgIC8vIHBsYWNlaG9sZGVyLlxyXG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZShoeWRyYXRlZEVsIHx8IGluc3RhbmNlLnN1YlRyZWUuZWwpLCBcclxuICAgICAgICAgICAgICAgIC8vIGFuY2hvciB3aWxsIG5vdCBiZSB1c2VkIGlmIHRoaXMgaXMgaHlkcmF0aW9uLCBzbyBvbmx5IG5lZWQgdG9cclxuICAgICAgICAgICAgICAgIC8vIGNvbnNpZGVyIHRoZSBjb21tZW50IHBsYWNlaG9sZGVyIGNhc2UuXHJcbiAgICAgICAgICAgICAgICBoeWRyYXRlZEVsID8gbnVsbCA6IG5leHQoaW5zdGFuY2Uuc3ViVHJlZSksIHN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIGlmIChwbGFjZWhvbGRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZShwbGFjZWhvbGRlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB1cGRhdGVIT0NIb3N0RWwoaW5zdGFuY2UsIHZub2RlLmVsKTtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gb25seSBkZWNyZWFzZSBkZXBzIGNvdW50IGlmIHN1c3BlbnNlIGlzIG5vdCBhbHJlYWR5IHJlc29sdmVkXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNJblBlbmRpbmdTdXNwZW5zZSAmJiAtLXN1c3BlbnNlLmRlcHMgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdW5tb3VudChwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpIHtcclxuICAgICAgICAgICAgc3VzcGVuc2UuaXNVbm1vdW50ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAoc3VzcGVuc2UuYWN0aXZlQnJhbmNoKSB7XHJcbiAgICAgICAgICAgICAgICB1bm1vdW50KHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzdXNwZW5zZS5wZW5kaW5nQnJhbmNoKSB7XHJcbiAgICAgICAgICAgICAgICB1bm1vdW50KHN1c3BlbnNlLnBlbmRpbmdCcmFuY2gsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gc3VzcGVuc2U7XHJcbn1cclxuZnVuY3Rpb24gaHlkcmF0ZVN1c3BlbnNlKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzLCBoeWRyYXRlTm9kZSkge1xyXG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzICovXHJcbiAgICBjb25zdCBzdXNwZW5zZSA9ICh2bm9kZS5zdXNwZW5zZSA9IGNyZWF0ZVN1c3BlbnNlQm91bmRhcnkodm5vZGUsIHBhcmVudFN1c3BlbnNlLCBwYXJlbnRDb21wb25lbnQsIG5vZGUucGFyZW50Tm9kZSwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksIG51bGwsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMsIHRydWUgLyogaHlkcmF0aW5nICovKSk7XHJcbiAgICAvLyB0aGVyZSBhcmUgdHdvIHBvc3NpYmxlIHNjZW5hcmlvcyBmb3Igc2VydmVyLXJlbmRlcmVkIHN1c3BlbnNlOlxyXG4gICAgLy8gLSBzdWNjZXNzOiBzc3IgY29udGVudCBzaG91bGQgYmUgZnVsbHkgcmVzb2x2ZWRcclxuICAgIC8vIC0gZmFpbHVyZTogc3NyIGNvbnRlbnQgc2hvdWxkIGJlIHRoZSBmYWxsYmFjayBicmFuY2guXHJcbiAgICAvLyBob3dldmVyLCBvbiB0aGUgY2xpZW50IHdlIGRvbid0IHJlYWxseSBrbm93IGlmIGl0IGhhcyBmYWlsZWQgb3Igbm90XHJcbiAgICAvLyBhdHRlbXB0IHRvIGh5ZHJhdGUgdGhlIERPTSBhc3N1bWluZyBpdCBoYXMgc3VjY2VlZGVkLCBidXQgd2Ugc3RpbGxcclxuICAgIC8vIG5lZWQgdG8gY29uc3RydWN0IGEgc3VzcGVuc2UgYm91bmRhcnkgZmlyc3RcclxuICAgIGNvbnN0IHJlc3VsdCA9IGh5ZHJhdGVOb2RlKG5vZGUsIChzdXNwZW5zZS5wZW5kaW5nQnJhbmNoID0gdm5vZGUuc3NDb250ZW50KSwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgaWYgKHN1c3BlbnNlLmRlcHMgPT09IDApIHtcclxuICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgKi9cclxufVxyXG5mdW5jdGlvbiBub3JtYWxpemVTdXNwZW5zZUNoaWxkcmVuKHZub2RlKSB7XHJcbiAgICBjb25zdCB7IHNoYXBlRmxhZywgY2hpbGRyZW4gfSA9IHZub2RlO1xyXG4gICAgY29uc3QgaXNTbG90Q2hpbGRyZW4gPSBzaGFwZUZsYWcgJiAzMiAvKiBTTE9UU19DSElMRFJFTiAqLztcclxuICAgIHZub2RlLnNzQ29udGVudCA9IG5vcm1hbGl6ZVN1c3BlbnNlU2xvdChpc1Nsb3RDaGlsZHJlbiA/IGNoaWxkcmVuLmRlZmF1bHQgOiBjaGlsZHJlbik7XHJcbiAgICB2bm9kZS5zc0ZhbGxiYWNrID0gaXNTbG90Q2hpbGRyZW5cclxuICAgICAgICA/IG5vcm1hbGl6ZVN1c3BlbnNlU2xvdChjaGlsZHJlbi5mYWxsYmFjaylcclxuICAgICAgICA6IGNyZWF0ZVZOb2RlKENvbW1lbnQpO1xyXG59XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN1c3BlbnNlU2xvdChzKSB7XHJcbiAgICBsZXQgYmxvY2s7XHJcbiAgICBpZiAoaXNGdW5jdGlvbihzKSkge1xyXG4gICAgICAgIGNvbnN0IHRyYWNrQmxvY2sgPSBpc0Jsb2NrVHJlZUVuYWJsZWQgJiYgcy5fYztcclxuICAgICAgICBpZiAodHJhY2tCbG9jaykge1xyXG4gICAgICAgICAgICAvLyBkaXNhYmxlVHJhY2tpbmc6IGZhbHNlXHJcbiAgICAgICAgICAgIC8vIGFsbG93IGJsb2NrIHRyYWNraW5nIGZvciBjb21waWxlZCBzbG90c1xyXG4gICAgICAgICAgICAvLyAoc2VlIC4vY29tcG9uZW50UmVuZGVyQ29udGV4dC50cylcclxuICAgICAgICAgICAgcy5fZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBvcGVuQmxvY2soKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcyA9IHMoKTtcclxuICAgICAgICBpZiAodHJhY2tCbG9jaykge1xyXG4gICAgICAgICAgICBzLl9kID0gdHJ1ZTtcclxuICAgICAgICAgICAgYmxvY2sgPSBjdXJyZW50QmxvY2s7XHJcbiAgICAgICAgICAgIGNsb3NlQmxvY2soKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoaXNBcnJheShzKSkge1xyXG4gICAgICAgIGNvbnN0IHNpbmdsZUNoaWxkID0gZmlsdGVyU2luZ2xlUm9vdChzKTtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFzaW5nbGVDaGlsZCkge1xyXG4gICAgICAgICAgICB3YXJuKGA8U3VzcGVuc2U+IHNsb3RzIGV4cGVjdCBhIHNpbmdsZSByb290IG5vZGUuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHMgPSBzaW5nbGVDaGlsZDtcclxuICAgIH1cclxuICAgIHMgPSBub3JtYWxpemVWTm9kZShzKTtcclxuICAgIGlmIChibG9jayAmJiAhcy5keW5hbWljQ2hpbGRyZW4pIHtcclxuICAgICAgICBzLmR5bmFtaWNDaGlsZHJlbiA9IGJsb2NrLmZpbHRlcihjID0+IGMgIT09IHMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHM7XHJcbn1cclxuZnVuY3Rpb24gcXVldWVFZmZlY3RXaXRoU3VzcGVuc2UoZm4sIHN1c3BlbnNlKSB7XHJcbiAgICBpZiAoc3VzcGVuc2UgJiYgc3VzcGVuc2UucGVuZGluZ0JyYW5jaCkge1xyXG4gICAgICAgIGlmIChpc0FycmF5KGZuKSkge1xyXG4gICAgICAgICAgICBzdXNwZW5zZS5lZmZlY3RzLnB1c2goLi4uZm4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc3VzcGVuc2UuZWZmZWN0cy5wdXNoKGZuKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBxdWV1ZVBvc3RGbHVzaENiKGZuKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIGJyYW5jaCkge1xyXG4gICAgc3VzcGVuc2UuYWN0aXZlQnJhbmNoID0gYnJhbmNoO1xyXG4gICAgY29uc3QgeyB2bm9kZSwgcGFyZW50Q29tcG9uZW50IH0gPSBzdXNwZW5zZTtcclxuICAgIGNvbnN0IGVsID0gKHZub2RlLmVsID0gYnJhbmNoLmVsKTtcclxuICAgIC8vIGluIGNhc2Ugc3VzcGVuc2UgaXMgdGhlIHJvb3Qgbm9kZSBvZiBhIGNvbXBvbmVudCxcclxuICAgIC8vIHJlY3Vyc2l2ZWx5IHVwZGF0ZSB0aGUgSE9DIGVsXHJcbiAgICBpZiAocGFyZW50Q29tcG9uZW50ICYmIHBhcmVudENvbXBvbmVudC5zdWJUcmVlID09PSB2bm9kZSkge1xyXG4gICAgICAgIHBhcmVudENvbXBvbmVudC52bm9kZS5lbCA9IGVsO1xyXG4gICAgICAgIHVwZGF0ZUhPQ0hvc3RFbChwYXJlbnRDb21wb25lbnQsIGVsKTtcclxuICAgIH1cclxufVxuXG5mdW5jdGlvbiBwcm92aWRlKGtleSwgdmFsdWUpIHtcclxuICAgIGlmICghY3VycmVudEluc3RhbmNlKSB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICB3YXJuKGBwcm92aWRlKCkgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgc2V0dXAoKS5gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBsZXQgcHJvdmlkZXMgPSBjdXJyZW50SW5zdGFuY2UucHJvdmlkZXM7XHJcbiAgICAgICAgLy8gYnkgZGVmYXVsdCBhbiBpbnN0YW5jZSBpbmhlcml0cyBpdHMgcGFyZW50J3MgcHJvdmlkZXMgb2JqZWN0XHJcbiAgICAgICAgLy8gYnV0IHdoZW4gaXQgbmVlZHMgdG8gcHJvdmlkZSB2YWx1ZXMgb2YgaXRzIG93biwgaXQgY3JlYXRlcyBpdHNcclxuICAgICAgICAvLyBvd24gcHJvdmlkZXMgb2JqZWN0IHVzaW5nIHBhcmVudCBwcm92aWRlcyBvYmplY3QgYXMgcHJvdG90eXBlLlxyXG4gICAgICAgIC8vIHRoaXMgd2F5IGluIGBpbmplY3RgIHdlIGNhbiBzaW1wbHkgbG9vayB1cCBpbmplY3Rpb25zIGZyb20gZGlyZWN0XHJcbiAgICAgICAgLy8gcGFyZW50IGFuZCBsZXQgdGhlIHByb3RvdHlwZSBjaGFpbiBkbyB0aGUgd29yay5cclxuICAgICAgICBjb25zdCBwYXJlbnRQcm92aWRlcyA9IGN1cnJlbnRJbnN0YW5jZS5wYXJlbnQgJiYgY3VycmVudEluc3RhbmNlLnBhcmVudC5wcm92aWRlcztcclxuICAgICAgICBpZiAocGFyZW50UHJvdmlkZXMgPT09IHByb3ZpZGVzKSB7XHJcbiAgICAgICAgICAgIHByb3ZpZGVzID0gY3VycmVudEluc3RhbmNlLnByb3ZpZGVzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRQcm92aWRlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRTIGRvZXNuJ3QgYWxsb3cgc3ltYm9sIGFzIGluZGV4IHR5cGVcclxuICAgICAgICBwcm92aWRlc1trZXldID0gdmFsdWU7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaW5qZWN0KGtleSwgZGVmYXVsdFZhbHVlLCB0cmVhdERlZmF1bHRBc0ZhY3RvcnkgPSBmYWxzZSkge1xyXG4gICAgLy8gZmFsbGJhY2sgdG8gYGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZWAgc28gdGhhdCB0aGlzIGNhbiBiZSBjYWxsZWQgaW5cclxuICAgIC8vIGEgZnVuY3Rpb25hbCBjb21wb25lbnRcclxuICAgIGNvbnN0IGluc3RhbmNlID0gY3VycmVudEluc3RhbmNlIHx8IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcclxuICAgIGlmIChpbnN0YW5jZSkge1xyXG4gICAgICAgIC8vICMyNDAwXHJcbiAgICAgICAgLy8gdG8gc3VwcG9ydCBgYXBwLnVzZWAgcGx1Z2lucyxcclxuICAgICAgICAvLyBmYWxsYmFjayB0byBhcHBDb250ZXh0J3MgYHByb3ZpZGVzYCBpZiB0aGUgaW5zdGFuY2UgaXMgYXQgcm9vdFxyXG4gICAgICAgIGNvbnN0IHByb3ZpZGVzID0gaW5zdGFuY2UucGFyZW50ID09IG51bGxcclxuICAgICAgICAgICAgPyBpbnN0YW5jZS52bm9kZS5hcHBDb250ZXh0ICYmIGluc3RhbmNlLnZub2RlLmFwcENvbnRleHQucHJvdmlkZXNcclxuICAgICAgICAgICAgOiBpbnN0YW5jZS5wYXJlbnQucHJvdmlkZXM7XHJcbiAgICAgICAgaWYgKHByb3ZpZGVzICYmIGtleSBpbiBwcm92aWRlcykge1xyXG4gICAgICAgICAgICAvLyBUUyBkb2Vzbid0IGFsbG93IHN5bWJvbCBhcyBpbmRleCB0eXBlXHJcbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlc1trZXldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJlYXREZWZhdWx0QXNGYWN0b3J5ICYmIGlzRnVuY3Rpb24oZGVmYXVsdFZhbHVlKVxyXG4gICAgICAgICAgICAgICAgPyBkZWZhdWx0VmFsdWUuY2FsbChpbnN0YW5jZS5wcm94eSlcclxuICAgICAgICAgICAgICAgIDogZGVmYXVsdFZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgd2FybihgaW5qZWN0aW9uIFwiJHtTdHJpbmcoa2V5KX1cIiBub3QgZm91bmQuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgd2FybihgaW5qZWN0KCkgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgc2V0dXAoKSBvciBmdW5jdGlvbmFsIGNvbXBvbmVudHMuYCk7XHJcbiAgICB9XHJcbn1cblxuLy8gU2ltcGxlIGVmZmVjdC5cclxuZnVuY3Rpb24gd2F0Y2hFZmZlY3QoZWZmZWN0LCBvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gZG9XYXRjaChlZmZlY3QsIG51bGwsIG9wdGlvbnMpO1xyXG59XHJcbmZ1bmN0aW9uIHdhdGNoUG9zdEVmZmVjdChlZmZlY3QsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBkb1dhdGNoKGVmZmVjdCwgbnVsbCwgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxyXG4gICAgICAgID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgeyBmbHVzaDogJ3Bvc3QnIH0pIDogeyBmbHVzaDogJ3Bvc3QnIH0pKTtcclxufVxyXG5mdW5jdGlvbiB3YXRjaFN5bmNFZmZlY3QoZWZmZWN0LCBvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gZG9XYXRjaChlZmZlY3QsIG51bGwsICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcclxuICAgICAgICA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgZmx1c2g6ICdzeW5jJyB9KSA6IHsgZmx1c2g6ICdzeW5jJyB9KSk7XHJcbn1cclxuLy8gaW5pdGlhbCB2YWx1ZSBmb3Igd2F0Y2hlcnMgdG8gdHJpZ2dlciBvbiB1bmRlZmluZWQgaW5pdGlhbCB2YWx1ZXNcclxuY29uc3QgSU5JVElBTF9XQVRDSEVSX1ZBTFVFID0ge307XHJcbi8vIGltcGxlbWVudGF0aW9uXHJcbmZ1bmN0aW9uIHdhdGNoKHNvdXJjZSwgY2IsIG9wdGlvbnMpIHtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWlzRnVuY3Rpb24oY2IpKSB7XHJcbiAgICAgICAgd2FybihgXFxgd2F0Y2goZm4sIG9wdGlvbnM/KVxcYCBzaWduYXR1cmUgaGFzIGJlZW4gbW92ZWQgdG8gYSBzZXBhcmF0ZSBBUEkuIGAgK1xyXG4gICAgICAgICAgICBgVXNlIFxcYHdhdGNoRWZmZWN0KGZuLCBvcHRpb25zPylcXGAgaW5zdGVhZC4gXFxgd2F0Y2hcXGAgbm93IG9ubHkgYCArXHJcbiAgICAgICAgICAgIGBzdXBwb3J0cyBcXGB3YXRjaChzb3VyY2UsIGNiLCBvcHRpb25zPykgc2lnbmF0dXJlLmApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRvV2F0Y2goc291cmNlLCBjYiwgb3B0aW9ucyk7XHJcbn1cclxuZnVuY3Rpb24gZG9XYXRjaChzb3VyY2UsIGNiLCB7IGltbWVkaWF0ZSwgZGVlcCwgZmx1c2gsIG9uVHJhY2ssIG9uVHJpZ2dlciB9ID0gRU1QVFlfT0JKKSB7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFjYikge1xyXG4gICAgICAgIGlmIChpbW1lZGlhdGUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB3YXJuKGB3YXRjaCgpIFwiaW1tZWRpYXRlXCIgb3B0aW9uIGlzIG9ubHkgcmVzcGVjdGVkIHdoZW4gdXNpbmcgdGhlIGAgK1xyXG4gICAgICAgICAgICAgICAgYHdhdGNoKHNvdXJjZSwgY2FsbGJhY2ssIG9wdGlvbnM/KSBzaWduYXR1cmUuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkZWVwICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgd2Fybihgd2F0Y2goKSBcImRlZXBcIiBvcHRpb24gaXMgb25seSByZXNwZWN0ZWQgd2hlbiB1c2luZyB0aGUgYCArXHJcbiAgICAgICAgICAgICAgICBgd2F0Y2goc291cmNlLCBjYWxsYmFjaywgb3B0aW9ucz8pIHNpZ25hdHVyZS5gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCB3YXJuSW52YWxpZFNvdXJjZSA9IChzKSA9PiB7XHJcbiAgICAgICAgd2FybihgSW52YWxpZCB3YXRjaCBzb3VyY2U6IGAsIHMsIGBBIHdhdGNoIHNvdXJjZSBjYW4gb25seSBiZSBhIGdldHRlci9lZmZlY3QgZnVuY3Rpb24sIGEgcmVmLCBgICtcclxuICAgICAgICAgICAgYGEgcmVhY3RpdmUgb2JqZWN0LCBvciBhbiBhcnJheSBvZiB0aGVzZSB0eXBlcy5gKTtcclxuICAgIH07XHJcbiAgICBjb25zdCBpbnN0YW5jZSA9IGN1cnJlbnRJbnN0YW5jZTtcclxuICAgIGxldCBnZXR0ZXI7XHJcbiAgICBsZXQgZm9yY2VUcmlnZ2VyID0gZmFsc2U7XHJcbiAgICBsZXQgaXNNdWx0aVNvdXJjZSA9IGZhbHNlO1xyXG4gICAgaWYgKGlzUmVmKHNvdXJjZSkpIHtcclxuICAgICAgICBnZXR0ZXIgPSAoKSA9PiBzb3VyY2UudmFsdWU7XHJcbiAgICAgICAgZm9yY2VUcmlnZ2VyID0gaXNTaGFsbG93JDEoc291cmNlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzUmVhY3RpdmUoc291cmNlKSkge1xyXG4gICAgICAgIGdldHRlciA9ICgpID0+IHNvdXJjZTtcclxuICAgICAgICBkZWVwID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzQXJyYXkoc291cmNlKSkge1xyXG4gICAgICAgIGlzTXVsdGlTb3VyY2UgPSB0cnVlO1xyXG4gICAgICAgIGZvcmNlVHJpZ2dlciA9IHNvdXJjZS5zb21lKHMgPT4gaXNSZWFjdGl2ZShzKSB8fCBpc1NoYWxsb3ckMShzKSk7XHJcbiAgICAgICAgZ2V0dGVyID0gKCkgPT4gc291cmNlLm1hcChzID0+IHtcclxuICAgICAgICAgICAgaWYgKGlzUmVmKHMpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcy52YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc1JlYWN0aXZlKHMpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhdmVyc2Uocyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNGdW5jdGlvbihzKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhzLCBpbnN0YW5jZSwgMiAvKiBXQVRDSF9HRVRURVIgKi8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHdhcm5JbnZhbGlkU291cmNlKHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKHNvdXJjZSkpIHtcclxuICAgICAgICBpZiAoY2IpIHtcclxuICAgICAgICAgICAgLy8gZ2V0dGVyIHdpdGggY2JcclxuICAgICAgICAgICAgZ2V0dGVyID0gKCkgPT4gY2FsbFdpdGhFcnJvckhhbmRsaW5nKHNvdXJjZSwgaW5zdGFuY2UsIDIgLyogV0FUQ0hfR0VUVEVSICovKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIG5vIGNiIC0+IHNpbXBsZSBlZmZlY3RcclxuICAgICAgICAgICAgZ2V0dGVyID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlICYmIGluc3RhbmNlLmlzVW5tb3VudGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGNsZWFudXApIHtcclxuICAgICAgICAgICAgICAgICAgICBjbGVhbnVwKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoc291cmNlLCBpbnN0YW5jZSwgMyAvKiBXQVRDSF9DQUxMQkFDSyAqLywgW29uQ2xlYW51cF0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGdldHRlciA9IE5PT1A7XHJcbiAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHdhcm5JbnZhbGlkU291cmNlKHNvdXJjZSk7XHJcbiAgICB9XHJcbiAgICBpZiAoY2IgJiYgZGVlcCkge1xyXG4gICAgICAgIGNvbnN0IGJhc2VHZXR0ZXIgPSBnZXR0ZXI7XHJcbiAgICAgICAgZ2V0dGVyID0gKCkgPT4gdHJhdmVyc2UoYmFzZUdldHRlcigpKTtcclxuICAgIH1cclxuICAgIGxldCBjbGVhbnVwO1xyXG4gICAgbGV0IG9uQ2xlYW51cCA9IChmbikgPT4ge1xyXG4gICAgICAgIGNsZWFudXAgPSBlZmZlY3Qub25TdG9wID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBjYWxsV2l0aEVycm9ySGFuZGxpbmcoZm4sIGluc3RhbmNlLCA0IC8qIFdBVENIX0NMRUFOVVAgKi8pO1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgLy8gaW4gU1NSIHRoZXJlIGlzIG5vIG5lZWQgdG8gc2V0dXAgYW4gYWN0dWFsIGVmZmVjdCwgYW5kIGl0IHNob3VsZCBiZSBub29wXHJcbiAgICAvLyB1bmxlc3MgaXQncyBlYWdlclxyXG4gICAgaWYgKGlzSW5TU1JDb21wb25lbnRTZXR1cCkge1xyXG4gICAgICAgIC8vIHdlIHdpbGwgYWxzbyBub3QgY2FsbCB0aGUgaW52YWxpZGF0ZSBjYWxsYmFjayAoKyBydW5uZXIgaXMgbm90IHNldCB1cClcclxuICAgICAgICBvbkNsZWFudXAgPSBOT09QO1xyXG4gICAgICAgIGlmICghY2IpIHtcclxuICAgICAgICAgICAgZ2V0dGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGltbWVkaWF0ZSkge1xyXG4gICAgICAgICAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhjYiwgaW5zdGFuY2UsIDMgLyogV0FUQ0hfQ0FMTEJBQ0sgKi8sIFtcclxuICAgICAgICAgICAgICAgIGdldHRlcigpLFxyXG4gICAgICAgICAgICAgICAgaXNNdWx0aVNvdXJjZSA/IFtdIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgb25DbGVhbnVwXHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gTk9PUDtcclxuICAgIH1cclxuICAgIGxldCBvbGRWYWx1ZSA9IGlzTXVsdGlTb3VyY2UgPyBbXSA6IElOSVRJQUxfV0FUQ0hFUl9WQUxVRTtcclxuICAgIGNvbnN0IGpvYiA9ICgpID0+IHtcclxuICAgICAgICBpZiAoIWVmZmVjdC5hY3RpdmUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2IpIHtcclxuICAgICAgICAgICAgLy8gd2F0Y2goc291cmNlLCBjYilcclxuICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBlZmZlY3QucnVuKCk7XHJcbiAgICAgICAgICAgIGlmIChkZWVwIHx8XHJcbiAgICAgICAgICAgICAgICBmb3JjZVRyaWdnZXIgfHxcclxuICAgICAgICAgICAgICAgIChpc011bHRpU291cmNlXHJcbiAgICAgICAgICAgICAgICAgICAgPyBuZXdWYWx1ZS5zb21lKCh2LCBpKSA9PiBoYXNDaGFuZ2VkKHYsIG9sZFZhbHVlW2ldKSlcclxuICAgICAgICAgICAgICAgICAgICA6IGhhc0NoYW5nZWQobmV3VmFsdWUsIG9sZFZhbHVlKSkgfHxcclxuICAgICAgICAgICAgICAgIChmYWxzZSAgKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gY2xlYW51cCBiZWZvcmUgcnVubmluZyBjYiBhZ2FpblxyXG4gICAgICAgICAgICAgICAgaWYgKGNsZWFudXApIHtcclxuICAgICAgICAgICAgICAgICAgICBjbGVhbnVwKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhjYiwgaW5zdGFuY2UsIDMgLyogV0FUQ0hfQ0FMTEJBQ0sgKi8sIFtcclxuICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAvLyBwYXNzIHVuZGVmaW5lZCBhcyB0aGUgb2xkIHZhbHVlIHdoZW4gaXQncyBjaGFuZ2VkIGZvciB0aGUgZmlyc3QgdGltZVxyXG4gICAgICAgICAgICAgICAgICAgIG9sZFZhbHVlID09PSBJTklUSUFMX1dBVENIRVJfVkFMVUUgPyB1bmRlZmluZWQgOiBvbGRWYWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICBvbkNsZWFudXBcclxuICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICAgICAgb2xkVmFsdWUgPSBuZXdWYWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gd2F0Y2hFZmZlY3RcclxuICAgICAgICAgICAgZWZmZWN0LnJ1bigpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBpbXBvcnRhbnQ6IG1hcmsgdGhlIGpvYiBhcyBhIHdhdGNoZXIgY2FsbGJhY2sgc28gdGhhdCBzY2hlZHVsZXIga25vd3NcclxuICAgIC8vIGl0IGlzIGFsbG93ZWQgdG8gc2VsZi10cmlnZ2VyICgjMTcyNylcclxuICAgIGpvYi5hbGxvd1JlY3Vyc2UgPSAhIWNiO1xyXG4gICAgbGV0IHNjaGVkdWxlcjtcclxuICAgIGlmIChmbHVzaCA9PT0gJ3N5bmMnKSB7XHJcbiAgICAgICAgc2NoZWR1bGVyID0gam9iOyAvLyB0aGUgc2NoZWR1bGVyIGZ1bmN0aW9uIGdldHMgY2FsbGVkIGRpcmVjdGx5XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChmbHVzaCA9PT0gJ3Bvc3QnKSB7XHJcbiAgICAgICAgc2NoZWR1bGVyID0gKCkgPT4gcXVldWVQb3N0UmVuZGVyRWZmZWN0KGpvYiwgaW5zdGFuY2UgJiYgaW5zdGFuY2Uuc3VzcGVuc2UpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gZGVmYXVsdDogJ3ByZSdcclxuICAgICAgICBzY2hlZHVsZXIgPSAoKSA9PiBxdWV1ZVByZUZsdXNoQ2Ioam9iKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGVmZmVjdCA9IG5ldyBSZWFjdGl2ZUVmZmVjdChnZXR0ZXIsIHNjaGVkdWxlcik7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgZWZmZWN0Lm9uVHJhY2sgPSBvblRyYWNrO1xyXG4gICAgICAgIGVmZmVjdC5vblRyaWdnZXIgPSBvblRyaWdnZXI7XHJcbiAgICB9XHJcbiAgICAvLyBpbml0aWFsIHJ1blxyXG4gICAgaWYgKGNiKSB7XHJcbiAgICAgICAgaWYgKGltbWVkaWF0ZSkge1xyXG4gICAgICAgICAgICBqb2IoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG9sZFZhbHVlID0gZWZmZWN0LnJ1bigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGZsdXNoID09PSAncG9zdCcpIHtcclxuICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoZWZmZWN0LnJ1bi5iaW5kKGVmZmVjdCksIGluc3RhbmNlICYmIGluc3RhbmNlLnN1c3BlbnNlKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGVmZmVjdC5ydW4oKTtcclxuICAgIH1cclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgZWZmZWN0LnN0b3AoKTtcclxuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgaW5zdGFuY2Uuc2NvcGUpIHtcclxuICAgICAgICAgICAgcmVtb3ZlKGluc3RhbmNlLnNjb3BlLmVmZmVjdHMsIGVmZmVjdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG4vLyB0aGlzLiR3YXRjaFxyXG5mdW5jdGlvbiBpbnN0YW5jZVdhdGNoKHNvdXJjZSwgdmFsdWUsIG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IHB1YmxpY1RoaXMgPSB0aGlzLnByb3h5O1xyXG4gICAgY29uc3QgZ2V0dGVyID0gaXNTdHJpbmcoc291cmNlKVxyXG4gICAgICAgID8gc291cmNlLmluY2x1ZGVzKCcuJylcclxuICAgICAgICAgICAgPyBjcmVhdGVQYXRoR2V0dGVyKHB1YmxpY1RoaXMsIHNvdXJjZSlcclxuICAgICAgICAgICAgOiAoKSA9PiBwdWJsaWNUaGlzW3NvdXJjZV1cclxuICAgICAgICA6IHNvdXJjZS5iaW5kKHB1YmxpY1RoaXMsIHB1YmxpY1RoaXMpO1xyXG4gICAgbGV0IGNiO1xyXG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XHJcbiAgICAgICAgY2IgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNiID0gdmFsdWUuaGFuZGxlcjtcclxuICAgICAgICBvcHRpb25zID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBjb25zdCBjdXIgPSBjdXJyZW50SW5zdGFuY2U7XHJcbiAgICBzZXRDdXJyZW50SW5zdGFuY2UodGhpcyk7XHJcbiAgICBjb25zdCByZXMgPSBkb1dhdGNoKGdldHRlciwgY2IuYmluZChwdWJsaWNUaGlzKSwgb3B0aW9ucyk7XHJcbiAgICBpZiAoY3VyKSB7XHJcbiAgICAgICAgc2V0Q3VycmVudEluc3RhbmNlKGN1cik7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB1bnNldEN1cnJlbnRJbnN0YW5jZSgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVQYXRoR2V0dGVyKGN0eCwgcGF0aCkge1xyXG4gICAgY29uc3Qgc2VnbWVudHMgPSBwYXRoLnNwbGl0KCcuJyk7XHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgIGxldCBjdXIgPSBjdHg7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGggJiYgY3VyOyBpKyspIHtcclxuICAgICAgICAgICAgY3VyID0gY3VyW3NlZ21lbnRzW2ldXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGN1cjtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gdHJhdmVyc2UodmFsdWUsIHNlZW4pIHtcclxuICAgIGlmICghaXNPYmplY3QodmFsdWUpIHx8IHZhbHVlW1wiX192X3NraXBcIiAvKiBTS0lQICovXSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICAgIHNlZW4gPSBzZWVuIHx8IG5ldyBTZXQoKTtcclxuICAgIGlmIChzZWVuLmhhcyh2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBzZWVuLmFkZCh2YWx1ZSk7XHJcbiAgICBpZiAoaXNSZWYodmFsdWUpKSB7XHJcbiAgICAgICAgdHJhdmVyc2UodmFsdWUudmFsdWUsIHNlZW4pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRyYXZlcnNlKHZhbHVlW2ldLCBzZWVuKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc1NldCh2YWx1ZSkgfHwgaXNNYXAodmFsdWUpKSB7XHJcbiAgICAgICAgdmFsdWUuZm9yRWFjaCgodikgPT4ge1xyXG4gICAgICAgICAgICB0cmF2ZXJzZSh2LCBzZWVuKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodmFsdWUpKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWUpIHtcclxuICAgICAgICAgICAgdHJhdmVyc2UodmFsdWVba2V5XSwgc2Vlbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59XG5cbmZ1bmN0aW9uIHVzZVRyYW5zaXRpb25TdGF0ZSgpIHtcclxuICAgIGNvbnN0IHN0YXRlID0ge1xyXG4gICAgICAgIGlzTW91bnRlZDogZmFsc2UsXHJcbiAgICAgICAgaXNMZWF2aW5nOiBmYWxzZSxcclxuICAgICAgICBpc1VubW91bnRpbmc6IGZhbHNlLFxyXG4gICAgICAgIGxlYXZpbmdWTm9kZXM6IG5ldyBNYXAoKVxyXG4gICAgfTtcclxuICAgIG9uTW91bnRlZCgoKSA9PiB7XHJcbiAgICAgICAgc3RhdGUuaXNNb3VudGVkID0gdHJ1ZTtcclxuICAgIH0pO1xyXG4gICAgb25CZWZvcmVVbm1vdW50KCgpID0+IHtcclxuICAgICAgICBzdGF0ZS5pc1VubW91bnRpbmcgPSB0cnVlO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gc3RhdGU7XHJcbn1cclxuY29uc3QgVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IgPSBbRnVuY3Rpb24sIEFycmF5XTtcclxuY29uc3QgQmFzZVRyYW5zaXRpb25JbXBsID0ge1xyXG4gICAgbmFtZTogYEJhc2VUcmFuc2l0aW9uYCxcclxuICAgIHByb3BzOiB7XHJcbiAgICAgICAgbW9kZTogU3RyaW5nLFxyXG4gICAgICAgIGFwcGVhcjogQm9vbGVhbixcclxuICAgICAgICBwZXJzaXN0ZWQ6IEJvb2xlYW4sXHJcbiAgICAgICAgLy8gZW50ZXJcclxuICAgICAgICBvbkJlZm9yZUVudGVyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcclxuICAgICAgICBvbkVudGVyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcclxuICAgICAgICBvbkFmdGVyRW50ZXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxyXG4gICAgICAgIG9uRW50ZXJDYW5jZWxsZWQ6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxyXG4gICAgICAgIC8vIGxlYXZlXHJcbiAgICAgICAgb25CZWZvcmVMZWF2ZTogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXHJcbiAgICAgICAgb25MZWF2ZTogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXHJcbiAgICAgICAgb25BZnRlckxlYXZlOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcclxuICAgICAgICBvbkxlYXZlQ2FuY2VsbGVkOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcclxuICAgICAgICAvLyBhcHBlYXJcclxuICAgICAgICBvbkJlZm9yZUFwcGVhcjogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXHJcbiAgICAgICAgb25BcHBlYXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxyXG4gICAgICAgIG9uQWZ0ZXJBcHBlYXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxyXG4gICAgICAgIG9uQXBwZWFyQ2FuY2VsbGVkOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvclxyXG4gICAgfSxcclxuICAgIHNldHVwKHByb3BzLCB7IHNsb3RzIH0pIHtcclxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xyXG4gICAgICAgIGNvbnN0IHN0YXRlID0gdXNlVHJhbnNpdGlvblN0YXRlKCk7XHJcbiAgICAgICAgbGV0IHByZXZUcmFuc2l0aW9uS2V5O1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gc2xvdHMuZGVmYXVsdCAmJiBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4oc2xvdHMuZGVmYXVsdCgpLCB0cnVlKTtcclxuICAgICAgICAgICAgaWYgKCFjaGlsZHJlbiB8fCAhY2hpbGRyZW4ubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGNoaWxkID0gY2hpbGRyZW5bMF07XHJcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgaGFzRm91bmQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIC8vIGxvY2F0ZSBmaXJzdCBub24tY29tbWVudCBjaGlsZFxyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjIG9mIGNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMudHlwZSAhPT0gQ29tbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGhhc0ZvdW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3YXJuIG1vcmUgdGhhbiBvbmUgbm9uLWNvbW1lbnQgY2hpbGRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oJzx0cmFuc2l0aW9uPiBjYW4gb25seSBiZSB1c2VkIG9uIGEgc2luZ2xlIGVsZW1lbnQgb3IgY29tcG9uZW50LiAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnVXNlIDx0cmFuc2l0aW9uLWdyb3VwPiBmb3IgbGlzdHMuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IGM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0ZvdW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gdGhlcmUncyBubyBuZWVkIHRvIHRyYWNrIHJlYWN0aXZpdHkgZm9yIHRoZXNlIHByb3BzIHNvIHVzZSB0aGUgcmF3XHJcbiAgICAgICAgICAgIC8vIHByb3BzIGZvciBhIGJpdCBiZXR0ZXIgcGVyZlxyXG4gICAgICAgICAgICBjb25zdCByYXdQcm9wcyA9IHRvUmF3KHByb3BzKTtcclxuICAgICAgICAgICAgY29uc3QgeyBtb2RlIH0gPSByYXdQcm9wcztcclxuICAgICAgICAgICAgLy8gY2hlY2sgbW9kZVxyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgICAgICBtb2RlICYmXHJcbiAgICAgICAgICAgICAgICBtb2RlICE9PSAnaW4tb3V0JyAmJlxyXG4gICAgICAgICAgICAgICAgbW9kZSAhPT0gJ291dC1pbicgJiZcclxuICAgICAgICAgICAgICAgIG1vZGUgIT09ICdkZWZhdWx0Jykge1xyXG4gICAgICAgICAgICAgICAgd2FybihgaW52YWxpZCA8dHJhbnNpdGlvbj4gbW9kZTogJHttb2RlfWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzdGF0ZS5pc0xlYXZpbmcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbXB0eVBsYWNlaG9sZGVyKGNoaWxkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBpbiB0aGUgY2FzZSBvZiA8dHJhbnNpdGlvbj48a2VlcC1hbGl2ZS8+PC90cmFuc2l0aW9uPiwgd2UgbmVlZCB0b1xyXG4gICAgICAgICAgICAvLyBjb21wYXJlIHRoZSB0eXBlIG9mIHRoZSBrZXB0LWFsaXZlIGNoaWxkcmVuLlxyXG4gICAgICAgICAgICBjb25zdCBpbm5lckNoaWxkID0gZ2V0S2VlcEFsaXZlQ2hpbGQoY2hpbGQpO1xyXG4gICAgICAgICAgICBpZiAoIWlubmVyQ2hpbGQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbXB0eVBsYWNlaG9sZGVyKGNoaWxkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBlbnRlckhvb2tzID0gcmVzb2x2ZVRyYW5zaXRpb25Ib29rcyhpbm5lckNoaWxkLCByYXdQcm9wcywgc3RhdGUsIGluc3RhbmNlKTtcclxuICAgICAgICAgICAgc2V0VHJhbnNpdGlvbkhvb2tzKGlubmVyQ2hpbGQsIGVudGVySG9va3MpO1xyXG4gICAgICAgICAgICBjb25zdCBvbGRDaGlsZCA9IGluc3RhbmNlLnN1YlRyZWU7XHJcbiAgICAgICAgICAgIGNvbnN0IG9sZElubmVyQ2hpbGQgPSBvbGRDaGlsZCAmJiBnZXRLZWVwQWxpdmVDaGlsZChvbGRDaGlsZCk7XHJcbiAgICAgICAgICAgIGxldCB0cmFuc2l0aW9uS2V5Q2hhbmdlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBjb25zdCB7IGdldFRyYW5zaXRpb25LZXkgfSA9IGlubmVyQ2hpbGQudHlwZTtcclxuICAgICAgICAgICAgaWYgKGdldFRyYW5zaXRpb25LZXkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGdldFRyYW5zaXRpb25LZXkoKTtcclxuICAgICAgICAgICAgICAgIGlmIChwcmV2VHJhbnNpdGlvbktleSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJldlRyYW5zaXRpb25LZXkgPSBrZXk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09IHByZXZUcmFuc2l0aW9uS2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJldlRyYW5zaXRpb25LZXkgPSBrZXk7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbktleUNoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGhhbmRsZSBtb2RlXHJcbiAgICAgICAgICAgIGlmIChvbGRJbm5lckNoaWxkICYmXHJcbiAgICAgICAgICAgICAgICBvbGRJbm5lckNoaWxkLnR5cGUgIT09IENvbW1lbnQgJiZcclxuICAgICAgICAgICAgICAgICghaXNTYW1lVk5vZGVUeXBlKGlubmVyQ2hpbGQsIG9sZElubmVyQ2hpbGQpIHx8IHRyYW5zaXRpb25LZXlDaGFuZ2VkKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbGVhdmluZ0hvb2tzID0gcmVzb2x2ZVRyYW5zaXRpb25Ib29rcyhvbGRJbm5lckNoaWxkLCByYXdQcm9wcywgc3RhdGUsIGluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBvbGQgdHJlZSdzIGhvb2tzIGluIGNhc2Ugb2YgZHluYW1pYyB0cmFuc2l0aW9uXHJcbiAgICAgICAgICAgICAgICBzZXRUcmFuc2l0aW9uSG9va3Mob2xkSW5uZXJDaGlsZCwgbGVhdmluZ0hvb2tzKTtcclxuICAgICAgICAgICAgICAgIC8vIHN3aXRjaGluZyBiZXR3ZWVuIGRpZmZlcmVudCB2aWV3c1xyXG4gICAgICAgICAgICAgICAgaWYgKG1vZGUgPT09ICdvdXQtaW4nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuaXNMZWF2aW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm4gcGxhY2Vob2xkZXIgbm9kZSBhbmQgcXVldWUgdXBkYXRlIHdoZW4gbGVhdmUgZmluaXNoZXNcclxuICAgICAgICAgICAgICAgICAgICBsZWF2aW5nSG9va3MuYWZ0ZXJMZWF2ZSA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuaXNMZWF2aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVtcHR5UGxhY2Vob2xkZXIoY2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobW9kZSA9PT0gJ2luLW91dCcgJiYgaW5uZXJDaGlsZC50eXBlICE9PSBDb21tZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVhdmluZ0hvb2tzLmRlbGF5TGVhdmUgPSAoZWwsIGVhcmx5UmVtb3ZlLCBkZWxheWVkTGVhdmUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVhdmluZ1ZOb2Rlc0NhY2hlID0gZ2V0TGVhdmluZ05vZGVzRm9yVHlwZShzdGF0ZSwgb2xkSW5uZXJDaGlsZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlYXZpbmdWTm9kZXNDYWNoZVtTdHJpbmcob2xkSW5uZXJDaGlsZC5rZXkpXSA9IG9sZElubmVyQ2hpbGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVhcmx5IHJlbW92YWwgY2FsbGJhY2tcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWwuX2xlYXZlQ2IgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlYXJseVJlbW92ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwuX2xlYXZlQ2IgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZW50ZXJIb29rcy5kZWxheWVkTGVhdmU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudGVySG9va3MuZGVsYXllZExlYXZlID0gZGVsYXllZExlYXZlO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNoaWxkO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn07XHJcbi8vIGV4cG9ydCB0aGUgcHVibGljIHR5cGUgZm9yIGgvdHN4IGluZmVyZW5jZVxyXG4vLyBhbHNvIHRvIGF2b2lkIGlubGluZSBpbXBvcnQoKSBpbiBnZW5lcmF0ZWQgZC50cyBmaWxlc1xyXG5jb25zdCBCYXNlVHJhbnNpdGlvbiA9IEJhc2VUcmFuc2l0aW9uSW1wbDtcclxuZnVuY3Rpb24gZ2V0TGVhdmluZ05vZGVzRm9yVHlwZShzdGF0ZSwgdm5vZGUpIHtcclxuICAgIGNvbnN0IHsgbGVhdmluZ1ZOb2RlcyB9ID0gc3RhdGU7XHJcbiAgICBsZXQgbGVhdmluZ1ZOb2Rlc0NhY2hlID0gbGVhdmluZ1ZOb2Rlcy5nZXQodm5vZGUudHlwZSk7XHJcbiAgICBpZiAoIWxlYXZpbmdWTm9kZXNDYWNoZSkge1xyXG4gICAgICAgIGxlYXZpbmdWTm9kZXNDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICAgICAgbGVhdmluZ1ZOb2Rlcy5zZXQodm5vZGUudHlwZSwgbGVhdmluZ1ZOb2Rlc0NhY2hlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBsZWF2aW5nVk5vZGVzQ2FjaGU7XHJcbn1cclxuLy8gVGhlIHRyYW5zaXRpb24gaG9va3MgYXJlIGF0dGFjaGVkIHRvIHRoZSB2bm9kZSBhcyB2bm9kZS50cmFuc2l0aW9uXHJcbi8vIGFuZCB3aWxsIGJlIGNhbGxlZCBhdCBhcHByb3ByaWF0ZSB0aW1pbmcgaW4gdGhlIHJlbmRlcmVyLlxyXG5mdW5jdGlvbiByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKHZub2RlLCBwcm9wcywgc3RhdGUsIGluc3RhbmNlKSB7XHJcbiAgICBjb25zdCB7IGFwcGVhciwgbW9kZSwgcGVyc2lzdGVkID0gZmFsc2UsIG9uQmVmb3JlRW50ZXIsIG9uRW50ZXIsIG9uQWZ0ZXJFbnRlciwgb25FbnRlckNhbmNlbGxlZCwgb25CZWZvcmVMZWF2ZSwgb25MZWF2ZSwgb25BZnRlckxlYXZlLCBvbkxlYXZlQ2FuY2VsbGVkLCBvbkJlZm9yZUFwcGVhciwgb25BcHBlYXIsIG9uQWZ0ZXJBcHBlYXIsIG9uQXBwZWFyQ2FuY2VsbGVkIH0gPSBwcm9wcztcclxuICAgIGNvbnN0IGtleSA9IFN0cmluZyh2bm9kZS5rZXkpO1xyXG4gICAgY29uc3QgbGVhdmluZ1ZOb2Rlc0NhY2hlID0gZ2V0TGVhdmluZ05vZGVzRm9yVHlwZShzdGF0ZSwgdm5vZGUpO1xyXG4gICAgY29uc3QgY2FsbEhvb2sgPSAoaG9vaywgYXJncykgPT4ge1xyXG4gICAgICAgIGhvb2sgJiZcclxuICAgICAgICAgICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoaG9vaywgaW5zdGFuY2UsIDkgLyogVFJBTlNJVElPTl9IT09LICovLCBhcmdzKTtcclxuICAgIH07XHJcbiAgICBjb25zdCBjYWxsQXN5bmNIb29rID0gKGhvb2ssIGFyZ3MpID0+IHtcclxuICAgICAgICBjb25zdCBkb25lID0gYXJnc1sxXTtcclxuICAgICAgICBjYWxsSG9vayhob29rLCBhcmdzKTtcclxuICAgICAgICBpZiAoaXNBcnJheShob29rKSkge1xyXG4gICAgICAgICAgICBpZiAoaG9vay5ldmVyeShob29rID0+IGhvb2subGVuZ3RoIDw9IDEpKVxyXG4gICAgICAgICAgICAgICAgZG9uZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChob29rLmxlbmd0aCA8PSAxKSB7XHJcbiAgICAgICAgICAgIGRvbmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgaG9va3MgPSB7XHJcbiAgICAgICAgbW9kZSxcclxuICAgICAgICBwZXJzaXN0ZWQsXHJcbiAgICAgICAgYmVmb3JlRW50ZXIoZWwpIHtcclxuICAgICAgICAgICAgbGV0IGhvb2sgPSBvbkJlZm9yZUVudGVyO1xyXG4gICAgICAgICAgICBpZiAoIXN0YXRlLmlzTW91bnRlZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFwcGVhcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGhvb2sgPSBvbkJlZm9yZUFwcGVhciB8fCBvbkJlZm9yZUVudGVyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGZvciBzYW1lIGVsZW1lbnQgKHYtc2hvdylcclxuICAgICAgICAgICAgaWYgKGVsLl9sZWF2ZUNiKSB7XHJcbiAgICAgICAgICAgICAgICBlbC5fbGVhdmVDYih0cnVlIC8qIGNhbmNlbGxlZCAqLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gZm9yIHRvZ2dsZWQgZWxlbWVudCB3aXRoIHNhbWUga2V5ICh2LWlmKVxyXG4gICAgICAgICAgICBjb25zdCBsZWF2aW5nVk5vZGUgPSBsZWF2aW5nVk5vZGVzQ2FjaGVba2V5XTtcclxuICAgICAgICAgICAgaWYgKGxlYXZpbmdWTm9kZSAmJlxyXG4gICAgICAgICAgICAgICAgaXNTYW1lVk5vZGVUeXBlKHZub2RlLCBsZWF2aW5nVk5vZGUpICYmXHJcbiAgICAgICAgICAgICAgICBsZWF2aW5nVk5vZGUuZWwuX2xlYXZlQ2IpIHtcclxuICAgICAgICAgICAgICAgIC8vIGZvcmNlIGVhcmx5IHJlbW92YWwgKG5vdCBjYW5jZWxsZWQpXHJcbiAgICAgICAgICAgICAgICBsZWF2aW5nVk5vZGUuZWwuX2xlYXZlQ2IoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYWxsSG9vayhob29rLCBbZWxdKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudGVyKGVsKSB7XHJcbiAgICAgICAgICAgIGxldCBob29rID0gb25FbnRlcjtcclxuICAgICAgICAgICAgbGV0IGFmdGVySG9vayA9IG9uQWZ0ZXJFbnRlcjtcclxuICAgICAgICAgICAgbGV0IGNhbmNlbEhvb2sgPSBvbkVudGVyQ2FuY2VsbGVkO1xyXG4gICAgICAgICAgICBpZiAoIXN0YXRlLmlzTW91bnRlZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFwcGVhcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGhvb2sgPSBvbkFwcGVhciB8fCBvbkVudGVyO1xyXG4gICAgICAgICAgICAgICAgICAgIGFmdGVySG9vayA9IG9uQWZ0ZXJBcHBlYXIgfHwgb25BZnRlckVudGVyO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbEhvb2sgPSBvbkFwcGVhckNhbmNlbGxlZCB8fCBvbkVudGVyQ2FuY2VsbGVkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgY29uc3QgZG9uZSA9IChlbC5fZW50ZXJDYiA9IChjYW5jZWxsZWQpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChjYWxsZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgY2FsbGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmIChjYW5jZWxsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsSG9vayhjYW5jZWxIb29rLCBbZWxdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxIb29rKGFmdGVySG9vaywgW2VsXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaG9va3MuZGVsYXllZExlYXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaG9va3MuZGVsYXllZExlYXZlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbC5fZW50ZXJDYiA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChob29rKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsQXN5bmNIb29rKGhvb2ssIFtlbCwgZG9uZV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZG9uZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBsZWF2ZShlbCwgcmVtb3ZlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IFN0cmluZyh2bm9kZS5rZXkpO1xyXG4gICAgICAgICAgICBpZiAoZWwuX2VudGVyQ2IpIHtcclxuICAgICAgICAgICAgICAgIGVsLl9lbnRlckNiKHRydWUgLyogY2FuY2VsbGVkICovKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc3RhdGUuaXNVbm1vdW50aW5nKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FsbEhvb2sob25CZWZvcmVMZWF2ZSwgW2VsXSk7XHJcbiAgICAgICAgICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgY29uc3QgZG9uZSA9IChlbC5fbGVhdmVDYiA9IChjYW5jZWxsZWQpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChjYWxsZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgY2FsbGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHJlbW92ZSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhbmNlbGxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxIb29rKG9uTGVhdmVDYW5jZWxsZWQsIFtlbF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbEhvb2sob25BZnRlckxlYXZlLCBbZWxdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsLl9sZWF2ZUNiID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxlYXZpbmdWTm9kZXNDYWNoZVtrZXldID09PSB2bm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBsZWF2aW5nVk5vZGVzQ2FjaGVba2V5XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGxlYXZpbmdWTm9kZXNDYWNoZVtrZXldID0gdm5vZGU7XHJcbiAgICAgICAgICAgIGlmIChvbkxlYXZlKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsQXN5bmNIb29rKG9uTGVhdmUsIFtlbCwgZG9uZV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZG9uZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjbG9uZSh2bm9kZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZVRyYW5zaXRpb25Ib29rcyh2bm9kZSwgcHJvcHMsIHN0YXRlLCBpbnN0YW5jZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBob29rcztcclxufVxyXG4vLyB0aGUgcGxhY2Vob2xkZXIgcmVhbGx5IG9ubHkgaGFuZGxlcyBvbmUgc3BlY2lhbCBjYXNlOiBLZWVwQWxpdmVcclxuLy8gaW4gdGhlIGNhc2Ugb2YgYSBLZWVwQWxpdmUgaW4gYSBsZWF2ZSBwaGFzZSB3ZSBuZWVkIHRvIHJldHVybiBhIEtlZXBBbGl2ZVxyXG4vLyBwbGFjZWhvbGRlciB3aXRoIGVtcHR5IGNvbnRlbnQgdG8gYXZvaWQgdGhlIEtlZXBBbGl2ZSBpbnN0YW5jZSBmcm9tIGJlaW5nXHJcbi8vIHVubW91bnRlZC5cclxuZnVuY3Rpb24gZW1wdHlQbGFjZWhvbGRlcih2bm9kZSkge1xyXG4gICAgaWYgKGlzS2VlcEFsaXZlKHZub2RlKSkge1xyXG4gICAgICAgIHZub2RlID0gY2xvbmVWTm9kZSh2bm9kZSk7XHJcbiAgICAgICAgdm5vZGUuY2hpbGRyZW4gPSBudWxsO1xyXG4gICAgICAgIHJldHVybiB2bm9kZTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRLZWVwQWxpdmVDaGlsZCh2bm9kZSkge1xyXG4gICAgcmV0dXJuIGlzS2VlcEFsaXZlKHZub2RlKVxyXG4gICAgICAgID8gdm5vZGUuY2hpbGRyZW5cclxuICAgICAgICAgICAgPyB2bm9kZS5jaGlsZHJlblswXVxyXG4gICAgICAgICAgICA6IHVuZGVmaW5lZFxyXG4gICAgICAgIDogdm5vZGU7XHJcbn1cclxuZnVuY3Rpb24gc2V0VHJhbnNpdGlvbkhvb2tzKHZub2RlLCBob29rcykge1xyXG4gICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDYgLyogQ09NUE9ORU5UICovICYmIHZub2RlLmNvbXBvbmVudCkge1xyXG4gICAgICAgIHNldFRyYW5zaXRpb25Ib29rcyh2bm9kZS5jb21wb25lbnQuc3ViVHJlZSwgaG9va3MpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodm5vZGUuc2hhcGVGbGFnICYgMTI4IC8qIFNVU1BFTlNFICovKSB7XHJcbiAgICAgICAgdm5vZGUuc3NDb250ZW50LnRyYW5zaXRpb24gPSBob29rcy5jbG9uZSh2bm9kZS5zc0NvbnRlbnQpO1xyXG4gICAgICAgIHZub2RlLnNzRmFsbGJhY2sudHJhbnNpdGlvbiA9IGhvb2tzLmNsb25lKHZub2RlLnNzRmFsbGJhY2spO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdm5vZGUudHJhbnNpdGlvbiA9IGhvb2tzO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbihjaGlsZHJlbiwga2VlcENvbW1lbnQgPSBmYWxzZSwgcGFyZW50S2V5KSB7XHJcbiAgICBsZXQgcmV0ID0gW107XHJcbiAgICBsZXQga2V5ZWRGcmFnbWVudENvdW50ID0gMDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBsZXQgY2hpbGQgPSBjaGlsZHJlbltpXTtcclxuICAgICAgICAvLyAjNTM2MCBpbmhlcml0IHBhcmVudCBrZXkgaW4gY2FzZSBvZiA8dGVtcGxhdGUgdi1mb3I+XHJcbiAgICAgICAgY29uc3Qga2V5ID0gcGFyZW50S2V5ID09IG51bGxcclxuICAgICAgICAgICAgPyBjaGlsZC5rZXlcclxuICAgICAgICAgICAgOiBTdHJpbmcocGFyZW50S2V5KSArIFN0cmluZyhjaGlsZC5rZXkgIT0gbnVsbCA/IGNoaWxkLmtleSA6IGkpO1xyXG4gICAgICAgIC8vIGhhbmRsZSBmcmFnbWVudCBjaGlsZHJlbiBjYXNlLCBlLmcuIHYtZm9yXHJcbiAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IEZyYWdtZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZC5wYXRjaEZsYWcgJiAxMjggLyogS0VZRURfRlJBR01FTlQgKi8pXHJcbiAgICAgICAgICAgICAgICBrZXllZEZyYWdtZW50Q291bnQrKztcclxuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4oY2hpbGQuY2hpbGRyZW4sIGtlZXBDb21tZW50LCBrZXkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY29tbWVudCBwbGFjZWhvbGRlcnMgc2hvdWxkIGJlIHNraXBwZWQsIGUuZy4gdi1pZlxyXG4gICAgICAgIGVsc2UgaWYgKGtlZXBDb21tZW50IHx8IGNoaWxkLnR5cGUgIT09IENvbW1lbnQpIHtcclxuICAgICAgICAgICAgcmV0LnB1c2goa2V5ICE9IG51bGwgPyBjbG9uZVZOb2RlKGNoaWxkLCB7IGtleSB9KSA6IGNoaWxkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyAjMTEyNiBpZiBhIHRyYW5zaXRpb24gY2hpbGRyZW4gbGlzdCBjb250YWlucyBtdWx0aXBsZSBzdWIgZnJhZ21lbnRzLCB0aGVzZVxyXG4gICAgLy8gZnJhZ21lbnRzIHdpbGwgYmUgbWVyZ2VkIGludG8gYSBmbGF0IGNoaWxkcmVuIGFycmF5LiBTaW5jZSBlYWNoIHYtZm9yXHJcbiAgICAvLyBmcmFnbWVudCBtYXkgY29udGFpbiBkaWZmZXJlbnQgc3RhdGljIGJpbmRpbmdzIGluc2lkZSwgd2UgbmVlZCB0byBkZS1vcFxyXG4gICAgLy8gdGhlc2UgY2hpbGRyZW4gdG8gZm9yY2UgZnVsbCBkaWZmcyB0byBlbnN1cmUgY29ycmVjdCBiZWhhdmlvci5cclxuICAgIGlmIChrZXllZEZyYWdtZW50Q291bnQgPiAxKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgcmV0W2ldLnBhdGNoRmxhZyA9IC0yIC8qIEJBSUwgKi87XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJldDtcclxufVxuXG4vLyBpbXBsZW1lbnRhdGlvbiwgY2xvc2UgdG8gbm8tb3BcclxuZnVuY3Rpb24gZGVmaW5lQ29tcG9uZW50KG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBpc0Z1bmN0aW9uKG9wdGlvbnMpID8geyBzZXR1cDogb3B0aW9ucywgbmFtZTogb3B0aW9ucy5uYW1lIH0gOiBvcHRpb25zO1xyXG59XG5cbmNvbnN0IGlzQXN5bmNXcmFwcGVyID0gKGkpID0+ICEhaS50eXBlLl9fYXN5bmNMb2FkZXI7XHJcbmZ1bmN0aW9uIGRlZmluZUFzeW5jQ29tcG9uZW50KHNvdXJjZSkge1xyXG4gICAgaWYgKGlzRnVuY3Rpb24oc291cmNlKSkge1xyXG4gICAgICAgIHNvdXJjZSA9IHsgbG9hZGVyOiBzb3VyY2UgfTtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgbG9hZGVyLCBsb2FkaW5nQ29tcG9uZW50LCBlcnJvckNvbXBvbmVudCwgZGVsYXkgPSAyMDAsIHRpbWVvdXQsIC8vIHVuZGVmaW5lZCA9IG5ldmVyIHRpbWVzIG91dFxyXG4gICAgc3VzcGVuc2libGUgPSB0cnVlLCBvbkVycm9yOiB1c2VyT25FcnJvciB9ID0gc291cmNlO1xyXG4gICAgbGV0IHBlbmRpbmdSZXF1ZXN0ID0gbnVsbDtcclxuICAgIGxldCByZXNvbHZlZENvbXA7XHJcbiAgICBsZXQgcmV0cmllcyA9IDA7XHJcbiAgICBjb25zdCByZXRyeSA9ICgpID0+IHtcclxuICAgICAgICByZXRyaWVzKys7XHJcbiAgICAgICAgcGVuZGluZ1JlcXVlc3QgPSBudWxsO1xyXG4gICAgICAgIHJldHVybiBsb2FkKCk7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgbG9hZCA9ICgpID0+IHtcclxuICAgICAgICBsZXQgdGhpc1JlcXVlc3Q7XHJcbiAgICAgICAgcmV0dXJuIChwZW5kaW5nUmVxdWVzdCB8fFxyXG4gICAgICAgICAgICAodGhpc1JlcXVlc3QgPSBwZW5kaW5nUmVxdWVzdCA9XHJcbiAgICAgICAgICAgICAgICBsb2FkZXIoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGVyciA9IGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyIDogbmV3IEVycm9yKFN0cmluZyhlcnIpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodXNlck9uRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHVzZXJSZXRyeSA9ICgpID0+IHJlc29sdmUocmV0cnkoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB1c2VyRmFpbCA9ICgpID0+IHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlck9uRXJyb3IoZXJyLCB1c2VyUmV0cnksIHVzZXJGYWlsLCByZXRyaWVzICsgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKGNvbXApID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpc1JlcXVlc3QgIT09IHBlbmRpbmdSZXF1ZXN0ICYmIHBlbmRpbmdSZXF1ZXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwZW5kaW5nUmVxdWVzdDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhY29tcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuKGBBc3luYyBjb21wb25lbnQgbG9hZGVyIHJlc29sdmVkIHRvIHVuZGVmaW5lZC4gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgSWYgeW91IGFyZSB1c2luZyByZXRyeSgpLCBtYWtlIHN1cmUgdG8gcmV0dXJuIGl0cyByZXR1cm4gdmFsdWUuYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGludGVyb3AgbW9kdWxlIGRlZmF1bHRcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcCAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoY29tcC5fX2VzTW9kdWxlIHx8IGNvbXBbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ01vZHVsZScpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXAgPSBjb21wLmRlZmF1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgY29tcCAmJiAhaXNPYmplY3QoY29tcCkgJiYgIWlzRnVuY3Rpb24oY29tcCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGFzeW5jIGNvbXBvbmVudCBsb2FkIHJlc3VsdDogJHtjb21wfWApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlZENvbXAgPSBjb21wO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wO1xyXG4gICAgICAgICAgICAgICAgfSkpKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZGVmaW5lQ29tcG9uZW50KHtcclxuICAgICAgICBuYW1lOiAnQXN5bmNDb21wb25lbnRXcmFwcGVyJyxcclxuICAgICAgICBfX2FzeW5jTG9hZGVyOiBsb2FkLFxyXG4gICAgICAgIGdldCBfX2FzeW5jUmVzb2x2ZWQoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlZENvbXA7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXR1cCgpIHtcclxuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBjdXJyZW50SW5zdGFuY2U7XHJcbiAgICAgICAgICAgIC8vIGFscmVhZHkgcmVzb2x2ZWRcclxuICAgICAgICAgICAgaWYgKHJlc29sdmVkQ29tcCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IGNyZWF0ZUlubmVyQ29tcChyZXNvbHZlZENvbXAsIGluc3RhbmNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBvbkVycm9yID0gKGVycikgPT4ge1xyXG4gICAgICAgICAgICAgICAgcGVuZGluZ1JlcXVlc3QgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoZXJyLCBpbnN0YW5jZSwgMTMgLyogQVNZTkNfQ09NUE9ORU5UX0xPQURFUiAqLywgIWVycm9yQ29tcG9uZW50IC8qIGRvIG5vdCB0aHJvdyBpbiBkZXYgaWYgdXNlciBwcm92aWRlZCBlcnJvciBjb21wb25lbnQgKi8pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvLyBzdXNwZW5zZS1jb250cm9sbGVkIG9yIFNTUi5cclxuICAgICAgICAgICAgaWYgKChzdXNwZW5zaWJsZSAmJiBpbnN0YW5jZS5zdXNwZW5zZSkgfHxcclxuICAgICAgICAgICAgICAgIChpc0luU1NSQ29tcG9uZW50U2V0dXApKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9hZCgpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oY29tcCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IGNyZWF0ZUlubmVyQ29tcChjb21wLCBpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IoZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4gZXJyb3JDb21wb25lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjcmVhdGVWTm9kZShlcnJvckNvbXBvbmVudCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVyclxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBsb2FkZWQgPSByZWYoZmFsc2UpO1xyXG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IHJlZigpO1xyXG4gICAgICAgICAgICBjb25zdCBkZWxheWVkID0gcmVmKCEhZGVsYXkpO1xyXG4gICAgICAgICAgICBpZiAoZGVsYXkpIHtcclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGF5ZWQudmFsdWUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH0sIGRlbGF5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGltZW91dCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWxvYWRlZC52YWx1ZSAmJiAhZXJyb3IudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKGBBc3luYyBjb21wb25lbnQgdGltZWQgb3V0IGFmdGVyICR7dGltZW91dH1tcy5gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25FcnJvcihlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvci52YWx1ZSA9IGVycjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LCB0aW1lb3V0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsb2FkKClcclxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGxvYWRlZC52YWx1ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UucGFyZW50ICYmIGlzS2VlcEFsaXZlKGluc3RhbmNlLnBhcmVudC52bm9kZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBwYXJlbnQgaXMga2VlcC1hbGl2ZSwgZm9yY2UgdXBkYXRlIHNvIHRoZSBsb2FkZWQgY29tcG9uZW50J3NcclxuICAgICAgICAgICAgICAgICAgICAvLyBuYW1lIGlzIHRha2VuIGludG8gYWNjb3VudFxyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlSm9iKGluc3RhbmNlLnBhcmVudC51cGRhdGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB7XHJcbiAgICAgICAgICAgICAgICBvbkVycm9yKGVycik7XHJcbiAgICAgICAgICAgICAgICBlcnJvci52YWx1ZSA9IGVycjtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAobG9hZGVkLnZhbHVlICYmIHJlc29sdmVkQ29tcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbm5lckNvbXAocmVzb2x2ZWRDb21wLCBpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChlcnJvci52YWx1ZSAmJiBlcnJvckNvbXBvbmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVWTm9kZShlcnJvckNvbXBvbmVudCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IudmFsdWVcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxvYWRpbmdDb21wb25lbnQgJiYgIWRlbGF5ZWQudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUobG9hZGluZ0NvbXBvbmVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlSW5uZXJDb21wKGNvbXAsIHsgdm5vZGU6IHsgcmVmLCBwcm9wcywgY2hpbGRyZW4sIHNoYXBlRmxhZyB9LCBwYXJlbnQgfSkge1xyXG4gICAgY29uc3Qgdm5vZGUgPSBjcmVhdGVWTm9kZShjb21wLCBwcm9wcywgY2hpbGRyZW4pO1xyXG4gICAgLy8gZW5zdXJlIGlubmVyIGNvbXBvbmVudCBpbmhlcml0cyB0aGUgYXN5bmMgd3JhcHBlcidzIHJlZiBvd25lclxyXG4gICAgdm5vZGUucmVmID0gcmVmO1xyXG4gICAgcmV0dXJuIHZub2RlO1xyXG59XG5cbmNvbnN0IGlzS2VlcEFsaXZlID0gKHZub2RlKSA9PiB2bm9kZS50eXBlLl9faXNLZWVwQWxpdmU7XHJcbmNvbnN0IEtlZXBBbGl2ZUltcGwgPSB7XHJcbiAgICBuYW1lOiBgS2VlcEFsaXZlYCxcclxuICAgIC8vIE1hcmtlciBmb3Igc3BlY2lhbCBoYW5kbGluZyBpbnNpZGUgdGhlIHJlbmRlcmVyLiBXZSBhcmUgbm90IHVzaW5nIGEgPT09XHJcbiAgICAvLyBjaGVjayBkaXJlY3RseSBvbiBLZWVwQWxpdmUgaW4gdGhlIHJlbmRlcmVyLCBiZWNhdXNlIGltcG9ydGluZyBpdCBkaXJlY3RseVxyXG4gICAgLy8gd291bGQgcHJldmVudCBpdCBmcm9tIGJlaW5nIHRyZWUtc2hha2VuLlxyXG4gICAgX19pc0tlZXBBbGl2ZTogdHJ1ZSxcclxuICAgIHByb3BzOiB7XHJcbiAgICAgICAgaW5jbHVkZTogW1N0cmluZywgUmVnRXhwLCBBcnJheV0sXHJcbiAgICAgICAgZXhjbHVkZTogW1N0cmluZywgUmVnRXhwLCBBcnJheV0sXHJcbiAgICAgICAgbWF4OiBbU3RyaW5nLCBOdW1iZXJdXHJcbiAgICB9LFxyXG4gICAgc2V0dXAocHJvcHMsIHsgc2xvdHMgfSkge1xyXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XHJcbiAgICAgICAgLy8gS2VlcEFsaXZlIGNvbW11bmljYXRlcyB3aXRoIHRoZSBpbnN0YW50aWF0ZWQgcmVuZGVyZXIgdmlhIHRoZVxyXG4gICAgICAgIC8vIGN0eCB3aGVyZSB0aGUgcmVuZGVyZXIgcGFzc2VzIGluIGl0cyBpbnRlcm5hbHMsXHJcbiAgICAgICAgLy8gYW5kIHRoZSBLZWVwQWxpdmUgaW5zdGFuY2UgZXhwb3NlcyBhY3RpdmF0ZS9kZWFjdGl2YXRlIGltcGxlbWVudGF0aW9ucy5cclxuICAgICAgICAvLyBUaGUgd2hvbGUgcG9pbnQgb2YgdGhpcyBpcyB0byBhdm9pZCBpbXBvcnRpbmcgS2VlcEFsaXZlIGRpcmVjdGx5IGluIHRoZVxyXG4gICAgICAgIC8vIHJlbmRlcmVyIHRvIGZhY2lsaXRhdGUgdHJlZS1zaGFraW5nLlxyXG4gICAgICAgIGNvbnN0IHNoYXJlZENvbnRleHQgPSBpbnN0YW5jZS5jdHg7XHJcbiAgICAgICAgLy8gaWYgdGhlIGludGVybmFsIHJlbmRlcmVyIGlzIG5vdCByZWdpc3RlcmVkLCBpdCBpbmRpY2F0ZXMgdGhhdCB0aGlzIGlzIHNlcnZlci1zaWRlIHJlbmRlcmluZyxcclxuICAgICAgICAvLyBmb3IgS2VlcEFsaXZlLCB3ZSBqdXN0IG5lZWQgdG8gcmVuZGVyIGl0cyBjaGlsZHJlblxyXG4gICAgICAgIGlmICghc2hhcmVkQ29udGV4dC5yZW5kZXJlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBzbG90cy5kZWZhdWx0ICYmIHNsb3RzLmRlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGggPT09IDEgPyBjaGlsZHJlblswXSA6IGNoaWxkcmVuO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjYWNoZSA9IG5ldyBNYXAoKTtcclxuICAgICAgICBjb25zdCBrZXlzID0gbmV3IFNldCgpO1xyXG4gICAgICAgIGxldCBjdXJyZW50ID0gbnVsbDtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgICAgICAgICBpbnN0YW5jZS5fX3ZfY2FjaGUgPSBjYWNoZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcGFyZW50U3VzcGVuc2UgPSBpbnN0YW5jZS5zdXNwZW5zZTtcclxuICAgICAgICBjb25zdCB7IHJlbmRlcmVyOiB7IHA6IHBhdGNoLCBtOiBtb3ZlLCB1bTogX3VubW91bnQsIG86IHsgY3JlYXRlRWxlbWVudCB9IH0gfSA9IHNoYXJlZENvbnRleHQ7XHJcbiAgICAgICAgY29uc3Qgc3RvcmFnZUNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIHNoYXJlZENvbnRleHQuYWN0aXZhdGUgPSAodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBpc1NWRywgb3B0aW1pemVkKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gdm5vZGUuY29tcG9uZW50O1xyXG4gICAgICAgICAgICBtb3ZlKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgMCAvKiBFTlRFUiAqLywgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgICAgICAvLyBpbiBjYXNlIHByb3BzIGhhdmUgY2hhbmdlZFxyXG4gICAgICAgICAgICBwYXRjaChpbnN0YW5jZS52bm9kZSwgdm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBpbnN0YW5jZSwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCB2bm9kZS5zbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5pc0RlYWN0aXZhdGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UuYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGludm9rZUFycmF5Rm5zKGluc3RhbmNlLmEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3Qgdm5vZGVIb29rID0gdm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHMub25Wbm9kZU1vdW50ZWQ7XHJcbiAgICAgICAgICAgICAgICBpZiAodm5vZGVIb29rKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgaW5zdGFuY2UucGFyZW50LCB2bm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBjb21wb25lbnRzIHRyZWVcclxuICAgICAgICAgICAgICAgIGRldnRvb2xzQ29tcG9uZW50QWRkZWQoaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBzaGFyZWRDb250ZXh0LmRlYWN0aXZhdGUgPSAodm5vZGUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnQ7XHJcbiAgICAgICAgICAgIG1vdmUodm5vZGUsIHN0b3JhZ2VDb250YWluZXIsIG51bGwsIDEgLyogTEVBVkUgKi8sIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5kYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGludm9rZUFycmF5Rm5zKGluc3RhbmNlLmRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHZub2RlSG9vayA9IHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLm9uVm5vZGVVbm1vdW50ZWQ7XHJcbiAgICAgICAgICAgICAgICBpZiAodm5vZGVIb29rKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgaW5zdGFuY2UucGFyZW50LCB2bm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5pc0RlYWN0aXZhdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGNvbXBvbmVudHMgdHJlZVxyXG4gICAgICAgICAgICAgICAgZGV2dG9vbHNDb21wb25lbnRBZGRlZChpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGZ1bmN0aW9uIHVubW91bnQodm5vZGUpIHtcclxuICAgICAgICAgICAgLy8gcmVzZXQgdGhlIHNoYXBlRmxhZyBzbyBpdCBjYW4gYmUgcHJvcGVybHkgdW5tb3VudGVkXHJcbiAgICAgICAgICAgIHJlc2V0U2hhcGVGbGFnKHZub2RlKTtcclxuICAgICAgICAgICAgX3VubW91bnQodm5vZGUsIGluc3RhbmNlLCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHBydW5lQ2FjaGUoZmlsdGVyKSB7XHJcbiAgICAgICAgICAgIGNhY2hlLmZvckVhY2goKHZub2RlLCBrZXkpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBnZXRDb21wb25lbnROYW1lKHZub2RlLnR5cGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgJiYgKCFmaWx0ZXIgfHwgIWZpbHRlcihuYW1lKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBwcnVuZUNhY2hlRW50cnkoa2V5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHBydW5lQ2FjaGVFbnRyeShrZXkpIHtcclxuICAgICAgICAgICAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KGtleSk7XHJcbiAgICAgICAgICAgIGlmICghY3VycmVudCB8fCBjYWNoZWQudHlwZSAhPT0gY3VycmVudC50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICB1bm1vdW50KGNhY2hlZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudCkge1xyXG4gICAgICAgICAgICAgICAgLy8gY3VycmVudCBhY3RpdmUgaW5zdGFuY2Ugc2hvdWxkIG5vIGxvbmdlciBiZSBrZXB0LWFsaXZlLlxyXG4gICAgICAgICAgICAgICAgLy8gd2UgY2FuJ3QgdW5tb3VudCBpdCBub3cgYnV0IGl0IG1pZ2h0IGJlIGxhdGVyLCBzbyByZXNldCBpdHMgZmxhZyBub3cuXHJcbiAgICAgICAgICAgICAgICByZXNldFNoYXBlRmxhZyhjdXJyZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYWNoZS5kZWxldGUoa2V5KTtcclxuICAgICAgICAgICAga2V5cy5kZWxldGUoa2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcHJ1bmUgY2FjaGUgb24gaW5jbHVkZS9leGNsdWRlIHByb3AgY2hhbmdlXHJcbiAgICAgICAgd2F0Y2goKCkgPT4gW3Byb3BzLmluY2x1ZGUsIHByb3BzLmV4Y2x1ZGVdLCAoW2luY2x1ZGUsIGV4Y2x1ZGVdKSA9PiB7XHJcbiAgICAgICAgICAgIGluY2x1ZGUgJiYgcHJ1bmVDYWNoZShuYW1lID0+IG1hdGNoZXMoaW5jbHVkZSwgbmFtZSkpO1xyXG4gICAgICAgICAgICBleGNsdWRlICYmIHBydW5lQ2FjaGUobmFtZSA9PiAhbWF0Y2hlcyhleGNsdWRlLCBuYW1lKSk7XHJcbiAgICAgICAgfSwgXHJcbiAgICAgICAgLy8gcHJ1bmUgcG9zdC1yZW5kZXIgYWZ0ZXIgYGN1cnJlbnRgIGhhcyBiZWVuIHVwZGF0ZWRcclxuICAgICAgICB7IGZsdXNoOiAncG9zdCcsIGRlZXA6IHRydWUgfSk7XHJcbiAgICAgICAgLy8gY2FjaGUgc3ViIHRyZWUgYWZ0ZXIgcmVuZGVyXHJcbiAgICAgICAgbGV0IHBlbmRpbmdDYWNoZUtleSA9IG51bGw7XHJcbiAgICAgICAgY29uc3QgY2FjaGVTdWJ0cmVlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBmaXggIzE2MjEsIHRoZSBwZW5kaW5nQ2FjaGVLZXkgY291bGQgYmUgMFxyXG4gICAgICAgICAgICBpZiAocGVuZGluZ0NhY2hlS2V5ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGNhY2hlLnNldChwZW5kaW5nQ2FjaGVLZXksIGdldElubmVyQ2hpbGQoaW5zdGFuY2Uuc3ViVHJlZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBvbk1vdW50ZWQoY2FjaGVTdWJ0cmVlKTtcclxuICAgICAgICBvblVwZGF0ZWQoY2FjaGVTdWJ0cmVlKTtcclxuICAgICAgICBvbkJlZm9yZVVubW91bnQoKCkgPT4ge1xyXG4gICAgICAgICAgICBjYWNoZS5mb3JFYWNoKGNhY2hlZCA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IHN1YlRyZWUsIHN1c3BlbnNlIH0gPSBpbnN0YW5jZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZub2RlID0gZ2V0SW5uZXJDaGlsZChzdWJUcmVlKTtcclxuICAgICAgICAgICAgICAgIGlmIChjYWNoZWQudHlwZSA9PT0gdm5vZGUudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGN1cnJlbnQgaW5zdGFuY2Ugd2lsbCBiZSB1bm1vdW50ZWQgYXMgcGFydCBvZiBrZWVwLWFsaXZlJ3MgdW5tb3VudFxyXG4gICAgICAgICAgICAgICAgICAgIHJlc2V0U2hhcGVGbGFnKHZub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBidXQgaW52b2tlIGl0cyBkZWFjdGl2YXRlZCBob29rIGhlcmVcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYSA9IHZub2RlLmNvbXBvbmVudC5kYTtcclxuICAgICAgICAgICAgICAgICAgICBkYSAmJiBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoZGEsIHN1c3BlbnNlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB1bm1vdW50KGNhY2hlZCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIHBlbmRpbmdDYWNoZUtleSA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmICghc2xvdHMuZGVmYXVsdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBzbG90cy5kZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJhd1ZOb2RlID0gY2hpbGRyZW5bMF07XHJcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgS2VlcEFsaXZlIHNob3VsZCBjb250YWluIGV4YWN0bHkgb25lIGNvbXBvbmVudCBjaGlsZC5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc1ZOb2RlKHJhd1ZOb2RlKSB8fFxyXG4gICAgICAgICAgICAgICAgKCEocmF3Vk5vZGUuc2hhcGVGbGFnICYgNCAvKiBTVEFURUZVTF9DT01QT05FTlQgKi8pICYmXHJcbiAgICAgICAgICAgICAgICAgICAgIShyYXdWTm9kZS5zaGFwZUZsYWcgJiAxMjggLyogU1VTUEVOU0UgKi8pKSkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmF3Vk5vZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHZub2RlID0gZ2V0SW5uZXJDaGlsZChyYXdWTm9kZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbXAgPSB2bm9kZS50eXBlO1xyXG4gICAgICAgICAgICAvLyBmb3IgYXN5bmMgY29tcG9uZW50cywgbmFtZSBjaGVjayBzaG91bGQgYmUgYmFzZWQgaW4gaXRzIGxvYWRlZFxyXG4gICAgICAgICAgICAvLyBpbm5lciBjb21wb25lbnQgaWYgYXZhaWxhYmxlXHJcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGlzQXN5bmNXcmFwcGVyKHZub2RlKVxyXG4gICAgICAgICAgICAgICAgPyB2bm9kZS50eXBlLl9fYXN5bmNSZXNvbHZlZCB8fCB7fVxyXG4gICAgICAgICAgICAgICAgOiBjb21wKTtcclxuICAgICAgICAgICAgY29uc3QgeyBpbmNsdWRlLCBleGNsdWRlLCBtYXggfSA9IHByb3BzO1xyXG4gICAgICAgICAgICBpZiAoKGluY2x1ZGUgJiYgKCFuYW1lIHx8ICFtYXRjaGVzKGluY2x1ZGUsIG5hbWUpKSkgfHxcclxuICAgICAgICAgICAgICAgIChleGNsdWRlICYmIG5hbWUgJiYgbWF0Y2hlcyhleGNsdWRlLCBuYW1lKSkpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSB2bm9kZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByYXdWTm9kZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBrZXkgPSB2bm9kZS5rZXkgPT0gbnVsbCA/IGNvbXAgOiB2bm9kZS5rZXk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlZFZOb2RlID0gY2FjaGUuZ2V0KGtleSk7XHJcbiAgICAgICAgICAgIC8vIGNsb25lIHZub2RlIGlmIGl0J3MgcmV1c2VkIGJlY2F1c2Ugd2UgYXJlIGdvaW5nIHRvIG11dGF0ZSBpdFxyXG4gICAgICAgICAgICBpZiAodm5vZGUuZWwpIHtcclxuICAgICAgICAgICAgICAgIHZub2RlID0gY2xvbmVWTm9kZSh2bm9kZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmF3Vk5vZGUuc2hhcGVGbGFnICYgMTI4IC8qIFNVU1BFTlNFICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmF3Vk5vZGUuc3NDb250ZW50ID0gdm5vZGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gIzE1MTMgaXQncyBwb3NzaWJsZSBmb3IgdGhlIHJldHVybmVkIHZub2RlIHRvIGJlIGNsb25lZCBkdWUgdG8gYXR0clxyXG4gICAgICAgICAgICAvLyBmYWxsdGhyb3VnaCBvciBzY29wZUlkLCBzbyB0aGUgdm5vZGUgaGVyZSBtYXkgbm90IGJlIHRoZSBmaW5hbCB2bm9kZVxyXG4gICAgICAgICAgICAvLyB0aGF0IGlzIG1vdW50ZWQuIEluc3RlYWQgb2YgY2FjaGluZyBpdCBkaXJlY3RseSwgd2Ugc3RvcmUgdGhlIHBlbmRpbmdcclxuICAgICAgICAgICAgLy8ga2V5IGFuZCBjYWNoZSBgaW5zdGFuY2Uuc3ViVHJlZWAgKHRoZSBub3JtYWxpemVkIHZub2RlKSBpblxyXG4gICAgICAgICAgICAvLyBiZWZvcmVNb3VudC9iZWZvcmVVcGRhdGUgaG9va3MuXHJcbiAgICAgICAgICAgIHBlbmRpbmdDYWNoZUtleSA9IGtleTtcclxuICAgICAgICAgICAgaWYgKGNhY2hlZFZOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjb3B5IG92ZXIgbW91bnRlZCBzdGF0ZVxyXG4gICAgICAgICAgICAgICAgdm5vZGUuZWwgPSBjYWNoZWRWTm9kZS5lbDtcclxuICAgICAgICAgICAgICAgIHZub2RlLmNvbXBvbmVudCA9IGNhY2hlZFZOb2RlLmNvbXBvbmVudDtcclxuICAgICAgICAgICAgICAgIGlmICh2bm9kZS50cmFuc2l0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVjdXJzaXZlbHkgdXBkYXRlIHRyYW5zaXRpb24gaG9va3Mgb24gc3ViVHJlZVxyXG4gICAgICAgICAgICAgICAgICAgIHNldFRyYW5zaXRpb25Ib29rcyh2bm9kZSwgdm5vZGUudHJhbnNpdGlvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBhdm9pZCB2bm9kZSBiZWluZyBtb3VudGVkIGFzIGZyZXNoXHJcbiAgICAgICAgICAgICAgICB2bm9kZS5zaGFwZUZsYWcgfD0gNTEyIC8qIENPTVBPTkVOVF9LRVBUX0FMSVZFICovO1xyXG4gICAgICAgICAgICAgICAgLy8gbWFrZSB0aGlzIGtleSB0aGUgZnJlc2hlc3RcclxuICAgICAgICAgICAgICAgIGtleXMuZGVsZXRlKGtleSk7XHJcbiAgICAgICAgICAgICAgICBrZXlzLmFkZChrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAga2V5cy5hZGQoa2V5KTtcclxuICAgICAgICAgICAgICAgIC8vIHBydW5lIG9sZGVzdCBlbnRyeVxyXG4gICAgICAgICAgICAgICAgaWYgKG1heCAmJiBrZXlzLnNpemUgPiBwYXJzZUludChtYXgsIDEwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBydW5lQ2FjaGVFbnRyeShrZXlzLnZhbHVlcygpLm5leHQoKS52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gYXZvaWQgdm5vZGUgYmVpbmcgdW5tb3VudGVkXHJcbiAgICAgICAgICAgIHZub2RlLnNoYXBlRmxhZyB8PSAyNTYgLyogQ09NUE9ORU5UX1NIT1VMRF9LRUVQX0FMSVZFICovO1xyXG4gICAgICAgICAgICBjdXJyZW50ID0gdm5vZGU7XHJcbiAgICAgICAgICAgIHJldHVybiBpc1N1c3BlbnNlKHJhd1ZOb2RlLnR5cGUpID8gcmF3Vk5vZGUgOiB2bm9kZTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59O1xyXG4vLyBleHBvcnQgdGhlIHB1YmxpYyB0eXBlIGZvciBoL3RzeCBpbmZlcmVuY2VcclxuLy8gYWxzbyB0byBhdm9pZCBpbmxpbmUgaW1wb3J0KCkgaW4gZ2VuZXJhdGVkIGQudHMgZmlsZXNcclxuY29uc3QgS2VlcEFsaXZlID0gS2VlcEFsaXZlSW1wbDtcclxuZnVuY3Rpb24gbWF0Y2hlcyhwYXR0ZXJuLCBuYW1lKSB7XHJcbiAgICBpZiAoaXNBcnJheShwYXR0ZXJuKSkge1xyXG4gICAgICAgIHJldHVybiBwYXR0ZXJuLnNvbWUoKHApID0+IG1hdGNoZXMocCwgbmFtZSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNTdHJpbmcocGF0dGVybikpIHtcclxuICAgICAgICByZXR1cm4gcGF0dGVybi5zcGxpdCgnLCcpLmluY2x1ZGVzKG5hbWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocGF0dGVybi50ZXN0KSB7XHJcbiAgICAgICAgcmV0dXJuIHBhdHRlcm4udGVzdChuYW1lKTtcclxuICAgIH1cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gb25BY3RpdmF0ZWQoaG9vaywgdGFyZ2V0KSB7XHJcbiAgICByZWdpc3RlcktlZXBBbGl2ZUhvb2soaG9vaywgXCJhXCIgLyogQUNUSVZBVEVEICovLCB0YXJnZXQpO1xyXG59XHJcbmZ1bmN0aW9uIG9uRGVhY3RpdmF0ZWQoaG9vaywgdGFyZ2V0KSB7XHJcbiAgICByZWdpc3RlcktlZXBBbGl2ZUhvb2soaG9vaywgXCJkYVwiIC8qIERFQUNUSVZBVEVEICovLCB0YXJnZXQpO1xyXG59XHJcbmZ1bmN0aW9uIHJlZ2lzdGVyS2VlcEFsaXZlSG9vayhob29rLCB0eXBlLCB0YXJnZXQgPSBjdXJyZW50SW5zdGFuY2UpIHtcclxuICAgIC8vIGNhY2hlIHRoZSBkZWFjdGl2YXRlIGJyYW5jaCBjaGVjayB3cmFwcGVyIGZvciBpbmplY3RlZCBob29rcyBzbyB0aGUgc2FtZVxyXG4gICAgLy8gaG9vayBjYW4gYmUgcHJvcGVybHkgZGVkdXBlZCBieSB0aGUgc2NoZWR1bGVyLiBcIl9fd2RjXCIgc3RhbmRzIGZvciBcIndpdGhcclxuICAgIC8vIGRlYWN0aXZhdGlvbiBjaGVja1wiLlxyXG4gICAgY29uc3Qgd3JhcHBlZEhvb2sgPSBob29rLl9fd2RjIHx8XHJcbiAgICAgICAgKGhvb2suX193ZGMgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIG9ubHkgZmlyZSB0aGUgaG9vayBpZiB0aGUgdGFyZ2V0IGluc3RhbmNlIGlzIE5PVCBpbiBhIGRlYWN0aXZhdGVkIGJyYW5jaC5cclxuICAgICAgICAgICAgbGV0IGN1cnJlbnQgPSB0YXJnZXQ7XHJcbiAgICAgICAgICAgIHdoaWxlIChjdXJyZW50KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudC5pc0RlYWN0aXZhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBob29rKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICBpbmplY3RIb29rKHR5cGUsIHdyYXBwZWRIb29rLCB0YXJnZXQpO1xyXG4gICAgLy8gSW4gYWRkaXRpb24gdG8gcmVnaXN0ZXJpbmcgaXQgb24gdGhlIHRhcmdldCBpbnN0YW5jZSwgd2Ugd2FsayB1cCB0aGUgcGFyZW50XHJcbiAgICAvLyBjaGFpbiBhbmQgcmVnaXN0ZXIgaXQgb24gYWxsIGFuY2VzdG9yIGluc3RhbmNlcyB0aGF0IGFyZSBrZWVwLWFsaXZlIHJvb3RzLlxyXG4gICAgLy8gVGhpcyBhdm9pZHMgdGhlIG5lZWQgdG8gd2FsayB0aGUgZW50aXJlIGNvbXBvbmVudCB0cmVlIHdoZW4gaW52b2tpbmcgdGhlc2VcclxuICAgIC8vIGhvb2tzLCBhbmQgbW9yZSBpbXBvcnRhbnRseSwgYXZvaWRzIHRoZSBuZWVkIHRvIHRyYWNrIGNoaWxkIGNvbXBvbmVudHMgaW5cclxuICAgIC8vIGFycmF5cy5cclxuICAgIGlmICh0YXJnZXQpIHtcclxuICAgICAgICBsZXQgY3VycmVudCA9IHRhcmdldC5wYXJlbnQ7XHJcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQgJiYgY3VycmVudC5wYXJlbnQpIHtcclxuICAgICAgICAgICAgaWYgKGlzS2VlcEFsaXZlKGN1cnJlbnQucGFyZW50LnZub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgaW5qZWN0VG9LZWVwQWxpdmVSb290KHdyYXBwZWRIb29rLCB0eXBlLCB0YXJnZXQsIGN1cnJlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaW5qZWN0VG9LZWVwQWxpdmVSb290KGhvb2ssIHR5cGUsIHRhcmdldCwga2VlcEFsaXZlUm9vdCkge1xyXG4gICAgLy8gaW5qZWN0SG9vayB3cmFwcyB0aGUgb3JpZ2luYWwgZm9yIGVycm9yIGhhbmRsaW5nLCBzbyBtYWtlIHN1cmUgdG8gcmVtb3ZlXHJcbiAgICAvLyB0aGUgd3JhcHBlZCB2ZXJzaW9uLlxyXG4gICAgY29uc3QgaW5qZWN0ZWQgPSBpbmplY3RIb29rKHR5cGUsIGhvb2ssIGtlZXBBbGl2ZVJvb3QsIHRydWUgLyogcHJlcGVuZCAqLyk7XHJcbiAgICBvblVubW91bnRlZCgoKSA9PiB7XHJcbiAgICAgICAgcmVtb3ZlKGtlZXBBbGl2ZVJvb3RbdHlwZV0sIGluamVjdGVkKTtcclxuICAgIH0sIHRhcmdldCk7XHJcbn1cclxuZnVuY3Rpb24gcmVzZXRTaGFwZUZsYWcodm5vZGUpIHtcclxuICAgIGxldCBzaGFwZUZsYWcgPSB2bm9kZS5zaGFwZUZsYWc7XHJcbiAgICBpZiAoc2hhcGVGbGFnICYgMjU2IC8qIENPTVBPTkVOVF9TSE9VTERfS0VFUF9BTElWRSAqLykge1xyXG4gICAgICAgIHNoYXBlRmxhZyAtPSAyNTYgLyogQ09NUE9ORU5UX1NIT1VMRF9LRUVQX0FMSVZFICovO1xyXG4gICAgfVxyXG4gICAgaWYgKHNoYXBlRmxhZyAmIDUxMiAvKiBDT01QT05FTlRfS0VQVF9BTElWRSAqLykge1xyXG4gICAgICAgIHNoYXBlRmxhZyAtPSA1MTIgLyogQ09NUE9ORU5UX0tFUFRfQUxJVkUgKi87XHJcbiAgICB9XHJcbiAgICB2bm9kZS5zaGFwZUZsYWcgPSBzaGFwZUZsYWc7XHJcbn1cclxuZnVuY3Rpb24gZ2V0SW5uZXJDaGlsZCh2bm9kZSkge1xyXG4gICAgcmV0dXJuIHZub2RlLnNoYXBlRmxhZyAmIDEyOCAvKiBTVVNQRU5TRSAqLyA/IHZub2RlLnNzQ29udGVudCA6IHZub2RlO1xyXG59XG5cbmZ1bmN0aW9uIGluamVjdEhvb2sodHlwZSwgaG9vaywgdGFyZ2V0ID0gY3VycmVudEluc3RhbmNlLCBwcmVwZW5kID0gZmFsc2UpIHtcclxuICAgIGlmICh0YXJnZXQpIHtcclxuICAgICAgICBjb25zdCBob29rcyA9IHRhcmdldFt0eXBlXSB8fCAodGFyZ2V0W3R5cGVdID0gW10pO1xyXG4gICAgICAgIC8vIGNhY2hlIHRoZSBlcnJvciBoYW5kbGluZyB3cmFwcGVyIGZvciBpbmplY3RlZCBob29rcyBzbyB0aGUgc2FtZSBob29rXHJcbiAgICAgICAgLy8gY2FuIGJlIHByb3Blcmx5IGRlZHVwZWQgYnkgdGhlIHNjaGVkdWxlci4gXCJfX3dlaFwiIHN0YW5kcyBmb3IgXCJ3aXRoIGVycm9yXHJcbiAgICAgICAgLy8gaGFuZGxpbmdcIi5cclxuICAgICAgICBjb25zdCB3cmFwcGVkSG9vayA9IGhvb2suX193ZWggfHxcclxuICAgICAgICAgICAgKGhvb2suX193ZWggPSAoLi4uYXJncykgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldC5pc1VubW91bnRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGRpc2FibGUgdHJhY2tpbmcgaW5zaWRlIGFsbCBsaWZlY3ljbGUgaG9va3NcclxuICAgICAgICAgICAgICAgIC8vIHNpbmNlIHRoZXkgY2FuIHBvdGVudGlhbGx5IGJlIGNhbGxlZCBpbnNpZGUgZWZmZWN0cy5cclxuICAgICAgICAgICAgICAgIHBhdXNlVHJhY2tpbmcoKTtcclxuICAgICAgICAgICAgICAgIC8vIFNldCBjdXJyZW50SW5zdGFuY2UgZHVyaW5nIGhvb2sgaW52b2NhdGlvbi5cclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgYXNzdW1lcyB0aGUgaG9vayBkb2VzIG5vdCBzeW5jaHJvbm91c2x5IHRyaWdnZXIgb3RoZXIgaG9va3MsIHdoaWNoXHJcbiAgICAgICAgICAgICAgICAvLyBjYW4gb25seSBiZSBmYWxzZSB3aGVuIHRoZSB1c2VyIGRvZXMgc29tZXRoaW5nIHJlYWxseSBmdW5reS5cclxuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRJbnN0YW5jZSh0YXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzID0gY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoaG9vaywgdGFyZ2V0LCB0eXBlLCBhcmdzKTtcclxuICAgICAgICAgICAgICAgIHVuc2V0Q3VycmVudEluc3RhbmNlKCk7XHJcbiAgICAgICAgICAgICAgICByZXNldFRyYWNraW5nKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICBpZiAocHJlcGVuZCkge1xyXG4gICAgICAgICAgICBob29rcy51bnNoaWZ0KHdyYXBwZWRIb29rKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGhvb2tzLnB1c2god3JhcHBlZEhvb2spO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gd3JhcHBlZEhvb2s7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICBjb25zdCBhcGlOYW1lID0gdG9IYW5kbGVyS2V5KEVycm9yVHlwZVN0cmluZ3NbdHlwZV0ucmVwbGFjZSgvIGhvb2skLywgJycpKTtcclxuICAgICAgICB3YXJuKGAke2FwaU5hbWV9IGlzIGNhbGxlZCB3aGVuIHRoZXJlIGlzIG5vIGFjdGl2ZSBjb21wb25lbnQgaW5zdGFuY2UgdG8gYmUgYCArXHJcbiAgICAgICAgICAgIGBhc3NvY2lhdGVkIHdpdGguIGAgK1xyXG4gICAgICAgICAgICBgTGlmZWN5Y2xlIGluamVjdGlvbiBBUElzIGNhbiBvbmx5IGJlIHVzZWQgZHVyaW5nIGV4ZWN1dGlvbiBvZiBzZXR1cCgpLmAgK1xyXG4gICAgICAgICAgICAoYCBJZiB5b3UgYXJlIHVzaW5nIGFzeW5jIHNldHVwKCksIG1ha2Ugc3VyZSB0byByZWdpc3RlciBsaWZlY3ljbGUgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYGhvb2tzIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQgc3RhdGVtZW50LmBcclxuICAgICAgICAgICAgICAgICkpO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IGNyZWF0ZUhvb2sgPSAobGlmZWN5Y2xlKSA9PiAoaG9vaywgdGFyZ2V0ID0gY3VycmVudEluc3RhbmNlKSA9PiBcclxuLy8gcG9zdC1jcmVhdGUgbGlmZWN5Y2xlIHJlZ2lzdHJhdGlvbnMgYXJlIG5vb3BzIGR1cmluZyBTU1IgKGV4Y2VwdCBmb3Igc2VydmVyUHJlZmV0Y2gpXHJcbighaXNJblNTUkNvbXBvbmVudFNldHVwIHx8IGxpZmVjeWNsZSA9PT0gXCJzcFwiIC8qIFNFUlZFUl9QUkVGRVRDSCAqLykgJiZcclxuICAgIGluamVjdEhvb2sobGlmZWN5Y2xlLCBob29rLCB0YXJnZXQpO1xyXG5jb25zdCBvbkJlZm9yZU1vdW50ID0gY3JlYXRlSG9vayhcImJtXCIgLyogQkVGT1JFX01PVU5UICovKTtcclxuY29uc3Qgb25Nb3VudGVkID0gY3JlYXRlSG9vayhcIm1cIiAvKiBNT1VOVEVEICovKTtcclxuY29uc3Qgb25CZWZvcmVVcGRhdGUgPSBjcmVhdGVIb29rKFwiYnVcIiAvKiBCRUZPUkVfVVBEQVRFICovKTtcclxuY29uc3Qgb25VcGRhdGVkID0gY3JlYXRlSG9vayhcInVcIiAvKiBVUERBVEVEICovKTtcclxuY29uc3Qgb25CZWZvcmVVbm1vdW50ID0gY3JlYXRlSG9vayhcImJ1bVwiIC8qIEJFRk9SRV9VTk1PVU5UICovKTtcclxuY29uc3Qgb25Vbm1vdW50ZWQgPSBjcmVhdGVIb29rKFwidW1cIiAvKiBVTk1PVU5URUQgKi8pO1xyXG5jb25zdCBvblNlcnZlclByZWZldGNoID0gY3JlYXRlSG9vayhcInNwXCIgLyogU0VSVkVSX1BSRUZFVENIICovKTtcclxuY29uc3Qgb25SZW5kZXJUcmlnZ2VyZWQgPSBjcmVhdGVIb29rKFwicnRnXCIgLyogUkVOREVSX1RSSUdHRVJFRCAqLyk7XHJcbmNvbnN0IG9uUmVuZGVyVHJhY2tlZCA9IGNyZWF0ZUhvb2soXCJydGNcIiAvKiBSRU5ERVJfVFJBQ0tFRCAqLyk7XHJcbmZ1bmN0aW9uIG9uRXJyb3JDYXB0dXJlZChob29rLCB0YXJnZXQgPSBjdXJyZW50SW5zdGFuY2UpIHtcclxuICAgIGluamVjdEhvb2soXCJlY1wiIC8qIEVSUk9SX0NBUFRVUkVEICovLCBob29rLCB0YXJnZXQpO1xyXG59XG5cbi8qKlxyXG5SdW50aW1lIGhlbHBlciBmb3IgYXBwbHlpbmcgZGlyZWN0aXZlcyB0byBhIHZub2RlLiBFeGFtcGxlIHVzYWdlOlxyXG5cbmNvbnN0IGNvbXAgPSByZXNvbHZlQ29tcG9uZW50KCdjb21wJylcclxuY29uc3QgZm9vID0gcmVzb2x2ZURpcmVjdGl2ZSgnZm9vJylcclxuY29uc3QgYmFyID0gcmVzb2x2ZURpcmVjdGl2ZSgnYmFyJylcclxuXG5yZXR1cm4gd2l0aERpcmVjdGl2ZXMoaChjb21wKSwgW1xyXG4gIFtmb28sIHRoaXMueF0sXHJcbiAgW2JhciwgdGhpcy55XVxyXG5dKVxyXG4qL1xyXG5mdW5jdGlvbiB2YWxpZGF0ZURpcmVjdGl2ZU5hbWUobmFtZSkge1xyXG4gICAgaWYgKGlzQnVpbHRJbkRpcmVjdGl2ZShuYW1lKSkge1xyXG4gICAgICAgIHdhcm4oJ0RvIG5vdCB1c2UgYnVpbHQtaW4gZGlyZWN0aXZlIGlkcyBhcyBjdXN0b20gZGlyZWN0aXZlIGlkOiAnICsgbmFtZSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEFkZHMgZGlyZWN0aXZlcyB0byBhIFZOb2RlLlxyXG4gKi9cclxuZnVuY3Rpb24gd2l0aERpcmVjdGl2ZXModm5vZGUsIGRpcmVjdGl2ZXMpIHtcclxuICAgIGNvbnN0IGludGVybmFsSW5zdGFuY2UgPSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2U7XHJcbiAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZSA9PT0gbnVsbCkge1xyXG4gICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB3YXJuKGB3aXRoRGlyZWN0aXZlcyBjYW4gb25seSBiZSB1c2VkIGluc2lkZSByZW5kZXIgZnVuY3Rpb25zLmApO1xyXG4gICAgICAgIHJldHVybiB2bm9kZTtcclxuICAgIH1cclxuICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0RXhwb3NlUHJveHkoaW50ZXJuYWxJbnN0YW5jZSkgfHxcclxuICAgICAgICBpbnRlcm5hbEluc3RhbmNlLnByb3h5O1xyXG4gICAgY29uc3QgYmluZGluZ3MgPSB2bm9kZS5kaXJzIHx8ICh2bm9kZS5kaXJzID0gW10pO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaXJlY3RpdmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbGV0IFtkaXIsIHZhbHVlLCBhcmcsIG1vZGlmaWVycyA9IEVNUFRZX09CSl0gPSBkaXJlY3RpdmVzW2ldO1xyXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKGRpcikpIHtcclxuICAgICAgICAgICAgZGlyID0ge1xyXG4gICAgICAgICAgICAgICAgbW91bnRlZDogZGlyLFxyXG4gICAgICAgICAgICAgICAgdXBkYXRlZDogZGlyXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkaXIuZGVlcCkge1xyXG4gICAgICAgICAgICB0cmF2ZXJzZSh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJpbmRpbmdzLnB1c2goe1xyXG4gICAgICAgICAgICBkaXIsXHJcbiAgICAgICAgICAgIGluc3RhbmNlLFxyXG4gICAgICAgICAgICB2YWx1ZSxcclxuICAgICAgICAgICAgb2xkVmFsdWU6IHZvaWQgMCxcclxuICAgICAgICAgICAgYXJnLFxyXG4gICAgICAgICAgICBtb2RpZmllcnNcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiB2bm9kZTtcclxufVxyXG5mdW5jdGlvbiBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBwcmV2Vk5vZGUsIGluc3RhbmNlLCBuYW1lKSB7XHJcbiAgICBjb25zdCBiaW5kaW5ncyA9IHZub2RlLmRpcnM7XHJcbiAgICBjb25zdCBvbGRCaW5kaW5ncyA9IHByZXZWTm9kZSAmJiBwcmV2Vk5vZGUuZGlycztcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmluZGluZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBiaW5kaW5nID0gYmluZGluZ3NbaV07XHJcbiAgICAgICAgaWYgKG9sZEJpbmRpbmdzKSB7XHJcbiAgICAgICAgICAgIGJpbmRpbmcub2xkVmFsdWUgPSBvbGRCaW5kaW5nc1tpXS52YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGhvb2sgPSBiaW5kaW5nLmRpcltuYW1lXTtcclxuICAgICAgICBpZiAoaG9vaykge1xyXG4gICAgICAgICAgICAvLyBkaXNhYmxlIHRyYWNraW5nIGluc2lkZSBhbGwgbGlmZWN5Y2xlIGhvb2tzXHJcbiAgICAgICAgICAgIC8vIHNpbmNlIHRoZXkgY2FuIHBvdGVudGlhbGx5IGJlIGNhbGxlZCBpbnNpZGUgZWZmZWN0cy5cclxuICAgICAgICAgICAgcGF1c2VUcmFja2luZygpO1xyXG4gICAgICAgICAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhob29rLCBpbnN0YW5jZSwgOCAvKiBESVJFQ1RJVkVfSE9PSyAqLywgW1xyXG4gICAgICAgICAgICAgICAgdm5vZGUuZWwsXHJcbiAgICAgICAgICAgICAgICBiaW5kaW5nLFxyXG4gICAgICAgICAgICAgICAgdm5vZGUsXHJcbiAgICAgICAgICAgICAgICBwcmV2Vk5vZGVcclxuICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgIHJlc2V0VHJhY2tpbmcoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuY29uc3QgQ09NUE9ORU5UUyA9ICdjb21wb25lbnRzJztcclxuY29uc3QgRElSRUNUSVZFUyA9ICdkaXJlY3RpdmVzJztcclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiByZXNvbHZlQ29tcG9uZW50KG5hbWUsIG1heWJlU2VsZlJlZmVyZW5jZSkge1xyXG4gICAgcmV0dXJuIHJlc29sdmVBc3NldChDT01QT05FTlRTLCBuYW1lLCB0cnVlLCBtYXliZVNlbGZSZWZlcmVuY2UpIHx8IG5hbWU7XHJcbn1cclxuY29uc3QgTlVMTF9EWU5BTUlDX0NPTVBPTkVOVCA9IFN5bWJvbCgpO1xyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHJlc29sdmVEeW5hbWljQ29tcG9uZW50KGNvbXBvbmVudCkge1xyXG4gICAgaWYgKGlzU3RyaW5nKGNvbXBvbmVudCkpIHtcclxuICAgICAgICByZXR1cm4gcmVzb2x2ZUFzc2V0KENPTVBPTkVOVFMsIGNvbXBvbmVudCwgZmFsc2UpIHx8IGNvbXBvbmVudDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIGludmFsaWQgdHlwZXMgd2lsbCBmYWxsdGhyb3VnaCB0byBjcmVhdGVWTm9kZSBhbmQgcmFpc2Ugd2FybmluZ1xyXG4gICAgICAgIHJldHVybiAoY29tcG9uZW50IHx8IE5VTExfRFlOQU1JQ19DT01QT05FTlQpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gcmVzb2x2ZURpcmVjdGl2ZShuYW1lKSB7XHJcbiAgICByZXR1cm4gcmVzb2x2ZUFzc2V0KERJUkVDVElWRVMsIG5hbWUpO1xyXG59XHJcbi8vIGltcGxlbWVudGF0aW9uXHJcbmZ1bmN0aW9uIHJlc29sdmVBc3NldCh0eXBlLCBuYW1lLCB3YXJuTWlzc2luZyA9IHRydWUsIG1heWJlU2VsZlJlZmVyZW5jZSA9IGZhbHNlKSB7XHJcbiAgICBjb25zdCBpbnN0YW5jZSA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSB8fCBjdXJyZW50SW5zdGFuY2U7XHJcbiAgICBpZiAoaW5zdGFuY2UpIHtcclxuICAgICAgICBjb25zdCBDb21wb25lbnQgPSBpbnN0YW5jZS50eXBlO1xyXG4gICAgICAgIC8vIGV4cGxpY2l0IHNlbGYgbmFtZSBoYXMgaGlnaGVzdCBwcmlvcml0eVxyXG4gICAgICAgIGlmICh0eXBlID09PSBDT01QT05FTlRTKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlbGZOYW1lID0gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpO1xyXG4gICAgICAgICAgICBpZiAoc2VsZk5hbWUgJiZcclxuICAgICAgICAgICAgICAgIChzZWxmTmFtZSA9PT0gbmFtZSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGZOYW1lID09PSBjYW1lbGl6ZShuYW1lKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGZOYW1lID09PSBjYXBpdGFsaXplKGNhbWVsaXplKG5hbWUpKSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBDb21wb25lbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVzID0gXHJcbiAgICAgICAgLy8gbG9jYWwgcmVnaXN0cmF0aW9uXHJcbiAgICAgICAgLy8gY2hlY2sgaW5zdGFuY2VbdHlwZV0gZmlyc3Qgd2hpY2ggaXMgcmVzb2x2ZWQgZm9yIG9wdGlvbnMgQVBJXHJcbiAgICAgICAgcmVzb2x2ZShpbnN0YW5jZVt0eXBlXSB8fCBDb21wb25lbnRbdHlwZV0sIG5hbWUpIHx8XHJcbiAgICAgICAgICAgIC8vIGdsb2JhbCByZWdpc3RyYXRpb25cclxuICAgICAgICAgICAgcmVzb2x2ZShpbnN0YW5jZS5hcHBDb250ZXh0W3R5cGVdLCBuYW1lKTtcclxuICAgICAgICBpZiAoIXJlcyAmJiBtYXliZVNlbGZSZWZlcmVuY2UpIHtcclxuICAgICAgICAgICAgLy8gZmFsbGJhY2sgdG8gaW1wbGljaXQgc2VsZi1yZWZlcmVuY2VcclxuICAgICAgICAgICAgcmV0dXJuIENvbXBvbmVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB3YXJuTWlzc2luZyAmJiAhcmVzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGV4dHJhID0gdHlwZSA9PT0gQ09NUE9ORU5UU1xyXG4gICAgICAgICAgICAgICAgPyBgXFxuSWYgdGhpcyBpcyBhIG5hdGl2ZSBjdXN0b20gZWxlbWVudCwgbWFrZSBzdXJlIHRvIGV4Y2x1ZGUgaXQgZnJvbSBgICtcclxuICAgICAgICAgICAgICAgICAgICBgY29tcG9uZW50IHJlc29sdXRpb24gdmlhIGNvbXBpbGVyT3B0aW9ucy5pc0N1c3RvbUVsZW1lbnQuYFxyXG4gICAgICAgICAgICAgICAgOiBgYDtcclxuICAgICAgICAgICAgd2FybihgRmFpbGVkIHRvIHJlc29sdmUgJHt0eXBlLnNsaWNlKDAsIC0xKX06ICR7bmFtZX0ke2V4dHJhfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgd2FybihgcmVzb2x2ZSR7Y2FwaXRhbGl6ZSh0eXBlLnNsaWNlKDAsIC0xKSl9IGAgK1xyXG4gICAgICAgICAgICBgY2FuIG9ubHkgYmUgdXNlZCBpbiByZW5kZXIoKSBvciBzZXR1cCgpLmApO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHJlc29sdmUocmVnaXN0cnksIG5hbWUpIHtcclxuICAgIHJldHVybiAocmVnaXN0cnkgJiZcclxuICAgICAgICAocmVnaXN0cnlbbmFtZV0gfHxcclxuICAgICAgICAgICAgcmVnaXN0cnlbY2FtZWxpemUobmFtZSldIHx8XHJcbiAgICAgICAgICAgIHJlZ2lzdHJ5W2NhcGl0YWxpemUoY2FtZWxpemUobmFtZSkpXSkpO1xyXG59XG5cbi8qKlxyXG4gKiBBY3R1YWwgaW1wbGVtZW50YXRpb25cclxuICovXHJcbmZ1bmN0aW9uIHJlbmRlckxpc3Qoc291cmNlLCByZW5kZXJJdGVtLCBjYWNoZSwgaW5kZXgpIHtcclxuICAgIGxldCByZXQ7XHJcbiAgICBjb25zdCBjYWNoZWQgPSAoY2FjaGUgJiYgY2FjaGVbaW5kZXhdKTtcclxuICAgIGlmIChpc0FycmF5KHNvdXJjZSkgfHwgaXNTdHJpbmcoc291cmNlKSkge1xyXG4gICAgICAgIHJldCA9IG5ldyBBcnJheShzb3VyY2UubGVuZ3RoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHNvdXJjZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgcmV0W2ldID0gcmVuZGVySXRlbShzb3VyY2VbaV0sIGksIHVuZGVmaW5lZCwgY2FjaGVkICYmIGNhY2hlZFtpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFOdW1iZXIuaXNJbnRlZ2VyKHNvdXJjZSkpIHtcclxuICAgICAgICAgICAgd2FybihgVGhlIHYtZm9yIHJhbmdlIGV4cGVjdCBhbiBpbnRlZ2VyIHZhbHVlIGJ1dCBnb3QgJHtzb3VyY2V9LmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXQgPSBuZXcgQXJyYXkoc291cmNlKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNvdXJjZTsgaSsrKSB7XHJcbiAgICAgICAgICAgIHJldFtpXSA9IHJlbmRlckl0ZW0oaSArIDEsIGksIHVuZGVmaW5lZCwgY2FjaGVkICYmIGNhY2hlZFtpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNPYmplY3Qoc291cmNlKSkge1xyXG4gICAgICAgIGlmIChzb3VyY2VbU3ltYm9sLml0ZXJhdG9yXSkge1xyXG4gICAgICAgICAgICByZXQgPSBBcnJheS5mcm9tKHNvdXJjZSwgKGl0ZW0sIGkpID0+IHJlbmRlckl0ZW0oaXRlbSwgaSwgdW5kZWZpbmVkLCBjYWNoZWQgJiYgY2FjaGVkW2ldKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcclxuICAgICAgICAgICAgcmV0ID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcclxuICAgICAgICAgICAgICAgIHJldFtpXSA9IHJlbmRlckl0ZW0oc291cmNlW2tleV0sIGtleSwgaSwgY2FjaGVkICYmIGNhY2hlZFtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXQgPSBbXTtcclxuICAgIH1cclxuICAgIGlmIChjYWNoZSkge1xyXG4gICAgICAgIGNhY2hlW2luZGV4XSA9IHJldDtcclxuICAgIH1cclxuICAgIHJldHVybiByZXQ7XHJcbn1cblxuLyoqXHJcbiAqIENvbXBpbGVyIHJ1bnRpbWUgaGVscGVyIGZvciBjcmVhdGluZyBkeW5hbWljIHNsb3RzIG9iamVjdFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlU2xvdHMoc2xvdHMsIGR5bmFtaWNTbG90cykge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkeW5hbWljU2xvdHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBzbG90ID0gZHluYW1pY1Nsb3RzW2ldO1xyXG4gICAgICAgIC8vIGFycmF5IG9mIGR5bmFtaWMgc2xvdCBnZW5lcmF0ZWQgYnkgPHRlbXBsYXRlIHYtZm9yPVwiLi4uXCIgI1suLi5dPlxyXG4gICAgICAgIGlmIChpc0FycmF5KHNsb3QpKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2xvdC5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgc2xvdHNbc2xvdFtqXS5uYW1lXSA9IHNsb3Rbal0uZm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc2xvdCkge1xyXG4gICAgICAgICAgICAvLyBjb25kaXRpb25hbCBzaW5nbGUgc2xvdCBnZW5lcmF0ZWQgYnkgPHRlbXBsYXRlIHYtaWY9XCIuLi5cIiAjZm9vPlxyXG4gICAgICAgICAgICBzbG90c1tzbG90Lm5hbWVdID0gc2xvdC5mbjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc2xvdHM7XHJcbn1cblxuLyoqXHJcbiAqIENvbXBpbGVyIHJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgYDxzbG90Lz5gXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiByZW5kZXJTbG90KHNsb3RzLCBuYW1lLCBwcm9wcyA9IHt9LCBcclxuLy8gdGhpcyBpcyBub3QgYSB1c2VyLWZhY2luZyBmdW5jdGlvbiwgc28gdGhlIGZhbGxiYWNrIGlzIGFsd2F5cyBnZW5lcmF0ZWQgYnlcclxuLy8gdGhlIGNvbXBpbGVyIGFuZCBndWFyYW50ZWVkIHRvIGJlIGEgZnVuY3Rpb24gcmV0dXJuaW5nIGFuIGFycmF5XHJcbmZhbGxiYWNrLCBub1Nsb3R0ZWQpIHtcclxuICAgIGlmIChjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UuaXNDRSB8fFxyXG4gICAgICAgIChjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UucGFyZW50ICYmXHJcbiAgICAgICAgICAgIGlzQXN5bmNXcmFwcGVyKGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZS5wYXJlbnQpICYmXHJcbiAgICAgICAgICAgIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZS5wYXJlbnQuaXNDRSkpIHtcclxuICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUoJ3Nsb3QnLCBuYW1lID09PSAnZGVmYXVsdCcgPyBudWxsIDogeyBuYW1lIH0sIGZhbGxiYWNrICYmIGZhbGxiYWNrKCkpO1xyXG4gICAgfVxyXG4gICAgbGV0IHNsb3QgPSBzbG90c1tuYW1lXTtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgc2xvdCAmJiBzbG90Lmxlbmd0aCA+IDEpIHtcclxuICAgICAgICB3YXJuKGBTU1Itb3B0aW1pemVkIHNsb3QgZnVuY3Rpb24gZGV0ZWN0ZWQgaW4gYSBub24tU1NSLW9wdGltaXplZCByZW5kZXIgYCArXHJcbiAgICAgICAgICAgIGBmdW5jdGlvbi4gWW91IG5lZWQgdG8gbWFyayB0aGlzIGNvbXBvbmVudCB3aXRoICRkeW5hbWljLXNsb3RzIGluIHRoZSBgICtcclxuICAgICAgICAgICAgYHBhcmVudCB0ZW1wbGF0ZS5gKTtcclxuICAgICAgICBzbG90ID0gKCkgPT4gW107XHJcbiAgICB9XHJcbiAgICAvLyBhIGNvbXBpbGVkIHNsb3QgZGlzYWJsZXMgYmxvY2sgdHJhY2tpbmcgYnkgZGVmYXVsdCB0byBhdm9pZCBtYW51YWxcclxuICAgIC8vIGludm9jYXRpb24gaW50ZXJmZXJpbmcgd2l0aCB0ZW1wbGF0ZS1iYXNlZCBibG9jayB0cmFja2luZywgYnV0IGluXHJcbiAgICAvLyBgcmVuZGVyU2xvdGAgd2UgY2FuIGJlIHN1cmUgdGhhdCBpdCdzIHRlbXBsYXRlLWJhc2VkIHNvIHdlIGNhbiBmb3JjZVxyXG4gICAgLy8gZW5hYmxlIGl0LlxyXG4gICAgaWYgKHNsb3QgJiYgc2xvdC5fYykge1xyXG4gICAgICAgIHNsb3QuX2QgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIG9wZW5CbG9jaygpO1xyXG4gICAgY29uc3QgdmFsaWRTbG90Q29udGVudCA9IHNsb3QgJiYgZW5zdXJlVmFsaWRWTm9kZShzbG90KHByb3BzKSk7XHJcbiAgICBjb25zdCByZW5kZXJlZCA9IGNyZWF0ZUJsb2NrKEZyYWdtZW50LCB7IGtleTogcHJvcHMua2V5IHx8IGBfJHtuYW1lfWAgfSwgdmFsaWRTbG90Q29udGVudCB8fCAoZmFsbGJhY2sgPyBmYWxsYmFjaygpIDogW10pLCB2YWxpZFNsb3RDb250ZW50ICYmIHNsb3RzLl8gPT09IDEgLyogU1RBQkxFICovXHJcbiAgICAgICAgPyA2NCAvKiBTVEFCTEVfRlJBR01FTlQgKi9cclxuICAgICAgICA6IC0yIC8qIEJBSUwgKi8pO1xyXG4gICAgaWYgKCFub1Nsb3R0ZWQgJiYgcmVuZGVyZWQuc2NvcGVJZCkge1xyXG4gICAgICAgIHJlbmRlcmVkLnNsb3RTY29wZUlkcyA9IFtyZW5kZXJlZC5zY29wZUlkICsgJy1zJ107XHJcbiAgICB9XHJcbiAgICBpZiAoc2xvdCAmJiBzbG90Ll9jKSB7XHJcbiAgICAgICAgc2xvdC5fZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVuZGVyZWQ7XHJcbn1cclxuZnVuY3Rpb24gZW5zdXJlVmFsaWRWTm9kZSh2bm9kZXMpIHtcclxuICAgIHJldHVybiB2bm9kZXMuc29tZShjaGlsZCA9PiB7XHJcbiAgICAgICAgaWYgKCFpc1ZOb2RlKGNoaWxkKSlcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IENvbW1lbnQpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gRnJhZ21lbnQgJiZcclxuICAgICAgICAgICAgIWVuc3VyZVZhbGlkVk5vZGUoY2hpbGQuY2hpbGRyZW4pKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9KVxyXG4gICAgICAgID8gdm5vZGVzXHJcbiAgICAgICAgOiBudWxsO1xyXG59XG5cbi8qKlxyXG4gKiBGb3IgcHJlZml4aW5nIGtleXMgaW4gdi1vbj1cIm9ialwiIHdpdGggXCJvblwiXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiB0b0hhbmRsZXJzKG9iaikge1xyXG4gICAgY29uc3QgcmV0ID0ge307XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFpc09iamVjdChvYmopKSB7XHJcbiAgICAgICAgd2Fybihgdi1vbiB3aXRoIG5vIGFyZ3VtZW50IGV4cGVjdHMgYW4gb2JqZWN0IHZhbHVlLmApO1xyXG4gICAgICAgIHJldHVybiByZXQ7XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcclxuICAgICAgICByZXRbdG9IYW5kbGVyS2V5KGtleSldID0gb2JqW2tleV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG59XG5cbi8qKlxyXG4gKiAjMjQzNyBJbiBWdWUgMywgZnVuY3Rpb25hbCBjb21wb25lbnRzIGRvIG5vdCBoYXZlIGEgcHVibGljIGluc3RhbmNlIHByb3h5IGJ1dFxyXG4gKiB0aGV5IGV4aXN0IGluIHRoZSBpbnRlcm5hbCBwYXJlbnQgY2hhaW4uIEZvciBjb2RlIHRoYXQgcmVsaWVzIG9uIHRyYXZlcnNpbmdcclxuICogcHVibGljICRwYXJlbnQgY2hhaW5zLCBza2lwIGZ1bmN0aW9uYWwgb25lcyBhbmQgZ28gdG8gdGhlIHBhcmVudCBpbnN0ZWFkLlxyXG4gKi9cclxuY29uc3QgZ2V0UHVibGljSW5zdGFuY2UgPSAoaSkgPT4ge1xyXG4gICAgaWYgKCFpKVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgaWYgKGlzU3RhdGVmdWxDb21wb25lbnQoaSkpXHJcbiAgICAgICAgcmV0dXJuIGdldEV4cG9zZVByb3h5KGkpIHx8IGkucHJveHk7XHJcbiAgICByZXR1cm4gZ2V0UHVibGljSW5zdGFuY2UoaS5wYXJlbnQpO1xyXG59O1xyXG5jb25zdCBwdWJsaWNQcm9wZXJ0aWVzTWFwID0gXHJcbi8vIE1vdmUgUFVSRSBtYXJrZXIgdG8gbmV3IGxpbmUgdG8gd29ya2Fyb3VuZCBjb21waWxlciBkaXNjYXJkaW5nIGl0XHJcbi8vIGR1ZSB0byB0eXBlIGFubm90YXRpb25cclxuLyojX19QVVJFX18qLyBleHRlbmQoT2JqZWN0LmNyZWF0ZShudWxsKSwge1xyXG4gICAgJDogaSA9PiBpLFxyXG4gICAgJGVsOiBpID0+IGkudm5vZGUuZWwsXHJcbiAgICAkZGF0YTogaSA9PiBpLmRhdGEsXHJcbiAgICAkcHJvcHM6IGkgPT4gKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IHNoYWxsb3dSZWFkb25seShpLnByb3BzKSA6IGkucHJvcHMpLFxyXG4gICAgJGF0dHJzOiBpID0+ICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBzaGFsbG93UmVhZG9ubHkoaS5hdHRycykgOiBpLmF0dHJzKSxcclxuICAgICRzbG90czogaSA9PiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gc2hhbGxvd1JlYWRvbmx5KGkuc2xvdHMpIDogaS5zbG90cyksXHJcbiAgICAkcmVmczogaSA9PiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gc2hhbGxvd1JlYWRvbmx5KGkucmVmcykgOiBpLnJlZnMpLFxyXG4gICAgJHBhcmVudDogaSA9PiBnZXRQdWJsaWNJbnN0YW5jZShpLnBhcmVudCksXHJcbiAgICAkcm9vdDogaSA9PiBnZXRQdWJsaWNJbnN0YW5jZShpLnJvb3QpLFxyXG4gICAgJGVtaXQ6IGkgPT4gaS5lbWl0LFxyXG4gICAgJG9wdGlvbnM6IGkgPT4gKF9fVlVFX09QVElPTlNfQVBJX18gPyByZXNvbHZlTWVyZ2VkT3B0aW9ucyhpKSA6IGkudHlwZSksXHJcbiAgICAkZm9yY2VVcGRhdGU6IGkgPT4gaS5mIHx8IChpLmYgPSAoKSA9PiBxdWV1ZUpvYihpLnVwZGF0ZSkpLFxyXG4gICAgJG5leHRUaWNrOiBpID0+IGkubiB8fCAoaS5uID0gbmV4dFRpY2suYmluZChpLnByb3h5KSksXHJcbiAgICAkd2F0Y2g6IGkgPT4gKF9fVlVFX09QVElPTlNfQVBJX18gPyBpbnN0YW5jZVdhdGNoLmJpbmQoaSkgOiBOT09QKVxyXG59KTtcclxuY29uc3QgaXNSZXNlcnZlZFByZWZpeCA9IChrZXkpID0+IGtleSA9PT0gJ18nIHx8IGtleSA9PT0gJyQnO1xyXG5jb25zdCBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMgPSB7XHJcbiAgICBnZXQoeyBfOiBpbnN0YW5jZSB9LCBrZXkpIHtcclxuICAgICAgICBjb25zdCB7IGN0eCwgc2V0dXBTdGF0ZSwgZGF0YSwgcHJvcHMsIGFjY2Vzc0NhY2hlLCB0eXBlLCBhcHBDb250ZXh0IH0gPSBpbnN0YW5jZTtcclxuICAgICAgICAvLyBmb3IgaW50ZXJuYWwgZm9ybWF0dGVycyB0byBrbm93IHRoYXQgdGhpcyBpcyBhIFZ1ZSBpbnN0YW5jZVxyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYga2V5ID09PSAnX19pc1Z1ZScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHByaW9yaXRpemUgPHNjcmlwdCBzZXR1cD4gYmluZGluZ3MgZHVyaW5nIGRldi5cclxuICAgICAgICAvLyB0aGlzIGFsbG93cyBldmVuIHByb3BlcnRpZXMgdGhhdCBzdGFydCB3aXRoIF8gb3IgJCB0byBiZSB1c2VkIC0gc28gdGhhdFxyXG4gICAgICAgIC8vIGl0IGFsaWducyB3aXRoIHRoZSBwcm9kdWN0aW9uIGJlaGF2aW9yIHdoZXJlIHRoZSByZW5kZXIgZm4gaXMgaW5saW5lZCBhbmRcclxuICAgICAgICAvLyBpbmRlZWQgaGFzIGFjY2VzcyB0byBhbGwgZGVjbGFyZWQgdmFyaWFibGVzLlxyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgc2V0dXBTdGF0ZSAhPT0gRU1QVFlfT0JKICYmXHJcbiAgICAgICAgICAgIHNldHVwU3RhdGUuX19pc1NjcmlwdFNldHVwICYmXHJcbiAgICAgICAgICAgIGhhc093bihzZXR1cFN0YXRlLCBrZXkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzZXR1cFN0YXRlW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGRhdGEgLyBwcm9wcyAvIGN0eFxyXG4gICAgICAgIC8vIFRoaXMgZ2V0dGVyIGdldHMgY2FsbGVkIGZvciBldmVyeSBwcm9wZXJ0eSBhY2Nlc3Mgb24gdGhlIHJlbmRlciBjb250ZXh0XHJcbiAgICAgICAgLy8gZHVyaW5nIHJlbmRlciBhbmQgaXMgYSBtYWpvciBob3RzcG90LiBUaGUgbW9zdCBleHBlbnNpdmUgcGFydCBvZiB0aGlzXHJcbiAgICAgICAgLy8gaXMgdGhlIG11bHRpcGxlIGhhc093bigpIGNhbGxzLiBJdCdzIG11Y2ggZmFzdGVyIHRvIGRvIGEgc2ltcGxlIHByb3BlcnR5XHJcbiAgICAgICAgLy8gYWNjZXNzIG9uIGEgcGxhaW4gb2JqZWN0LCBzbyB3ZSB1c2UgYW4gYWNjZXNzQ2FjaGUgb2JqZWN0ICh3aXRoIG51bGxcclxuICAgICAgICAvLyBwcm90b3R5cGUpIHRvIG1lbW9pemUgd2hhdCBhY2Nlc3MgdHlwZSBhIGtleSBjb3JyZXNwb25kcyB0by5cclxuICAgICAgICBsZXQgbm9ybWFsaXplZFByb3BzO1xyXG4gICAgICAgIGlmIChrZXlbMF0gIT09ICckJykge1xyXG4gICAgICAgICAgICBjb25zdCBuID0gYWNjZXNzQ2FjaGVba2V5XTtcclxuICAgICAgICAgICAgaWYgKG4gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxIC8qIFNFVFVQICovOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0dXBTdGF0ZVtrZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMiAvKiBEQVRBICovOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YVtrZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNCAvKiBDT05URVhUICovOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3R4W2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzIC8qIFBST1BTICovOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvcHNba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBkZWZhdWx0OiBqdXN0IGZhbGx0aHJvdWdoXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc2V0dXBTdGF0ZSAhPT0gRU1QVFlfT0JKICYmIGhhc093bihzZXR1cFN0YXRlLCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBhY2Nlc3NDYWNoZVtrZXldID0gMSAvKiBTRVRVUCAqLztcclxuICAgICAgICAgICAgICAgIHJldHVybiBzZXR1cFN0YXRlW2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZGF0YSAhPT0gRU1QVFlfT0JKICYmIGhhc093bihkYXRhLCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBhY2Nlc3NDYWNoZVtrZXldID0gMiAvKiBEQVRBICovO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChcclxuICAgICAgICAgICAgLy8gb25seSBjYWNoZSBvdGhlciBwcm9wZXJ0aWVzIHdoZW4gaW5zdGFuY2UgaGFzIGRlY2xhcmVkICh0aHVzIHN0YWJsZSlcclxuICAgICAgICAgICAgLy8gcHJvcHNcclxuICAgICAgICAgICAgKG5vcm1hbGl6ZWRQcm9wcyA9IGluc3RhbmNlLnByb3BzT3B0aW9uc1swXSkgJiZcclxuICAgICAgICAgICAgICAgIGhhc093bihub3JtYWxpemVkUHJvcHMsIGtleSkpIHtcclxuICAgICAgICAgICAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSAzIC8qIFBST1BTICovO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3BzW2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY3R4ICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKGN0eCwga2V5KSkge1xyXG4gICAgICAgICAgICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDQgLyogQ09OVEVYVCAqLztcclxuICAgICAgICAgICAgICAgIHJldHVybiBjdHhba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghX19WVUVfT1BUSU9OU19BUElfXyB8fCBzaG91bGRDYWNoZUFjY2Vzcykge1xyXG4gICAgICAgICAgICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDAgLyogT1RIRVIgKi87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcHVibGljR2V0dGVyID0gcHVibGljUHJvcGVydGllc01hcFtrZXldO1xyXG4gICAgICAgIGxldCBjc3NNb2R1bGUsIGdsb2JhbFByb3BlcnRpZXM7XHJcbiAgICAgICAgLy8gcHVibGljICR4eHggcHJvcGVydGllc1xyXG4gICAgICAgIGlmIChwdWJsaWNHZXR0ZXIpIHtcclxuICAgICAgICAgICAgaWYgKGtleSA9PT0gJyRhdHRycycpIHtcclxuICAgICAgICAgICAgICAgIHRyYWNrKGluc3RhbmNlLCBcImdldFwiIC8qIEdFVCAqLywga2V5KTtcclxuICAgICAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBtYXJrQXR0cnNBY2Nlc3NlZCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBwdWJsaWNHZXR0ZXIoaW5zdGFuY2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChcclxuICAgICAgICAvLyBjc3MgbW9kdWxlIChpbmplY3RlZCBieSB2dWUtbG9hZGVyKVxyXG4gICAgICAgIChjc3NNb2R1bGUgPSB0eXBlLl9fY3NzTW9kdWxlcykgJiZcclxuICAgICAgICAgICAgKGNzc01vZHVsZSA9IGNzc01vZHVsZVtrZXldKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gY3NzTW9kdWxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjdHggIT09IEVNUFRZX09CSiAmJiBoYXNPd24oY3R4LCBrZXkpKSB7XHJcbiAgICAgICAgICAgIC8vIHVzZXIgbWF5IHNldCBjdXN0b20gcHJvcGVydGllcyB0byBgdGhpc2AgdGhhdCBzdGFydCB3aXRoIGAkYFxyXG4gICAgICAgICAgICBhY2Nlc3NDYWNoZVtrZXldID0gNCAvKiBDT05URVhUICovO1xyXG4gICAgICAgICAgICByZXR1cm4gY3R4W2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKFxyXG4gICAgICAgIC8vIGdsb2JhbCBwcm9wZXJ0aWVzXHJcbiAgICAgICAgKChnbG9iYWxQcm9wZXJ0aWVzID0gYXBwQ29udGV4dC5jb25maWcuZ2xvYmFsUHJvcGVydGllcyksXHJcbiAgICAgICAgICAgIGhhc093bihnbG9iYWxQcm9wZXJ0aWVzLCBrZXkpKSkge1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2xvYmFsUHJvcGVydGllc1trZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgJiZcclxuICAgICAgICAgICAgKCFpc1N0cmluZyhrZXkpIHx8XHJcbiAgICAgICAgICAgICAgICAvLyAjMTA5MSBhdm9pZCBpbnRlcm5hbCBpc1JlZi9pc1ZOb2RlIGNoZWNrcyBvbiBjb21wb25lbnQgaW5zdGFuY2UgbGVhZGluZ1xyXG4gICAgICAgICAgICAgICAgLy8gdG8gaW5maW5pdGUgd2FybmluZyBsb29wXHJcbiAgICAgICAgICAgICAgICBrZXkuaW5kZXhPZignX192JykgIT09IDApKSB7XHJcbiAgICAgICAgICAgIGlmIChkYXRhICE9PSBFTVBUWV9PQkogJiYgaXNSZXNlcnZlZFByZWZpeChrZXlbMF0pICYmIGhhc093bihkYXRhLCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKGBQcm9wZXJ0eSAke0pTT04uc3RyaW5naWZ5KGtleSl9IG11c3QgYmUgYWNjZXNzZWQgdmlhICRkYXRhIGJlY2F1c2UgaXQgc3RhcnRzIHdpdGggYSByZXNlcnZlZCBgICtcclxuICAgICAgICAgICAgICAgICAgICBgY2hhcmFjdGVyIChcIiRcIiBvciBcIl9cIikgYW5kIGlzIG5vdCBwcm94aWVkIG9uIHRoZSByZW5kZXIgY29udGV4dC5gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpbnN0YW5jZSA9PT0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKGBQcm9wZXJ0eSAke0pTT04uc3RyaW5naWZ5KGtleSl9IHdhcyBhY2Nlc3NlZCBkdXJpbmcgcmVuZGVyIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBidXQgaXMgbm90IGRlZmluZWQgb24gaW5zdGFuY2UuYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgc2V0KHsgXzogaW5zdGFuY2UgfSwga2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IHsgZGF0YSwgc2V0dXBTdGF0ZSwgY3R4IH0gPSBpbnN0YW5jZTtcclxuICAgICAgICBpZiAoc2V0dXBTdGF0ZSAhPT0gRU1QVFlfT0JKICYmIGhhc093bihzZXR1cFN0YXRlLCBrZXkpKSB7XHJcbiAgICAgICAgICAgIHNldHVwU3RhdGVba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZGF0YSAhPT0gRU1QVFlfT0JKICYmIGhhc093bihkYXRhLCBrZXkpKSB7XHJcbiAgICAgICAgICAgIGRhdGFba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaGFzT3duKGluc3RhbmNlLnByb3BzLCBrZXkpKSB7XHJcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgd2FybihgQXR0ZW1wdGluZyB0byBtdXRhdGUgcHJvcCBcIiR7a2V5fVwiLiBQcm9wcyBhcmUgcmVhZG9ubHkuYCwgaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChrZXlbMF0gPT09ICckJyAmJiBrZXkuc2xpY2UoMSkgaW4gaW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgICAgICB3YXJuKGBBdHRlbXB0aW5nIHRvIG11dGF0ZSBwdWJsaWMgcHJvcGVydHkgXCIke2tleX1cIi4gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYFByb3BlcnRpZXMgc3RhcnRpbmcgd2l0aCAkIGFyZSByZXNlcnZlZCBhbmQgcmVhZG9ubHkuYCwgaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGtleSBpbiBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZy5nbG9iYWxQcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcclxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjdHhba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSxcclxuICAgIGhhcyh7IF86IHsgZGF0YSwgc2V0dXBTdGF0ZSwgYWNjZXNzQ2FjaGUsIGN0eCwgYXBwQ29udGV4dCwgcHJvcHNPcHRpb25zIH0gfSwga2V5KSB7XHJcbiAgICAgICAgbGV0IG5vcm1hbGl6ZWRQcm9wcztcclxuICAgICAgICByZXR1cm4gKCEhYWNjZXNzQ2FjaGVba2V5XSB8fFxyXG4gICAgICAgICAgICAoZGF0YSAhPT0gRU1QVFlfT0JKICYmIGhhc093bihkYXRhLCBrZXkpKSB8fFxyXG4gICAgICAgICAgICAoc2V0dXBTdGF0ZSAhPT0gRU1QVFlfT0JKICYmIGhhc093bihzZXR1cFN0YXRlLCBrZXkpKSB8fFxyXG4gICAgICAgICAgICAoKG5vcm1hbGl6ZWRQcm9wcyA9IHByb3BzT3B0aW9uc1swXSkgJiYgaGFzT3duKG5vcm1hbGl6ZWRQcm9wcywga2V5KSkgfHxcclxuICAgICAgICAgICAgaGFzT3duKGN0eCwga2V5KSB8fFxyXG4gICAgICAgICAgICBoYXNPd24ocHVibGljUHJvcGVydGllc01hcCwga2V5KSB8fFxyXG4gICAgICAgICAgICBoYXNPd24oYXBwQ29udGV4dC5jb25maWcuZ2xvYmFsUHJvcGVydGllcywga2V5KSk7XHJcbiAgICB9LFxyXG4gICAgZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGRlc2NyaXB0b3IpIHtcclxuICAgICAgICBpZiAoZGVzY3JpcHRvci5nZXQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvLyBpbnZhbGlkYXRlIGtleSBjYWNoZSBvZiBhIGdldHRlciBiYXNlZCBwcm9wZXJ0eSAjNTQxN1xyXG4gICAgICAgICAgICB0YXJnZXQuXy5hY2Nlc3NDYWNoZVtrZXldID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaGFzT3duKGRlc2NyaXB0b3IsICd2YWx1ZScpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0KHRhcmdldCwga2V5LCBkZXNjcmlwdG9yLnZhbHVlLCBudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGRlc2NyaXB0b3IpO1xyXG4gICAgfVxyXG59O1xyXG5pZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFmYWxzZSkge1xyXG4gICAgUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzLm93bktleXMgPSAodGFyZ2V0KSA9PiB7XHJcbiAgICAgICAgd2FybihgQXZvaWQgYXBwIGxvZ2ljIHRoYXQgcmVsaWVzIG9uIGVudW1lcmF0aW5nIGtleXMgb24gYSBjb21wb25lbnQgaW5zdGFuY2UuIGAgK1xyXG4gICAgICAgICAgICBgVGhlIGtleXMgd2lsbCBiZSBlbXB0eSBpbiBwcm9kdWN0aW9uIG1vZGUgdG8gYXZvaWQgcGVyZm9ybWFuY2Ugb3ZlcmhlYWQuYCk7XHJcbiAgICAgICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpO1xyXG4gICAgfTtcclxufVxyXG5jb25zdCBSdW50aW1lQ29tcGlsZWRQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMgPSAvKiNfX1BVUkVfXyovIGV4dGVuZCh7fSwgUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzLCB7XHJcbiAgICBnZXQodGFyZ2V0LCBrZXkpIHtcclxuICAgICAgICAvLyBmYXN0IHBhdGggZm9yIHVuc2NvcGFibGVzIHdoZW4gdXNpbmcgYHdpdGhgIGJsb2NrXHJcbiAgICAgICAgaWYgKGtleSA9PT0gU3ltYm9sLnVuc2NvcGFibGVzKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycy5nZXQodGFyZ2V0LCBrZXksIHRhcmdldCk7XHJcbiAgICB9LFxyXG4gICAgaGFzKF8sIGtleSkge1xyXG4gICAgICAgIGNvbnN0IGhhcyA9IGtleVswXSAhPT0gJ18nICYmICFpc0dsb2JhbGx5V2hpdGVsaXN0ZWQoa2V5KTtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFoYXMgJiYgUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzLmhhcyhfLCBrZXkpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYFByb3BlcnR5ICR7SlNPTi5zdHJpbmdpZnkoa2V5KX0gc2hvdWxkIG5vdCBzdGFydCB3aXRoIF8gd2hpY2ggaXMgYSByZXNlcnZlZCBwcmVmaXggZm9yIFZ1ZSBpbnRlcm5hbHMuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBoYXM7XHJcbiAgICB9XHJcbn0pO1xyXG4vLyBkZXYgb25seVxyXG4vLyBJbiBkZXYgbW9kZSwgdGhlIHByb3h5IHRhcmdldCBleHBvc2VzIHRoZSBzYW1lIHByb3BlcnRpZXMgYXMgc2VlbiBvbiBgdGhpc2BcclxuLy8gZm9yIGVhc2llciBjb25zb2xlIGluc3BlY3Rpb24uIEluIHByb2QgbW9kZSBpdCB3aWxsIGJlIGFuIGVtcHR5IG9iamVjdCBzb1xyXG4vLyB0aGVzZSBwcm9wZXJ0aWVzIGRlZmluaXRpb25zIGNhbiBiZSBza2lwcGVkLlxyXG5mdW5jdGlvbiBjcmVhdGVEZXZSZW5kZXJDb250ZXh0KGluc3RhbmNlKSB7XHJcbiAgICBjb25zdCB0YXJnZXQgPSB7fTtcclxuICAgIC8vIGV4cG9zZSBpbnRlcm5hbCBpbnN0YW5jZSBmb3IgcHJveHkgaGFuZGxlcnNcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGBfYCwge1xyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBnZXQ6ICgpID0+IGluc3RhbmNlXHJcbiAgICB9KTtcclxuICAgIC8vIGV4cG9zZSBwdWJsaWMgcHJvcGVydGllc1xyXG4gICAgT2JqZWN0LmtleXMocHVibGljUHJvcGVydGllc01hcCkuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwge1xyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICBnZXQ6ICgpID0+IHB1YmxpY1Byb3BlcnRpZXNNYXBba2V5XShpbnN0YW5jZSksXHJcbiAgICAgICAgICAgIC8vIGludGVyY2VwdGVkIGJ5IHRoZSBwcm94eSBzbyBubyBuZWVkIGZvciBpbXBsZW1lbnRhdGlvbixcclxuICAgICAgICAgICAgLy8gYnV0IG5lZWRlZCB0byBwcmV2ZW50IHNldCBlcnJvcnNcclxuICAgICAgICAgICAgc2V0OiBOT09QXHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbn1cclxuLy8gZGV2IG9ubHlcclxuZnVuY3Rpb24gZXhwb3NlUHJvcHNPblJlbmRlckNvbnRleHQoaW5zdGFuY2UpIHtcclxuICAgIGNvbnN0IHsgY3R4LCBwcm9wc09wdGlvbnM6IFtwcm9wc09wdGlvbnNdIH0gPSBpbnN0YW5jZTtcclxuICAgIGlmIChwcm9wc09wdGlvbnMpIHtcclxuICAgICAgICBPYmplY3Qua2V5cyhwcm9wc09wdGlvbnMpLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgZ2V0OiAoKSA9PiBpbnN0YW5jZS5wcm9wc1trZXldLFxyXG4gICAgICAgICAgICAgICAgc2V0OiBOT09QXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbi8vIGRldiBvbmx5XHJcbmZ1bmN0aW9uIGV4cG9zZVNldHVwU3RhdGVPblJlbmRlckNvbnRleHQoaW5zdGFuY2UpIHtcclxuICAgIGNvbnN0IHsgY3R4LCBzZXR1cFN0YXRlIH0gPSBpbnN0YW5jZTtcclxuICAgIE9iamVjdC5rZXlzKHRvUmF3KHNldHVwU3RhdGUpKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgaWYgKCFzZXR1cFN0YXRlLl9faXNTY3JpcHRTZXR1cCkge1xyXG4gICAgICAgICAgICBpZiAoaXNSZXNlcnZlZFByZWZpeChrZXlbMF0pKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKGBzZXR1cCgpIHJldHVybiBwcm9wZXJ0eSAke0pTT04uc3RyaW5naWZ5KGtleSl9IHNob3VsZCBub3Qgc3RhcnQgd2l0aCBcIiRcIiBvciBcIl9cIiBgICtcclxuICAgICAgICAgICAgICAgICAgICBgd2hpY2ggYXJlIHJlc2VydmVkIHByZWZpeGVzIGZvciBWdWUgaW50ZXJuYWxzLmApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xyXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGdldDogKCkgPT4gc2V0dXBTdGF0ZVtrZXldLFxyXG4gICAgICAgICAgICAgICAgc2V0OiBOT09QXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUR1cGxpY2F0ZUNoZWNrZXIoKSB7XHJcbiAgICBjb25zdCBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICByZXR1cm4gKHR5cGUsIGtleSkgPT4ge1xyXG4gICAgICAgIGlmIChjYWNoZVtrZXldKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYCR7dHlwZX0gcHJvcGVydHkgXCIke2tleX1cIiBpcyBhbHJlYWR5IGRlZmluZWQgaW4gJHtjYWNoZVtrZXldfS5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNhY2hlW2tleV0gPSB0eXBlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxubGV0IHNob3VsZENhY2hlQWNjZXNzID0gdHJ1ZTtcclxuZnVuY3Rpb24gYXBwbHlPcHRpb25zKGluc3RhbmNlKSB7XHJcbiAgICBjb25zdCBvcHRpb25zID0gcmVzb2x2ZU1lcmdlZE9wdGlvbnMoaW5zdGFuY2UpO1xyXG4gICAgY29uc3QgcHVibGljVGhpcyA9IGluc3RhbmNlLnByb3h5O1xyXG4gICAgY29uc3QgY3R4ID0gaW5zdGFuY2UuY3R4O1xyXG4gICAgLy8gZG8gbm90IGNhY2hlIHByb3BlcnR5IGFjY2VzcyBvbiBwdWJsaWMgcHJveHkgZHVyaW5nIHN0YXRlIGluaXRpYWxpemF0aW9uXHJcbiAgICBzaG91bGRDYWNoZUFjY2VzcyA9IGZhbHNlO1xyXG4gICAgLy8gY2FsbCBiZWZvcmVDcmVhdGUgZmlyc3QgYmVmb3JlIGFjY2Vzc2luZyBvdGhlciBvcHRpb25zIHNpbmNlXHJcbiAgICAvLyB0aGUgaG9vayBtYXkgbXV0YXRlIHJlc29sdmVkIG9wdGlvbnMgKCMyNzkxKVxyXG4gICAgaWYgKG9wdGlvbnMuYmVmb3JlQ3JlYXRlKSB7XHJcbiAgICAgICAgY2FsbEhvb2sob3B0aW9ucy5iZWZvcmVDcmVhdGUsIGluc3RhbmNlLCBcImJjXCIgLyogQkVGT1JFX0NSRUFURSAqLyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB7IFxyXG4gICAgLy8gc3RhdGVcclxuICAgIGRhdGE6IGRhdGFPcHRpb25zLCBjb21wdXRlZDogY29tcHV0ZWRPcHRpb25zLCBtZXRob2RzLCB3YXRjaDogd2F0Y2hPcHRpb25zLCBwcm92aWRlOiBwcm92aWRlT3B0aW9ucywgaW5qZWN0OiBpbmplY3RPcHRpb25zLCBcclxuICAgIC8vIGxpZmVjeWNsZVxyXG4gICAgY3JlYXRlZCwgYmVmb3JlTW91bnQsIG1vdW50ZWQsIGJlZm9yZVVwZGF0ZSwgdXBkYXRlZCwgYWN0aXZhdGVkLCBkZWFjdGl2YXRlZCwgYmVmb3JlRGVzdHJveSwgYmVmb3JlVW5tb3VudCwgZGVzdHJveWVkLCB1bm1vdW50ZWQsIHJlbmRlciwgcmVuZGVyVHJhY2tlZCwgcmVuZGVyVHJpZ2dlcmVkLCBlcnJvckNhcHR1cmVkLCBzZXJ2ZXJQcmVmZXRjaCwgXHJcbiAgICAvLyBwdWJsaWMgQVBJXHJcbiAgICBleHBvc2UsIGluaGVyaXRBdHRycywgXHJcbiAgICAvLyBhc3NldHNcclxuICAgIGNvbXBvbmVudHMsIGRpcmVjdGl2ZXMsIGZpbHRlcnMgfSA9IG9wdGlvbnM7XHJcbiAgICBjb25zdCBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBjcmVhdGVEdXBsaWNhdGVDaGVja2VyKCkgOiBudWxsO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGNvbnN0IFtwcm9wc09wdGlvbnNdID0gaW5zdGFuY2UucHJvcHNPcHRpb25zO1xyXG4gICAgICAgIGlmIChwcm9wc09wdGlvbnMpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHNPcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMoXCJQcm9wc1wiIC8qIFBST1BTICovLCBrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gb3B0aW9ucyBpbml0aWFsaXphdGlvbiBvcmRlciAodG8gYmUgY29uc2lzdGVudCB3aXRoIFZ1ZSAyKTpcclxuICAgIC8vIC0gcHJvcHMgKGFscmVhZHkgZG9uZSBvdXRzaWRlIG9mIHRoaXMgZnVuY3Rpb24pXHJcbiAgICAvLyAtIGluamVjdFxyXG4gICAgLy8gLSBtZXRob2RzXHJcbiAgICAvLyAtIGRhdGEgKGRlZmVycmVkIHNpbmNlIGl0IHJlbGllcyBvbiBgdGhpc2AgYWNjZXNzKVxyXG4gICAgLy8gLSBjb21wdXRlZFxyXG4gICAgLy8gLSB3YXRjaCAoZGVmZXJyZWQgc2luY2UgaXQgcmVsaWVzIG9uIGB0aGlzYCBhY2Nlc3MpXHJcbiAgICBpZiAoaW5qZWN0T3B0aW9ucykge1xyXG4gICAgICAgIHJlc29sdmVJbmplY3Rpb25zKGluamVjdE9wdGlvbnMsIGN0eCwgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzLCBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZy51bndyYXBJbmplY3RlZFJlZik7XHJcbiAgICB9XHJcbiAgICBpZiAobWV0aG9kcykge1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG1ldGhvZHMpIHtcclxuICAgICAgICAgICAgY29uc3QgbWV0aG9kSGFuZGxlciA9IG1ldGhvZHNba2V5XTtcclxuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24obWV0aG9kSGFuZGxlcikpIHtcclxuICAgICAgICAgICAgICAgIC8vIEluIGRldiBtb2RlLCB3ZSB1c2UgdGhlIGBjcmVhdGVSZW5kZXJDb250ZXh0YCBmdW5jdGlvbiB0byBkZWZpbmVcclxuICAgICAgICAgICAgICAgIC8vIG1ldGhvZHMgdG8gdGhlIHByb3h5IHRhcmdldCwgYW5kIHRob3NlIGFyZSByZWFkLW9ubHkgYnV0XHJcbiAgICAgICAgICAgICAgICAvLyByZWNvbmZpZ3VyYWJsZSwgc28gaXQgbmVlZHMgdG8gYmUgcmVkZWZpbmVkIGhlcmVcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG1ldGhvZEhhbmRsZXIuYmluZChwdWJsaWNUaGlzKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4W2tleV0gPSBtZXRob2RIYW5kbGVyLmJpbmQocHVibGljVGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKFwiTWV0aG9kc1wiIC8qIE1FVEhPRFMgKi8sIGtleSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKGBNZXRob2QgXCIke2tleX1cIiBoYXMgdHlwZSBcIiR7dHlwZW9mIG1ldGhvZEhhbmRsZXJ9XCIgaW4gdGhlIGNvbXBvbmVudCBkZWZpbml0aW9uLiBgICtcclxuICAgICAgICAgICAgICAgICAgICBgRGlkIHlvdSByZWZlcmVuY2UgdGhlIGZ1bmN0aW9uIGNvcnJlY3RseT9gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChkYXRhT3B0aW9ucykge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWlzRnVuY3Rpb24oZGF0YU9wdGlvbnMpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYFRoZSBkYXRhIG9wdGlvbiBtdXN0IGJlIGEgZnVuY3Rpb24uIGAgK1xyXG4gICAgICAgICAgICAgICAgYFBsYWluIG9iamVjdCB1c2FnZSBpcyBubyBsb25nZXIgc3VwcG9ydGVkLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBkYXRhID0gZGF0YU9wdGlvbnMuY2FsbChwdWJsaWNUaGlzLCBwdWJsaWNUaGlzKTtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGlzUHJvbWlzZShkYXRhKSkge1xyXG4gICAgICAgICAgICB3YXJuKGBkYXRhKCkgcmV0dXJuZWQgYSBQcm9taXNlIC0gbm90ZSBkYXRhKCkgY2Fubm90IGJlIGFzeW5jOyBJZiB5b3UgYCArXHJcbiAgICAgICAgICAgICAgICBgaW50ZW5kIHRvIHBlcmZvcm0gZGF0YSBmZXRjaGluZyBiZWZvcmUgY29tcG9uZW50IHJlbmRlcnMsIHVzZSBgICtcclxuICAgICAgICAgICAgICAgIGBhc3luYyBzZXR1cCgpICsgPFN1c3BlbnNlPi5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpc09iamVjdChkYXRhKSkge1xyXG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgd2FybihgZGF0YSgpIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0LmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaW5zdGFuY2UuZGF0YSA9IHJlYWN0aXZlKGRhdGEpO1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKFwiRGF0YVwiIC8qIERBVEEgKi8sIGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZXhwb3NlIGRhdGEgb24gY3R4IGR1cmluZyBkZXZcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUmVzZXJ2ZWRQcmVmaXgoa2V5WzBdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IGRhdGFba2V5XSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldDogTk9PUFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBzdGF0ZSBpbml0aWFsaXphdGlvbiBjb21wbGV0ZSBhdCB0aGlzIHBvaW50IC0gc3RhcnQgY2FjaGluZyBhY2Nlc3NcclxuICAgIHNob3VsZENhY2hlQWNjZXNzID0gdHJ1ZTtcclxuICAgIGlmIChjb21wdXRlZE9wdGlvbnMpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBjb21wdXRlZE9wdGlvbnMpIHtcclxuICAgICAgICAgICAgY29uc3Qgb3B0ID0gY29tcHV0ZWRPcHRpb25zW2tleV07XHJcbiAgICAgICAgICAgIGNvbnN0IGdldCA9IGlzRnVuY3Rpb24ob3B0KVxyXG4gICAgICAgICAgICAgICAgPyBvcHQuYmluZChwdWJsaWNUaGlzLCBwdWJsaWNUaGlzKVxyXG4gICAgICAgICAgICAgICAgOiBpc0Z1bmN0aW9uKG9wdC5nZXQpXHJcbiAgICAgICAgICAgICAgICAgICAgPyBvcHQuZ2V0LmJpbmQocHVibGljVGhpcywgcHVibGljVGhpcylcclxuICAgICAgICAgICAgICAgICAgICA6IE5PT1A7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgZ2V0ID09PSBOT09QKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKGBDb21wdXRlZCBwcm9wZXJ0eSBcIiR7a2V5fVwiIGhhcyBubyBnZXR0ZXIuYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgc2V0ID0gIWlzRnVuY3Rpb24ob3B0KSAmJiBpc0Z1bmN0aW9uKG9wdC5zZXQpXHJcbiAgICAgICAgICAgICAgICA/IG9wdC5zZXQuYmluZChwdWJsaWNUaGlzKVxyXG4gICAgICAgICAgICAgICAgOiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcclxuICAgICAgICAgICAgICAgICAgICA/ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybihgV3JpdGUgb3BlcmF0aW9uIGZhaWxlZDogY29tcHV0ZWQgcHJvcGVydHkgXCIke2tleX1cIiBpcyByZWFkb25seS5gKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgOiBOT09QO1xyXG4gICAgICAgICAgICBjb25zdCBjID0gY29tcHV0ZWQoe1xyXG4gICAgICAgICAgICAgICAgZ2V0LFxyXG4gICAgICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IGMudmFsdWUsXHJcbiAgICAgICAgICAgICAgICBzZXQ6IHYgPT4gKGMudmFsdWUgPSB2KVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKFwiQ29tcHV0ZWRcIiAvKiBDT01QVVRFRCAqLywga2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICh3YXRjaE9wdGlvbnMpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB3YXRjaE9wdGlvbnMpIHtcclxuICAgICAgICAgICAgY3JlYXRlV2F0Y2hlcih3YXRjaE9wdGlvbnNba2V5XSwgY3R4LCBwdWJsaWNUaGlzLCBrZXkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChwcm92aWRlT3B0aW9ucykge1xyXG4gICAgICAgIGNvbnN0IHByb3ZpZGVzID0gaXNGdW5jdGlvbihwcm92aWRlT3B0aW9ucylcclxuICAgICAgICAgICAgPyBwcm92aWRlT3B0aW9ucy5jYWxsKHB1YmxpY1RoaXMpXHJcbiAgICAgICAgICAgIDogcHJvdmlkZU9wdGlvbnM7XHJcbiAgICAgICAgUmVmbGVjdC5vd25LZXlzKHByb3ZpZGVzKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgICAgIHByb3ZpZGUoa2V5LCBwcm92aWRlc1trZXldKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGlmIChjcmVhdGVkKSB7XHJcbiAgICAgICAgY2FsbEhvb2soY3JlYXRlZCwgaW5zdGFuY2UsIFwiY1wiIC8qIENSRUFURUQgKi8pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJMaWZlY3ljbGVIb29rKHJlZ2lzdGVyLCBob29rKSB7XHJcbiAgICAgICAgaWYgKGlzQXJyYXkoaG9vaykpIHtcclxuICAgICAgICAgICAgaG9vay5mb3JFYWNoKF9ob29rID0+IHJlZ2lzdGVyKF9ob29rLmJpbmQocHVibGljVGhpcykpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaG9vaykge1xyXG4gICAgICAgICAgICByZWdpc3Rlcihob29rLmJpbmQocHVibGljVGhpcykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbkJlZm9yZU1vdW50LCBiZWZvcmVNb3VudCk7XHJcbiAgICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25Nb3VudGVkLCBtb3VudGVkKTtcclxuICAgIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbkJlZm9yZVVwZGF0ZSwgYmVmb3JlVXBkYXRlKTtcclxuICAgIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvblVwZGF0ZWQsIHVwZGF0ZWQpO1xyXG4gICAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uQWN0aXZhdGVkLCBhY3RpdmF0ZWQpO1xyXG4gICAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uRGVhY3RpdmF0ZWQsIGRlYWN0aXZhdGVkKTtcclxuICAgIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbkVycm9yQ2FwdHVyZWQsIGVycm9yQ2FwdHVyZWQpO1xyXG4gICAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uUmVuZGVyVHJhY2tlZCwgcmVuZGVyVHJhY2tlZCk7XHJcbiAgICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25SZW5kZXJUcmlnZ2VyZWQsIHJlbmRlclRyaWdnZXJlZCk7XHJcbiAgICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25CZWZvcmVVbm1vdW50LCBiZWZvcmVVbm1vdW50KTtcclxuICAgIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvblVubW91bnRlZCwgdW5tb3VudGVkKTtcclxuICAgIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvblNlcnZlclByZWZldGNoLCBzZXJ2ZXJQcmVmZXRjaCk7XHJcbiAgICBpZiAoaXNBcnJheShleHBvc2UpKSB7XHJcbiAgICAgICAgaWYgKGV4cG9zZS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgY29uc3QgZXhwb3NlZCA9IGluc3RhbmNlLmV4cG9zZWQgfHwgKGluc3RhbmNlLmV4cG9zZWQgPSB7fSk7XHJcbiAgICAgICAgICAgIGV4cG9zZS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3NlZCwga2V5LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiAoKSA9PiBwdWJsaWNUaGlzW2tleV0sXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0OiB2YWwgPT4gKHB1YmxpY1RoaXNba2V5XSA9IHZhbClcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIWluc3RhbmNlLmV4cG9zZWQpIHtcclxuICAgICAgICAgICAgaW5zdGFuY2UuZXhwb3NlZCA9IHt9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIG9wdGlvbnMgdGhhdCBhcmUgaGFuZGxlZCB3aGVuIGNyZWF0aW5nIHRoZSBpbnN0YW5jZSBidXQgYWxzbyBuZWVkIHRvIGJlXHJcbiAgICAvLyBhcHBsaWVkIGZyb20gbWl4aW5zXHJcbiAgICBpZiAocmVuZGVyICYmIGluc3RhbmNlLnJlbmRlciA9PT0gTk9PUCkge1xyXG4gICAgICAgIGluc3RhbmNlLnJlbmRlciA9IHJlbmRlcjtcclxuICAgIH1cclxuICAgIGlmIChpbmhlcml0QXR0cnMgIT0gbnVsbCkge1xyXG4gICAgICAgIGluc3RhbmNlLmluaGVyaXRBdHRycyA9IGluaGVyaXRBdHRycztcclxuICAgIH1cclxuICAgIC8vIGFzc2V0IG9wdGlvbnMuXHJcbiAgICBpZiAoY29tcG9uZW50cylcclxuICAgICAgICBpbnN0YW5jZS5jb21wb25lbnRzID0gY29tcG9uZW50cztcclxuICAgIGlmIChkaXJlY3RpdmVzKVxyXG4gICAgICAgIGluc3RhbmNlLmRpcmVjdGl2ZXMgPSBkaXJlY3RpdmVzO1xyXG59XHJcbmZ1bmN0aW9uIHJlc29sdmVJbmplY3Rpb25zKGluamVjdE9wdGlvbnMsIGN0eCwgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzID0gTk9PUCwgdW53cmFwUmVmID0gZmFsc2UpIHtcclxuICAgIGlmIChpc0FycmF5KGluamVjdE9wdGlvbnMpKSB7XHJcbiAgICAgICAgaW5qZWN0T3B0aW9ucyA9IG5vcm1hbGl6ZUluamVjdChpbmplY3RPcHRpb25zKTtcclxuICAgIH1cclxuICAgIGZvciAoY29uc3Qga2V5IGluIGluamVjdE9wdGlvbnMpIHtcclxuICAgICAgICBjb25zdCBvcHQgPSBpbmplY3RPcHRpb25zW2tleV07XHJcbiAgICAgICAgbGV0IGluamVjdGVkO1xyXG4gICAgICAgIGlmIChpc09iamVjdChvcHQpKSB7XHJcbiAgICAgICAgICAgIGlmICgnZGVmYXVsdCcgaW4gb3B0KSB7XHJcbiAgICAgICAgICAgICAgICBpbmplY3RlZCA9IGluamVjdChvcHQuZnJvbSB8fCBrZXksIG9wdC5kZWZhdWx0LCB0cnVlIC8qIHRyZWF0IGRlZmF1bHQgZnVuY3Rpb24gYXMgZmFjdG9yeSAqLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpbmplY3RlZCA9IGluamVjdChvcHQuZnJvbSB8fCBrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpbmplY3RlZCA9IGluamVjdChvcHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNSZWYoaW5qZWN0ZWQpKSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE8gcmVtb3ZlIHRoZSBjaGVjayBpbiAzLjNcclxuICAgICAgICAgICAgaWYgKHVud3JhcFJlZikge1xyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiAoKSA9PiBpbmplY3RlZC52YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICBzZXQ6IHYgPT4gKGluamVjdGVkLnZhbHVlID0gdilcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYGluamVjdGVkIHByb3BlcnR5IFwiJHtrZXl9XCIgaXMgYSByZWYgYW5kIHdpbGwgYmUgYXV0by11bndyYXBwZWQgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGBhbmQgbm8gbG9uZ2VyIG5lZWRzIFxcYC52YWx1ZVxcYCBpbiB0aGUgbmV4dCBtaW5vciByZWxlYXNlLiBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYFRvIG9wdC1pbiB0byB0aGUgbmV3IGJlaGF2aW9yIG5vdywgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGBzZXQgXFxgYXBwLmNvbmZpZy51bndyYXBJbmplY3RlZFJlZiA9IHRydWVcXGAgKHRoaXMgY29uZmlnIGlzIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgdGVtcG9yYXJ5IGFuZCB3aWxsIG5vdCBiZSBuZWVkZWQgaW4gdGhlIGZ1dHVyZS4pYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjdHhba2V5XSA9IGluamVjdGVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjdHhba2V5XSA9IGluamVjdGVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyhcIkluamVjdFwiIC8qIElOSkVDVCAqLywga2V5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY2FsbEhvb2soaG9vaywgaW5zdGFuY2UsIHR5cGUpIHtcclxuICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGlzQXJyYXkoaG9vaylcclxuICAgICAgICA/IGhvb2subWFwKGggPT4gaC5iaW5kKGluc3RhbmNlLnByb3h5KSlcclxuICAgICAgICA6IGhvb2suYmluZChpbnN0YW5jZS5wcm94eSksIGluc3RhbmNlLCB0eXBlKTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVXYXRjaGVyKHJhdywgY3R4LCBwdWJsaWNUaGlzLCBrZXkpIHtcclxuICAgIGNvbnN0IGdldHRlciA9IGtleS5pbmNsdWRlcygnLicpXHJcbiAgICAgICAgPyBjcmVhdGVQYXRoR2V0dGVyKHB1YmxpY1RoaXMsIGtleSlcclxuICAgICAgICA6ICgpID0+IHB1YmxpY1RoaXNba2V5XTtcclxuICAgIGlmIChpc1N0cmluZyhyYXcpKSB7XHJcbiAgICAgICAgY29uc3QgaGFuZGxlciA9IGN0eFtyYXddO1xyXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XHJcbiAgICAgICAgICAgIHdhdGNoKGdldHRlciwgaGFuZGxlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICB3YXJuKGBJbnZhbGlkIHdhdGNoIGhhbmRsZXIgc3BlY2lmaWVkIGJ5IGtleSBcIiR7cmF3fVwiYCwgaGFuZGxlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNGdW5jdGlvbihyYXcpKSB7XHJcbiAgICAgICAgd2F0Y2goZ2V0dGVyLCByYXcuYmluZChwdWJsaWNUaGlzKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc09iamVjdChyYXcpKSB7XHJcbiAgICAgICAgaWYgKGlzQXJyYXkocmF3KSkge1xyXG4gICAgICAgICAgICByYXcuZm9yRWFjaChyID0+IGNyZWF0ZVdhdGNoZXIociwgY3R4LCBwdWJsaWNUaGlzLCBrZXkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSBpc0Z1bmN0aW9uKHJhdy5oYW5kbGVyKVxyXG4gICAgICAgICAgICAgICAgPyByYXcuaGFuZGxlci5iaW5kKHB1YmxpY1RoaXMpXHJcbiAgICAgICAgICAgICAgICA6IGN0eFtyYXcuaGFuZGxlcl07XHJcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XHJcbiAgICAgICAgICAgICAgICB3YXRjaChnZXR0ZXIsIGhhbmRsZXIsIHJhdyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKGBJbnZhbGlkIHdhdGNoIGhhbmRsZXIgc3BlY2lmaWVkIGJ5IGtleSBcIiR7cmF3LmhhbmRsZXJ9XCJgLCBoYW5kbGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIHdhcm4oYEludmFsaWQgd2F0Y2ggb3B0aW9uOiBcIiR7a2V5fVwiYCwgcmF3KTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmVzb2x2ZSBtZXJnZWQgb3B0aW9ucyBhbmQgY2FjaGUgaXQgb24gdGhlIGNvbXBvbmVudC5cclxuICogVGhpcyBpcyBkb25lIG9ubHkgb25jZSBwZXItY29tcG9uZW50IHNpbmNlIHRoZSBtZXJnaW5nIGRvZXMgbm90IGludm9sdmVcclxuICogaW5zdGFuY2VzLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVzb2x2ZU1lcmdlZE9wdGlvbnMoaW5zdGFuY2UpIHtcclxuICAgIGNvbnN0IGJhc2UgPSBpbnN0YW5jZS50eXBlO1xyXG4gICAgY29uc3QgeyBtaXhpbnMsIGV4dGVuZHM6IGV4dGVuZHNPcHRpb25zIH0gPSBiYXNlO1xyXG4gICAgY29uc3QgeyBtaXhpbnM6IGdsb2JhbE1peGlucywgb3B0aW9uc0NhY2hlOiBjYWNoZSwgY29uZmlnOiB7IG9wdGlvbk1lcmdlU3RyYXRlZ2llcyB9IH0gPSBpbnN0YW5jZS5hcHBDb250ZXh0O1xyXG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KGJhc2UpO1xyXG4gICAgbGV0IHJlc29sdmVkO1xyXG4gICAgaWYgKGNhY2hlZCkge1xyXG4gICAgICAgIHJlc29sdmVkID0gY2FjaGVkO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoIWdsb2JhbE1peGlucy5sZW5ndGggJiYgIW1peGlucyAmJiAhZXh0ZW5kc09wdGlvbnMpIHtcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJlc29sdmVkID0gYmFzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXNvbHZlZCA9IHt9O1xyXG4gICAgICAgIGlmIChnbG9iYWxNaXhpbnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGdsb2JhbE1peGlucy5mb3JFYWNoKG0gPT4gbWVyZ2VPcHRpb25zKHJlc29sdmVkLCBtLCBvcHRpb25NZXJnZVN0cmF0ZWdpZXMsIHRydWUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbWVyZ2VPcHRpb25zKHJlc29sdmVkLCBiYXNlLCBvcHRpb25NZXJnZVN0cmF0ZWdpZXMpO1xyXG4gICAgfVxyXG4gICAgY2FjaGUuc2V0KGJhc2UsIHJlc29sdmVkKTtcclxuICAgIHJldHVybiByZXNvbHZlZDtcclxufVxyXG5mdW5jdGlvbiBtZXJnZU9wdGlvbnModG8sIGZyb20sIHN0cmF0cywgYXNNaXhpbiA9IGZhbHNlKSB7XHJcbiAgICBjb25zdCB7IG1peGlucywgZXh0ZW5kczogZXh0ZW5kc09wdGlvbnMgfSA9IGZyb207XHJcbiAgICBpZiAoZXh0ZW5kc09wdGlvbnMpIHtcclxuICAgICAgICBtZXJnZU9wdGlvbnModG8sIGV4dGVuZHNPcHRpb25zLCBzdHJhdHMsIHRydWUpO1xyXG4gICAgfVxyXG4gICAgaWYgKG1peGlucykge1xyXG4gICAgICAgIG1peGlucy5mb3JFYWNoKChtKSA9PiBtZXJnZU9wdGlvbnModG8sIG0sIHN0cmF0cywgdHJ1ZSkpO1xyXG4gICAgfVxyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gZnJvbSkge1xyXG4gICAgICAgIGlmIChhc01peGluICYmIGtleSA9PT0gJ2V4cG9zZScpIHtcclxuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgICAgICB3YXJuKGBcImV4cG9zZVwiIG9wdGlvbiBpcyBpZ25vcmVkIHdoZW4gZGVjbGFyZWQgaW4gbWl4aW5zIG9yIGV4dGVuZHMuIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBJdCBzaG91bGQgb25seSBiZSBkZWNsYXJlZCBpbiB0aGUgYmFzZSBjb21wb25lbnQgaXRzZWxmLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3Qgc3RyYXQgPSBpbnRlcm5hbE9wdGlvbk1lcmdlU3RyYXRzW2tleV0gfHwgKHN0cmF0cyAmJiBzdHJhdHNba2V5XSk7XHJcbiAgICAgICAgICAgIHRvW2tleV0gPSBzdHJhdCA/IHN0cmF0KHRvW2tleV0sIGZyb21ba2V5XSkgOiBmcm9tW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRvO1xyXG59XHJcbmNvbnN0IGludGVybmFsT3B0aW9uTWVyZ2VTdHJhdHMgPSB7XHJcbiAgICBkYXRhOiBtZXJnZURhdGFGbixcclxuICAgIHByb3BzOiBtZXJnZU9iamVjdE9wdGlvbnMsXHJcbiAgICBlbWl0czogbWVyZ2VPYmplY3RPcHRpb25zLFxyXG4gICAgLy8gb2JqZWN0c1xyXG4gICAgbWV0aG9kczogbWVyZ2VPYmplY3RPcHRpb25zLFxyXG4gICAgY29tcHV0ZWQ6IG1lcmdlT2JqZWN0T3B0aW9ucyxcclxuICAgIC8vIGxpZmVjeWNsZVxyXG4gICAgYmVmb3JlQ3JlYXRlOiBtZXJnZUFzQXJyYXksXHJcbiAgICBjcmVhdGVkOiBtZXJnZUFzQXJyYXksXHJcbiAgICBiZWZvcmVNb3VudDogbWVyZ2VBc0FycmF5LFxyXG4gICAgbW91bnRlZDogbWVyZ2VBc0FycmF5LFxyXG4gICAgYmVmb3JlVXBkYXRlOiBtZXJnZUFzQXJyYXksXHJcbiAgICB1cGRhdGVkOiBtZXJnZUFzQXJyYXksXHJcbiAgICBiZWZvcmVEZXN0cm95OiBtZXJnZUFzQXJyYXksXHJcbiAgICBiZWZvcmVVbm1vdW50OiBtZXJnZUFzQXJyYXksXHJcbiAgICBkZXN0cm95ZWQ6IG1lcmdlQXNBcnJheSxcclxuICAgIHVubW91bnRlZDogbWVyZ2VBc0FycmF5LFxyXG4gICAgYWN0aXZhdGVkOiBtZXJnZUFzQXJyYXksXHJcbiAgICBkZWFjdGl2YXRlZDogbWVyZ2VBc0FycmF5LFxyXG4gICAgZXJyb3JDYXB0dXJlZDogbWVyZ2VBc0FycmF5LFxyXG4gICAgc2VydmVyUHJlZmV0Y2g6IG1lcmdlQXNBcnJheSxcclxuICAgIC8vIGFzc2V0c1xyXG4gICAgY29tcG9uZW50czogbWVyZ2VPYmplY3RPcHRpb25zLFxyXG4gICAgZGlyZWN0aXZlczogbWVyZ2VPYmplY3RPcHRpb25zLFxyXG4gICAgLy8gd2F0Y2hcclxuICAgIHdhdGNoOiBtZXJnZVdhdGNoT3B0aW9ucyxcclxuICAgIC8vIHByb3ZpZGUgLyBpbmplY3RcclxuICAgIHByb3ZpZGU6IG1lcmdlRGF0YUZuLFxyXG4gICAgaW5qZWN0OiBtZXJnZUluamVjdFxyXG59O1xyXG5mdW5jdGlvbiBtZXJnZURhdGFGbih0bywgZnJvbSkge1xyXG4gICAgaWYgKCFmcm9tKSB7XHJcbiAgICAgICAgcmV0dXJuIHRvO1xyXG4gICAgfVxyXG4gICAgaWYgKCF0bykge1xyXG4gICAgICAgIHJldHVybiBmcm9tO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZERhdGFGbigpIHtcclxuICAgICAgICByZXR1cm4gKGV4dGVuZCkoaXNGdW5jdGlvbih0bykgPyB0by5jYWxsKHRoaXMsIHRoaXMpIDogdG8sIGlzRnVuY3Rpb24oZnJvbSkgPyBmcm9tLmNhbGwodGhpcywgdGhpcykgOiBmcm9tKTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gbWVyZ2VJbmplY3QodG8sIGZyb20pIHtcclxuICAgIHJldHVybiBtZXJnZU9iamVjdE9wdGlvbnMobm9ybWFsaXplSW5qZWN0KHRvKSwgbm9ybWFsaXplSW5qZWN0KGZyb20pKTtcclxufVxyXG5mdW5jdGlvbiBub3JtYWxpemVJbmplY3QocmF3KSB7XHJcbiAgICBpZiAoaXNBcnJheShyYXcpKSB7XHJcbiAgICAgICAgY29uc3QgcmVzID0ge307XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYXcubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgcmVzW3Jhd1tpXV0gPSByYXdbaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmF3O1xyXG59XHJcbmZ1bmN0aW9uIG1lcmdlQXNBcnJheSh0bywgZnJvbSkge1xyXG4gICAgcmV0dXJuIHRvID8gWy4uLm5ldyBTZXQoW10uY29uY2F0KHRvLCBmcm9tKSldIDogZnJvbTtcclxufVxyXG5mdW5jdGlvbiBtZXJnZU9iamVjdE9wdGlvbnModG8sIGZyb20pIHtcclxuICAgIHJldHVybiB0byA/IGV4dGVuZChleHRlbmQoT2JqZWN0LmNyZWF0ZShudWxsKSwgdG8pLCBmcm9tKSA6IGZyb207XHJcbn1cclxuZnVuY3Rpb24gbWVyZ2VXYXRjaE9wdGlvbnModG8sIGZyb20pIHtcclxuICAgIGlmICghdG8pXHJcbiAgICAgICAgcmV0dXJuIGZyb207XHJcbiAgICBpZiAoIWZyb20pXHJcbiAgICAgICAgcmV0dXJuIHRvO1xyXG4gICAgY29uc3QgbWVyZ2VkID0gZXh0ZW5kKE9iamVjdC5jcmVhdGUobnVsbCksIHRvKTtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIGZyb20pIHtcclxuICAgICAgICBtZXJnZWRba2V5XSA9IG1lcmdlQXNBcnJheSh0b1trZXldLCBmcm9tW2tleV0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1lcmdlZDtcclxufVxuXG5mdW5jdGlvbiBpbml0UHJvcHMoaW5zdGFuY2UsIHJhd1Byb3BzLCBpc1N0YXRlZnVsLCAvLyByZXN1bHQgb2YgYml0d2lzZSBmbGFnIGNvbXBhcmlzb25cclxuaXNTU1IgPSBmYWxzZSkge1xyXG4gICAgY29uc3QgcHJvcHMgPSB7fTtcclxuICAgIGNvbnN0IGF0dHJzID0ge307XHJcbiAgICBkZWYoYXR0cnMsIEludGVybmFsT2JqZWN0S2V5LCAxKTtcclxuICAgIGluc3RhbmNlLnByb3BzRGVmYXVsdHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgc2V0RnVsbFByb3BzKGluc3RhbmNlLCByYXdQcm9wcywgcHJvcHMsIGF0dHJzKTtcclxuICAgIC8vIGVuc3VyZSBhbGwgZGVjbGFyZWQgcHJvcCBrZXlzIGFyZSBwcmVzZW50XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBpbnN0YW5jZS5wcm9wc09wdGlvbnNbMF0pIHtcclxuICAgICAgICBpZiAoIShrZXkgaW4gcHJvcHMpKSB7XHJcbiAgICAgICAgICAgIHByb3BzW2tleV0gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gdmFsaWRhdGlvblxyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIHZhbGlkYXRlUHJvcHMocmF3UHJvcHMgfHwge30sIHByb3BzLCBpbnN0YW5jZSk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNTdGF0ZWZ1bCkge1xyXG4gICAgICAgIC8vIHN0YXRlZnVsXHJcbiAgICAgICAgaW5zdGFuY2UucHJvcHMgPSBpc1NTUiA/IHByb3BzIDogc2hhbGxvd1JlYWN0aXZlKHByb3BzKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmICghaW5zdGFuY2UudHlwZS5wcm9wcykge1xyXG4gICAgICAgICAgICAvLyBmdW5jdGlvbmFsIHcvIG9wdGlvbmFsIHByb3BzLCBwcm9wcyA9PT0gYXR0cnNcclxuICAgICAgICAgICAgaW5zdGFuY2UucHJvcHMgPSBhdHRycztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGZ1bmN0aW9uYWwgdy8gZGVjbGFyZWQgcHJvcHNcclxuICAgICAgICAgICAgaW5zdGFuY2UucHJvcHMgPSBwcm9wcztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpbnN0YW5jZS5hdHRycyA9IGF0dHJzO1xyXG59XHJcbmZ1bmN0aW9uIHVwZGF0ZVByb3BzKGluc3RhbmNlLCByYXdQcm9wcywgcmF3UHJldlByb3BzLCBvcHRpbWl6ZWQpIHtcclxuICAgIGNvbnN0IHsgcHJvcHMsIGF0dHJzLCB2bm9kZTogeyBwYXRjaEZsYWcgfSB9ID0gaW5zdGFuY2U7XHJcbiAgICBjb25zdCByYXdDdXJyZW50UHJvcHMgPSB0b1Jhdyhwcm9wcyk7XHJcbiAgICBjb25zdCBbb3B0aW9uc10gPSBpbnN0YW5jZS5wcm9wc09wdGlvbnM7XHJcbiAgICBsZXQgaGFzQXR0cnNDaGFuZ2VkID0gZmFsc2U7XHJcbiAgICBpZiAoXHJcbiAgICAvLyBhbHdheXMgZm9yY2UgZnVsbCBkaWZmIGluIGRldlxyXG4gICAgLy8gLSAjMTk0MiBpZiBobXIgaXMgZW5hYmxlZCB3aXRoIHNmYyBjb21wb25lbnRcclxuICAgIC8vIC0gdml0ZSM4NzIgbm9uLXNmYyBjb21wb25lbnQgdXNlZCBieSBzZmMgY29tcG9uZW50XHJcbiAgICAhKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgIChpbnN0YW5jZS50eXBlLl9faG1ySWQgfHxcclxuICAgICAgICAgICAgKGluc3RhbmNlLnBhcmVudCAmJiBpbnN0YW5jZS5wYXJlbnQudHlwZS5fX2htcklkKSkpICYmXHJcbiAgICAgICAgKG9wdGltaXplZCB8fCBwYXRjaEZsYWcgPiAwKSAmJlxyXG4gICAgICAgICEocGF0Y2hGbGFnICYgMTYgLyogRlVMTF9QUk9QUyAqLykpIHtcclxuICAgICAgICBpZiAocGF0Y2hGbGFnICYgOCAvKiBQUk9QUyAqLykge1xyXG4gICAgICAgICAgICAvLyBDb21waWxlci1nZW5lcmF0ZWQgcHJvcHMgJiBubyBrZXlzIGNoYW5nZSwganVzdCBzZXQgdGhlIHVwZGF0ZWRcclxuICAgICAgICAgICAgLy8gdGhlIHByb3BzLlxyXG4gICAgICAgICAgICBjb25zdCBwcm9wc1RvVXBkYXRlID0gaW5zdGFuY2Uudm5vZGUuZHluYW1pY1Byb3BzO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BzVG9VcGRhdGUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGxldCBrZXkgPSBwcm9wc1RvVXBkYXRlW2ldO1xyXG4gICAgICAgICAgICAgICAgLy8gc2tpcCBpZiB0aGUgcHJvcCBrZXkgaXMgYSBkZWNsYXJlZCBlbWl0IGV2ZW50IGxpc3RlbmVyXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNFbWl0TGlzdGVuZXIoaW5zdGFuY2UuZW1pdHNPcHRpb25zLCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBQUk9QUyBmbGFnIGd1YXJhbnRlZXMgcmF3UHJvcHMgdG8gYmUgbm9uLW51bGxcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcmF3UHJvcHNba2V5XTtcclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYXR0ciAvIHByb3BzIHNlcGFyYXRpb24gd2FzIGRvbmUgb24gaW5pdCBhbmQgd2lsbCBiZSBjb25zaXN0ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaW4gdGhpcyBjb2RlIHBhdGgsIHNvIGp1c3QgY2hlY2sgaWYgYXR0cnMgaGF2ZSBpdC5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzT3duKGF0dHJzLCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gYXR0cnNba2V5XSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnNba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzQXR0cnNDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FtZWxpemVkS2V5ID0gY2FtZWxpemUoa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHNbY2FtZWxpemVkS2V5XSA9IHJlc29sdmVQcm9wVmFsdWUob3B0aW9ucywgcmF3Q3VycmVudFByb3BzLCBjYW1lbGl6ZWRLZXksIHZhbHVlLCBpbnN0YW5jZSwgZmFsc2UgLyogaXNBYnNlbnQgKi8pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gYXR0cnNba2V5XSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyc1trZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0F0dHJzQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gZnVsbCBwcm9wcyB1cGRhdGUuXHJcbiAgICAgICAgaWYgKHNldEZ1bGxQcm9wcyhpbnN0YW5jZSwgcmF3UHJvcHMsIHByb3BzLCBhdHRycykpIHtcclxuICAgICAgICAgICAgaGFzQXR0cnNDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaW4gY2FzZSBvZiBkeW5hbWljIHByb3BzLCBjaGVjayBpZiB3ZSBuZWVkIHRvIGRlbGV0ZSBrZXlzIGZyb21cclxuICAgICAgICAvLyB0aGUgcHJvcHMgb2JqZWN0XHJcbiAgICAgICAgbGV0IGtlYmFiS2V5O1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHJhd0N1cnJlbnRQcm9wcykge1xyXG4gICAgICAgICAgICBpZiAoIXJhd1Byb3BzIHx8XHJcbiAgICAgICAgICAgICAgICAvLyBmb3IgY2FtZWxDYXNlXHJcbiAgICAgICAgICAgICAgICAoIWhhc093bihyYXdQcm9wcywga2V5KSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGl0J3MgcG9zc2libGUgdGhlIG9yaWdpbmFsIHByb3BzIHdhcyBwYXNzZWQgaW4gYXMga2ViYWItY2FzZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBjb252ZXJ0ZWQgdG8gY2FtZWxDYXNlICgjOTU1KVxyXG4gICAgICAgICAgICAgICAgICAgICgoa2ViYWJLZXkgPSBoeXBoZW5hdGUoa2V5KSkgPT09IGtleSB8fCAhaGFzT3duKHJhd1Byb3BzLCBrZWJhYktleSkpKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmF3UHJldlByb3BzICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvciBjYW1lbENhc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgKHJhd1ByZXZQcm9wc1trZXldICE9PSB1bmRlZmluZWQgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvciBrZWJhYi1jYXNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYXdQcmV2UHJvcHNba2ViYWJLZXldICE9PSB1bmRlZmluZWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzW2tleV0gPSByZXNvbHZlUHJvcFZhbHVlKG9wdGlvbnMsIHJhd0N1cnJlbnRQcm9wcywga2V5LCB1bmRlZmluZWQsIGluc3RhbmNlLCB0cnVlIC8qIGlzQWJzZW50ICovKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcHJvcHNba2V5XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpbiB0aGUgY2FzZSBvZiBmdW5jdGlvbmFsIGNvbXBvbmVudCB3L28gcHJvcHMgZGVjbGFyYXRpb24sIHByb3BzIGFuZFxyXG4gICAgICAgIC8vIGF0dHJzIHBvaW50IHRvIHRoZSBzYW1lIG9iamVjdCBzbyBpdCBzaG91bGQgYWxyZWFkeSBoYXZlIGJlZW4gdXBkYXRlZC5cclxuICAgICAgICBpZiAoYXR0cnMgIT09IHJhd0N1cnJlbnRQcm9wcykge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRycykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFyYXdQcm9wcyB8fFxyXG4gICAgICAgICAgICAgICAgICAgICghaGFzT3duKHJhd1Byb3BzLCBrZXkpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICghZmFsc2UgKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgYXR0cnNba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gdHJpZ2dlciB1cGRhdGVzIGZvciAkYXR0cnMgaW4gY2FzZSBpdCdzIHVzZWQgaW4gY29tcG9uZW50IHNsb3RzXHJcbiAgICBpZiAoaGFzQXR0cnNDaGFuZ2VkKSB7XHJcbiAgICAgICAgdHJpZ2dlcihpbnN0YW5jZSwgXCJzZXRcIiAvKiBTRVQgKi8sICckYXR0cnMnKTtcclxuICAgIH1cclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICB2YWxpZGF0ZVByb3BzKHJhd1Byb3BzIHx8IHt9LCBwcm9wcywgaW5zdGFuY2UpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHNldEZ1bGxQcm9wcyhpbnN0YW5jZSwgcmF3UHJvcHMsIHByb3BzLCBhdHRycykge1xyXG4gICAgY29uc3QgW29wdGlvbnMsIG5lZWRDYXN0S2V5c10gPSBpbnN0YW5jZS5wcm9wc09wdGlvbnM7XHJcbiAgICBsZXQgaGFzQXR0cnNDaGFuZ2VkID0gZmFsc2U7XHJcbiAgICBsZXQgcmF3Q2FzdFZhbHVlcztcclxuICAgIGlmIChyYXdQcm9wcykge1xyXG4gICAgICAgIGZvciAobGV0IGtleSBpbiByYXdQcm9wcykge1xyXG4gICAgICAgICAgICAvLyBrZXksIHJlZiBhcmUgcmVzZXJ2ZWQgYW5kIG5ldmVyIHBhc3NlZCBkb3duXHJcbiAgICAgICAgICAgIGlmIChpc1Jlc2VydmVkUHJvcChrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHJhd1Byb3BzW2tleV07XHJcbiAgICAgICAgICAgIC8vIHByb3Agb3B0aW9uIG5hbWVzIGFyZSBjYW1lbGl6ZWQgZHVyaW5nIG5vcm1hbGl6YXRpb24sIHNvIHRvIHN1cHBvcnRcclxuICAgICAgICAgICAgLy8ga2ViYWIgLT4gY2FtZWwgY29udmVyc2lvbiBoZXJlIHdlIG5lZWQgdG8gY2FtZWxpemUgdGhlIGtleS5cclxuICAgICAgICAgICAgbGV0IGNhbWVsS2V5O1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucyAmJiBoYXNPd24ob3B0aW9ucywgKGNhbWVsS2V5ID0gY2FtZWxpemUoa2V5KSkpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIW5lZWRDYXN0S2V5cyB8fCAhbmVlZENhc3RLZXlzLmluY2x1ZGVzKGNhbWVsS2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3BzW2NhbWVsS2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgKHJhd0Nhc3RWYWx1ZXMgfHwgKHJhd0Nhc3RWYWx1ZXMgPSB7fSkpW2NhbWVsS2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc0VtaXRMaXN0ZW5lcihpbnN0YW5jZS5lbWl0c09wdGlvbnMsIGtleSkpIHtcclxuICAgICAgICAgICAgICAgIGlmICghKGtleSBpbiBhdHRycykgfHwgdmFsdWUgIT09IGF0dHJzW2tleV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBhdHRyc1trZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzQXR0cnNDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChuZWVkQ2FzdEtleXMpIHtcclxuICAgICAgICBjb25zdCByYXdDdXJyZW50UHJvcHMgPSB0b1Jhdyhwcm9wcyk7XHJcbiAgICAgICAgY29uc3QgY2FzdFZhbHVlcyA9IHJhd0Nhc3RWYWx1ZXMgfHwgRU1QVFlfT0JKO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmVlZENhc3RLZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IG5lZWRDYXN0S2V5c1tpXTtcclxuICAgICAgICAgICAgcHJvcHNba2V5XSA9IHJlc29sdmVQcm9wVmFsdWUob3B0aW9ucywgcmF3Q3VycmVudFByb3BzLCBrZXksIGNhc3RWYWx1ZXNba2V5XSwgaW5zdGFuY2UsICFoYXNPd24oY2FzdFZhbHVlcywga2V5KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGhhc0F0dHJzQ2hhbmdlZDtcclxufVxyXG5mdW5jdGlvbiByZXNvbHZlUHJvcFZhbHVlKG9wdGlvbnMsIHByb3BzLCBrZXksIHZhbHVlLCBpbnN0YW5jZSwgaXNBYnNlbnQpIHtcclxuICAgIGNvbnN0IG9wdCA9IG9wdGlvbnNba2V5XTtcclxuICAgIGlmIChvcHQgIT0gbnVsbCkge1xyXG4gICAgICAgIGNvbnN0IGhhc0RlZmF1bHQgPSBoYXNPd24ob3B0LCAnZGVmYXVsdCcpO1xyXG4gICAgICAgIC8vIGRlZmF1bHQgdmFsdWVzXHJcbiAgICAgICAgaWYgKGhhc0RlZmF1bHQgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSBvcHQuZGVmYXVsdDtcclxuICAgICAgICAgICAgaWYgKG9wdC50eXBlICE9PSBGdW5jdGlvbiAmJiBpc0Z1bmN0aW9uKGRlZmF1bHRWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgcHJvcHNEZWZhdWx0cyB9ID0gaW5zdGFuY2U7XHJcbiAgICAgICAgICAgICAgICBpZiAoa2V5IGluIHByb3BzRGVmYXVsdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHByb3BzRGVmYXVsdHNba2V5XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldEN1cnJlbnRJbnN0YW5jZShpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwcm9wc0RlZmF1bHRzW2tleV0gPSBkZWZhdWx0VmFsdWUuY2FsbChudWxsLCBwcm9wcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdW5zZXRDdXJyZW50SW5zdGFuY2UoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gZGVmYXVsdFZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGJvb2xlYW4gY2FzdGluZ1xyXG4gICAgICAgIGlmIChvcHRbMCAvKiBzaG91bGRDYXN0ICovXSkge1xyXG4gICAgICAgICAgICBpZiAoaXNBYnNlbnQgJiYgIWhhc0RlZmF1bHQpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAob3B0WzEgLyogc2hvdWxkQ2FzdFRydWUgKi9dICYmXHJcbiAgICAgICAgICAgICAgICAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSBoeXBoZW5hdGUoa2V5KSkpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB2YWx1ZTtcclxufVxyXG5mdW5jdGlvbiBub3JtYWxpemVQcm9wc09wdGlvbnMoY29tcCwgYXBwQ29udGV4dCwgYXNNaXhpbiA9IGZhbHNlKSB7XHJcbiAgICBjb25zdCBjYWNoZSA9IGFwcENvbnRleHQucHJvcHNDYWNoZTtcclxuICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChjb21wKTtcclxuICAgIGlmIChjYWNoZWQpIHtcclxuICAgICAgICByZXR1cm4gY2FjaGVkO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmF3ID0gY29tcC5wcm9wcztcclxuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSB7fTtcclxuICAgIGNvbnN0IG5lZWRDYXN0S2V5cyA9IFtdO1xyXG4gICAgLy8gYXBwbHkgbWl4aW4vZXh0ZW5kcyBwcm9wc1xyXG4gICAgbGV0IGhhc0V4dGVuZHMgPSBmYWxzZTtcclxuICAgIGlmIChfX1ZVRV9PUFRJT05TX0FQSV9fICYmICFpc0Z1bmN0aW9uKGNvbXApKSB7XHJcbiAgICAgICAgY29uc3QgZXh0ZW5kUHJvcHMgPSAocmF3KSA9PiB7XHJcbiAgICAgICAgICAgIGhhc0V4dGVuZHMgPSB0cnVlO1xyXG4gICAgICAgICAgICBjb25zdCBbcHJvcHMsIGtleXNdID0gbm9ybWFsaXplUHJvcHNPcHRpb25zKHJhdywgYXBwQ29udGV4dCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGV4dGVuZChub3JtYWxpemVkLCBwcm9wcyk7XHJcbiAgICAgICAgICAgIGlmIChrZXlzKVxyXG4gICAgICAgICAgICAgICAgbmVlZENhc3RLZXlzLnB1c2goLi4ua2V5cyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoIWFzTWl4aW4gJiYgYXBwQ29udGV4dC5taXhpbnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGFwcENvbnRleHQubWl4aW5zLmZvckVhY2goZXh0ZW5kUHJvcHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29tcC5leHRlbmRzKSB7XHJcbiAgICAgICAgICAgIGV4dGVuZFByb3BzKGNvbXAuZXh0ZW5kcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb21wLm1peGlucykge1xyXG4gICAgICAgICAgICBjb21wLm1peGlucy5mb3JFYWNoKGV4dGVuZFByb3BzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoIXJhdyAmJiAhaGFzRXh0ZW5kcykge1xyXG4gICAgICAgIGNhY2hlLnNldChjb21wLCBFTVBUWV9BUlIpO1xyXG4gICAgICAgIHJldHVybiBFTVBUWV9BUlI7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNBcnJheShyYXcpKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYXcubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaXNTdHJpbmcocmF3W2ldKSkge1xyXG4gICAgICAgICAgICAgICAgd2FybihgcHJvcHMgbXVzdCBiZSBzdHJpbmdzIHdoZW4gdXNpbmcgYXJyYXkgc3ludGF4LmAsIHJhd1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZEtleSA9IGNhbWVsaXplKHJhd1tpXSk7XHJcbiAgICAgICAgICAgIGlmICh2YWxpZGF0ZVByb3BOYW1lKG5vcm1hbGl6ZWRLZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkW25vcm1hbGl6ZWRLZXldID0gRU1QVFlfT0JKO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocmF3KSB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaXNPYmplY3QocmF3KSkge1xyXG4gICAgICAgICAgICB3YXJuKGBpbnZhbGlkIHByb3BzIG9wdGlvbnNgLCByYXcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiByYXcpIHtcclxuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZEtleSA9IGNhbWVsaXplKGtleSk7XHJcbiAgICAgICAgICAgIGlmICh2YWxpZGF0ZVByb3BOYW1lKG5vcm1hbGl6ZWRLZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvcHQgPSByYXdba2V5XTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHByb3AgPSAobm9ybWFsaXplZFtub3JtYWxpemVkS2V5XSA9XHJcbiAgICAgICAgICAgICAgICAgICAgaXNBcnJheShvcHQpIHx8IGlzRnVuY3Rpb24ob3B0KSA/IHsgdHlwZTogb3B0IH0gOiBvcHQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHByb3ApIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBib29sZWFuSW5kZXggPSBnZXRUeXBlSW5kZXgoQm9vbGVhbiwgcHJvcC50eXBlKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdHJpbmdJbmRleCA9IGdldFR5cGVJbmRleChTdHJpbmcsIHByb3AudHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcFswIC8qIHNob3VsZENhc3QgKi9dID0gYm9vbGVhbkluZGV4ID4gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcFsxIC8qIHNob3VsZENhc3RUcnVlICovXSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZ0luZGV4IDwgMCB8fCBib29sZWFuSW5kZXggPCBzdHJpbmdJbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgcHJvcCBuZWVkcyBib29sZWFuIGNhc3Rpbmcgb3IgZGVmYXVsdCB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChib29sZWFuSW5kZXggPiAtMSB8fCBoYXNPd24ocHJvcCwgJ2RlZmF1bHQnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZWVkQ2FzdEtleXMucHVzaChub3JtYWxpemVkS2V5KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCByZXMgPSBbbm9ybWFsaXplZCwgbmVlZENhc3RLZXlzXTtcclxuICAgIGNhY2hlLnNldChjb21wLCByZXMpO1xyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BOYW1lKGtleSkge1xyXG4gICAgaWYgKGtleVswXSAhPT0gJyQnKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICB3YXJuKGBJbnZhbGlkIHByb3AgbmFtZTogXCIke2tleX1cIiBpcyBhIHJlc2VydmVkIHByb3BlcnR5LmApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbi8vIHVzZSBmdW5jdGlvbiBzdHJpbmcgbmFtZSB0byBjaGVjayB0eXBlIGNvbnN0cnVjdG9yc1xyXG4vLyBzbyB0aGF0IGl0IHdvcmtzIGFjcm9zcyB2bXMgLyBpZnJhbWVzLlxyXG5mdW5jdGlvbiBnZXRUeXBlKGN0b3IpIHtcclxuICAgIGNvbnN0IG1hdGNoID0gY3RvciAmJiBjdG9yLnRvU3RyaW5nKCkubWF0Y2goL15cXHMqZnVuY3Rpb24gKFxcdyspLyk7XHJcbiAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6IGN0b3IgPT09IG51bGwgPyAnbnVsbCcgOiAnJztcclxufVxyXG5mdW5jdGlvbiBpc1NhbWVUeXBlKGEsIGIpIHtcclxuICAgIHJldHVybiBnZXRUeXBlKGEpID09PSBnZXRUeXBlKGIpO1xyXG59XHJcbmZ1bmN0aW9uIGdldFR5cGVJbmRleCh0eXBlLCBleHBlY3RlZFR5cGVzKSB7XHJcbiAgICBpZiAoaXNBcnJheShleHBlY3RlZFR5cGVzKSkge1xyXG4gICAgICAgIHJldHVybiBleHBlY3RlZFR5cGVzLmZpbmRJbmRleCh0ID0+IGlzU2FtZVR5cGUodCwgdHlwZSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNGdW5jdGlvbihleHBlY3RlZFR5cGVzKSkge1xyXG4gICAgICAgIHJldHVybiBpc1NhbWVUeXBlKGV4cGVjdGVkVHlwZXMsIHR5cGUpID8gMCA6IC0xO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIC0xO1xyXG59XHJcbi8qKlxyXG4gKiBkZXYgb25seVxyXG4gKi9cclxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wcyhyYXdQcm9wcywgcHJvcHMsIGluc3RhbmNlKSB7XHJcbiAgICBjb25zdCByZXNvbHZlZFZhbHVlcyA9IHRvUmF3KHByb3BzKTtcclxuICAgIGNvbnN0IG9wdGlvbnMgPSBpbnN0YW5jZS5wcm9wc09wdGlvbnNbMF07XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvcHRpb25zKSB7XHJcbiAgICAgICAgbGV0IG9wdCA9IG9wdGlvbnNba2V5XTtcclxuICAgICAgICBpZiAob3B0ID09IG51bGwpXHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIHZhbGlkYXRlUHJvcChrZXksIHJlc29sdmVkVmFsdWVzW2tleV0sIG9wdCwgIWhhc093bihyYXdQcm9wcywga2V5KSAmJiAhaGFzT3duKHJhd1Byb3BzLCBoeXBoZW5hdGUoa2V5KSkpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBkZXYgb25seVxyXG4gKi9cclxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wKG5hbWUsIHZhbHVlLCBwcm9wLCBpc0Fic2VudCkge1xyXG4gICAgY29uc3QgeyB0eXBlLCByZXF1aXJlZCwgdmFsaWRhdG9yIH0gPSBwcm9wO1xyXG4gICAgLy8gcmVxdWlyZWQhXHJcbiAgICBpZiAocmVxdWlyZWQgJiYgaXNBYnNlbnQpIHtcclxuICAgICAgICB3YXJuKCdNaXNzaW5nIHJlcXVpcmVkIHByb3A6IFwiJyArIG5hbWUgKyAnXCInKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICAvLyBtaXNzaW5nIGJ1dCBvcHRpb25hbFxyXG4gICAgaWYgKHZhbHVlID09IG51bGwgJiYgIXByb3AucmVxdWlyZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICAvLyB0eXBlIGNoZWNrXHJcbiAgICBpZiAodHlwZSAhPSBudWxsICYmIHR5cGUgIT09IHRydWUpIHtcclxuICAgICAgICBsZXQgaXNWYWxpZCA9IGZhbHNlO1xyXG4gICAgICAgIGNvbnN0IHR5cGVzID0gaXNBcnJheSh0eXBlKSA/IHR5cGUgOiBbdHlwZV07XHJcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRUeXBlcyA9IFtdO1xyXG4gICAgICAgIC8vIHZhbHVlIGlzIHZhbGlkIGFzIGxvbmcgYXMgb25lIG9mIHRoZSBzcGVjaWZpZWQgdHlwZXMgbWF0Y2hcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aCAmJiAhaXNWYWxpZDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgdmFsaWQsIGV4cGVjdGVkVHlwZSB9ID0gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZXNbaV0pO1xyXG4gICAgICAgICAgICBleHBlY3RlZFR5cGVzLnB1c2goZXhwZWN0ZWRUeXBlIHx8ICcnKTtcclxuICAgICAgICAgICAgaXNWYWxpZCA9IHZhbGlkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWlzVmFsaWQpIHtcclxuICAgICAgICAgICAgd2FybihnZXRJbnZhbGlkVHlwZU1lc3NhZ2UobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIGN1c3RvbSB2YWxpZGF0b3JcclxuICAgIGlmICh2YWxpZGF0b3IgJiYgIXZhbGlkYXRvcih2YWx1ZSkpIHtcclxuICAgICAgICB3YXJuKCdJbnZhbGlkIHByb3A6IGN1c3RvbSB2YWxpZGF0b3IgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJyArIG5hbWUgKyAnXCIuJyk7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgaXNTaW1wbGVUeXBlID0gLyojX19QVVJFX18qLyBtYWtlTWFwKCdTdHJpbmcsTnVtYmVyLEJvb2xlYW4sRnVuY3Rpb24sU3ltYm9sLEJpZ0ludCcpO1xyXG4vKipcclxuICogZGV2IG9ubHlcclxuICovXHJcbmZ1bmN0aW9uIGFzc2VydFR5cGUodmFsdWUsIHR5cGUpIHtcclxuICAgIGxldCB2YWxpZDtcclxuICAgIGNvbnN0IGV4cGVjdGVkVHlwZSA9IGdldFR5cGUodHlwZSk7XHJcbiAgICBpZiAoaXNTaW1wbGVUeXBlKGV4cGVjdGVkVHlwZSkpIHtcclxuICAgICAgICBjb25zdCB0ID0gdHlwZW9mIHZhbHVlO1xyXG4gICAgICAgIHZhbGlkID0gdCA9PT0gZXhwZWN0ZWRUeXBlLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgLy8gZm9yIHByaW1pdGl2ZSB3cmFwcGVyIG9iamVjdHNcclxuICAgICAgICBpZiAoIXZhbGlkICYmIHQgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ09iamVjdCcpIHtcclxuICAgICAgICB2YWxpZCA9IGlzT2JqZWN0KHZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ0FycmF5Jykge1xyXG4gICAgICAgIHZhbGlkID0gaXNBcnJheSh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdudWxsJykge1xyXG4gICAgICAgIHZhbGlkID0gdmFsdWUgPT09IG51bGw7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdmFsaWQsXHJcbiAgICAgICAgZXhwZWN0ZWRUeXBlXHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBkZXYgb25seVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0SW52YWxpZFR5cGVNZXNzYWdlKG5hbWUsIHZhbHVlLCBleHBlY3RlZFR5cGVzKSB7XHJcbiAgICBsZXQgbWVzc2FnZSA9IGBJbnZhbGlkIHByb3A6IHR5cGUgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJHtuYW1lfVwiLmAgK1xyXG4gICAgICAgIGAgRXhwZWN0ZWQgJHtleHBlY3RlZFR5cGVzLm1hcChjYXBpdGFsaXplKS5qb2luKCcgfCAnKX1gO1xyXG4gICAgY29uc3QgZXhwZWN0ZWRUeXBlID0gZXhwZWN0ZWRUeXBlc1swXTtcclxuICAgIGNvbnN0IHJlY2VpdmVkVHlwZSA9IHRvUmF3VHlwZSh2YWx1ZSk7XHJcbiAgICBjb25zdCBleHBlY3RlZFZhbHVlID0gc3R5bGVWYWx1ZSh2YWx1ZSwgZXhwZWN0ZWRUeXBlKTtcclxuICAgIGNvbnN0IHJlY2VpdmVkVmFsdWUgPSBzdHlsZVZhbHVlKHZhbHVlLCByZWNlaXZlZFR5cGUpO1xyXG4gICAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBzcGVjaWZ5IGV4cGVjdGVkIHZhbHVlXHJcbiAgICBpZiAoZXhwZWN0ZWRUeXBlcy5sZW5ndGggPT09IDEgJiZcclxuICAgICAgICBpc0V4cGxpY2FibGUoZXhwZWN0ZWRUeXBlKSAmJlxyXG4gICAgICAgICFpc0Jvb2xlYW4oZXhwZWN0ZWRUeXBlLCByZWNlaXZlZFR5cGUpKSB7XHJcbiAgICAgICAgbWVzc2FnZSArPSBgIHdpdGggdmFsdWUgJHtleHBlY3RlZFZhbHVlfWA7XHJcbiAgICB9XHJcbiAgICBtZXNzYWdlICs9IGAsIGdvdCAke3JlY2VpdmVkVHlwZX0gYDtcclxuICAgIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gc3BlY2lmeSByZWNlaXZlZCB2YWx1ZVxyXG4gICAgaWYgKGlzRXhwbGljYWJsZShyZWNlaXZlZFR5cGUpKSB7XHJcbiAgICAgICAgbWVzc2FnZSArPSBgd2l0aCB2YWx1ZSAke3JlY2VpdmVkVmFsdWV9LmA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWVzc2FnZTtcclxufVxyXG4vKipcclxuICogZGV2IG9ubHlcclxuICovXHJcbmZ1bmN0aW9uIHN0eWxlVmFsdWUodmFsdWUsIHR5cGUpIHtcclxuICAgIGlmICh0eXBlID09PSAnU3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiBgXCIke3ZhbHVlfVwiYDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGUgPT09ICdOdW1iZXInKSB7XHJcbiAgICAgICAgcmV0dXJuIGAke051bWJlcih2YWx1ZSl9YDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBgJHt2YWx1ZX1gO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBkZXYgb25seVxyXG4gKi9cclxuZnVuY3Rpb24gaXNFeHBsaWNhYmxlKHR5cGUpIHtcclxuICAgIGNvbnN0IGV4cGxpY2l0VHlwZXMgPSBbJ3N0cmluZycsICdudW1iZXInLCAnYm9vbGVhbiddO1xyXG4gICAgcmV0dXJuIGV4cGxpY2l0VHlwZXMuc29tZShlbGVtID0+IHR5cGUudG9Mb3dlckNhc2UoKSA9PT0gZWxlbSk7XHJcbn1cclxuLyoqXHJcbiAqIGRldiBvbmx5XHJcbiAqL1xyXG5mdW5jdGlvbiBpc0Jvb2xlYW4oLi4uYXJncykge1xyXG4gICAgcmV0dXJuIGFyZ3Muc29tZShlbGVtID0+IGVsZW0udG9Mb3dlckNhc2UoKSA9PT0gJ2Jvb2xlYW4nKTtcclxufVxuXG5jb25zdCBpc0ludGVybmFsS2V5ID0gKGtleSkgPT4ga2V5WzBdID09PSAnXycgfHwga2V5ID09PSAnJHN0YWJsZSc7XHJcbmNvbnN0IG5vcm1hbGl6ZVNsb3RWYWx1ZSA9ICh2YWx1ZSkgPT4gaXNBcnJheSh2YWx1ZSlcclxuICAgID8gdmFsdWUubWFwKG5vcm1hbGl6ZVZOb2RlKVxyXG4gICAgOiBbbm9ybWFsaXplVk5vZGUodmFsdWUpXTtcclxuY29uc3Qgbm9ybWFsaXplU2xvdCA9IChrZXksIHJhd1Nsb3QsIGN0eCkgPT4ge1xyXG4gICAgaWYgKHJhd1Nsb3QuX24pIHtcclxuICAgICAgICAvLyBhbHJlYWR5IG5vcm1hbGl6ZWQgLSAjNTM1M1xyXG4gICAgICAgIHJldHVybiByYXdTbG90O1xyXG4gICAgfVxyXG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IHdpdGhDdHgoKC4uLmFyZ3MpID0+IHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGN1cnJlbnRJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICB3YXJuKGBTbG90IFwiJHtrZXl9XCIgaW52b2tlZCBvdXRzaWRlIG9mIHRoZSByZW5kZXIgZnVuY3Rpb246IGAgK1xyXG4gICAgICAgICAgICAgICAgYHRoaXMgd2lsbCBub3QgdHJhY2sgZGVwZW5kZW5jaWVzIHVzZWQgaW4gdGhlIHNsb3QuIGAgK1xyXG4gICAgICAgICAgICAgICAgYEludm9rZSB0aGUgc2xvdCBmdW5jdGlvbiBpbnNpZGUgdGhlIHJlbmRlciBmdW5jdGlvbiBpbnN0ZWFkLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbm9ybWFsaXplU2xvdFZhbHVlKHJhd1Nsb3QoLi4uYXJncykpO1xyXG4gICAgfSwgY3R4KTtcclxuICAgIG5vcm1hbGl6ZWQuX2MgPSBmYWxzZTtcclxuICAgIHJldHVybiBub3JtYWxpemVkO1xyXG59O1xyXG5jb25zdCBub3JtYWxpemVPYmplY3RTbG90cyA9IChyYXdTbG90cywgc2xvdHMsIGluc3RhbmNlKSA9PiB7XHJcbiAgICBjb25zdCBjdHggPSByYXdTbG90cy5fY3R4O1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gcmF3U2xvdHMpIHtcclxuICAgICAgICBpZiAoaXNJbnRlcm5hbEtleShrZXkpKVxyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IHJhd1Nsb3RzW2tleV07XHJcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHNsb3RzW2tleV0gPSBub3JtYWxpemVTbG90KGtleSwgdmFsdWUsIGN0eCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHZhbHVlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgIShmYWxzZSApKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKGBOb24tZnVuY3Rpb24gdmFsdWUgZW5jb3VudGVyZWQgZm9yIHNsb3QgXCIke2tleX1cIi4gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYFByZWZlciBmdW5jdGlvbiBzbG90cyBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlLmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVTbG90VmFsdWUodmFsdWUpO1xyXG4gICAgICAgICAgICBzbG90c1trZXldID0gKCkgPT4gbm9ybWFsaXplZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IG5vcm1hbGl6ZVZOb2RlU2xvdHMgPSAoaW5zdGFuY2UsIGNoaWxkcmVuKSA9PiB7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgIWlzS2VlcEFsaXZlKGluc3RhbmNlLnZub2RlKSAmJlxyXG4gICAgICAgICEoZmFsc2UgKSkge1xyXG4gICAgICAgIHdhcm4oYE5vbi1mdW5jdGlvbiB2YWx1ZSBlbmNvdW50ZXJlZCBmb3IgZGVmYXVsdCBzbG90LiBgICtcclxuICAgICAgICAgICAgYFByZWZlciBmdW5jdGlvbiBzbG90cyBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlLmApO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZVNsb3RWYWx1ZShjaGlsZHJlbik7XHJcbiAgICBpbnN0YW5jZS5zbG90cy5kZWZhdWx0ID0gKCkgPT4gbm9ybWFsaXplZDtcclxufTtcclxuY29uc3QgaW5pdFNsb3RzID0gKGluc3RhbmNlLCBjaGlsZHJlbikgPT4ge1xyXG4gICAgaWYgKGluc3RhbmNlLnZub2RlLnNoYXBlRmxhZyAmIDMyIC8qIFNMT1RTX0NISUxEUkVOICovKSB7XHJcbiAgICAgICAgY29uc3QgdHlwZSA9IGNoaWxkcmVuLl87XHJcbiAgICAgICAgaWYgKHR5cGUpIHtcclxuICAgICAgICAgICAgLy8gdXNlcnMgY2FuIGdldCB0aGUgc2hhbGxvdyByZWFkb25seSB2ZXJzaW9uIG9mIHRoZSBzbG90cyBvYmplY3QgdGhyb3VnaCBgdGhpcy4kc2xvdHNgLFxyXG4gICAgICAgICAgICAvLyB3ZSBzaG91bGQgYXZvaWQgdGhlIHByb3h5IG9iamVjdCBwb2xsdXRpbmcgdGhlIHNsb3RzIG9mIHRoZSBpbnRlcm5hbCBpbnN0YW5jZVxyXG4gICAgICAgICAgICBpbnN0YW5jZS5zbG90cyA9IHRvUmF3KGNoaWxkcmVuKTtcclxuICAgICAgICAgICAgLy8gbWFrZSBjb21waWxlciBtYXJrZXIgbm9uLWVudW1lcmFibGVcclxuICAgICAgICAgICAgZGVmKGNoaWxkcmVuLCAnXycsIHR5cGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbm9ybWFsaXplT2JqZWN0U2xvdHMoY2hpbGRyZW4sIChpbnN0YW5jZS5zbG90cyA9IHt9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaW5zdGFuY2Uuc2xvdHMgPSB7fTtcclxuICAgICAgICBpZiAoY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgbm9ybWFsaXplVk5vZGVTbG90cyhpbnN0YW5jZSwgY2hpbGRyZW4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGRlZihpbnN0YW5jZS5zbG90cywgSW50ZXJuYWxPYmplY3RLZXksIDEpO1xyXG59O1xyXG5jb25zdCB1cGRhdGVTbG90cyA9IChpbnN0YW5jZSwgY2hpbGRyZW4sIG9wdGltaXplZCkgPT4ge1xyXG4gICAgY29uc3QgeyB2bm9kZSwgc2xvdHMgfSA9IGluc3RhbmNlO1xyXG4gICAgbGV0IG5lZWREZWxldGlvbkNoZWNrID0gdHJ1ZTtcclxuICAgIGxldCBkZWxldGlvbkNvbXBhcmlzb25UYXJnZXQgPSBFTVBUWV9PQko7XHJcbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMzIgLyogU0xPVFNfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICBjb25zdCB0eXBlID0gY2hpbGRyZW4uXztcclxuICAgICAgICBpZiAodHlwZSkge1xyXG4gICAgICAgICAgICAvLyBjb21waWxlZCBzbG90cy5cclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBpc0htclVwZGF0aW5nKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBQYXJlbnQgd2FzIEhNUiB1cGRhdGVkIHNvIHNsb3QgY29udGVudCBtYXkgaGF2ZSBjaGFuZ2VkLlxyXG4gICAgICAgICAgICAgICAgLy8gZm9yY2UgdXBkYXRlIHNsb3RzIGFuZCBtYXJrIGluc3RhbmNlIGZvciBobXIgYXMgd2VsbFxyXG4gICAgICAgICAgICAgICAgZXh0ZW5kKHNsb3RzLCBjaGlsZHJlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAob3B0aW1pemVkICYmIHR5cGUgPT09IDEgLyogU1RBQkxFICovKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjb21waWxlZCBBTkQgc3RhYmxlLlxyXG4gICAgICAgICAgICAgICAgLy8gbm8gbmVlZCB0byB1cGRhdGUsIGFuZCBza2lwIHN0YWxlIHNsb3RzIHJlbW92YWwuXHJcbiAgICAgICAgICAgICAgICBuZWVkRGVsZXRpb25DaGVjayA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gY29tcGlsZWQgYnV0IGR5bmFtaWMgKHYtaWYvdi1mb3Igb24gc2xvdHMpIC0gdXBkYXRlIHNsb3RzLCBidXQgc2tpcFxyXG4gICAgICAgICAgICAgICAgLy8gbm9ybWFsaXphdGlvbi5cclxuICAgICAgICAgICAgICAgIGV4dGVuZChzbG90cywgY2hpbGRyZW4pO1xyXG4gICAgICAgICAgICAgICAgLy8gIzI4OTNcclxuICAgICAgICAgICAgICAgIC8vIHdoZW4gcmVuZGVyaW5nIHRoZSBvcHRpbWl6ZWQgc2xvdHMgYnkgbWFudWFsbHkgd3JpdHRlbiByZW5kZXIgZnVuY3Rpb24sXHJcbiAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGRlbGV0ZSB0aGUgYHNsb3RzLl9gIGZsYWcgaWYgbmVjZXNzYXJ5IHRvIG1ha2Ugc3Vic2VxdWVudCB1cGRhdGVzIHJlbGlhYmxlLFxyXG4gICAgICAgICAgICAgICAgLy8gaS5lLiBsZXQgdGhlIGByZW5kZXJTbG90YCBjcmVhdGUgdGhlIGJhaWxlZCBGcmFnbWVudFxyXG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpbWl6ZWQgJiYgdHlwZSA9PT0gMSAvKiBTVEFCTEUgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc2xvdHMuXztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbmVlZERlbGV0aW9uQ2hlY2sgPSAhY2hpbGRyZW4uJHN0YWJsZTtcclxuICAgICAgICAgICAgbm9ybWFsaXplT2JqZWN0U2xvdHMoY2hpbGRyZW4sIHNsb3RzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVsZXRpb25Db21wYXJpc29uVGFyZ2V0ID0gY2hpbGRyZW47XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChjaGlsZHJlbikge1xyXG4gICAgICAgIC8vIG5vbiBzbG90IG9iamVjdCBjaGlsZHJlbiAoZGlyZWN0IHZhbHVlKSBwYXNzZWQgdG8gYSBjb21wb25lbnRcclxuICAgICAgICBub3JtYWxpemVWTm9kZVNsb3RzKGluc3RhbmNlLCBjaGlsZHJlbik7XHJcbiAgICAgICAgZGVsZXRpb25Db21wYXJpc29uVGFyZ2V0ID0geyBkZWZhdWx0OiAxIH07XHJcbiAgICB9XHJcbiAgICAvLyBkZWxldGUgc3RhbGUgc2xvdHNcclxuICAgIGlmIChuZWVkRGVsZXRpb25DaGVjaykge1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNsb3RzKSB7XHJcbiAgICAgICAgICAgIGlmICghaXNJbnRlcm5hbEtleShrZXkpICYmICEoa2V5IGluIGRlbGV0aW9uQ29tcGFyaXNvblRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBzbG90c1trZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xuXG5mdW5jdGlvbiBjcmVhdGVBcHBDb250ZXh0KCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBhcHA6IG51bGwsXHJcbiAgICAgICAgY29uZmlnOiB7XHJcbiAgICAgICAgICAgIGlzTmF0aXZlVGFnOiBOTyxcclxuICAgICAgICAgICAgcGVyZm9ybWFuY2U6IGZhbHNlLFxyXG4gICAgICAgICAgICBnbG9iYWxQcm9wZXJ0aWVzOiB7fSxcclxuICAgICAgICAgICAgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzOiB7fSxcclxuICAgICAgICAgICAgZXJyb3JIYW5kbGVyOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIHdhcm5IYW5kbGVyOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIGNvbXBpbGVyT3B0aW9uczoge31cclxuICAgICAgICB9LFxyXG4gICAgICAgIG1peGluczogW10sXHJcbiAgICAgICAgY29tcG9uZW50czoge30sXHJcbiAgICAgICAgZGlyZWN0aXZlczoge30sXHJcbiAgICAgICAgcHJvdmlkZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXHJcbiAgICAgICAgb3B0aW9uc0NhY2hlOiBuZXcgV2Vha01hcCgpLFxyXG4gICAgICAgIHByb3BzQ2FjaGU6IG5ldyBXZWFrTWFwKCksXHJcbiAgICAgICAgZW1pdHNDYWNoZTogbmV3IFdlYWtNYXAoKVxyXG4gICAgfTtcclxufVxyXG5sZXQgdWlkID0gMDtcclxuZnVuY3Rpb24gY3JlYXRlQXBwQVBJKHJlbmRlciwgaHlkcmF0ZSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUFwcChyb290Q29tcG9uZW50LCByb290UHJvcHMgPSBudWxsKSB7XHJcbiAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKHJvb3RDb21wb25lbnQpKSB7XHJcbiAgICAgICAgICAgIHJvb3RDb21wb25lbnQgPSBPYmplY3QuYXNzaWduKHt9LCByb290Q29tcG9uZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJvb3RQcm9wcyAhPSBudWxsICYmICFpc09iamVjdChyb290UHJvcHMpKSB7XHJcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB3YXJuKGByb290IHByb3BzIHBhc3NlZCB0byBhcHAubW91bnQoKSBtdXN0IGJlIGFuIG9iamVjdC5gKTtcclxuICAgICAgICAgICAgcm9vdFByb3BzID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZUFwcENvbnRleHQoKTtcclxuICAgICAgICBjb25zdCBpbnN0YWxsZWRQbHVnaW5zID0gbmV3IFNldCgpO1xyXG4gICAgICAgIGxldCBpc01vdW50ZWQgPSBmYWxzZTtcclxuICAgICAgICBjb25zdCBhcHAgPSAoY29udGV4dC5hcHAgPSB7XHJcbiAgICAgICAgICAgIF91aWQ6IHVpZCsrLFxyXG4gICAgICAgICAgICBfY29tcG9uZW50OiByb290Q29tcG9uZW50LFxyXG4gICAgICAgICAgICBfcHJvcHM6IHJvb3RQcm9wcyxcclxuICAgICAgICAgICAgX2NvbnRhaW5lcjogbnVsbCxcclxuICAgICAgICAgICAgX2NvbnRleHQ6IGNvbnRleHQsXHJcbiAgICAgICAgICAgIF9pbnN0YW5jZTogbnVsbCxcclxuICAgICAgICAgICAgdmVyc2lvbixcclxuICAgICAgICAgICAgZ2V0IGNvbmZpZygpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmNvbmZpZztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0IGNvbmZpZyh2KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgYXBwLmNvbmZpZyBjYW5ub3QgYmUgcmVwbGFjZWQuIE1vZGlmeSBpbmRpdmlkdWFsIG9wdGlvbnMgaW5zdGVhZC5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdXNlKHBsdWdpbiwgLi4ub3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbGxlZFBsdWdpbnMuaGFzKHBsdWdpbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgd2FybihgUGx1Z2luIGhhcyBhbHJlYWR5IGJlZW4gYXBwbGllZCB0byB0YXJnZXQgYXBwLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocGx1Z2luICYmIGlzRnVuY3Rpb24ocGx1Z2luLmluc3RhbGwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFsbGVkUGx1Z2lucy5hZGQocGx1Z2luKTtcclxuICAgICAgICAgICAgICAgICAgICBwbHVnaW4uaW5zdGFsbChhcHAsIC4uLm9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNGdW5jdGlvbihwbHVnaW4pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFsbGVkUGx1Z2lucy5hZGQocGx1Z2luKTtcclxuICAgICAgICAgICAgICAgICAgICBwbHVnaW4oYXBwLCAuLi5vcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYEEgcGx1Z2luIG11c3QgZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgYW4gb2JqZWN0IHdpdGggYW4gXCJpbnN0YWxsXCIgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGBmdW5jdGlvbi5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBhcHA7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG1peGluKG1peGluKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX19WVUVfT1BUSU9OU19BUElfXykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghY29udGV4dC5taXhpbnMuaW5jbHVkZXMobWl4aW4pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQubWl4aW5zLnB1c2gobWl4aW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybignTWl4aW4gaGFzIGFscmVhZHkgYmVlbiBhcHBsaWVkIHRvIHRhcmdldCBhcHAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChtaXhpbi5uYW1lID8gYDogJHttaXhpbi5uYW1lfWAgOiAnJykpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oJ01peGlucyBhcmUgb25seSBhdmFpbGFibGUgaW4gYnVpbGRzIHN1cHBvcnRpbmcgT3B0aW9ucyBBUEknKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBhcHA7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNvbXBvbmVudChuYW1lLCBjb21wb25lbnQpIHtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUobmFtZSwgY29udGV4dC5jb25maWcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFjb21wb25lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5jb21wb25lbnRzW25hbWVdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBjb250ZXh0LmNvbXBvbmVudHNbbmFtZV0pIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKGBDb21wb25lbnQgXCIke25hbWV9XCIgaGFzIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkIGluIHRhcmdldCBhcHAuYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmNvbXBvbmVudHNbbmFtZV0gPSBjb21wb25lbnQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkaXJlY3RpdmUobmFtZSwgZGlyZWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVEaXJlY3RpdmVOYW1lKG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFkaXJlY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5kaXJlY3RpdmVzW25hbWVdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBjb250ZXh0LmRpcmVjdGl2ZXNbbmFtZV0pIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKGBEaXJlY3RpdmUgXCIke25hbWV9XCIgaGFzIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkIGluIHRhcmdldCBhcHAuYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmRpcmVjdGl2ZXNbbmFtZV0gPSBkaXJlY3RpdmU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBtb3VudChyb290Q29udGFpbmVyLCBpc0h5ZHJhdGUsIGlzU1ZHKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzTW91bnRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICM1NTcxXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiByb290Q29udGFpbmVyLl9fdnVlX2FwcF9fKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oYFRoZXJlIGlzIGFscmVhZHkgYW4gYXBwIGluc3RhbmNlIG1vdW50ZWQgb24gdGhlIGhvc3QgY29udGFpbmVyLlxcbmAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYCBJZiB5b3Ugd2FudCB0byBtb3VudCBhbm90aGVyIGFwcCBvbiB0aGUgc2FtZSBob3N0IGNvbnRhaW5lcixgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAgeW91IG5lZWQgdG8gdW5tb3VudCB0aGUgcHJldmlvdXMgYXBwIGJ5IGNhbGxpbmcgXFxgYXBwLnVubW91bnQoKVxcYCBmaXJzdC5gKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgdm5vZGUgPSBjcmVhdGVWTm9kZShyb290Q29tcG9uZW50LCByb290UHJvcHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0b3JlIGFwcCBjb250ZXh0IG9uIHRoZSByb290IFZOb2RlLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBiZSBzZXQgb24gdGhlIHJvb3QgaW5zdGFuY2Ugb24gaW5pdGlhbCBtb3VudC5cclxuICAgICAgICAgICAgICAgICAgICB2bm9kZS5hcHBDb250ZXh0ID0gY29udGV4dDtcclxuICAgICAgICAgICAgICAgICAgICAvLyBITVIgcm9vdCByZWxvYWRcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQucmVsb2FkID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyKGNsb25lVk5vZGUodm5vZGUpLCByb290Q29udGFpbmVyLCBpc1NWRyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0h5ZHJhdGUgJiYgaHlkcmF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoeWRyYXRlKHZub2RlLCByb290Q29udGFpbmVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcih2bm9kZSwgcm9vdENvbnRhaW5lciwgaXNTVkcpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpc01vdW50ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGFwcC5fY29udGFpbmVyID0gcm9vdENvbnRhaW5lcjtcclxuICAgICAgICAgICAgICAgICAgICByb290Q29udGFpbmVyLl9fdnVlX2FwcF9fID0gYXBwO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcC5faW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldnRvb2xzSW5pdEFwcChhcHAsIHZlcnNpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0RXhwb3NlUHJveHkodm5vZGUuY29tcG9uZW50KSB8fCB2bm9kZS5jb21wb25lbnQucHJveHk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKGBBcHAgaGFzIGFscmVhZHkgYmVlbiBtb3VudGVkLlxcbmAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgSWYgeW91IHdhbnQgdG8gcmVtb3VudCB0aGUgc2FtZSBhcHAsIG1vdmUgeW91ciBhcHAgY3JlYXRpb24gbG9naWMgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGBpbnRvIGEgZmFjdG9yeSBmdW5jdGlvbiBhbmQgY3JlYXRlIGZyZXNoIGFwcCBpbnN0YW5jZXMgZm9yIGVhY2ggYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGBtb3VudCAtIGUuZy4gXFxgY29uc3QgY3JlYXRlTXlBcHAgPSAoKSA9PiBjcmVhdGVBcHAoQXBwKVxcYGApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB1bm1vdW50KCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTW91bnRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcihudWxsLCBhcHAuX2NvbnRhaW5lcik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXBwLl9pbnN0YW5jZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldnRvb2xzVW5tb3VudEFwcChhcHApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgYXBwLl9jb250YWluZXIuX192dWVfYXBwX187XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKGBDYW5ub3QgdW5tb3VudCBhbiBhcHAgdGhhdCBpcyBub3QgbW91bnRlZC5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcHJvdmlkZShrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGtleSBpbiBjb250ZXh0LnByb3ZpZGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgQXBwIGFscmVhZHkgcHJvdmlkZXMgcHJvcGVydHkgd2l0aCBrZXkgXCIke1N0cmluZyhrZXkpfVwiLiBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYEl0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gd2l0aCB0aGUgbmV3IHZhbHVlLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29udGV4dC5wcm92aWRlc1trZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGFwcDtcclxuICAgIH07XHJcbn1cblxuLyoqXHJcbiAqIEZ1bmN0aW9uIGZvciBoYW5kbGluZyBhIHRlbXBsYXRlIHJlZlxyXG4gKi9cclxuZnVuY3Rpb24gc2V0UmVmKHJhd1JlZiwgb2xkUmF3UmVmLCBwYXJlbnRTdXNwZW5zZSwgdm5vZGUsIGlzVW5tb3VudCA9IGZhbHNlKSB7XHJcbiAgICBpZiAoaXNBcnJheShyYXdSZWYpKSB7XHJcbiAgICAgICAgcmF3UmVmLmZvckVhY2goKHIsIGkpID0+IHNldFJlZihyLCBvbGRSYXdSZWYgJiYgKGlzQXJyYXkob2xkUmF3UmVmKSA/IG9sZFJhd1JlZltpXSA6IG9sZFJhd1JlZiksIHBhcmVudFN1c3BlbnNlLCB2bm9kZSwgaXNVbm1vdW50KSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzQXN5bmNXcmFwcGVyKHZub2RlKSAmJiAhaXNVbm1vdW50KSB7XHJcbiAgICAgICAgLy8gd2hlbiBtb3VudGluZyBhc3luYyBjb21wb25lbnRzLCBub3RoaW5nIG5lZWRzIHRvIGJlIGRvbmUsXHJcbiAgICAgICAgLy8gYmVjYXVzZSB0aGUgdGVtcGxhdGUgcmVmIGlzIGZvcndhcmRlZCB0byBpbm5lciBjb21wb25lbnRcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCByZWZWYWx1ZSA9IHZub2RlLnNoYXBlRmxhZyAmIDQgLyogU1RBVEVGVUxfQ09NUE9ORU5UICovXHJcbiAgICAgICAgPyBnZXRFeHBvc2VQcm94eSh2bm9kZS5jb21wb25lbnQpIHx8IHZub2RlLmNvbXBvbmVudC5wcm94eVxyXG4gICAgICAgIDogdm5vZGUuZWw7XHJcbiAgICBjb25zdCB2YWx1ZSA9IGlzVW5tb3VudCA/IG51bGwgOiByZWZWYWx1ZTtcclxuICAgIGNvbnN0IHsgaTogb3duZXIsIHI6IHJlZiB9ID0gcmF3UmVmO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhb3duZXIpIHtcclxuICAgICAgICB3YXJuKGBNaXNzaW5nIHJlZiBvd25lciBjb250ZXh0LiByZWYgY2Fubm90IGJlIHVzZWQgb24gaG9pc3RlZCB2bm9kZXMuIGAgK1xyXG4gICAgICAgICAgICBgQSB2bm9kZSB3aXRoIHJlZiBtdXN0IGJlIGNyZWF0ZWQgaW5zaWRlIHRoZSByZW5kZXIgZnVuY3Rpb24uYCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgb2xkUmVmID0gb2xkUmF3UmVmICYmIG9sZFJhd1JlZi5yO1xyXG4gICAgY29uc3QgcmVmcyA9IG93bmVyLnJlZnMgPT09IEVNUFRZX09CSiA/IChvd25lci5yZWZzID0ge30pIDogb3duZXIucmVmcztcclxuICAgIGNvbnN0IHNldHVwU3RhdGUgPSBvd25lci5zZXR1cFN0YXRlO1xyXG4gICAgLy8gZHluYW1pYyByZWYgY2hhbmdlZC4gdW5zZXQgb2xkIHJlZlxyXG4gICAgaWYgKG9sZFJlZiAhPSBudWxsICYmIG9sZFJlZiAhPT0gcmVmKSB7XHJcbiAgICAgICAgaWYgKGlzU3RyaW5nKG9sZFJlZikpIHtcclxuICAgICAgICAgICAgcmVmc1tvbGRSZWZdID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKGhhc093bihzZXR1cFN0YXRlLCBvbGRSZWYpKSB7XHJcbiAgICAgICAgICAgICAgICBzZXR1cFN0YXRlW29sZFJlZl0gPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzUmVmKG9sZFJlZikpIHtcclxuICAgICAgICAgICAgb2xkUmVmLnZhbHVlID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoaXNGdW5jdGlvbihyZWYpKSB7XHJcbiAgICAgICAgY2FsbFdpdGhFcnJvckhhbmRsaW5nKHJlZiwgb3duZXIsIDEyIC8qIEZVTkNUSU9OX1JFRiAqLywgW3ZhbHVlLCByZWZzXSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBfaXNTdHJpbmcgPSBpc1N0cmluZyhyZWYpO1xyXG4gICAgICAgIGNvbnN0IF9pc1JlZiA9IGlzUmVmKHJlZik7XHJcbiAgICAgICAgaWYgKF9pc1N0cmluZyB8fCBfaXNSZWYpIHtcclxuICAgICAgICAgICAgY29uc3QgZG9TZXQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmF3UmVmLmYpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZyA9IF9pc1N0cmluZyA/IHJlZnNbcmVmXSA6IHJlZi52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNVbm1vdW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQXJyYXkoZXhpc3RpbmcpICYmIHJlbW92ZShleGlzdGluZywgcmVmVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0FycmF5KGV4aXN0aW5nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pc1N0cmluZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnNbcmVmXSA9IFtyZWZWYWx1ZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc093bihzZXR1cFN0YXRlLCByZWYpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHVwU3RhdGVbcmVmXSA9IHJlZnNbcmVmXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWYudmFsdWUgPSBbcmVmVmFsdWVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyYXdSZWYuaylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmc1tyYXdSZWYua10gPSByZWYudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWV4aXN0aW5nLmluY2x1ZGVzKHJlZlZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcucHVzaChyZWZWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChfaXNTdHJpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWZzW3JlZl0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzT3duKHNldHVwU3RhdGUsIHJlZikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dXBTdGF0ZVtyZWZdID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNSZWYocmVmKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlZi52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyYXdSZWYuaylcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmc1tyYXdSZWYua10gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oJ0ludmFsaWQgdGVtcGxhdGUgcmVmIHR5cGU6JywgcmVmLCBgKCR7dHlwZW9mIHJlZn0pYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgZG9TZXQuaWQgPSAtMTtcclxuICAgICAgICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChkb1NldCwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZG9TZXQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgd2FybignSW52YWxpZCB0ZW1wbGF0ZSByZWYgdHlwZTonLCByZWYsIGAoJHt0eXBlb2YgcmVmfSlgKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxubGV0IGhhc01pc21hdGNoID0gZmFsc2U7XHJcbmNvbnN0IGlzU1ZHQ29udGFpbmVyID0gKGNvbnRhaW5lcikgPT4gL3N2Zy8udGVzdChjb250YWluZXIubmFtZXNwYWNlVVJJKSAmJiBjb250YWluZXIudGFnTmFtZSAhPT0gJ2ZvcmVpZ25PYmplY3QnO1xyXG5jb25zdCBpc0NvbW1lbnQgPSAobm9kZSkgPT4gbm9kZS5ub2RlVHlwZSA9PT0gOCAvKiBDT01NRU5UICovO1xyXG4vLyBOb3RlOiBoeWRyYXRpb24gaXMgRE9NLXNwZWNpZmljXHJcbi8vIEJ1dCB3ZSBoYXZlIHRvIHBsYWNlIGl0IGluIGNvcmUgZHVlIHRvIHRpZ2h0IGNvdXBsaW5nIHdpdGggY29yZSAtIHNwbGl0dGluZ1xyXG4vLyBpdCBvdXQgY3JlYXRlcyBhIHRvbiBvZiB1bm5lY2Vzc2FyeSBjb21wbGV4aXR5LlxyXG4vLyBIeWRyYXRpb24gYWxzbyBkZXBlbmRzIG9uIHNvbWUgcmVuZGVyZXIgaW50ZXJuYWwgbG9naWMgd2hpY2ggbmVlZHMgdG8gYmVcclxuLy8gcGFzc2VkIGluIHZpYSBhcmd1bWVudHMuXHJcbmZ1bmN0aW9uIGNyZWF0ZUh5ZHJhdGlvbkZ1bmN0aW9ucyhyZW5kZXJlckludGVybmFscykge1xyXG4gICAgY29uc3QgeyBtdDogbW91bnRDb21wb25lbnQsIHA6IHBhdGNoLCBvOiB7IHBhdGNoUHJvcCwgY3JlYXRlVGV4dCwgbmV4dFNpYmxpbmcsIHBhcmVudE5vZGUsIHJlbW92ZSwgaW5zZXJ0LCBjcmVhdGVDb21tZW50IH0gfSA9IHJlbmRlcmVySW50ZXJuYWxzO1xyXG4gICAgY29uc3QgaHlkcmF0ZSA9ICh2bm9kZSwgY29udGFpbmVyKSA9PiB7XHJcbiAgICAgICAgaWYgKCFjb250YWluZXIuaGFzQ2hpbGROb2RlcygpKSB7XHJcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgd2FybihgQXR0ZW1wdGluZyB0byBoeWRyYXRlIGV4aXN0aW5nIG1hcmt1cCBidXQgY29udGFpbmVyIGlzIGVtcHR5LiBgICtcclxuICAgICAgICAgICAgICAgICAgICBgUGVyZm9ybWluZyBmdWxsIG1vdW50IGluc3RlYWQuYCk7XHJcbiAgICAgICAgICAgIHBhdGNoKG51bGwsIHZub2RlLCBjb250YWluZXIpO1xyXG4gICAgICAgICAgICBmbHVzaFBvc3RGbHVzaENicygpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGhhc01pc21hdGNoID0gZmFsc2U7XHJcbiAgICAgICAgaHlkcmF0ZU5vZGUoY29udGFpbmVyLmZpcnN0Q2hpbGQsIHZub2RlLCBudWxsLCBudWxsLCBudWxsKTtcclxuICAgICAgICBmbHVzaFBvc3RGbHVzaENicygpO1xyXG4gICAgICAgIGlmIChoYXNNaXNtYXRjaCAmJiAhZmFsc2UpIHtcclxuICAgICAgICAgICAgLy8gdGhpcyBlcnJvciBzaG91bGQgc2hvdyB1cCBpbiBwcm9kdWN0aW9uXHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEh5ZHJhdGlvbiBjb21wbGV0ZWQgYnV0IGNvbnRhaW5zIG1pc21hdGNoZXMuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IGh5ZHJhdGVOb2RlID0gKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCA9IGZhbHNlKSA9PiB7XHJcbiAgICAgICAgY29uc3QgaXNGcmFnbWVudFN0YXJ0ID0gaXNDb21tZW50KG5vZGUpICYmIG5vZGUuZGF0YSA9PT0gJ1snO1xyXG4gICAgICAgIGNvbnN0IG9uTWlzbWF0Y2ggPSAoKSA9PiBoYW5kbGVNaXNtYXRjaChub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBpc0ZyYWdtZW50U3RhcnQpO1xyXG4gICAgICAgIGNvbnN0IHsgdHlwZSwgcmVmLCBzaGFwZUZsYWcsIHBhdGNoRmxhZyB9ID0gdm5vZGU7XHJcbiAgICAgICAgY29uc3QgZG9tVHlwZSA9IG5vZGUubm9kZVR5cGU7XHJcbiAgICAgICAgdm5vZGUuZWwgPSBub2RlO1xyXG4gICAgICAgIGlmIChwYXRjaEZsYWcgPT09IC0yIC8qIEJBSUwgKi8pIHtcclxuICAgICAgICAgICAgb3B0aW1pemVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHZub2RlLmR5bmFtaWNDaGlsZHJlbiA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBuZXh0Tm9kZSA9IG51bGw7XHJcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgVGV4dDpcclxuICAgICAgICAgICAgICAgIGlmIChkb21UeXBlICE9PSAzIC8qIFRFWFQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyAjNTcyOCBlbXB0eSB0ZXh0IG5vZGUgaW5zaWRlIGEgc2xvdCBjYW4gY2F1c2UgaHlkcmF0aW9uIGZhaWx1cmVcclxuICAgICAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIHRoZSBzZXJ2ZXIgcmVuZGVyZWQgSFRNTCB3b24ndCBjb250YWluIGEgdGV4dCBub2RlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZub2RlLmNoaWxkcmVuID09PSAnJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnQoKHZub2RlLmVsID0gY3JlYXRlVGV4dCgnJykpLCBwYXJlbnROb2RlKG5vZGUpLCBub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBub2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBvbk1pc21hdGNoKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuZGF0YSAhPT0gdm5vZGUuY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzTWlzbWF0Y2ggPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oYEh5ZHJhdGlvbiB0ZXh0IG1pc21hdGNoOmAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBcXG4tIENsaWVudDogJHtKU09OLnN0cmluZ2lmeShub2RlLmRhdGEpfWAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBcXG4tIFNlcnZlcjogJHtKU09OLnN0cmluZ2lmeSh2bm9kZS5jaGlsZHJlbil9YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuZGF0YSA9IHZub2RlLmNoaWxkcmVuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IG5leHRTaWJsaW5nKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgQ29tbWVudDpcclxuICAgICAgICAgICAgICAgIGlmIChkb21UeXBlICE9PSA4IC8qIENPTU1FTlQgKi8gfHwgaXNGcmFnbWVudFN0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBvbk1pc21hdGNoKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IG5leHRTaWJsaW5nKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgU3RhdGljOlxyXG4gICAgICAgICAgICAgICAgaWYgKGRvbVR5cGUgIT09IDEgLyogRUxFTUVOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gb25NaXNtYXRjaCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIGFuY2hvciwgYWRvcHQgY29udGVudFxyXG4gICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gbm9kZTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgc3RhdGljIHZub2RlIGhhcyBpdHMgY29udGVudCBzdHJpcHBlZCBkdXJpbmcgYnVpbGQsXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRvcHQgaXQgZnJvbSB0aGUgc2VydmVyLXJlbmRlcmVkIEhUTUwuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmVlZFRvQWRvcHRDb250ZW50ID0gIXZub2RlLmNoaWxkcmVuLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZub2RlLnN0YXRpY0NvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5lZWRUb0Fkb3B0Q29udGVudClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZub2RlLmNoaWxkcmVuICs9IG5leHROb2RlLm91dGVySFRNTDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IHZub2RlLnN0YXRpY0NvdW50IC0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdm5vZGUuYW5jaG9yID0gbmV4dE5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBuZXh0U2libGluZyhuZXh0Tm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0Tm9kZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIEZyYWdtZW50OlxyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0ZyYWdtZW50U3RhcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gaHlkcmF0ZUZyYWdtZW50KG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGlmIChzaGFwZUZsYWcgJiAxIC8qIEVMRU1FTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZG9tVHlwZSAhPT0gMSAvKiBFTEVNRU5UICovIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZub2RlLnR5cGUudG9Mb3dlckNhc2UoKSAhPT1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gb25NaXNtYXRjaCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBoeWRyYXRlRWxlbWVudChub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNoYXBlRmxhZyAmIDYgLyogQ09NUE9ORU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiBzZXR0aW5nIHVwIHRoZSByZW5kZXIgZWZmZWN0LCBpZiB0aGUgaW5pdGlhbCB2bm9kZSBhbHJlYWR5XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaGFzIC5lbCBzZXQsIHRoZSBjb21wb25lbnQgd2lsbCBwZXJmb3JtIGh5ZHJhdGlvbiBpbnN0ZWFkIG9mIG1vdW50XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gb24gaXRzIHN1Yi10cmVlLlxyXG4gICAgICAgICAgICAgICAgICAgIHZub2RlLnNsb3RTY29wZUlkcyA9IHNsb3RTY29wZUlkcztcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250YWluZXIgPSBwYXJlbnROb2RlKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1vdW50Q29tcG9uZW50KHZub2RlLCBjb250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHQ29udGFpbmVyKGNvbnRhaW5lciksIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY29tcG9uZW50IG1heSBiZSBhc3luYywgc28gaW4gdGhlIGNhc2Ugb2YgZnJhZ21lbnRzIHdlIGNhbm5vdCByZWx5XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gb24gY29tcG9uZW50J3MgcmVuZGVyZWQgb3V0cHV0IHRvIGRldGVybWluZSB0aGUgZW5kIG9mIHRoZSBmcmFnbWVudFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGluc3RlYWQsIHdlIGRvIGEgbG9va2FoZWFkIHRvIGZpbmQgdGhlIGVuZCBhbmNob3Igbm9kZS5cclxuICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IGlzRnJhZ21lbnRTdGFydFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGxvY2F0ZUNsb3NpbmdBc3luY0FuY2hvcihub2RlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG5leHRTaWJsaW5nKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICM0MjkzIHRlbGVwb3J0IGFzIGNvbXBvbmVudCByb290XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHROb2RlICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQ29tbWVudChuZXh0Tm9kZSkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUuZGF0YSA9PT0gJ3RlbGVwb3J0IGVuZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBuZXh0U2libGluZyhuZXh0Tm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vICMzNzg3XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgY29tcG9uZW50IGlzIGFzeW5jLCBpdCBtYXkgZ2V0IG1vdmVkIC8gdW5tb3VudGVkIGJlZm9yZSBpdHNcclxuICAgICAgICAgICAgICAgICAgICAvLyBpbm5lciBjb21wb25lbnQgaXMgbG9hZGVkLCBzbyB3ZSBuZWVkIHRvIGdpdmUgaXQgYSBwbGFjZWhvbGRlclxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHZub2RlIHRoYXQgbWF0Y2hlcyBpdHMgYWRvcHRlZCBET00uXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQXN5bmNXcmFwcGVyKHZub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3ViVHJlZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRnJhZ21lbnRTdGFydCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViVHJlZSA9IGNyZWF0ZVZOb2RlKEZyYWdtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YlRyZWUuYW5jaG9yID0gbmV4dE5vZGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG5leHROb2RlLnByZXZpb3VzU2libGluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogY29udGFpbmVyLmxhc3RDaGlsZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YlRyZWUgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubm9kZVR5cGUgPT09IDMgPyBjcmVhdGVUZXh0Vk5vZGUoJycpIDogY3JlYXRlVk5vZGUoJ2RpdicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YlRyZWUuZWwgPSBub2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2bm9kZS5jb21wb25lbnQuc3ViVHJlZSA9IHN1YlRyZWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2hhcGVGbGFnICYgNjQgLyogVEVMRVBPUlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZG9tVHlwZSAhPT0gOCAvKiBDT01NRU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gb25NaXNtYXRjaCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSB2bm9kZS50eXBlLmh5ZHJhdGUobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscywgaHlkcmF0ZUNoaWxkcmVuKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaGFwZUZsYWcgJiAxMjggLyogU1VTUEVOU0UgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IHZub2RlLnR5cGUuaHlkcmF0ZShub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkdDb250YWluZXIocGFyZW50Tm9kZShub2RlKSksIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscywgaHlkcmF0ZU5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybignSW52YWxpZCBIb3N0Vk5vZGUgdHlwZTonLCB0eXBlLCBgKCR7dHlwZW9mIHR5cGV9KWApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVmICE9IG51bGwpIHtcclxuICAgICAgICAgICAgc2V0UmVmKHJlZiwgbnVsbCwgcGFyZW50U3VzcGVuc2UsIHZub2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5leHROb2RlO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGh5ZHJhdGVFbGVtZW50ID0gKGVsLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgICAgICBvcHRpbWl6ZWQgPSBvcHRpbWl6ZWQgfHwgISF2bm9kZS5keW5hbWljQ2hpbGRyZW47XHJcbiAgICAgICAgY29uc3QgeyB0eXBlLCBwcm9wcywgcGF0Y2hGbGFnLCBzaGFwZUZsYWcsIGRpcnMgfSA9IHZub2RlO1xyXG4gICAgICAgIC8vICM0MDA2IGZvciBmb3JtIGVsZW1lbnRzIHdpdGggbm9uLXN0cmluZyB2LW1vZGVsIHZhbHVlIGJpbmRpbmdzXHJcbiAgICAgICAgLy8gZS5nLiA8b3B0aW9uIDp2YWx1ZT1cIm9ialwiPiwgPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIDp0cnVlLXZhbHVlPVwiMVwiPlxyXG4gICAgICAgIGNvbnN0IGZvcmNlUGF0Y2hWYWx1ZSA9ICh0eXBlID09PSAnaW5wdXQnICYmIGRpcnMpIHx8IHR5cGUgPT09ICdvcHRpb24nO1xyXG4gICAgICAgIC8vIHNraXAgcHJvcHMgJiBjaGlsZHJlbiBpZiB0aGlzIGlzIGhvaXN0ZWQgc3RhdGljIG5vZGVzXHJcbiAgICAgICAgLy8gIzU0MDUgaW4gZGV2LCBhbHdheXMgaHlkcmF0ZSBjaGlsZHJlbiBmb3IgSE1SXHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBmb3JjZVBhdGNoVmFsdWUgfHwgcGF0Y2hGbGFnICE9PSAtMSAvKiBIT0lTVEVEICovKSB7XHJcbiAgICAgICAgICAgIGlmIChkaXJzKSB7XHJcbiAgICAgICAgICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsICdjcmVhdGVkJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gcHJvcHNcclxuICAgICAgICAgICAgaWYgKHByb3BzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZm9yY2VQYXRjaFZhbHVlIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgIW9wdGltaXplZCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoRmxhZyAmICgxNiAvKiBGVUxMX1BST1BTICovIHwgMzIgLyogSFlEUkFURV9FVkVOVFMgKi8pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChmb3JjZVBhdGNoVmFsdWUgJiYga2V5LmVuZHNXaXRoKCd2YWx1ZScpKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGlzT24oa2V5KSAmJiAhaXNSZXNlcnZlZFByb3Aoa2V5KSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGNoUHJvcChlbCwga2V5LCBudWxsLCBwcm9wc1trZXldLCBmYWxzZSwgdW5kZWZpbmVkLCBwYXJlbnRDb21wb25lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocHJvcHMub25DbGljaykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZhc3QgcGF0aCBmb3IgY2xpY2sgbGlzdGVuZXJzICh3aGljaCBpcyBtb3N0IG9mdGVuKSB0byBhdm9pZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGl0ZXJhdGluZyB0aHJvdWdoIHByb3BzLlxyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoUHJvcChlbCwgJ29uQ2xpY2snLCBudWxsLCBwcm9wcy5vbkNsaWNrLCBmYWxzZSwgdW5kZWZpbmVkLCBwYXJlbnRDb21wb25lbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHZub2RlIC8gZGlyZWN0aXZlIGhvb2tzXHJcbiAgICAgICAgICAgIGxldCB2bm9kZUhvb2tzO1xyXG4gICAgICAgICAgICBpZiAoKHZub2RlSG9va3MgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlQmVmb3JlTW91bnQpKSB7XHJcbiAgICAgICAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rcywgcGFyZW50Q29tcG9uZW50LCB2bm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRpcnMpIHtcclxuICAgICAgICAgICAgICAgIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgJ2JlZm9yZU1vdW50Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCh2bm9kZUhvb2tzID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZU1vdW50ZWQpIHx8IGRpcnMpIHtcclxuICAgICAgICAgICAgICAgIHF1ZXVlRWZmZWN0V2l0aFN1c3BlbnNlKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB2bm9kZUhvb2tzICYmIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2tzLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBkaXJzICYmIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgJ21vdW50ZWQnKTtcclxuICAgICAgICAgICAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBjaGlsZHJlblxyXG4gICAgICAgICAgICBpZiAoc2hhcGVGbGFnICYgMTYgLyogQVJSQVlfQ0hJTERSRU4gKi8gJiZcclxuICAgICAgICAgICAgICAgIC8vIHNraXAgaWYgZWxlbWVudCBoYXMgaW5uZXJIVE1MIC8gdGV4dENvbnRlbnRcclxuICAgICAgICAgICAgICAgICEocHJvcHMgJiYgKHByb3BzLmlubmVySFRNTCB8fCBwcm9wcy50ZXh0Q29udGVudCkpKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IGh5ZHJhdGVDaGlsZHJlbihlbC5maXJzdENoaWxkLCB2bm9kZSwgZWwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIGxldCBoYXNXYXJuZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzTWlzbWF0Y2ggPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWhhc1dhcm5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuKGBIeWRyYXRpb24gY2hpbGRyZW4gbWlzbWF0Y2ggaW4gPCR7dm5vZGUudHlwZX0+OiBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBzZXJ2ZXIgcmVuZGVyZWQgZWxlbWVudCBjb250YWlucyBtb3JlIGNoaWxkIG5vZGVzIHRoYW4gY2xpZW50IHZkb20uYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc1dhcm5lZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBTU1JlZCBET00gY29udGFpbnMgbW9yZSBub2RlcyB0aGFuIGl0IHNob3VsZC4gUmVtb3ZlIHRoZW0uXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VyID0gbmV4dDtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0ID0gbmV4dC5uZXh0U2libGluZztcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmUoY3VyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzaGFwZUZsYWcgJiA4IC8qIFRFWFRfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICAgICAgICAgIGlmIChlbC50ZXh0Q29udGVudCAhPT0gdm5vZGUuY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICBoYXNNaXNtYXRjaCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oYEh5ZHJhdGlvbiB0ZXh0IGNvbnRlbnQgbWlzbWF0Y2ggaW4gPCR7dm5vZGUudHlwZX0+OlxcbmAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYC0gQ2xpZW50OiAke2VsLnRleHRDb250ZW50fVxcbmAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYC0gU2VydmVyOiAke3Zub2RlLmNoaWxkcmVufWApO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsLnRleHRDb250ZW50ID0gdm5vZGUuY2hpbGRyZW47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGVsLm5leHRTaWJsaW5nO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGh5ZHJhdGVDaGlsZHJlbiA9IChub2RlLCBwYXJlbnRWTm9kZSwgY29udGFpbmVyLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgIG9wdGltaXplZCA9IG9wdGltaXplZCB8fCAhIXBhcmVudFZOb2RlLmR5bmFtaWNDaGlsZHJlbjtcclxuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudFZOb2RlLmNoaWxkcmVuO1xyXG4gICAgICAgIGNvbnN0IGwgPSBjaGlsZHJlbi5sZW5ndGg7XHJcbiAgICAgICAgbGV0IGhhc1dhcm5lZCA9IGZhbHNlO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZub2RlID0gb3B0aW1pemVkXHJcbiAgICAgICAgICAgICAgICA/IGNoaWxkcmVuW2ldXHJcbiAgICAgICAgICAgICAgICA6IChjaGlsZHJlbltpXSA9IG5vcm1hbGl6ZVZOb2RlKGNoaWxkcmVuW2ldKSk7XHJcbiAgICAgICAgICAgIGlmIChub2RlKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gaHlkcmF0ZU5vZGUobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh2bm9kZS50eXBlID09PSBUZXh0ICYmICF2bm9kZS5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBoYXNNaXNtYXRjaCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFoYXNXYXJuZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKGBIeWRyYXRpb24gY2hpbGRyZW4gbWlzbWF0Y2ggaW4gPCR7Y29udGFpbmVyLnRhZ05hbWUudG9Mb3dlckNhc2UoKX0+OiBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYHNlcnZlciByZW5kZXJlZCBlbGVtZW50IGNvbnRhaW5zIGZld2VyIGNoaWxkIG5vZGVzIHRoYW4gY2xpZW50IHZkb20uYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzV2FybmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHRoZSBTU1JlZCBET00gZGlkbid0IGNvbnRhaW4gZW5vdWdoIG5vZGVzLiBNb3VudCB0aGUgbWlzc2luZyBvbmVzLlxyXG4gICAgICAgICAgICAgICAgcGF0Y2gobnVsbCwgdm5vZGUsIGNvbnRhaW5lciwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkdDb250YWluZXIoY29udGFpbmVyKSwgc2xvdFNjb3BlSWRzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgIH07XHJcbiAgICBjb25zdCBoeWRyYXRlRnJhZ21lbnQgPSAobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyBzbG90U2NvcGVJZHM6IGZyYWdtZW50U2xvdFNjb3BlSWRzIH0gPSB2bm9kZTtcclxuICAgICAgICBpZiAoZnJhZ21lbnRTbG90U2NvcGVJZHMpIHtcclxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzID0gc2xvdFNjb3BlSWRzXHJcbiAgICAgICAgICAgICAgICA/IHNsb3RTY29wZUlkcy5jb25jYXQoZnJhZ21lbnRTbG90U2NvcGVJZHMpXHJcbiAgICAgICAgICAgICAgICA6IGZyYWdtZW50U2xvdFNjb3BlSWRzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjb250YWluZXIgPSBwYXJlbnROb2RlKG5vZGUpO1xyXG4gICAgICAgIGNvbnN0IG5leHQgPSBoeWRyYXRlQ2hpbGRyZW4obmV4dFNpYmxpbmcobm9kZSksIHZub2RlLCBjb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICBpZiAobmV4dCAmJiBpc0NvbW1lbnQobmV4dCkgJiYgbmV4dC5kYXRhID09PSAnXScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5leHRTaWJsaW5nKCh2bm9kZS5hbmNob3IgPSBuZXh0KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBmcmFnbWVudCBkaWRuJ3QgaHlkcmF0ZSBzdWNjZXNzZnVsbHksIHNpbmNlIHdlIGRpZG4ndCBnZXQgYSBlbmQgYW5jaG9yXHJcbiAgICAgICAgICAgIC8vIGJhY2suIFRoaXMgc2hvdWxkIGhhdmUgbGVkIHRvIG5vZGUvY2hpbGRyZW4gbWlzbWF0Y2ggd2FybmluZ3MuXHJcbiAgICAgICAgICAgIGhhc01pc21hdGNoID0gdHJ1ZTtcclxuICAgICAgICAgICAgLy8gc2luY2UgdGhlIGFuY2hvciBpcyBtaXNzaW5nLCB3ZSBuZWVkIHRvIGNyZWF0ZSBvbmUgYW5kIGluc2VydCBpdFxyXG4gICAgICAgICAgICBpbnNlcnQoKHZub2RlLmFuY2hvciA9IGNyZWF0ZUNvbW1lbnQoYF1gKSksIGNvbnRhaW5lciwgbmV4dCk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXh0O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBoYW5kbGVNaXNtYXRjaCA9IChub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBpc0ZyYWdtZW50KSA9PiB7XHJcbiAgICAgICAgaGFzTWlzbWF0Y2ggPSB0cnVlO1xyXG4gICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICB3YXJuKGBIeWRyYXRpb24gbm9kZSBtaXNtYXRjaDpcXG4tIENsaWVudCB2bm9kZTpgLCB2bm9kZS50eXBlLCBgXFxuLSBTZXJ2ZXIgcmVuZGVyZWQgRE9NOmAsIG5vZGUsIG5vZGUubm9kZVR5cGUgPT09IDMgLyogVEVYVCAqL1xyXG4gICAgICAgICAgICAgICAgPyBgKHRleHQpYFxyXG4gICAgICAgICAgICAgICAgOiBpc0NvbW1lbnQobm9kZSkgJiYgbm9kZS5kYXRhID09PSAnWydcclxuICAgICAgICAgICAgICAgICAgICA/IGAoc3RhcnQgb2YgZnJhZ21lbnQpYFxyXG4gICAgICAgICAgICAgICAgICAgIDogYGApO1xyXG4gICAgICAgIHZub2RlLmVsID0gbnVsbDtcclxuICAgICAgICBpZiAoaXNGcmFnbWVudCkge1xyXG4gICAgICAgICAgICAvLyByZW1vdmUgZXhjZXNzaXZlIGZyYWdtZW50IG5vZGVzXHJcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IGxvY2F0ZUNsb3NpbmdBc3luY0FuY2hvcihub2RlKTtcclxuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSBuZXh0U2libGluZyhub2RlKTtcclxuICAgICAgICAgICAgICAgIGlmIChuZXh0ICYmIG5leHQgIT09IGVuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZShuZXh0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG5leHQgPSBuZXh0U2libGluZyhub2RlKTtcclxuICAgICAgICBjb25zdCBjb250YWluZXIgPSBwYXJlbnROb2RlKG5vZGUpO1xyXG4gICAgICAgIHJlbW92ZShub2RlKTtcclxuICAgICAgICBwYXRjaChudWxsLCB2bm9kZSwgY29udGFpbmVyLCBuZXh0LCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWR0NvbnRhaW5lcihjb250YWluZXIpLCBzbG90U2NvcGVJZHMpO1xyXG4gICAgICAgIHJldHVybiBuZXh0O1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGxvY2F0ZUNsb3NpbmdBc3luY0FuY2hvciA9IChub2RlKSA9PiB7XHJcbiAgICAgICAgbGV0IG1hdGNoID0gMDtcclxuICAgICAgICB3aGlsZSAobm9kZSkge1xyXG4gICAgICAgICAgICBub2RlID0gbmV4dFNpYmxpbmcobm9kZSk7XHJcbiAgICAgICAgICAgIGlmIChub2RlICYmIGlzQ29tbWVudChub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuZGF0YSA9PT0gJ1snKVxyXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoKys7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5kYXRhID09PSAnXScpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2ggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHRTaWJsaW5nKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2gtLTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFtoeWRyYXRlLCBoeWRyYXRlTm9kZV07XHJcbn1cblxuLyogZXNsaW50LWRpc2FibGUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzICovXHJcbmxldCBzdXBwb3J0ZWQ7XHJcbmxldCBwZXJmO1xyXG5mdW5jdGlvbiBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIHR5cGUpIHtcclxuICAgIGlmIChpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZy5wZXJmb3JtYW5jZSAmJiBpc1N1cHBvcnRlZCgpKSB7XHJcbiAgICAgICAgcGVyZi5tYXJrKGB2dWUtJHt0eXBlfS0ke2luc3RhbmNlLnVpZH1gKTtcclxuICAgIH1cclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XHJcbiAgICAgICAgZGV2dG9vbHNQZXJmU3RhcnQoaW5zdGFuY2UsIHR5cGUsIGlzU3VwcG9ydGVkKCkgPyBwZXJmLm5vdygpIDogRGF0ZS5ub3coKSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZW5kTWVhc3VyZShpbnN0YW5jZSwgdHlwZSkge1xyXG4gICAgaWYgKGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLnBlcmZvcm1hbmNlICYmIGlzU3VwcG9ydGVkKCkpIHtcclxuICAgICAgICBjb25zdCBzdGFydFRhZyA9IGB2dWUtJHt0eXBlfS0ke2luc3RhbmNlLnVpZH1gO1xyXG4gICAgICAgIGNvbnN0IGVuZFRhZyA9IHN0YXJ0VGFnICsgYDplbmRgO1xyXG4gICAgICAgIHBlcmYubWFyayhlbmRUYWcpO1xyXG4gICAgICAgIHBlcmYubWVhc3VyZShgPCR7Zm9ybWF0Q29tcG9uZW50TmFtZShpbnN0YW5jZSwgaW5zdGFuY2UudHlwZSl9PiAke3R5cGV9YCwgc3RhcnRUYWcsIGVuZFRhZyk7XHJcbiAgICAgICAgcGVyZi5jbGVhck1hcmtzKHN0YXJ0VGFnKTtcclxuICAgICAgICBwZXJmLmNsZWFyTWFya3MoZW5kVGFnKTtcclxuICAgIH1cclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XHJcbiAgICAgICAgZGV2dG9vbHNQZXJmRW5kKGluc3RhbmNlLCB0eXBlLCBpc1N1cHBvcnRlZCgpID8gcGVyZi5ub3coKSA6IERhdGUubm93KCkpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzU3VwcG9ydGVkKCkge1xyXG4gICAgaWYgKHN1cHBvcnRlZCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIHN1cHBvcnRlZDtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucGVyZm9ybWFuY2UpIHtcclxuICAgICAgICBzdXBwb3J0ZWQgPSB0cnVlO1xyXG4gICAgICAgIHBlcmYgPSB3aW5kb3cucGVyZm9ybWFuY2U7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBzdXBwb3J0ZWQgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiBzdXBwb3J0ZWQ7XHJcbn1cblxuLyoqXHJcbiAqIFRoaXMgaXMgb25seSBjYWxsZWQgaW4gZXNtLWJ1bmRsZXIgYnVpbGRzLlxyXG4gKiBJdCBpcyBjYWxsZWQgd2hlbiBhIHJlbmRlcmVyIGlzIGNyZWF0ZWQsIGluIGBiYXNlQ3JlYXRlUmVuZGVyZXJgIHNvIHRoYXRcclxuICogaW1wb3J0aW5nIHJ1bnRpbWUtY29yZSBpcyBzaWRlLWVmZmVjdHMgZnJlZS5cclxuICpcclxuICogaXN0YW5idWwtaWdub3JlLW5leHRcclxuICovXHJcbmZ1bmN0aW9uIGluaXRGZWF0dXJlRmxhZ3MoKSB7XHJcbiAgICBjb25zdCBuZWVkV2FybiA9IFtdO1xyXG4gICAgaWYgKHR5cGVvZiBfX1ZVRV9PUFRJT05TX0FQSV9fICE9PSAnYm9vbGVhbicpIHtcclxuICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgbmVlZFdhcm4ucHVzaChgX19WVUVfT1BUSU9OU19BUElfX2ApO1xyXG4gICAgICAgIGdldEdsb2JhbFRoaXMoKS5fX1ZVRV9PUFRJT05TX0FQSV9fID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgX19WVUVfUFJPRF9ERVZUT09MU19fICE9PSAnYm9vbGVhbicpIHtcclxuICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgbmVlZFdhcm4ucHVzaChgX19WVUVfUFJPRF9ERVZUT09MU19fYCk7XHJcbiAgICAgICAgZ2V0R2xvYmFsVGhpcygpLl9fVlVFX1BST0RfREVWVE9PTFNfXyA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBuZWVkV2Fybi5sZW5ndGgpIHtcclxuICAgICAgICBjb25zdCBtdWx0aSA9IG5lZWRXYXJuLmxlbmd0aCA+IDE7XHJcbiAgICAgICAgY29uc29sZS53YXJuKGBGZWF0dXJlIGZsYWcke211bHRpID8gYHNgIDogYGB9ICR7bmVlZFdhcm4uam9pbignLCAnKX0gJHttdWx0aSA/IGBhcmVgIDogYGlzYH0gbm90IGV4cGxpY2l0bHkgZGVmaW5lZC4gWW91IGFyZSBydW5uaW5nIHRoZSBlc20tYnVuZGxlciBidWlsZCBvZiBWdWUsIGAgK1xyXG4gICAgICAgICAgICBgd2hpY2ggZXhwZWN0cyB0aGVzZSBjb21waWxlLXRpbWUgZmVhdHVyZSBmbGFncyB0byBiZSBnbG9iYWxseSBpbmplY3RlZCBgICtcclxuICAgICAgICAgICAgYHZpYSB0aGUgYnVuZGxlciBjb25maWcgaW4gb3JkZXIgdG8gZ2V0IGJldHRlciB0cmVlLXNoYWtpbmcgaW4gdGhlIGAgK1xyXG4gICAgICAgICAgICBgcHJvZHVjdGlvbiBidW5kbGUuXFxuXFxuYCArXHJcbiAgICAgICAgICAgIGBGb3IgbW9yZSBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9saW5rLnZ1ZWpzLm9yZy9mZWF0dXJlLWZsYWdzLmApO1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IHF1ZXVlUG9zdFJlbmRlckVmZmVjdCA9IHF1ZXVlRWZmZWN0V2l0aFN1c3BlbnNlXHJcbiAgICA7XHJcbi8qKlxyXG4gKiBUaGUgY3JlYXRlUmVuZGVyZXIgZnVuY3Rpb24gYWNjZXB0cyB0d28gZ2VuZXJpYyBhcmd1bWVudHM6XHJcbiAqIEhvc3ROb2RlIGFuZCBIb3N0RWxlbWVudCwgY29ycmVzcG9uZGluZyB0byBOb2RlIGFuZCBFbGVtZW50IHR5cGVzIGluIHRoZVxyXG4gKiBob3N0IGVudmlyb25tZW50LiBGb3IgZXhhbXBsZSwgZm9yIHJ1bnRpbWUtZG9tLCBIb3N0Tm9kZSB3b3VsZCBiZSB0aGUgRE9NXHJcbiAqIGBOb2RlYCBpbnRlcmZhY2UgYW5kIEhvc3RFbGVtZW50IHdvdWxkIGJlIHRoZSBET00gYEVsZW1lbnRgIGludGVyZmFjZS5cclxuICpcclxuICogQ3VzdG9tIHJlbmRlcmVycyBjYW4gcGFzcyBpbiB0aGUgcGxhdGZvcm0gc3BlY2lmaWMgdHlwZXMgbGlrZSB0aGlzOlxyXG4gKlxyXG4gKiBgYGAganNcclxuICogY29uc3QgeyByZW5kZXIsIGNyZWF0ZUFwcCB9ID0gY3JlYXRlUmVuZGVyZXI8Tm9kZSwgRWxlbWVudD4oe1xyXG4gKiAgIHBhdGNoUHJvcCxcclxuICogICAuLi5ub2RlT3BzXHJcbiAqIH0pXHJcbiAqIGBgYFxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlUmVuZGVyZXIob3B0aW9ucykge1xyXG4gICAgcmV0dXJuIGJhc2VDcmVhdGVSZW5kZXJlcihvcHRpb25zKTtcclxufVxyXG4vLyBTZXBhcmF0ZSBBUEkgZm9yIGNyZWF0aW5nIGh5ZHJhdGlvbi1lbmFibGVkIHJlbmRlcmVyLlxyXG4vLyBIeWRyYXRpb24gbG9naWMgaXMgb25seSB1c2VkIHdoZW4gY2FsbGluZyB0aGlzIGZ1bmN0aW9uLCBtYWtpbmcgaXRcclxuLy8gdHJlZS1zaGFrYWJsZS5cclxuZnVuY3Rpb24gY3JlYXRlSHlkcmF0aW9uUmVuZGVyZXIob3B0aW9ucykge1xyXG4gICAgcmV0dXJuIGJhc2VDcmVhdGVSZW5kZXJlcihvcHRpb25zLCBjcmVhdGVIeWRyYXRpb25GdW5jdGlvbnMpO1xyXG59XHJcbi8vIGltcGxlbWVudGF0aW9uXHJcbmZ1bmN0aW9uIGJhc2VDcmVhdGVSZW5kZXJlcihvcHRpb25zLCBjcmVhdGVIeWRyYXRpb25GbnMpIHtcclxuICAgIC8vIGNvbXBpbGUtdGltZSBmZWF0dXJlIGZsYWdzIGNoZWNrXHJcbiAgICB7XHJcbiAgICAgICAgaW5pdEZlYXR1cmVGbGFncygpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgdGFyZ2V0ID0gZ2V0R2xvYmFsVGhpcygpO1xyXG4gICAgdGFyZ2V0Ll9fVlVFX18gPSB0cnVlO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgICAgICBzZXREZXZ0b29sc0hvb2sodGFyZ2V0Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX18sIHRhcmdldCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB7IGluc2VydDogaG9zdEluc2VydCwgcmVtb3ZlOiBob3N0UmVtb3ZlLCBwYXRjaFByb3A6IGhvc3RQYXRjaFByb3AsIGNyZWF0ZUVsZW1lbnQ6IGhvc3RDcmVhdGVFbGVtZW50LCBjcmVhdGVUZXh0OiBob3N0Q3JlYXRlVGV4dCwgY3JlYXRlQ29tbWVudDogaG9zdENyZWF0ZUNvbW1lbnQsIHNldFRleHQ6IGhvc3RTZXRUZXh0LCBzZXRFbGVtZW50VGV4dDogaG9zdFNldEVsZW1lbnRUZXh0LCBwYXJlbnROb2RlOiBob3N0UGFyZW50Tm9kZSwgbmV4dFNpYmxpbmc6IGhvc3ROZXh0U2libGluZywgc2V0U2NvcGVJZDogaG9zdFNldFNjb3BlSWQgPSBOT09QLCBjbG9uZU5vZGU6IGhvc3RDbG9uZU5vZGUsIGluc2VydFN0YXRpY0NvbnRlbnQ6IGhvc3RJbnNlcnRTdGF0aWNDb250ZW50IH0gPSBvcHRpb25zO1xyXG4gICAgLy8gTm90ZTogZnVuY3Rpb25zIGluc2lkZSB0aGlzIGNsb3N1cmUgc2hvdWxkIHVzZSBgY29uc3QgeHh4ID0gKCkgPT4ge31gXHJcbiAgICAvLyBzdHlsZSBpbiBvcmRlciB0byBwcmV2ZW50IGJlaW5nIGlubGluZWQgYnkgbWluaWZpZXJzLlxyXG4gICAgY29uc3QgcGF0Y2ggPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciA9IG51bGwsIHBhcmVudENvbXBvbmVudCA9IG51bGwsIHBhcmVudFN1c3BlbnNlID0gbnVsbCwgaXNTVkcgPSBmYWxzZSwgc2xvdFNjb3BlSWRzID0gbnVsbCwgb3B0aW1pemVkID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGlzSG1yVXBkYXRpbmcgPyBmYWxzZSA6ICEhbjIuZHluYW1pY0NoaWxkcmVuKSA9PiB7XHJcbiAgICAgICAgaWYgKG4xID09PSBuMikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHBhdGNoaW5nICYgbm90IHNhbWUgdHlwZSwgdW5tb3VudCBvbGQgdHJlZVxyXG4gICAgICAgIGlmIChuMSAmJiAhaXNTYW1lVk5vZGVUeXBlKG4xLCBuMikpIHtcclxuICAgICAgICAgICAgYW5jaG9yID0gZ2V0TmV4dEhvc3ROb2RlKG4xKTtcclxuICAgICAgICAgICAgdW5tb3VudChuMSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIG4xID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG4yLnBhdGNoRmxhZyA9PT0gLTIgLyogQkFJTCAqLykge1xyXG4gICAgICAgICAgICBvcHRpbWl6ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgbjIuZHluYW1pY0NoaWxkcmVuID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgeyB0eXBlLCByZWYsIHNoYXBlRmxhZyB9ID0gbjI7XHJcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgVGV4dDpcclxuICAgICAgICAgICAgICAgIHByb2Nlc3NUZXh0KG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgQ29tbWVudDpcclxuICAgICAgICAgICAgICAgIHByb2Nlc3NDb21tZW50Tm9kZShuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFN0YXRpYzpcclxuICAgICAgICAgICAgICAgIGlmIChuMSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbW91bnRTdGF0aWNOb2RlKG4yLCBjb250YWluZXIsIGFuY2hvciwgaXNTVkcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2hTdGF0aWNOb2RlKG4xLCBuMiwgY29udGFpbmVyLCBpc1NWRyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBGcmFnbWVudDpcclxuICAgICAgICAgICAgICAgIHByb2Nlc3NGcmFnbWVudChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBpZiAoc2hhcGVGbGFnICYgMSAvKiBFTEVNRU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0VsZW1lbnQobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNoYXBlRmxhZyAmIDYgLyogQ09NUE9ORU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0NvbXBvbmVudChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2hhcGVGbGFnICYgNjQgLyogVEVMRVBPUlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlLnByb2Nlc3MobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCBpbnRlcm5hbHMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2hhcGVGbGFnICYgMTI4IC8qIFNVU1BFTlNFICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZS5wcm9jZXNzKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgaW50ZXJuYWxzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oJ0ludmFsaWQgVk5vZGUgdHlwZTonLCB0eXBlLCBgKCR7dHlwZW9mIHR5cGV9KWApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBzZXQgcmVmXHJcbiAgICAgICAgaWYgKHJlZiAhPSBudWxsICYmIHBhcmVudENvbXBvbmVudCkge1xyXG4gICAgICAgICAgICBzZXRSZWYocmVmLCBuMSAmJiBuMS5yZWYsIHBhcmVudFN1c3BlbnNlLCBuMiB8fCBuMSwgIW4yKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcHJvY2Vzc1RleHQgPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvcikgPT4ge1xyXG4gICAgICAgIGlmIChuMSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGhvc3RJbnNlcnQoKG4yLmVsID0gaG9zdENyZWF0ZVRleHQobjIuY2hpbGRyZW4pKSwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgZWwgPSAobjIuZWwgPSBuMS5lbCk7XHJcbiAgICAgICAgICAgIGlmIChuMi5jaGlsZHJlbiAhPT0gbjEuY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgICAgIGhvc3RTZXRUZXh0KGVsLCBuMi5jaGlsZHJlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcHJvY2Vzc0NvbW1lbnROb2RlID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IpID0+IHtcclxuICAgICAgICBpZiAobjEgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBob3N0SW5zZXJ0KChuMi5lbCA9IGhvc3RDcmVhdGVDb21tZW50KG4yLmNoaWxkcmVuIHx8ICcnKSksIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHRoZXJlJ3Mgbm8gc3VwcG9ydCBmb3IgZHluYW1pYyBjb21tZW50c1xyXG4gICAgICAgICAgICBuMi5lbCA9IG4xLmVsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBtb3VudFN0YXRpY05vZGUgPSAobjIsIGNvbnRhaW5lciwgYW5jaG9yLCBpc1NWRykgPT4ge1xyXG4gICAgICAgIFtuMi5lbCwgbjIuYW5jaG9yXSA9IGhvc3RJbnNlcnRTdGF0aWNDb250ZW50KG4yLmNoaWxkcmVuLCBjb250YWluZXIsIGFuY2hvciwgaXNTVkcsIG4yLmVsLCBuMi5hbmNob3IpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRGV2IC8gSE1SIG9ubHlcclxuICAgICAqL1xyXG4gICAgY29uc3QgcGF0Y2hTdGF0aWNOb2RlID0gKG4xLCBuMiwgY29udGFpbmVyLCBpc1NWRykgPT4ge1xyXG4gICAgICAgIC8vIHN0YXRpYyBub2RlcyBhcmUgb25seSBwYXRjaGVkIGR1cmluZyBkZXYgZm9yIEhNUlxyXG4gICAgICAgIGlmIChuMi5jaGlsZHJlbiAhPT0gbjEuY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgY29uc3QgYW5jaG9yID0gaG9zdE5leHRTaWJsaW5nKG4xLmFuY2hvcik7XHJcbiAgICAgICAgICAgIC8vIHJlbW92ZSBleGlzdGluZ1xyXG4gICAgICAgICAgICByZW1vdmVTdGF0aWNOb2RlKG4xKTtcclxuICAgICAgICAgICAgW24yLmVsLCBuMi5hbmNob3JdID0gaG9zdEluc2VydFN0YXRpY0NvbnRlbnQobjIuY2hpbGRyZW4sIGNvbnRhaW5lciwgYW5jaG9yLCBpc1NWRyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBuMi5lbCA9IG4xLmVsO1xyXG4gICAgICAgICAgICBuMi5hbmNob3IgPSBuMS5hbmNob3I7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IG1vdmVTdGF0aWNOb2RlID0gKHsgZWwsIGFuY2hvciB9LCBjb250YWluZXIsIG5leHRTaWJsaW5nKSA9PiB7XHJcbiAgICAgICAgbGV0IG5leHQ7XHJcbiAgICAgICAgd2hpbGUgKGVsICYmIGVsICE9PSBhbmNob3IpIHtcclxuICAgICAgICAgICAgbmV4dCA9IGhvc3ROZXh0U2libGluZyhlbCk7XHJcbiAgICAgICAgICAgIGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgbmV4dFNpYmxpbmcpO1xyXG4gICAgICAgICAgICBlbCA9IG5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGhvc3RJbnNlcnQoYW5jaG9yLCBjb250YWluZXIsIG5leHRTaWJsaW5nKTtcclxuICAgIH07XHJcbiAgICBjb25zdCByZW1vdmVTdGF0aWNOb2RlID0gKHsgZWwsIGFuY2hvciB9KSA9PiB7XHJcbiAgICAgICAgbGV0IG5leHQ7XHJcbiAgICAgICAgd2hpbGUgKGVsICYmIGVsICE9PSBhbmNob3IpIHtcclxuICAgICAgICAgICAgbmV4dCA9IGhvc3ROZXh0U2libGluZyhlbCk7XHJcbiAgICAgICAgICAgIGhvc3RSZW1vdmUoZWwpO1xyXG4gICAgICAgICAgICBlbCA9IG5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGhvc3RSZW1vdmUoYW5jaG9yKTtcclxuICAgIH07XHJcbiAgICBjb25zdCBwcm9jZXNzRWxlbWVudCA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgICAgICBpc1NWRyA9IGlzU1ZHIHx8IG4yLnR5cGUgPT09ICdzdmcnO1xyXG4gICAgICAgIGlmIChuMSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIG1vdW50RWxlbWVudChuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwYXRjaEVsZW1lbnQobjEsIG4yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBtb3VudEVsZW1lbnQgPSAodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgICAgICBsZXQgZWw7XHJcbiAgICAgICAgbGV0IHZub2RlSG9vaztcclxuICAgICAgICBjb25zdCB7IHR5cGUsIHByb3BzLCBzaGFwZUZsYWcsIHRyYW5zaXRpb24sIHBhdGNoRmxhZywgZGlycyB9ID0gdm5vZGU7XHJcbiAgICAgICAgaWYgKCEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgdm5vZGUuZWwgJiZcclxuICAgICAgICAgICAgaG9zdENsb25lTm9kZSAhPT0gdW5kZWZpbmVkICYmXHJcbiAgICAgICAgICAgIHBhdGNoRmxhZyA9PT0gLTEgLyogSE9JU1RFRCAqLykge1xyXG4gICAgICAgICAgICAvLyBJZiBhIHZub2RlIGhhcyBub24tbnVsbCBlbCwgaXQgbWVhbnMgaXQncyBiZWluZyByZXVzZWQuXHJcbiAgICAgICAgICAgIC8vIE9ubHkgc3RhdGljIHZub2RlcyBjYW4gYmUgcmV1c2VkLCBzbyBpdHMgbW91bnRlZCBET00gbm9kZXMgc2hvdWxkIGJlXHJcbiAgICAgICAgICAgIC8vIGV4YWN0bHkgdGhlIHNhbWUsIGFuZCB3ZSBjYW4gc2ltcGx5IGRvIGEgY2xvbmUgaGVyZS5cclxuICAgICAgICAgICAgLy8gb25seSBkbyB0aGlzIGluIHByb2R1Y3Rpb24gc2luY2UgY2xvbmVkIHRyZWVzIGNhbm5vdCBiZSBITVIgdXBkYXRlZC5cclxuICAgICAgICAgICAgZWwgPSB2bm9kZS5lbCA9IGhvc3RDbG9uZU5vZGUodm5vZGUuZWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZWwgPSB2bm9kZS5lbCA9IGhvc3RDcmVhdGVFbGVtZW50KHZub2RlLnR5cGUsIGlzU1ZHLCBwcm9wcyAmJiBwcm9wcy5pcywgcHJvcHMpO1xyXG4gICAgICAgICAgICAvLyBtb3VudCBjaGlsZHJlbiBmaXJzdCwgc2luY2Ugc29tZSBwcm9wcyBtYXkgcmVseSBvbiBjaGlsZCBjb250ZW50XHJcbiAgICAgICAgICAgIC8vIGJlaW5nIGFscmVhZHkgcmVuZGVyZWQsIGUuZy4gYDxzZWxlY3QgdmFsdWU+YFxyXG4gICAgICAgICAgICBpZiAoc2hhcGVGbGFnICYgOCAvKiBURVhUX0NISUxEUkVOICovKSB7XHJcbiAgICAgICAgICAgICAgICBob3N0U2V0RWxlbWVudFRleHQoZWwsIHZub2RlLmNoaWxkcmVuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzaGFwZUZsYWcgJiAxNiAvKiBBUlJBWV9DSElMRFJFTiAqLykge1xyXG4gICAgICAgICAgICAgICAgbW91bnRDaGlsZHJlbih2bm9kZS5jaGlsZHJlbiwgZWwsIG51bGwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHICYmIHR5cGUgIT09ICdmb3JlaWduT2JqZWN0Jywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkaXJzKSB7XHJcbiAgICAgICAgICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsICdjcmVhdGVkJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gcHJvcHNcclxuICAgICAgICAgICAgaWYgKHByb3BzKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgIT09ICd2YWx1ZScgJiYgIWlzUmVzZXJ2ZWRQcm9wKGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwga2V5LCBudWxsLCBwcm9wc1trZXldLCBpc1NWRywgdm5vZGUuY2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHVubW91bnRDaGlsZHJlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBTcGVjaWFsIGNhc2UgZm9yIHNldHRpbmcgdmFsdWUgb24gRE9NIGVsZW1lbnRzOlxyXG4gICAgICAgICAgICAgICAgICogLSBpdCBjYW4gYmUgb3JkZXItc2Vuc2l0aXZlIChlLmcuIHNob3VsZCBiZSBzZXQgKmFmdGVyKiBtaW4vbWF4LCAjMjMyNSwgIzQwMjQpXHJcbiAgICAgICAgICAgICAgICAgKiAtIGl0IG5lZWRzIHRvIGJlIGZvcmNlZCAoIzE0NzEpXHJcbiAgICAgICAgICAgICAgICAgKiAjMjM1MyBwcm9wb3NlcyBhZGRpbmcgYW5vdGhlciByZW5kZXJlciBvcHRpb24gdG8gY29uZmlndXJlIHRoaXMsIGJ1dFxyXG4gICAgICAgICAgICAgICAgICogdGhlIHByb3BlcnRpZXMgYWZmZWN0cyBhcmUgc28gZmluaXRlIGl0IGlzIHdvcnRoIHNwZWNpYWwgY2FzaW5nIGl0XHJcbiAgICAgICAgICAgICAgICAgKiBoZXJlIHRvIHJlZHVjZSB0aGUgY29tcGxleGl0eS4gKFNwZWNpYWwgY2FzaW5nIGl0IGFsc28gc2hvdWxkIG5vdFxyXG4gICAgICAgICAgICAgICAgICogYWZmZWN0IG5vbi1ET00gcmVuZGVyZXJzKVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBpZiAoJ3ZhbHVlJyBpbiBwcm9wcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGhvc3RQYXRjaFByb3AoZWwsICd2YWx1ZScsIG51bGwsIHByb3BzLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICgodm5vZGVIb29rID0gcHJvcHMub25Wbm9kZUJlZm9yZU1vdW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHNjb3BlSWRcclxuICAgICAgICAgICAgc2V0U2NvcGVJZChlbCwgdm5vZGUsIHZub2RlLnNjb3BlSWQsIHNsb3RTY29wZUlkcywgcGFyZW50Q29tcG9uZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsLCAnX192bm9kZScsIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlOiB2bm9kZSxcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWwsICdfX3Z1ZVBhcmVudENvbXBvbmVudCcsIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBwYXJlbnRDb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRpcnMpIHtcclxuICAgICAgICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCAnYmVmb3JlTW91bnQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gIzE1ODMgRm9yIGluc2lkZSBzdXNwZW5zZSArIHN1c3BlbnNlIG5vdCByZXNvbHZlZCBjYXNlLCBlbnRlciBob29rIHNob3VsZCBjYWxsIHdoZW4gc3VzcGVuc2UgcmVzb2x2ZWRcclxuICAgICAgICAvLyAjMTY4OSBGb3IgaW5zaWRlIHN1c3BlbnNlICsgc3VzcGVuc2UgcmVzb2x2ZWQgY2FzZSwganVzdCBjYWxsIGl0XHJcbiAgICAgICAgY29uc3QgbmVlZENhbGxUcmFuc2l0aW9uSG9va3MgPSAoIXBhcmVudFN1c3BlbnNlIHx8IChwYXJlbnRTdXNwZW5zZSAmJiAhcGFyZW50U3VzcGVuc2UucGVuZGluZ0JyYW5jaCkpICYmXHJcbiAgICAgICAgICAgIHRyYW5zaXRpb24gJiZcclxuICAgICAgICAgICAgIXRyYW5zaXRpb24ucGVyc2lzdGVkO1xyXG4gICAgICAgIGlmIChuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcykge1xyXG4gICAgICAgICAgICB0cmFuc2l0aW9uLmJlZm9yZUVudGVyKGVsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaG9zdEluc2VydChlbCwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgIGlmICgodm5vZGVIb29rID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZU1vdW50ZWQpIHx8XHJcbiAgICAgICAgICAgIG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzIHx8XHJcbiAgICAgICAgICAgIGRpcnMpIHtcclxuICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHZub2RlSG9vayAmJiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcclxuICAgICAgICAgICAgICAgIG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzICYmIHRyYW5zaXRpb24uZW50ZXIoZWwpO1xyXG4gICAgICAgICAgICAgICAgZGlycyAmJiBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsICdtb3VudGVkJyk7XHJcbiAgICAgICAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3Qgc2V0U2NvcGVJZCA9IChlbCwgdm5vZGUsIHNjb3BlSWQsIHNsb3RTY29wZUlkcywgcGFyZW50Q29tcG9uZW50KSA9PiB7XHJcbiAgICAgICAgaWYgKHNjb3BlSWQpIHtcclxuICAgICAgICAgICAgaG9zdFNldFNjb3BlSWQoZWwsIHNjb3BlSWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2xvdFNjb3BlSWRzKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2xvdFNjb3BlSWRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBob3N0U2V0U2NvcGVJZChlbCwgc2xvdFNjb3BlSWRzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocGFyZW50Q29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgIGxldCBzdWJUcmVlID0gcGFyZW50Q29tcG9uZW50LnN1YlRyZWU7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgIHN1YlRyZWUucGF0Y2hGbGFnID4gMCAmJlxyXG4gICAgICAgICAgICAgICAgc3ViVHJlZS5wYXRjaEZsYWcgJiAyMDQ4IC8qIERFVl9ST09UX0ZSQUdNRU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICBzdWJUcmVlID1cclxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJTaW5nbGVSb290KHN1YlRyZWUuY2hpbGRyZW4pIHx8IHN1YlRyZWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHZub2RlID09PSBzdWJUcmVlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRWTm9kZSA9IHBhcmVudENvbXBvbmVudC52bm9kZTtcclxuICAgICAgICAgICAgICAgIHNldFNjb3BlSWQoZWwsIHBhcmVudFZOb2RlLCBwYXJlbnRWTm9kZS5zY29wZUlkLCBwYXJlbnRWTm9kZS5zbG90U2NvcGVJZHMsIHBhcmVudENvbXBvbmVudC5wYXJlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IG1vdW50Q2hpbGRyZW4gPSAoY2hpbGRyZW4sIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHN0YXJ0ID0gMCkgPT4ge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gKGNoaWxkcmVuW2ldID0gb3B0aW1pemVkXHJcbiAgICAgICAgICAgICAgICA/IGNsb25lSWZNb3VudGVkKGNoaWxkcmVuW2ldKVxyXG4gICAgICAgICAgICAgICAgOiBub3JtYWxpemVWTm9kZShjaGlsZHJlbltpXSkpO1xyXG4gICAgICAgICAgICBwYXRjaChudWxsLCBjaGlsZCwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHBhdGNoRWxlbWVudCA9IChuMSwgbjIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGVsID0gKG4yLmVsID0gbjEuZWwpO1xyXG4gICAgICAgIGxldCB7IHBhdGNoRmxhZywgZHluYW1pY0NoaWxkcmVuLCBkaXJzIH0gPSBuMjtcclxuICAgICAgICAvLyAjMTQyNiB0YWtlIHRoZSBvbGQgdm5vZGUncyBwYXRjaCBmbGFnIGludG8gYWNjb3VudCBzaW5jZSB1c2VyIG1heSBjbG9uZSBhXHJcbiAgICAgICAgLy8gY29tcGlsZXItZ2VuZXJhdGVkIHZub2RlLCB3aGljaCBkZS1vcHRzIHRvIEZVTExfUFJPUFNcclxuICAgICAgICBwYXRjaEZsYWcgfD0gbjEucGF0Y2hGbGFnICYgMTYgLyogRlVMTF9QUk9QUyAqLztcclxuICAgICAgICBjb25zdCBvbGRQcm9wcyA9IG4xLnByb3BzIHx8IEVNUFRZX09CSjtcclxuICAgICAgICBjb25zdCBuZXdQcm9wcyA9IG4yLnByb3BzIHx8IEVNUFRZX09CSjtcclxuICAgICAgICBsZXQgdm5vZGVIb29rO1xyXG4gICAgICAgIC8vIGRpc2FibGUgcmVjdXJzZSBpbiBiZWZvcmVVcGRhdGUgaG9va3NcclxuICAgICAgICBwYXJlbnRDb21wb25lbnQgJiYgdG9nZ2xlUmVjdXJzZShwYXJlbnRDb21wb25lbnQsIGZhbHNlKTtcclxuICAgICAgICBpZiAoKHZub2RlSG9vayA9IG5ld1Byb3BzLm9uVm5vZGVCZWZvcmVVcGRhdGUpKSB7XHJcbiAgICAgICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudENvbXBvbmVudCwgbjIsIG4xKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRpcnMpIHtcclxuICAgICAgICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayhuMiwgbjEsIHBhcmVudENvbXBvbmVudCwgJ2JlZm9yZVVwZGF0ZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwYXJlbnRDb21wb25lbnQgJiYgdG9nZ2xlUmVjdXJzZShwYXJlbnRDb21wb25lbnQsIHRydWUpO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaXNIbXJVcGRhdGluZykge1xyXG4gICAgICAgICAgICAvLyBITVIgdXBkYXRlZCwgZm9yY2UgZnVsbCBkaWZmXHJcbiAgICAgICAgICAgIHBhdGNoRmxhZyA9IDA7XHJcbiAgICAgICAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBkeW5hbWljQ2hpbGRyZW4gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBhcmVDaGlsZHJlblNWRyA9IGlzU1ZHICYmIG4yLnR5cGUgIT09ICdmb3JlaWduT2JqZWN0JztcclxuICAgICAgICBpZiAoZHluYW1pY0NoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgIHBhdGNoQmxvY2tDaGlsZHJlbihuMS5keW5hbWljQ2hpbGRyZW4sIGR5bmFtaWNDaGlsZHJlbiwgZWwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGFyZUNoaWxkcmVuU1ZHLCBzbG90U2NvcGVJZHMpO1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHBhcmVudENvbXBvbmVudCAmJiBwYXJlbnRDb21wb25lbnQudHlwZS5fX2htcklkKSB7XHJcbiAgICAgICAgICAgICAgICB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKG4xLCBuMik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIW9wdGltaXplZCkge1xyXG4gICAgICAgICAgICAvLyBmdWxsIGRpZmZcclxuICAgICAgICAgICAgcGF0Y2hDaGlsZHJlbihuMSwgbjIsIGVsLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBhcmVDaGlsZHJlblNWRywgc2xvdFNjb3BlSWRzLCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwYXRjaEZsYWcgPiAwKSB7XHJcbiAgICAgICAgICAgIC8vIHRoZSBwcmVzZW5jZSBvZiBhIHBhdGNoRmxhZyBtZWFucyB0aGlzIGVsZW1lbnQncyByZW5kZXIgY29kZSB3YXNcclxuICAgICAgICAgICAgLy8gZ2VuZXJhdGVkIGJ5IHRoZSBjb21waWxlciBhbmQgY2FuIHRha2UgdGhlIGZhc3QgcGF0aC5cclxuICAgICAgICAgICAgLy8gaW4gdGhpcyBwYXRoIG9sZCBub2RlIGFuZCBuZXcgbm9kZSBhcmUgZ3VhcmFudGVlZCB0byBoYXZlIHRoZSBzYW1lIHNoYXBlXHJcbiAgICAgICAgICAgIC8vIChpLmUuIGF0IHRoZSBleGFjdCBzYW1lIHBvc2l0aW9uIGluIHRoZSBzb3VyY2UgdGVtcGxhdGUpXHJcbiAgICAgICAgICAgIGlmIChwYXRjaEZsYWcgJiAxNiAvKiBGVUxMX1BST1BTICovKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBlbGVtZW50IHByb3BzIGNvbnRhaW4gZHluYW1pYyBrZXlzLCBmdWxsIGRpZmYgbmVlZGVkXHJcbiAgICAgICAgICAgICAgICBwYXRjaFByb3BzKGVsLCBuMiwgb2xkUHJvcHMsIG5ld1Byb3BzLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjbGFzc1xyXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBmbGFnIGlzIG1hdGNoZWQgd2hlbiB0aGUgZWxlbWVudCBoYXMgZHluYW1pYyBjbGFzcyBiaW5kaW5ncy5cclxuICAgICAgICAgICAgICAgIGlmIChwYXRjaEZsYWcgJiAyIC8qIENMQVNTICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9sZFByb3BzLmNsYXNzICE9PSBuZXdQcm9wcy5jbGFzcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCAnY2xhc3MnLCBudWxsLCBuZXdQcm9wcy5jbGFzcywgaXNTVkcpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHN0eWxlXHJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGZsYWcgaXMgbWF0Y2hlZCB3aGVuIHRoZSBlbGVtZW50IGhhcyBkeW5hbWljIHN0eWxlIGJpbmRpbmdzXHJcbiAgICAgICAgICAgICAgICBpZiAocGF0Y2hGbGFnICYgNCAvKiBTVFlMRSAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGhvc3RQYXRjaFByb3AoZWwsICdzdHlsZScsIG9sZFByb3BzLnN0eWxlLCBuZXdQcm9wcy5zdHlsZSwgaXNTVkcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gcHJvcHNcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgZmxhZyBpcyBtYXRjaGVkIHdoZW4gdGhlIGVsZW1lbnQgaGFzIGR5bmFtaWMgcHJvcC9hdHRyIGJpbmRpbmdzXHJcbiAgICAgICAgICAgICAgICAvLyBvdGhlciB0aGFuIGNsYXNzIGFuZCBzdHlsZS4gVGhlIGtleXMgb2YgZHluYW1pYyBwcm9wL2F0dHJzIGFyZSBzYXZlZCBmb3JcclxuICAgICAgICAgICAgICAgIC8vIGZhc3RlciBpdGVyYXRpb24uXHJcbiAgICAgICAgICAgICAgICAvLyBOb3RlIGR5bmFtaWMga2V5cyBsaWtlIDpbZm9vXT1cImJhclwiIHdpbGwgY2F1c2UgdGhpcyBvcHRpbWl6YXRpb24gdG9cclxuICAgICAgICAgICAgICAgIC8vIGJhaWwgb3V0IGFuZCBnbyB0aHJvdWdoIGEgZnVsbCBkaWZmIGJlY2F1c2Ugd2UgbmVlZCB0byB1bnNldCB0aGUgb2xkIGtleVxyXG4gICAgICAgICAgICAgICAgaWYgKHBhdGNoRmxhZyAmIDggLyogUFJPUFMgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgZmxhZyBpcyBwcmVzZW50IHRoZW4gZHluYW1pY1Byb3BzIG11c3QgYmUgbm9uLW51bGxcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wc1RvVXBkYXRlID0gbjIuZHluYW1pY1Byb3BzO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcHNUb1VwZGF0ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBwcm9wc1RvVXBkYXRlW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2ID0gb2xkUHJvcHNba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IG5ld1Byb3BzW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICMxNDcxIGZvcmNlIHBhdGNoIHZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ICE9PSBwcmV2IHx8IGtleSA9PT0gJ3ZhbHVlJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwga2V5LCBwcmV2LCBuZXh0LCBpc1NWRywgbjEuY2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHVubW91bnRDaGlsZHJlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gdGV4dFxyXG4gICAgICAgICAgICAvLyBUaGlzIGZsYWcgaXMgbWF0Y2hlZCB3aGVuIHRoZSBlbGVtZW50IGhhcyBvbmx5IGR5bmFtaWMgdGV4dCBjaGlsZHJlbi5cclxuICAgICAgICAgICAgaWYgKHBhdGNoRmxhZyAmIDEgLyogVEVYVCAqLykge1xyXG4gICAgICAgICAgICAgICAgaWYgKG4xLmNoaWxkcmVuICE9PSBuMi5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGhvc3RTZXRFbGVtZW50VGV4dChlbCwgbjIuY2hpbGRyZW4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCFvcHRpbWl6ZWQgJiYgZHluYW1pY0NoaWxkcmVuID09IG51bGwpIHtcclxuICAgICAgICAgICAgLy8gdW5vcHRpbWl6ZWQsIGZ1bGwgZGlmZlxyXG4gICAgICAgICAgICBwYXRjaFByb3BzKGVsLCBuMiwgb2xkUHJvcHMsIG5ld1Byb3BzLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgodm5vZGVIb29rID0gbmV3UHJvcHMub25Wbm9kZVVwZGF0ZWQpIHx8IGRpcnMpIHtcclxuICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHZub2RlSG9vayAmJiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIG4yLCBuMSk7XHJcbiAgICAgICAgICAgICAgICBkaXJzICYmIGludm9rZURpcmVjdGl2ZUhvb2sobjIsIG4xLCBwYXJlbnRDb21wb25lbnQsICd1cGRhdGVkJyk7XHJcbiAgICAgICAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gVGhlIGZhc3QgcGF0aCBmb3IgYmxvY2tzLlxyXG4gICAgY29uc3QgcGF0Y2hCbG9ja0NoaWxkcmVuID0gKG9sZENoaWxkcmVuLCBuZXdDaGlsZHJlbiwgZmFsbGJhY2tDb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMpID0+IHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9sZFZOb2RlID0gb2xkQ2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1ZOb2RlID0gbmV3Q2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgIC8vIERldGVybWluZSB0aGUgY29udGFpbmVyIChwYXJlbnQgZWxlbWVudCkgZm9yIHRoZSBwYXRjaC5cclxuICAgICAgICAgICAgY29uc3QgY29udGFpbmVyID0gXHJcbiAgICAgICAgICAgIC8vIG9sZFZOb2RlIG1heSBiZSBhbiBlcnJvcmVkIGFzeW5jIHNldHVwKCkgY29tcG9uZW50IGluc2lkZSBTdXNwZW5zZVxyXG4gICAgICAgICAgICAvLyB3aGljaCB3aWxsIG5vdCBoYXZlIGEgbW91bnRlZCBlbGVtZW50XHJcbiAgICAgICAgICAgIG9sZFZOb2RlLmVsICYmXHJcbiAgICAgICAgICAgICAgICAvLyAtIEluIHRoZSBjYXNlIG9mIGEgRnJhZ21lbnQsIHdlIG5lZWQgdG8gcHJvdmlkZSB0aGUgYWN0dWFsIHBhcmVudFxyXG4gICAgICAgICAgICAgICAgLy8gb2YgdGhlIEZyYWdtZW50IGl0c2VsZiBzbyBpdCBjYW4gbW92ZSBpdHMgY2hpbGRyZW4uXHJcbiAgICAgICAgICAgICAgICAob2xkVk5vZGUudHlwZSA9PT0gRnJhZ21lbnQgfHxcclxuICAgICAgICAgICAgICAgICAgICAvLyAtIEluIHRoZSBjYXNlIG9mIGRpZmZlcmVudCBub2RlcywgdGhlcmUgaXMgZ29pbmcgdG8gYmUgYSByZXBsYWNlbWVudFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoaWNoIGFsc28gcmVxdWlyZXMgdGhlIGNvcnJlY3QgcGFyZW50IGNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgICAgICFpc1NhbWVWTm9kZVR5cGUob2xkVk5vZGUsIG5ld1ZOb2RlKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIC0gSW4gdGhlIGNhc2Ugb2YgYSBjb21wb25lbnQsIGl0IGNvdWxkIGNvbnRhaW4gYW55dGhpbmcuXHJcbiAgICAgICAgICAgICAgICAgICAgb2xkVk5vZGUuc2hhcGVGbGFnICYgKDYgLyogQ09NUE9ORU5UICovIHwgNjQgLyogVEVMRVBPUlQgKi8pKVxyXG4gICAgICAgICAgICAgICAgPyBob3N0UGFyZW50Tm9kZShvbGRWTm9kZS5lbClcclxuICAgICAgICAgICAgICAgIDogLy8gSW4gb3RoZXIgY2FzZXMsIHRoZSBwYXJlbnQgY29udGFpbmVyIGlzIG5vdCBhY3R1YWxseSB1c2VkIHNvIHdlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8ganVzdCBwYXNzIHRoZSBibG9jayBlbGVtZW50IGhlcmUgdG8gYXZvaWQgYSBET00gcGFyZW50Tm9kZSBjYWxsLlxyXG4gICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrQ29udGFpbmVyO1xyXG4gICAgICAgICAgICBwYXRjaChvbGRWTm9kZSwgbmV3Vk5vZGUsIGNvbnRhaW5lciwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHBhdGNoUHJvcHMgPSAoZWwsIHZub2RlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHKSA9PiB7XHJcbiAgICAgICAgaWYgKG9sZFByb3BzICE9PSBuZXdQcm9wcykge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBuZXdQcm9wcykge1xyXG4gICAgICAgICAgICAgICAgLy8gZW1wdHkgc3RyaW5nIGlzIG5vdCB2YWxpZCBwcm9wXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNSZXNlcnZlZFByb3Aoa2V5KSlcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSBuZXdQcm9wc1trZXldO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJldiA9IG9sZFByb3BzW2tleV07XHJcbiAgICAgICAgICAgICAgICAvLyBkZWZlciBwYXRjaGluZyB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgaWYgKG5leHQgIT09IHByZXYgJiYga2V5ICE9PSAndmFsdWUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwga2V5LCBwcmV2LCBuZXh0LCBpc1NWRywgdm5vZGUuY2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHVubW91bnRDaGlsZHJlbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG9sZFByb3BzICE9PSBFTVBUWV9PQkopIHtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9sZFByb3BzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1Jlc2VydmVkUHJvcChrZXkpICYmICEoa2V5IGluIG5ld1Byb3BzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCBrZXksIG9sZFByb3BzW2tleV0sIG51bGwsIGlzU1ZHLCB2bm9kZS5jaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdW5tb3VudENoaWxkcmVuKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCd2YWx1ZScgaW4gbmV3UHJvcHMpIHtcclxuICAgICAgICAgICAgICAgIGhvc3RQYXRjaFByb3AoZWwsICd2YWx1ZScsIG9sZFByb3BzLnZhbHVlLCBuZXdQcm9wcy52YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcHJvY2Vzc0ZyYWdtZW50ID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGZyYWdtZW50U3RhcnRBbmNob3IgPSAobjIuZWwgPSBuMSA/IG4xLmVsIDogaG9zdENyZWF0ZVRleHQoJycpKTtcclxuICAgICAgICBjb25zdCBmcmFnbWVudEVuZEFuY2hvciA9IChuMi5hbmNob3IgPSBuMSA/IG4xLmFuY2hvciA6IGhvc3RDcmVhdGVUZXh0KCcnKSk7XHJcbiAgICAgICAgbGV0IHsgcGF0Y2hGbGFnLCBkeW5hbWljQ2hpbGRyZW4sIHNsb3RTY29wZUlkczogZnJhZ21lbnRTbG90U2NvcGVJZHMgfSA9IG4yO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgLy8gIzU1MjMgZGV2IHJvb3QgZnJhZ21lbnQgbWF5IGluaGVyaXQgZGlyZWN0aXZlc1xyXG4gICAgICAgICAgICAoaXNIbXJVcGRhdGluZyB8fCBwYXRjaEZsYWcgJiAyMDQ4IC8qIERFVl9ST09UX0ZSQUdNRU5UICovKSkge1xyXG4gICAgICAgICAgICAvLyBITVIgdXBkYXRlZCAvIERldiByb290IGZyYWdtZW50ICh3LyBjb21tZW50cyksIGZvcmNlIGZ1bGwgZGlmZlxyXG4gICAgICAgICAgICBwYXRjaEZsYWcgPSAwO1xyXG4gICAgICAgICAgICBvcHRpbWl6ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgZHluYW1pY0NoaWxkcmVuID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBhIHNsb3QgZnJhZ21lbnQgd2l0aCA6c2xvdHRlZCBzY29wZSBpZHNcclxuICAgICAgICBpZiAoZnJhZ21lbnRTbG90U2NvcGVJZHMpIHtcclxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzID0gc2xvdFNjb3BlSWRzXHJcbiAgICAgICAgICAgICAgICA/IHNsb3RTY29wZUlkcy5jb25jYXQoZnJhZ21lbnRTbG90U2NvcGVJZHMpXHJcbiAgICAgICAgICAgICAgICA6IGZyYWdtZW50U2xvdFNjb3BlSWRzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobjEgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBob3N0SW5zZXJ0KGZyYWdtZW50U3RhcnRBbmNob3IsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICAgICAgaG9zdEluc2VydChmcmFnbWVudEVuZEFuY2hvciwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgICAgICAvLyBhIGZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYXJyYXkgY2hpbGRyZW5cclxuICAgICAgICAgICAgLy8gc2luY2UgdGhleSBhcmUgZWl0aGVyIGdlbmVyYXRlZCBieSB0aGUgY29tcGlsZXIsIG9yIGltcGxpY2l0bHkgY3JlYXRlZFxyXG4gICAgICAgICAgICAvLyBmcm9tIGFycmF5cy5cclxuICAgICAgICAgICAgbW91bnRDaGlsZHJlbihuMi5jaGlsZHJlbiwgY29udGFpbmVyLCBmcmFnbWVudEVuZEFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChwYXRjaEZsYWcgPiAwICYmXHJcbiAgICAgICAgICAgICAgICBwYXRjaEZsYWcgJiA2NCAvKiBTVEFCTEVfRlJBR01FTlQgKi8gJiZcclxuICAgICAgICAgICAgICAgIGR5bmFtaWNDaGlsZHJlbiAmJlxyXG4gICAgICAgICAgICAgICAgLy8gIzI3MTUgdGhlIHByZXZpb3VzIGZyYWdtZW50IGNvdWxkJ3ZlIGJlZW4gYSBCQUlMZWQgb25lIGFzIGEgcmVzdWx0XHJcbiAgICAgICAgICAgICAgICAvLyBvZiByZW5kZXJTbG90KCkgd2l0aCBubyB2YWxpZCBjaGlsZHJlblxyXG4gICAgICAgICAgICAgICAgbjEuZHluYW1pY0NoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBhIHN0YWJsZSBmcmFnbWVudCAodGVtcGxhdGUgcm9vdCBvciA8dGVtcGxhdGUgdi1mb3I+KSBkb2Vzbid0IG5lZWQgdG9cclxuICAgICAgICAgICAgICAgIC8vIHBhdGNoIGNoaWxkcmVuIG9yZGVyLCBidXQgaXQgbWF5IGNvbnRhaW4gZHluYW1pY0NoaWxkcmVuLlxyXG4gICAgICAgICAgICAgICAgcGF0Y2hCbG9ja0NoaWxkcmVuKG4xLmR5bmFtaWNDaGlsZHJlbiwgZHluYW1pY0NoaWxkcmVuLCBjb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBwYXJlbnRDb21wb25lbnQgJiYgcGFyZW50Q29tcG9uZW50LnR5cGUuX19obXJJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4objEsIG4yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKFxyXG4gICAgICAgICAgICAgICAgLy8gIzIwODAgaWYgdGhlIHN0YWJsZSBmcmFnbWVudCBoYXMgYSBrZXksIGl0J3MgYSA8dGVtcGxhdGUgdi1mb3I+IHRoYXQgbWF5XHJcbiAgICAgICAgICAgICAgICAvLyAgZ2V0IG1vdmVkIGFyb3VuZC4gTWFrZSBzdXJlIGFsbCByb290IGxldmVsIHZub2RlcyBpbmhlcml0IGVsLlxyXG4gICAgICAgICAgICAgICAgLy8gIzIxMzQgb3IgaWYgaXQncyBhIGNvbXBvbmVudCByb290LCBpdCBtYXkgYWxzbyBnZXQgbW92ZWQgYXJvdW5kXHJcbiAgICAgICAgICAgICAgICAvLyBhcyB0aGUgY29tcG9uZW50IGlzIGJlaW5nIG1vdmVkLlxyXG4gICAgICAgICAgICAgICAgbjIua2V5ICE9IG51bGwgfHxcclxuICAgICAgICAgICAgICAgICAgICAocGFyZW50Q29tcG9uZW50ICYmIG4yID09PSBwYXJlbnRDb21wb25lbnQuc3ViVHJlZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKG4xLCBuMiwgdHJ1ZSAvKiBzaGFsbG93ICovKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGtleWVkIC8gdW5rZXllZCwgb3IgbWFudWFsIGZyYWdtZW50cy5cclxuICAgICAgICAgICAgICAgIC8vIGZvciBrZXllZCAmIHVua2V5ZWQsIHNpbmNlIHRoZXkgYXJlIGNvbXBpbGVyIGdlbmVyYXRlZCBmcm9tIHYtZm9yLFxyXG4gICAgICAgICAgICAgICAgLy8gZWFjaCBjaGlsZCBpcyBndWFyYW50ZWVkIHRvIGJlIGEgYmxvY2sgc28gdGhlIGZyYWdtZW50IHdpbGwgbmV2ZXJcclxuICAgICAgICAgICAgICAgIC8vIGhhdmUgZHluYW1pY0NoaWxkcmVuLlxyXG4gICAgICAgICAgICAgICAgcGF0Y2hDaGlsZHJlbihuMSwgbjIsIGNvbnRhaW5lciwgZnJhZ21lbnRFbmRBbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcHJvY2Vzc0NvbXBvbmVudCA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgICAgICBuMi5zbG90U2NvcGVJZHMgPSBzbG90U2NvcGVJZHM7XHJcbiAgICAgICAgaWYgKG4xID09IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKG4yLnNoYXBlRmxhZyAmIDUxMiAvKiBDT01QT05FTlRfS0VQVF9BTElWRSAqLykge1xyXG4gICAgICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LmN0eC5hY3RpdmF0ZShuMiwgY29udGFpbmVyLCBhbmNob3IsIGlzU1ZHLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbW91bnRDb21wb25lbnQobjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdXBkYXRlQ29tcG9uZW50KG4xLCBuMiwgb3B0aW1pemVkKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgbW91bnRDb21wb25lbnQgPSAoaW5pdGlhbFZOb2RlLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gKGluaXRpYWxWTm9kZS5jb21wb25lbnQgPSBjcmVhdGVDb21wb25lbnRJbnN0YW5jZShpbml0aWFsVk5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UpKTtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGluc3RhbmNlLnR5cGUuX19obXJJZCkge1xyXG4gICAgICAgICAgICByZWdpc3RlckhNUihpbnN0YW5jZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgcHVzaFdhcm5pbmdDb250ZXh0KGluaXRpYWxWTm9kZSk7XHJcbiAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYG1vdW50YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGluamVjdCByZW5kZXJlciBpbnRlcm5hbHMgZm9yIGtlZXBBbGl2ZVxyXG4gICAgICAgIGlmIChpc0tlZXBBbGl2ZShpbml0aWFsVk5vZGUpKSB7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLmN0eC5yZW5kZXJlciA9IGludGVybmFscztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcmVzb2x2ZSBwcm9wcyBhbmQgc2xvdHMgZm9yIHNldHVwIGNvbnRleHRcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYGluaXRgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZXR1cENvbXBvbmVudChpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBpbml0YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gc2V0dXAoKSBpcyBhc3luYy4gVGhpcyBjb21wb25lbnQgcmVsaWVzIG9uIGFzeW5jIGxvZ2ljIHRvIGJlIHJlc29sdmVkXHJcbiAgICAgICAgLy8gYmVmb3JlIHByb2NlZWRpbmdcclxuICAgICAgICBpZiAoaW5zdGFuY2UuYXN5bmNEZXApIHtcclxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UgJiYgcGFyZW50U3VzcGVuc2UucmVnaXN0ZXJEZXAoaW5zdGFuY2UsIHNldHVwUmVuZGVyRWZmZWN0KTtcclxuICAgICAgICAgICAgLy8gR2l2ZSBpdCBhIHBsYWNlaG9sZGVyIGlmIHRoaXMgaXMgbm90IGh5ZHJhdGlvblxyXG4gICAgICAgICAgICAvLyBUT0RPIGhhbmRsZSBzZWxmLWRlZmluZWQgZmFsbGJhY2tcclxuICAgICAgICAgICAgaWYgKCFpbml0aWFsVk5vZGUuZWwpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gKGluc3RhbmNlLnN1YlRyZWUgPSBjcmVhdGVWTm9kZShDb21tZW50KSk7XHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzQ29tbWVudE5vZGUobnVsbCwgcGxhY2Vob2xkZXIsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNldHVwUmVuZGVyRWZmZWN0KGluc3RhbmNlLCBpbml0aWFsVk5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCk7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xyXG4gICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgbW91bnRgKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgdXBkYXRlQ29tcG9uZW50ID0gKG4xLCBuMiwgb3B0aW1pemVkKSA9PiB7XHJcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSAobjIuY29tcG9uZW50ID0gbjEuY29tcG9uZW50KTtcclxuICAgICAgICBpZiAoc2hvdWxkVXBkYXRlQ29tcG9uZW50KG4xLCBuMiwgb3B0aW1pemVkKSkge1xyXG4gICAgICAgICAgICBpZiAoaW5zdGFuY2UuYXN5bmNEZXAgJiZcclxuICAgICAgICAgICAgICAgICFpbnN0YW5jZS5hc3luY1Jlc29sdmVkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBhc3luYyAmIHN0aWxsIHBlbmRpbmcgLSBqdXN0IHVwZGF0ZSBwcm9wcyBhbmQgc2xvdHNcclxuICAgICAgICAgICAgICAgIC8vIHNpbmNlIHRoZSBjb21wb25lbnQncyByZWFjdGl2ZSBlZmZlY3QgZm9yIHJlbmRlciBpc24ndCBzZXQtdXAgeWV0XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHVzaFdhcm5pbmdDb250ZXh0KG4yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHVwZGF0ZUNvbXBvbmVudFByZVJlbmRlcihpbnN0YW5jZSwgbjIsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9wV2FybmluZ0NvbnRleHQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIG5vcm1hbCB1cGRhdGVcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlLm5leHQgPSBuMjtcclxuICAgICAgICAgICAgICAgIC8vIGluIGNhc2UgdGhlIGNoaWxkIGNvbXBvbmVudCBpcyBhbHNvIHF1ZXVlZCwgcmVtb3ZlIGl0IHRvIGF2b2lkXHJcbiAgICAgICAgICAgICAgICAvLyBkb3VibGUgdXBkYXRpbmcgdGhlIHNhbWUgY2hpbGQgY29tcG9uZW50IGluIHRoZSBzYW1lIGZsdXNoLlxyXG4gICAgICAgICAgICAgICAgaW52YWxpZGF0ZUpvYihpbnN0YW5jZS51cGRhdGUpO1xyXG4gICAgICAgICAgICAgICAgLy8gaW5zdGFuY2UudXBkYXRlIGlzIHRoZSByZWFjdGl2ZSBlZmZlY3QuXHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS51cGRhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gbm8gdXBkYXRlIG5lZWRlZC4ganVzdCBjb3B5IG92ZXIgcHJvcGVydGllc1xyXG4gICAgICAgICAgICBuMi5lbCA9IG4xLmVsO1xyXG4gICAgICAgICAgICBpbnN0YW5jZS52bm9kZSA9IG4yO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBzZXR1cFJlbmRlckVmZmVjdCA9IChpbnN0YW5jZSwgaW5pdGlhbFZOb2RlLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgICAgICBjb25zdCBjb21wb25lbnRVcGRhdGVGbiA9ICgpID0+IHtcclxuICAgICAgICAgICAgaWYgKCFpbnN0YW5jZS5pc01vdW50ZWQpIHtcclxuICAgICAgICAgICAgICAgIGxldCB2bm9kZUhvb2s7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IGVsLCBwcm9wcyB9ID0gaW5pdGlhbFZOb2RlO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBibSwgbSwgcGFyZW50IH0gPSBpbnN0YW5jZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGlzQXN5bmNXcmFwcGVyVk5vZGUgPSBpc0FzeW5jV3JhcHBlcihpbml0aWFsVk5vZGUpO1xyXG4gICAgICAgICAgICAgICAgdG9nZ2xlUmVjdXJzZShpbnN0YW5jZSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgLy8gYmVmb3JlTW91bnQgaG9va1xyXG4gICAgICAgICAgICAgICAgaWYgKGJtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlQXJyYXlGbnMoYm0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gb25Wbm9kZUJlZm9yZU1vdW50XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzQXN5bmNXcmFwcGVyVk5vZGUgJiZcclxuICAgICAgICAgICAgICAgICAgICAodm5vZGVIb29rID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZUJlZm9yZU1vdW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudCwgaW5pdGlhbFZOb2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRvZ2dsZVJlY3Vyc2UoaW5zdGFuY2UsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsICYmIGh5ZHJhdGVOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdm5vZGUgaGFzIGFkb3B0ZWQgaG9zdCBub2RlIC0gcGVyZm9ybSBoeWRyYXRpb24gaW5zdGVhZCBvZiBtb3VudC5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBoeWRyYXRlU3ViVHJlZSA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgcmVuZGVyYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2Uuc3ViVHJlZSA9IHJlbmRlckNvbXBvbmVudFJvb3QoaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgcmVuZGVyYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgaHlkcmF0ZWApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGh5ZHJhdGVOb2RlKGVsLCBpbnN0YW5jZS5zdWJUcmVlLCBpbnN0YW5jZSwgcGFyZW50U3VzcGVuc2UsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgaHlkcmF0ZWApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNBc3luY1dyYXBwZXJWTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsVk5vZGUudHlwZS5fX2FzeW5jTG9hZGVyKCkudGhlbihcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm90ZTogd2UgYXJlIG1vdmluZyB0aGUgcmVuZGVyIGNhbGwgaW50byBhbiBhc3luYyBjYWxsYmFjayxcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hpY2ggbWVhbnMgaXQgd29uJ3QgdHJhY2sgZGVwZW5kZW5jaWVzIC0gYnV0IGl0J3Mgb2sgYmVjYXVzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhIHNlcnZlci1yZW5kZXJlZCBhc3luYyB3cmFwcGVyIGlzIGFscmVhZHkgaW4gcmVzb2x2ZWQgc3RhdGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGl0IHdpbGwgbmV2ZXIgbmVlZCB0byBjaGFuZ2UuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICgpID0+ICFpbnN0YW5jZS5pc1VubW91bnRlZCAmJiBoeWRyYXRlU3ViVHJlZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGh5ZHJhdGVTdWJUcmVlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3ViVHJlZSA9IChpbnN0YW5jZS5zdWJUcmVlID0gcmVuZGVyQ29tcG9uZW50Um9vdChpbnN0YW5jZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYHBhdGNoYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoKG51bGwsIHN1YlRyZWUsIGNvbnRhaW5lciwgYW5jaG9yLCBpbnN0YW5jZSwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBwYXRjaGApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpbml0aWFsVk5vZGUuZWwgPSBzdWJUcmVlLmVsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gbW91bnRlZCBob29rXHJcbiAgICAgICAgICAgICAgICBpZiAobSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChtLCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBvblZub2RlTW91bnRlZFxyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0FzeW5jV3JhcHBlclZOb2RlICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVNb3VudGVkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNjb3BlZEluaXRpYWxWTm9kZSA9IGluaXRpYWxWTm9kZTtcclxuICAgICAgICAgICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4gaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50LCBzY29wZWRJbml0aWFsVk5vZGUpLCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBhY3RpdmF0ZWQgaG9vayBmb3Iga2VlcC1hbGl2ZSByb290cy5cclxuICAgICAgICAgICAgICAgIC8vICMxNzQyIGFjdGl2YXRlZCBob29rIG11c3QgYmUgYWNjZXNzZWQgYWZ0ZXIgZmlyc3QgcmVuZGVyXHJcbiAgICAgICAgICAgICAgICAvLyBzaW5jZSB0aGUgaG9vayBtYXkgYmUgaW5qZWN0ZWQgYnkgYSBjaGlsZCBrZWVwLWFsaXZlXHJcbiAgICAgICAgICAgICAgICBpZiAoaW5pdGlhbFZOb2RlLnNoYXBlRmxhZyAmIDI1NiAvKiBDT01QT05FTlRfU0hPVUxEX0tFRVBfQUxJVkUgKi8gfHxcclxuICAgICAgICAgICAgICAgICAgICAocGFyZW50ICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQXN5bmNXcmFwcGVyKHBhcmVudC52bm9kZSkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LnZub2RlLnNoYXBlRmxhZyAmIDI1NiAvKiBDT01QT05FTlRfU0hPVUxEX0tFRVBfQUxJVkUgKi8pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UuYSAmJiBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoaW5zdGFuY2UuYSwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuaXNNb3VudGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGV2dG9vbHNDb21wb25lbnRBZGRlZChpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyAjMjQ1ODogZGVmZXJlbmNlIG1vdW50LW9ubHkgb2JqZWN0IHBhcmFtZXRlcnMgdG8gcHJldmVudCBtZW1sZWFrc1xyXG4gICAgICAgICAgICAgICAgaW5pdGlhbFZOb2RlID0gY29udGFpbmVyID0gYW5jaG9yID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZUNvbXBvbmVudFxyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0cmlnZ2VyZWQgYnkgbXV0YXRpb24gb2YgY29tcG9uZW50J3Mgb3duIHN0YXRlIChuZXh0OiBudWxsKVxyXG4gICAgICAgICAgICAgICAgLy8gT1IgcGFyZW50IGNhbGxpbmcgcHJvY2Vzc0NvbXBvbmVudCAobmV4dDogVk5vZGUpXHJcbiAgICAgICAgICAgICAgICBsZXQgeyBuZXh0LCBidSwgdSwgcGFyZW50LCB2bm9kZSB9ID0gaW5zdGFuY2U7XHJcbiAgICAgICAgICAgICAgICBsZXQgb3JpZ2luTmV4dCA9IG5leHQ7XHJcbiAgICAgICAgICAgICAgICBsZXQgdm5vZGVIb29rO1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHB1c2hXYXJuaW5nQ29udGV4dChuZXh0IHx8IGluc3RhbmNlLnZub2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIERpc2FsbG93IGNvbXBvbmVudCBlZmZlY3QgcmVjdXJzaW9uIGR1cmluZyBwcmUtbGlmZWN5Y2xlIGhvb2tzLlxyXG4gICAgICAgICAgICAgICAgdG9nZ2xlUmVjdXJzZShpbnN0YW5jZSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5leHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0LmVsID0gdm5vZGUuZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlQ29tcG9uZW50UHJlUmVuZGVyKGluc3RhbmNlLCBuZXh0LCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHZub2RlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gYmVmb3JlVXBkYXRlIGhvb2tcclxuICAgICAgICAgICAgICAgIGlmIChidSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGludm9rZUFycmF5Rm5zKGJ1KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIG9uVm5vZGVCZWZvcmVVcGRhdGVcclxuICAgICAgICAgICAgICAgIGlmICgodm5vZGVIb29rID0gbmV4dC5wcm9wcyAmJiBuZXh0LnByb3BzLm9uVm5vZGVCZWZvcmVVcGRhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50LCBuZXh0LCB2bm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0b2dnbGVSZWN1cnNlKGluc3RhbmNlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIC8vIHJlbmRlclxyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFRyZWUgPSByZW5kZXJDb21wb25lbnRSb290KGluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgcmVuZGVyYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2VHJlZSA9IGluc3RhbmNlLnN1YlRyZWU7XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5zdWJUcmVlID0gbmV4dFRyZWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgcGF0Y2hgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHBhdGNoKHByZXZUcmVlLCBuZXh0VHJlZSwgXHJcbiAgICAgICAgICAgICAgICAvLyBwYXJlbnQgbWF5IGhhdmUgY2hhbmdlZCBpZiBpdCdzIGluIGEgdGVsZXBvcnRcclxuICAgICAgICAgICAgICAgIGhvc3RQYXJlbnROb2RlKHByZXZUcmVlLmVsKSwgXHJcbiAgICAgICAgICAgICAgICAvLyBhbmNob3IgbWF5IGhhdmUgY2hhbmdlZCBpZiBpdCdzIGluIGEgZnJhZ21lbnRcclxuICAgICAgICAgICAgICAgIGdldE5leHRIb3N0Tm9kZShwcmV2VHJlZSksIGluc3RhbmNlLCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcpO1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBwYXRjaGApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbmV4dC5lbCA9IG5leHRUcmVlLmVsO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9yaWdpbk5leHQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBzZWxmLXRyaWdnZXJlZCB1cGRhdGUuIEluIGNhc2Ugb2YgSE9DLCB1cGRhdGUgcGFyZW50IGNvbXBvbmVudFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHZub2RlIGVsLiBIT0MgaXMgaW5kaWNhdGVkIGJ5IHBhcmVudCBpbnN0YW5jZSdzIHN1YlRyZWUgcG9pbnRpbmdcclxuICAgICAgICAgICAgICAgICAgICAvLyB0byBjaGlsZCBjb21wb25lbnQncyB2bm9kZVxyXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUhPQ0hvc3RFbChpbnN0YW5jZSwgbmV4dFRyZWUuZWwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlZCBob29rXHJcbiAgICAgICAgICAgICAgICBpZiAodSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCh1LCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBvblZub2RlVXBkYXRlZFxyXG4gICAgICAgICAgICAgICAgaWYgKCh2bm9kZUhvb2sgPSBuZXh0LnByb3BzICYmIG5leHQucHJvcHMub25Wbm9kZVVwZGF0ZWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudCwgbmV4dCwgdm5vZGUpLCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgICAgICAgICAgICAgICAgIGRldnRvb2xzQ29tcG9uZW50VXBkYXRlZChpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9wV2FybmluZ0NvbnRleHQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gY3JlYXRlIHJlYWN0aXZlIGVmZmVjdCBmb3IgcmVuZGVyaW5nXHJcbiAgICAgICAgY29uc3QgZWZmZWN0ID0gKGluc3RhbmNlLmVmZmVjdCA9IG5ldyBSZWFjdGl2ZUVmZmVjdChjb21wb25lbnRVcGRhdGVGbiwgKCkgPT4gcXVldWVKb2IodXBkYXRlKSwgaW5zdGFuY2Uuc2NvcGUgLy8gdHJhY2sgaXQgaW4gY29tcG9uZW50J3MgZWZmZWN0IHNjb3BlXHJcbiAgICAgICAgKSk7XHJcbiAgICAgICAgY29uc3QgdXBkYXRlID0gKGluc3RhbmNlLnVwZGF0ZSA9ICgpID0+IGVmZmVjdC5ydW4oKSk7XHJcbiAgICAgICAgdXBkYXRlLmlkID0gaW5zdGFuY2UudWlkO1xyXG4gICAgICAgIC8vIGFsbG93UmVjdXJzZVxyXG4gICAgICAgIC8vICMxODAxLCAjMjA0MyBjb21wb25lbnQgcmVuZGVyIGVmZmVjdHMgc2hvdWxkIGFsbG93IHJlY3Vyc2l2ZSB1cGRhdGVzXHJcbiAgICAgICAgdG9nZ2xlUmVjdXJzZShpbnN0YW5jZSwgdHJ1ZSk7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICBlZmZlY3Qub25UcmFjayA9IGluc3RhbmNlLnJ0Y1xyXG4gICAgICAgICAgICAgICAgPyBlID0+IGludm9rZUFycmF5Rm5zKGluc3RhbmNlLnJ0YywgZSlcclxuICAgICAgICAgICAgICAgIDogdm9pZCAwO1xyXG4gICAgICAgICAgICBlZmZlY3Qub25UcmlnZ2VyID0gaW5zdGFuY2UucnRnXHJcbiAgICAgICAgICAgICAgICA/IGUgPT4gaW52b2tlQXJyYXlGbnMoaW5zdGFuY2UucnRnLCBlKVxyXG4gICAgICAgICAgICAgICAgOiB2b2lkIDA7XHJcbiAgICAgICAgICAgIHVwZGF0ZS5vd25lckluc3RhbmNlID0gaW5zdGFuY2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHVwZGF0ZSgpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHVwZGF0ZUNvbXBvbmVudFByZVJlbmRlciA9IChpbnN0YW5jZSwgbmV4dFZOb2RlLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgICAgICBuZXh0Vk5vZGUuY29tcG9uZW50ID0gaW5zdGFuY2U7XHJcbiAgICAgICAgY29uc3QgcHJldlByb3BzID0gaW5zdGFuY2Uudm5vZGUucHJvcHM7XHJcbiAgICAgICAgaW5zdGFuY2Uudm5vZGUgPSBuZXh0Vk5vZGU7XHJcbiAgICAgICAgaW5zdGFuY2UubmV4dCA9IG51bGw7XHJcbiAgICAgICAgdXBkYXRlUHJvcHMoaW5zdGFuY2UsIG5leHRWTm9kZS5wcm9wcywgcHJldlByb3BzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgIHVwZGF0ZVNsb3RzKGluc3RhbmNlLCBuZXh0Vk5vZGUuY2hpbGRyZW4sIG9wdGltaXplZCk7XHJcbiAgICAgICAgcGF1c2VUcmFja2luZygpO1xyXG4gICAgICAgIC8vIHByb3BzIHVwZGF0ZSBtYXkgaGF2ZSB0cmlnZ2VyZWQgcHJlLWZsdXNoIHdhdGNoZXJzLlxyXG4gICAgICAgIC8vIGZsdXNoIHRoZW0gYmVmb3JlIHRoZSByZW5kZXIgdXBkYXRlLlxyXG4gICAgICAgIGZsdXNoUHJlRmx1c2hDYnModW5kZWZpbmVkLCBpbnN0YW5jZS51cGRhdGUpO1xyXG4gICAgICAgIHJlc2V0VHJhY2tpbmcoKTtcclxuICAgIH07XHJcbiAgICBjb25zdCBwYXRjaENoaWxkcmVuID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCA9IGZhbHNlKSA9PiB7XHJcbiAgICAgICAgY29uc3QgYzEgPSBuMSAmJiBuMS5jaGlsZHJlbjtcclxuICAgICAgICBjb25zdCBwcmV2U2hhcGVGbGFnID0gbjEgPyBuMS5zaGFwZUZsYWcgOiAwO1xyXG4gICAgICAgIGNvbnN0IGMyID0gbjIuY2hpbGRyZW47XHJcbiAgICAgICAgY29uc3QgeyBwYXRjaEZsYWcsIHNoYXBlRmxhZyB9ID0gbjI7XHJcbiAgICAgICAgLy8gZmFzdCBwYXRoXHJcbiAgICAgICAgaWYgKHBhdGNoRmxhZyA+IDApIHtcclxuICAgICAgICAgICAgaWYgKHBhdGNoRmxhZyAmIDEyOCAvKiBLRVlFRF9GUkFHTUVOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBjb3VsZCBiZSBlaXRoZXIgZnVsbHkta2V5ZWQgb3IgbWl4ZWQgKHNvbWUga2V5ZWQgc29tZSBub3QpXHJcbiAgICAgICAgICAgICAgICAvLyBwcmVzZW5jZSBvZiBwYXRjaEZsYWcgbWVhbnMgY2hpbGRyZW4gYXJlIGd1YXJhbnRlZWQgdG8gYmUgYXJyYXlzXHJcbiAgICAgICAgICAgICAgICBwYXRjaEtleWVkQ2hpbGRyZW4oYzEsIGMyLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChwYXRjaEZsYWcgJiAyNTYgLyogVU5LRVlFRF9GUkFHTUVOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgLy8gdW5rZXllZFxyXG4gICAgICAgICAgICAgICAgcGF0Y2hVbmtleWVkQ2hpbGRyZW4oYzEsIGMyLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjaGlsZHJlbiBoYXMgMyBwb3NzaWJpbGl0aWVzOiB0ZXh0LCBhcnJheSBvciBubyBjaGlsZHJlbi5cclxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgOCAvKiBURVhUX0NISUxEUkVOICovKSB7XHJcbiAgICAgICAgICAgIC8vIHRleHQgY2hpbGRyZW4gZmFzdCBwYXRoXHJcbiAgICAgICAgICAgIGlmIChwcmV2U2hhcGVGbGFnICYgMTYgLyogQVJSQVlfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICAgICAgICAgIHVubW91bnRDaGlsZHJlbihjMSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGMyICE9PSBjMSkge1xyXG4gICAgICAgICAgICAgICAgaG9zdFNldEVsZW1lbnRUZXh0KGNvbnRhaW5lciwgYzIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAocHJldlNoYXBlRmxhZyAmIDE2IC8qIEFSUkFZX0NISUxEUkVOICovKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBwcmV2IGNoaWxkcmVuIHdhcyBhcnJheVxyXG4gICAgICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDE2IC8qIEFSUkFZX0NISUxEUkVOICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdHdvIGFycmF5cywgY2Fubm90IGFzc3VtZSBhbnl0aGluZywgZG8gZnVsbCBkaWZmXHJcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2hLZXllZENoaWxkcmVuKGMxLCBjMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBubyBuZXcgY2hpbGRyZW4sIGp1c3QgdW5tb3VudCBvbGRcclxuICAgICAgICAgICAgICAgICAgICB1bm1vdW50Q2hpbGRyZW4oYzEsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gcHJldiBjaGlsZHJlbiB3YXMgdGV4dCBPUiBudWxsXHJcbiAgICAgICAgICAgICAgICAvLyBuZXcgY2hpbGRyZW4gaXMgYXJyYXkgT1IgbnVsbFxyXG4gICAgICAgICAgICAgICAgaWYgKHByZXZTaGFwZUZsYWcgJiA4IC8qIFRFWFRfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBob3N0U2V0RWxlbWVudFRleHQoY29udGFpbmVyLCAnJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBtb3VudCBuZXcgaWYgYXJyYXlcclxuICAgICAgICAgICAgICAgIGlmIChzaGFwZUZsYWcgJiAxNiAvKiBBUlJBWV9DSElMRFJFTiAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIG1vdW50Q2hpbGRyZW4oYzIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHBhdGNoVW5rZXllZENoaWxkcmVuID0gKGMxLCBjMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgIGMxID0gYzEgfHwgRU1QVFlfQVJSO1xyXG4gICAgICAgIGMyID0gYzIgfHwgRU1QVFlfQVJSO1xyXG4gICAgICAgIGNvbnN0IG9sZExlbmd0aCA9IGMxLmxlbmd0aDtcclxuICAgICAgICBjb25zdCBuZXdMZW5ndGggPSBjMi5sZW5ndGg7XHJcbiAgICAgICAgY29uc3QgY29tbW9uTGVuZ3RoID0gTWF0aC5taW4ob2xkTGVuZ3RoLCBuZXdMZW5ndGgpO1xyXG4gICAgICAgIGxldCBpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb21tb25MZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBuZXh0Q2hpbGQgPSAoYzJbaV0gPSBvcHRpbWl6ZWRcclxuICAgICAgICAgICAgICAgID8gY2xvbmVJZk1vdW50ZWQoYzJbaV0pXHJcbiAgICAgICAgICAgICAgICA6IG5vcm1hbGl6ZVZOb2RlKGMyW2ldKSk7XHJcbiAgICAgICAgICAgIHBhdGNoKGMxW2ldLCBuZXh0Q2hpbGQsIGNvbnRhaW5lciwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9sZExlbmd0aCA+IG5ld0xlbmd0aCkge1xyXG4gICAgICAgICAgICAvLyByZW1vdmUgb2xkXHJcbiAgICAgICAgICAgIHVubW91bnRDaGlsZHJlbihjMSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSwgZmFsc2UsIGNvbW1vbkxlbmd0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBtb3VudCBuZXdcclxuICAgICAgICAgICAgbW91bnRDaGlsZHJlbihjMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgY29tbW9uTGVuZ3RoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gY2FuIGJlIGFsbC1rZXllZCBvciBtaXhlZFxyXG4gICAgY29uc3QgcGF0Y2hLZXllZENoaWxkcmVuID0gKGMxLCBjMiwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICBjb25zdCBsMiA9IGMyLmxlbmd0aDtcclxuICAgICAgICBsZXQgZTEgPSBjMS5sZW5ndGggLSAxOyAvLyBwcmV2IGVuZGluZyBpbmRleFxyXG4gICAgICAgIGxldCBlMiA9IGwyIC0gMTsgLy8gbmV4dCBlbmRpbmcgaW5kZXhcclxuICAgICAgICAvLyAxLiBzeW5jIGZyb20gc3RhcnRcclxuICAgICAgICAvLyAoYSBiKSBjXHJcbiAgICAgICAgLy8gKGEgYikgZCBlXHJcbiAgICAgICAgd2hpbGUgKGkgPD0gZTEgJiYgaSA8PSBlMikge1xyXG4gICAgICAgICAgICBjb25zdCBuMSA9IGMxW2ldO1xyXG4gICAgICAgICAgICBjb25zdCBuMiA9IChjMltpXSA9IG9wdGltaXplZFxyXG4gICAgICAgICAgICAgICAgPyBjbG9uZUlmTW91bnRlZChjMltpXSlcclxuICAgICAgICAgICAgICAgIDogbm9ybWFsaXplVk5vZGUoYzJbaV0pKTtcclxuICAgICAgICAgICAgaWYgKGlzU2FtZVZOb2RlVHlwZShuMSwgbjIpKSB7XHJcbiAgICAgICAgICAgICAgICBwYXRjaChuMSwgbjIsIGNvbnRhaW5lciwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gMi4gc3luYyBmcm9tIGVuZFxyXG4gICAgICAgIC8vIGEgKGIgYylcclxuICAgICAgICAvLyBkIGUgKGIgYylcclxuICAgICAgICB3aGlsZSAoaSA8PSBlMSAmJiBpIDw9IGUyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG4xID0gYzFbZTFdO1xyXG4gICAgICAgICAgICBjb25zdCBuMiA9IChjMltlMl0gPSBvcHRpbWl6ZWRcclxuICAgICAgICAgICAgICAgID8gY2xvbmVJZk1vdW50ZWQoYzJbZTJdKVxyXG4gICAgICAgICAgICAgICAgOiBub3JtYWxpemVWTm9kZShjMltlMl0pKTtcclxuICAgICAgICAgICAgaWYgKGlzU2FtZVZOb2RlVHlwZShuMSwgbjIpKSB7XHJcbiAgICAgICAgICAgICAgICBwYXRjaChuMSwgbjIsIGNvbnRhaW5lciwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGUxLS07XHJcbiAgICAgICAgICAgIGUyLS07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDMuIGNvbW1vbiBzZXF1ZW5jZSArIG1vdW50XHJcbiAgICAgICAgLy8gKGEgYilcclxuICAgICAgICAvLyAoYSBiKSBjXHJcbiAgICAgICAgLy8gaSA9IDIsIGUxID0gMSwgZTIgPSAyXHJcbiAgICAgICAgLy8gKGEgYilcclxuICAgICAgICAvLyBjIChhIGIpXHJcbiAgICAgICAgLy8gaSA9IDAsIGUxID0gLTEsIGUyID0gMFxyXG4gICAgICAgIGlmIChpID4gZTEpIHtcclxuICAgICAgICAgICAgaWYgKGkgPD0gZTIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRQb3MgPSBlMiArIDE7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhbmNob3IgPSBuZXh0UG9zIDwgbDIgPyBjMltuZXh0UG9zXS5lbCA6IHBhcmVudEFuY2hvcjtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChpIDw9IGUyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2gobnVsbCwgKGMyW2ldID0gb3B0aW1pemVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY2xvbmVJZk1vdW50ZWQoYzJbaV0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbm9ybWFsaXplVk5vZGUoYzJbaV0pKSwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDQuIGNvbW1vbiBzZXF1ZW5jZSArIHVubW91bnRcclxuICAgICAgICAvLyAoYSBiKSBjXHJcbiAgICAgICAgLy8gKGEgYilcclxuICAgICAgICAvLyBpID0gMiwgZTEgPSAyLCBlMiA9IDFcclxuICAgICAgICAvLyBhIChiIGMpXHJcbiAgICAgICAgLy8gKGIgYylcclxuICAgICAgICAvLyBpID0gMCwgZTEgPSAwLCBlMiA9IC0xXHJcbiAgICAgICAgZWxzZSBpZiAoaSA+IGUyKSB7XHJcbiAgICAgICAgICAgIHdoaWxlIChpIDw9IGUxKSB7XHJcbiAgICAgICAgICAgICAgICB1bm1vdW50KGMxW2ldLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyA1LiB1bmtub3duIHNlcXVlbmNlXHJcbiAgICAgICAgLy8gW2kgLi4uIGUxICsgMV06IGEgYiBbYyBkIGVdIGYgZ1xyXG4gICAgICAgIC8vIFtpIC4uLiBlMiArIDFdOiBhIGIgW2UgZCBjIGhdIGYgZ1xyXG4gICAgICAgIC8vIGkgPSAyLCBlMSA9IDQsIGUyID0gNVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBzMSA9IGk7IC8vIHByZXYgc3RhcnRpbmcgaW5kZXhcclxuICAgICAgICAgICAgY29uc3QgczIgPSBpOyAvLyBuZXh0IHN0YXJ0aW5nIGluZGV4XHJcbiAgICAgICAgICAgIC8vIDUuMSBidWlsZCBrZXk6aW5kZXggbWFwIGZvciBuZXdDaGlsZHJlblxyXG4gICAgICAgICAgICBjb25zdCBrZXlUb05ld0luZGV4TWFwID0gbmV3IE1hcCgpO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSBzMjsgaSA8PSBlMjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0Q2hpbGQgPSAoYzJbaV0gPSBvcHRpbWl6ZWRcclxuICAgICAgICAgICAgICAgICAgICA/IGNsb25lSWZNb3VudGVkKGMyW2ldKVxyXG4gICAgICAgICAgICAgICAgICAgIDogbm9ybWFsaXplVk5vZGUoYzJbaV0pKTtcclxuICAgICAgICAgICAgICAgIGlmIChuZXh0Q2hpbGQua2V5ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGtleVRvTmV3SW5kZXhNYXAuaGFzKG5leHRDaGlsZC5rZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oYER1cGxpY2F0ZSBrZXlzIGZvdW5kIGR1cmluZyB1cGRhdGU6YCwgSlNPTi5zdHJpbmdpZnkobmV4dENoaWxkLmtleSksIGBNYWtlIHN1cmUga2V5cyBhcmUgdW5pcXVlLmApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBrZXlUb05ld0luZGV4TWFwLnNldChuZXh0Q2hpbGQua2V5LCBpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyA1LjIgbG9vcCB0aHJvdWdoIG9sZCBjaGlsZHJlbiBsZWZ0IHRvIGJlIHBhdGNoZWQgYW5kIHRyeSB0byBwYXRjaFxyXG4gICAgICAgICAgICAvLyBtYXRjaGluZyBub2RlcyAmIHJlbW92ZSBub2RlcyB0aGF0IGFyZSBubyBsb25nZXIgcHJlc2VudFxyXG4gICAgICAgICAgICBsZXQgajtcclxuICAgICAgICAgICAgbGV0IHBhdGNoZWQgPSAwO1xyXG4gICAgICAgICAgICBjb25zdCB0b0JlUGF0Y2hlZCA9IGUyIC0gczIgKyAxO1xyXG4gICAgICAgICAgICBsZXQgbW92ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgLy8gdXNlZCB0byB0cmFjayB3aGV0aGVyIGFueSBub2RlIGhhcyBtb3ZlZFxyXG4gICAgICAgICAgICBsZXQgbWF4TmV3SW5kZXhTb0ZhciA9IDA7XHJcbiAgICAgICAgICAgIC8vIHdvcmtzIGFzIE1hcDxuZXdJbmRleCwgb2xkSW5kZXg+XHJcbiAgICAgICAgICAgIC8vIE5vdGUgdGhhdCBvbGRJbmRleCBpcyBvZmZzZXQgYnkgKzFcclxuICAgICAgICAgICAgLy8gYW5kIG9sZEluZGV4ID0gMCBpcyBhIHNwZWNpYWwgdmFsdWUgaW5kaWNhdGluZyB0aGUgbmV3IG5vZGUgaGFzXHJcbiAgICAgICAgICAgIC8vIG5vIGNvcnJlc3BvbmRpbmcgb2xkIG5vZGUuXHJcbiAgICAgICAgICAgIC8vIHVzZWQgZm9yIGRldGVybWluaW5nIGxvbmdlc3Qgc3RhYmxlIHN1YnNlcXVlbmNlXHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0luZGV4VG9PbGRJbmRleE1hcCA9IG5ldyBBcnJheSh0b0JlUGF0Y2hlZCk7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b0JlUGF0Y2hlZDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgbmV3SW5kZXhUb09sZEluZGV4TWFwW2ldID0gMDtcclxuICAgICAgICAgICAgZm9yIChpID0gczE7IGkgPD0gZTE7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJldkNoaWxkID0gYzFbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAocGF0Y2hlZCA+PSB0b0JlUGF0Y2hlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFsbCBuZXcgY2hpbGRyZW4gaGF2ZSBiZWVuIHBhdGNoZWQgc28gdGhpcyBjYW4gb25seSBiZSBhIHJlbW92YWxcclxuICAgICAgICAgICAgICAgICAgICB1bm1vdW50KHByZXZDaGlsZCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsZXQgbmV3SW5kZXg7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJldkNoaWxkLmtleSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3SW5kZXggPSBrZXlUb05ld0luZGV4TWFwLmdldChwcmV2Q2hpbGQua2V5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGtleS1sZXNzIG5vZGUsIHRyeSB0byBsb2NhdGUgYSBrZXktbGVzcyBub2RlIG9mIHRoZSBzYW1lIHR5cGVcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSBzMjsgaiA8PSBlMjsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdJbmRleFRvT2xkSW5kZXhNYXBbaiAtIHMyXSA9PT0gMCAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNTYW1lVk5vZGVUeXBlKHByZXZDaGlsZCwgYzJbal0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdJbmRleCA9IGo7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChuZXdJbmRleCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdW5tb3VudChwcmV2Q2hpbGQsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3SW5kZXhUb09sZEluZGV4TWFwW25ld0luZGV4IC0gczJdID0gaSArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0luZGV4ID49IG1heE5ld0luZGV4U29GYXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4TmV3SW5kZXhTb0ZhciA9IG5ld0luZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBwYXRjaChwcmV2Q2hpbGQsIGMyW25ld0luZGV4XSwgY29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoZWQrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyA1LjMgbW92ZSBhbmQgbW91bnRcclxuICAgICAgICAgICAgLy8gZ2VuZXJhdGUgbG9uZ2VzdCBzdGFibGUgc3Vic2VxdWVuY2Ugb25seSB3aGVuIG5vZGVzIGhhdmUgbW92ZWRcclxuICAgICAgICAgICAgY29uc3QgaW5jcmVhc2luZ05ld0luZGV4U2VxdWVuY2UgPSBtb3ZlZFxyXG4gICAgICAgICAgICAgICAgPyBnZXRTZXF1ZW5jZShuZXdJbmRleFRvT2xkSW5kZXhNYXApXHJcbiAgICAgICAgICAgICAgICA6IEVNUFRZX0FSUjtcclxuICAgICAgICAgICAgaiA9IGluY3JlYXNpbmdOZXdJbmRleFNlcXVlbmNlLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgIC8vIGxvb3BpbmcgYmFja3dhcmRzIHNvIHRoYXQgd2UgY2FuIHVzZSBsYXN0IHBhdGNoZWQgbm9kZSBhcyBhbmNob3JcclxuICAgICAgICAgICAgZm9yIChpID0gdG9CZVBhdGNoZWQgLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gczIgKyBpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dENoaWxkID0gYzJbbmV4dEluZGV4XTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFuY2hvciA9IG5leHRJbmRleCArIDEgPCBsMiA/IGMyW25leHRJbmRleCArIDFdLmVsIDogcGFyZW50QW5jaG9yO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5ld0luZGV4VG9PbGRJbmRleE1hcFtpXSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdW50IG5ld1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoKG51bGwsIG5leHRDaGlsZCwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtb3ZlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdmUgaWY6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgaXMgbm8gc3RhYmxlIHN1YnNlcXVlbmNlIChlLmcuIGEgcmV2ZXJzZSlcclxuICAgICAgICAgICAgICAgICAgICAvLyBPUiBjdXJyZW50IG5vZGUgaXMgbm90IGFtb25nIHRoZSBzdGFibGUgc2VxdWVuY2VcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaiA8IDAgfHwgaSAhPT0gaW5jcmVhc2luZ05ld0luZGV4U2VxdWVuY2Vbal0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZShuZXh0Q2hpbGQsIGNvbnRhaW5lciwgYW5jaG9yLCAyIC8qIFJFT1JERVIgKi8pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgai0tO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBtb3ZlID0gKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgbW92ZVR5cGUsIHBhcmVudFN1c3BlbnNlID0gbnVsbCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHsgZWwsIHR5cGUsIHRyYW5zaXRpb24sIGNoaWxkcmVuLCBzaGFwZUZsYWcgfSA9IHZub2RlO1xyXG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiA2IC8qIENPTVBPTkVOVCAqLykge1xyXG4gICAgICAgICAgICBtb3ZlKHZub2RlLmNvbXBvbmVudC5zdWJUcmVlLCBjb250YWluZXIsIGFuY2hvciwgbW92ZVR5cGUpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiAxMjggLyogU1VTUEVOU0UgKi8pIHtcclxuICAgICAgICAgICAgdm5vZGUuc3VzcGVuc2UubW92ZShjb250YWluZXIsIGFuY2hvciwgbW92ZVR5cGUpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiA2NCAvKiBURUxFUE9SVCAqLykge1xyXG4gICAgICAgICAgICB0eXBlLm1vdmUodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBpbnRlcm5hbHMpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlID09PSBGcmFnbWVudCkge1xyXG4gICAgICAgICAgICBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIGFuY2hvcik7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIG1vdmUoY2hpbGRyZW5baV0sIGNvbnRhaW5lciwgYW5jaG9yLCBtb3ZlVHlwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaG9zdEluc2VydCh2bm9kZS5hbmNob3IsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZSA9PT0gU3RhdGljKSB7XHJcbiAgICAgICAgICAgIG1vdmVTdGF0aWNOb2RlKHZub2RlLCBjb250YWluZXIsIGFuY2hvcik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gc2luZ2xlIG5vZGVzXHJcbiAgICAgICAgY29uc3QgbmVlZFRyYW5zaXRpb24gPSBtb3ZlVHlwZSAhPT0gMiAvKiBSRU9SREVSICovICYmXHJcbiAgICAgICAgICAgIHNoYXBlRmxhZyAmIDEgLyogRUxFTUVOVCAqLyAmJlxyXG4gICAgICAgICAgICB0cmFuc2l0aW9uO1xyXG4gICAgICAgIGlmIChuZWVkVHJhbnNpdGlvbikge1xyXG4gICAgICAgICAgICBpZiAobW92ZVR5cGUgPT09IDAgLyogRU5URVIgKi8pIHtcclxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb24uYmVmb3JlRW50ZXIoZWwpO1xyXG4gICAgICAgICAgICAgICAgaG9zdEluc2VydChlbCwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHRyYW5zaXRpb24uZW50ZXIoZWwpLCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IGxlYXZlLCBkZWxheUxlYXZlLCBhZnRlckxlYXZlIH0gPSB0cmFuc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVtb3ZlID0gKCkgPT4gaG9zdEluc2VydChlbCwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGVyZm9ybUxlYXZlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlYXZlKGVsLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZnRlckxlYXZlICYmIGFmdGVyTGVhdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBpZiAoZGVsYXlMZWF2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGF5TGVhdmUoZWwsIHJlbW92ZSwgcGVyZm9ybUxlYXZlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHBlcmZvcm1MZWF2ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIGFuY2hvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHVubW91bnQgPSAodm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlID0gZmFsc2UsIG9wdGltaXplZCA9IGZhbHNlKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyB0eXBlLCBwcm9wcywgcmVmLCBjaGlsZHJlbiwgZHluYW1pY0NoaWxkcmVuLCBzaGFwZUZsYWcsIHBhdGNoRmxhZywgZGlycyB9ID0gdm5vZGU7XHJcbiAgICAgICAgLy8gdW5zZXQgcmVmXHJcbiAgICAgICAgaWYgKHJlZiAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHNldFJlZihyZWYsIG51bGwsIHBhcmVudFN1c3BlbnNlLCB2bm9kZSwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiAyNTYgLyogQ09NUE9ORU5UX1NIT1VMRF9LRUVQX0FMSVZFICovKSB7XHJcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudC5jdHguZGVhY3RpdmF0ZSh2bm9kZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc2hvdWxkSW52b2tlRGlycyA9IHNoYXBlRmxhZyAmIDEgLyogRUxFTUVOVCAqLyAmJiBkaXJzO1xyXG4gICAgICAgIGNvbnN0IHNob3VsZEludm9rZVZub2RlSG9vayA9ICFpc0FzeW5jV3JhcHBlcih2bm9kZSk7XHJcbiAgICAgICAgbGV0IHZub2RlSG9vaztcclxuICAgICAgICBpZiAoc2hvdWxkSW52b2tlVm5vZGVIb29rICYmXHJcbiAgICAgICAgICAgICh2bm9kZUhvb2sgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlQmVmb3JlVW5tb3VudCkpIHtcclxuICAgICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCB2bm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiA2IC8qIENPTVBPTkVOVCAqLykge1xyXG4gICAgICAgICAgICB1bm1vdW50Q29tcG9uZW50KHZub2RlLmNvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChzaGFwZUZsYWcgJiAxMjggLyogU1VTUEVOU0UgKi8pIHtcclxuICAgICAgICAgICAgICAgIHZub2RlLnN1c3BlbnNlLnVubW91bnQocGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc2hvdWxkSW52b2tlRGlycykge1xyXG4gICAgICAgICAgICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCAnYmVmb3JlVW5tb3VudCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzaGFwZUZsYWcgJiA2NCAvKiBURUxFUE9SVCAqLykge1xyXG4gICAgICAgICAgICAgICAgdm5vZGUudHlwZS5yZW1vdmUodm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG9wdGltaXplZCwgaW50ZXJuYWxzLCBkb1JlbW92ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZHluYW1pY0NoaWxkcmVuICYmXHJcbiAgICAgICAgICAgICAgICAvLyAjMTE1MzogZmFzdCBwYXRoIHNob3VsZCBub3QgYmUgdGFrZW4gZm9yIG5vbi1zdGFibGUgKHYtZm9yKSBmcmFnbWVudHNcclxuICAgICAgICAgICAgICAgICh0eXBlICE9PSBGcmFnbWVudCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIChwYXRjaEZsYWcgPiAwICYmIHBhdGNoRmxhZyAmIDY0IC8qIFNUQUJMRV9GUkFHTUVOVCAqLykpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBmYXN0IHBhdGggZm9yIGJsb2NrIG5vZGVzOiBvbmx5IG5lZWQgdG8gdW5tb3VudCBkeW5hbWljIGNoaWxkcmVuLlxyXG4gICAgICAgICAgICAgICAgdW5tb3VudENoaWxkcmVuKGR5bmFtaWNDaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZmFsc2UsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCh0eXBlID09PSBGcmFnbWVudCAmJlxyXG4gICAgICAgICAgICAgICAgcGF0Y2hGbGFnICZcclxuICAgICAgICAgICAgICAgICAgICAoMTI4IC8qIEtFWUVEX0ZSQUdNRU5UICovIHwgMjU2IC8qIFVOS0VZRURfRlJBR01FTlQgKi8pKSB8fFxyXG4gICAgICAgICAgICAgICAgKCFvcHRpbWl6ZWQgJiYgc2hhcGVGbGFnICYgMTYgLyogQVJSQVlfQ0hJTERSRU4gKi8pKSB7XHJcbiAgICAgICAgICAgICAgICB1bm1vdW50Q2hpbGRyZW4oY2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkb1JlbW92ZSkge1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlKHZub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKHNob3VsZEludm9rZVZub2RlSG9vayAmJlxyXG4gICAgICAgICAgICAodm5vZGVIb29rID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZVVubW91bnRlZCkpIHx8XHJcbiAgICAgICAgICAgIHNob3VsZEludm9rZURpcnMpIHtcclxuICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHZub2RlSG9vayAmJiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcclxuICAgICAgICAgICAgICAgIHNob3VsZEludm9rZURpcnMgJiZcclxuICAgICAgICAgICAgICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsICd1bm1vdW50ZWQnKTtcclxuICAgICAgICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCByZW1vdmUgPSB2bm9kZSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyB0eXBlLCBlbCwgYW5jaG9yLCB0cmFuc2l0aW9uIH0gPSB2bm9kZTtcclxuICAgICAgICBpZiAodHlwZSA9PT0gRnJhZ21lbnQpIHtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgdm5vZGUucGF0Y2hGbGFnID4gMCAmJlxyXG4gICAgICAgICAgICAgICAgdm5vZGUucGF0Y2hGbGFnICYgMjA0OCAvKiBERVZfUk9PVF9GUkFHTUVOVCAqLyAmJlxyXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbiAmJlxyXG4gICAgICAgICAgICAgICAgIXRyYW5zaXRpb24ucGVyc2lzdGVkKSB7XHJcbiAgICAgICAgICAgICAgICB2bm9kZS5jaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gQ29tbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0UmVtb3ZlKGNoaWxkLmVsKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZShjaGlsZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVGcmFnbWVudChlbCwgYW5jaG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlID09PSBTdGF0aWMpIHtcclxuICAgICAgICAgICAgcmVtb3ZlU3RhdGljTm9kZSh2bm9kZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcGVyZm9ybVJlbW92ZSA9ICgpID0+IHtcclxuICAgICAgICAgICAgaG9zdFJlbW92ZShlbCk7XHJcbiAgICAgICAgICAgIGlmICh0cmFuc2l0aW9uICYmICF0cmFuc2l0aW9uLnBlcnNpc3RlZCAmJiB0cmFuc2l0aW9uLmFmdGVyTGVhdmUpIHtcclxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb24uYWZ0ZXJMZWF2ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMSAvKiBFTEVNRU5UICovICYmXHJcbiAgICAgICAgICAgIHRyYW5zaXRpb24gJiZcclxuICAgICAgICAgICAgIXRyYW5zaXRpb24ucGVyc2lzdGVkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgbGVhdmUsIGRlbGF5TGVhdmUgfSA9IHRyYW5zaXRpb247XHJcbiAgICAgICAgICAgIGNvbnN0IHBlcmZvcm1MZWF2ZSA9ICgpID0+IGxlYXZlKGVsLCBwZXJmb3JtUmVtb3ZlKTtcclxuICAgICAgICAgICAgaWYgKGRlbGF5TGVhdmUpIHtcclxuICAgICAgICAgICAgICAgIGRlbGF5TGVhdmUodm5vZGUuZWwsIHBlcmZvcm1SZW1vdmUsIHBlcmZvcm1MZWF2ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBwZXJmb3JtTGVhdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcGVyZm9ybVJlbW92ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCByZW1vdmVGcmFnbWVudCA9IChjdXIsIGVuZCkgPT4ge1xyXG4gICAgICAgIC8vIEZvciBmcmFnbWVudHMsIGRpcmVjdGx5IHJlbW92ZSBhbGwgY29udGFpbmVkIERPTSBub2Rlcy5cclxuICAgICAgICAvLyAoZnJhZ21lbnQgY2hpbGQgbm9kZXMgY2Fubm90IGhhdmUgdHJhbnNpdGlvbilcclxuICAgICAgICBsZXQgbmV4dDtcclxuICAgICAgICB3aGlsZSAoY3VyICE9PSBlbmQpIHtcclxuICAgICAgICAgICAgbmV4dCA9IGhvc3ROZXh0U2libGluZyhjdXIpO1xyXG4gICAgICAgICAgICBob3N0UmVtb3ZlKGN1cik7XHJcbiAgICAgICAgICAgIGN1ciA9IG5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGhvc3RSZW1vdmUoZW5kKTtcclxuICAgIH07XHJcbiAgICBjb25zdCB1bm1vdW50Q29tcG9uZW50ID0gKGluc3RhbmNlLCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpID0+IHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGluc3RhbmNlLnR5cGUuX19obXJJZCkge1xyXG4gICAgICAgICAgICB1bnJlZ2lzdGVySE1SKGluc3RhbmNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgeyBidW0sIHNjb3BlLCB1cGRhdGUsIHN1YlRyZWUsIHVtIH0gPSBpbnN0YW5jZTtcclxuICAgICAgICAvLyBiZWZvcmVVbm1vdW50IGhvb2tcclxuICAgICAgICBpZiAoYnVtKSB7XHJcbiAgICAgICAgICAgIGludm9rZUFycmF5Rm5zKGJ1bSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHN0b3AgZWZmZWN0cyBpbiBjb21wb25lbnQgc2NvcGVcclxuICAgICAgICBzY29wZS5zdG9wKCk7XHJcbiAgICAgICAgLy8gdXBkYXRlIG1heSBiZSBudWxsIGlmIGEgY29tcG9uZW50IGlzIHVubW91bnRlZCBiZWZvcmUgaXRzIGFzeW5jXHJcbiAgICAgICAgLy8gc2V0dXAgaGFzIHJlc29sdmVkLlxyXG4gICAgICAgIGlmICh1cGRhdGUpIHtcclxuICAgICAgICAgICAgLy8gc28gdGhhdCBzY2hlZHVsZXIgd2lsbCBubyBsb25nZXIgaW52b2tlIGl0XHJcbiAgICAgICAgICAgIHVwZGF0ZS5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgdW5tb3VudChzdWJUcmVlLCBpbnN0YW5jZSwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gdW5tb3VudGVkIGhvb2tcclxuICAgICAgICBpZiAodW0pIHtcclxuICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KHVtLCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLmlzVW5tb3VudGVkID0gdHJ1ZTtcclxuICAgICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgLy8gQSBjb21wb25lbnQgd2l0aCBhc3luYyBkZXAgaW5zaWRlIGEgcGVuZGluZyBzdXNwZW5zZSBpcyB1bm1vdW50ZWQgYmVmb3JlXHJcbiAgICAgICAgLy8gaXRzIGFzeW5jIGRlcCByZXNvbHZlcy4gVGhpcyBzaG91bGQgcmVtb3ZlIHRoZSBkZXAgZnJvbSB0aGUgc3VzcGVuc2UsIGFuZFxyXG4gICAgICAgIC8vIGNhdXNlIHRoZSBzdXNwZW5zZSB0byByZXNvbHZlIGltbWVkaWF0ZWx5IGlmIHRoYXQgd2FzIHRoZSBsYXN0IGRlcC5cclxuICAgICAgICBpZiAocGFyZW50U3VzcGVuc2UgJiZcclxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UucGVuZGluZ0JyYW5jaCAmJlxyXG4gICAgICAgICAgICAhcGFyZW50U3VzcGVuc2UuaXNVbm1vdW50ZWQgJiZcclxuICAgICAgICAgICAgaW5zdGFuY2UuYXN5bmNEZXAgJiZcclxuICAgICAgICAgICAgIWluc3RhbmNlLmFzeW5jUmVzb2x2ZWQgJiZcclxuICAgICAgICAgICAgaW5zdGFuY2Uuc3VzcGVuc2VJZCA9PT0gcGFyZW50U3VzcGVuc2UucGVuZGluZ0lkKSB7XHJcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLmRlcHMtLTtcclxuICAgICAgICAgICAgaWYgKHBhcmVudFN1c3BlbnNlLmRlcHMgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgICAgICAgICBkZXZ0b29sc0NvbXBvbmVudFJlbW92ZWQoaW5zdGFuY2UpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCB1bm1vdW50Q2hpbGRyZW4gPSAoY2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlID0gZmFsc2UsIG9wdGltaXplZCA9IGZhbHNlLCBzdGFydCA9IDApID0+IHtcclxuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB1bm1vdW50KGNoaWxkcmVuW2ldLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSwgb3B0aW1pemVkKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgZ2V0TmV4dEhvc3ROb2RlID0gdm5vZGUgPT4ge1xyXG4gICAgICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiA2IC8qIENPTVBPTkVOVCAqLykge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2V0TmV4dEhvc3ROb2RlKHZub2RlLmNvbXBvbmVudC5zdWJUcmVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDEyOCAvKiBTVVNQRU5TRSAqLykge1xyXG4gICAgICAgICAgICByZXR1cm4gdm5vZGUuc3VzcGVuc2UubmV4dCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaG9zdE5leHRTaWJsaW5nKCh2bm9kZS5hbmNob3IgfHwgdm5vZGUuZWwpKTtcclxuICAgIH07XHJcbiAgICBjb25zdCByZW5kZXIgPSAodm5vZGUsIGNvbnRhaW5lciwgaXNTVkcpID0+IHtcclxuICAgICAgICBpZiAodm5vZGUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpZiAoY29udGFpbmVyLl92bm9kZSkge1xyXG4gICAgICAgICAgICAgICAgdW5tb3VudChjb250YWluZXIuX3Zub2RlLCBudWxsLCBudWxsLCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcGF0Y2goY29udGFpbmVyLl92bm9kZSB8fCBudWxsLCB2bm9kZSwgY29udGFpbmVyLCBudWxsLCBudWxsLCBudWxsLCBpc1NWRyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZsdXNoUG9zdEZsdXNoQ2JzKCk7XHJcbiAgICAgICAgY29udGFpbmVyLl92bm9kZSA9IHZub2RlO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGludGVybmFscyA9IHtcclxuICAgICAgICBwOiBwYXRjaCxcclxuICAgICAgICB1bTogdW5tb3VudCxcclxuICAgICAgICBtOiBtb3ZlLFxyXG4gICAgICAgIHI6IHJlbW92ZSxcclxuICAgICAgICBtdDogbW91bnRDb21wb25lbnQsXHJcbiAgICAgICAgbWM6IG1vdW50Q2hpbGRyZW4sXHJcbiAgICAgICAgcGM6IHBhdGNoQ2hpbGRyZW4sXHJcbiAgICAgICAgcGJjOiBwYXRjaEJsb2NrQ2hpbGRyZW4sXHJcbiAgICAgICAgbjogZ2V0TmV4dEhvc3ROb2RlLFxyXG4gICAgICAgIG86IG9wdGlvbnNcclxuICAgIH07XHJcbiAgICBsZXQgaHlkcmF0ZTtcclxuICAgIGxldCBoeWRyYXRlTm9kZTtcclxuICAgIGlmIChjcmVhdGVIeWRyYXRpb25GbnMpIHtcclxuICAgICAgICBbaHlkcmF0ZSwgaHlkcmF0ZU5vZGVdID0gY3JlYXRlSHlkcmF0aW9uRm5zKGludGVybmFscyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlbmRlcixcclxuICAgICAgICBoeWRyYXRlLFxyXG4gICAgICAgIGNyZWF0ZUFwcDogY3JlYXRlQXBwQVBJKHJlbmRlciwgaHlkcmF0ZSlcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gdG9nZ2xlUmVjdXJzZSh7IGVmZmVjdCwgdXBkYXRlIH0sIGFsbG93ZWQpIHtcclxuICAgIGVmZmVjdC5hbGxvd1JlY3Vyc2UgPSB1cGRhdGUuYWxsb3dSZWN1cnNlID0gYWxsb3dlZDtcclxufVxyXG4vKipcclxuICogIzExNTZcclxuICogV2hlbiBhIGNvbXBvbmVudCBpcyBITVItZW5hYmxlZCwgd2UgbmVlZCB0byBtYWtlIHN1cmUgdGhhdCBhbGwgc3RhdGljIG5vZGVzXHJcbiAqIGluc2lkZSBhIGJsb2NrIGFsc28gaW5oZXJpdCB0aGUgRE9NIGVsZW1lbnQgZnJvbSB0aGUgcHJldmlvdXMgdHJlZSBzbyB0aGF0XHJcbiAqIEhNUiB1cGRhdGVzICh3aGljaCBhcmUgZnVsbCB1cGRhdGVzKSBjYW4gcmV0cmlldmUgdGhlIGVsZW1lbnQgZm9yIHBhdGNoaW5nLlxyXG4gKlxyXG4gKiAjMjA4MFxyXG4gKiBJbnNpZGUga2V5ZWQgYHRlbXBsYXRlYCBmcmFnbWVudCBzdGF0aWMgY2hpbGRyZW4sIGlmIGEgZnJhZ21lbnQgaXMgbW92ZWQsXHJcbiAqIHRoZSBjaGlsZHJlbiB3aWxsIGFsd2F5cyBiZSBtb3ZlZC4gVGhlcmVmb3JlLCBpbiBvcmRlciB0byBlbnN1cmUgY29ycmVjdCBtb3ZlXHJcbiAqIHBvc2l0aW9uLCBlbCBzaG91bGQgYmUgaW5oZXJpdGVkIGZyb20gcHJldmlvdXMgbm9kZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKG4xLCBuMiwgc2hhbGxvdyA9IGZhbHNlKSB7XHJcbiAgICBjb25zdCBjaDEgPSBuMS5jaGlsZHJlbjtcclxuICAgIGNvbnN0IGNoMiA9IG4yLmNoaWxkcmVuO1xyXG4gICAgaWYgKGlzQXJyYXkoY2gxKSAmJiBpc0FycmF5KGNoMikpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoMS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAvLyB0aGlzIGlzIG9ubHkgY2FsbGVkIGluIHRoZSBvcHRpbWl6ZWQgcGF0aCBzbyBhcnJheSBjaGlsZHJlbiBhcmVcclxuICAgICAgICAgICAgLy8gZ3VhcmFudGVlZCB0byBiZSB2bm9kZXNcclxuICAgICAgICAgICAgY29uc3QgYzEgPSBjaDFbaV07XHJcbiAgICAgICAgICAgIGxldCBjMiA9IGNoMltpXTtcclxuICAgICAgICAgICAgaWYgKGMyLnNoYXBlRmxhZyAmIDEgLyogRUxFTUVOVCAqLyAmJiAhYzIuZHluYW1pY0NoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYzIucGF0Y2hGbGFnIDw9IDAgfHwgYzIucGF0Y2hGbGFnID09PSAzMiAvKiBIWURSQVRFX0VWRU5UUyAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGMyID0gY2gyW2ldID0gY2xvbmVJZk1vdW50ZWQoY2gyW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICBjMi5lbCA9IGMxLmVsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFzaGFsbG93KVxyXG4gICAgICAgICAgICAgICAgICAgIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4oYzEsIGMyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBhbHNvIGluaGVyaXQgZm9yIGNvbW1lbnQgbm9kZXMsIGJ1dCBub3QgcGxhY2Vob2xkZXJzIChlLmcuIHYtaWYgd2hpY2hcclxuICAgICAgICAgICAgLy8gd291bGQgaGF2ZSByZWNlaXZlZCAuZWwgZHVyaW5nIGJsb2NrIHBhdGNoKVxyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGMyLnR5cGUgPT09IENvbW1lbnQgJiYgIWMyLmVsKSB7XHJcbiAgICAgICAgICAgICAgICBjMi5lbCA9IGMxLmVsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xvbmdlc3RfaW5jcmVhc2luZ19zdWJzZXF1ZW5jZVxyXG5mdW5jdGlvbiBnZXRTZXF1ZW5jZShhcnIpIHtcclxuICAgIGNvbnN0IHAgPSBhcnIuc2xpY2UoKTtcclxuICAgIGNvbnN0IHJlc3VsdCA9IFswXTtcclxuICAgIGxldCBpLCBqLCB1LCB2LCBjO1xyXG4gICAgY29uc3QgbGVuID0gYXJyLmxlbmd0aDtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGFyckkgPSBhcnJbaV07XHJcbiAgICAgICAgaWYgKGFyckkgIT09IDApIHtcclxuICAgICAgICAgICAgaiA9IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgIGlmIChhcnJbal0gPCBhcnJJKSB7XHJcbiAgICAgICAgICAgICAgICBwW2ldID0gajtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGkpO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdSA9IDA7XHJcbiAgICAgICAgICAgIHYgPSByZXN1bHQubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgd2hpbGUgKHUgPCB2KSB7XHJcbiAgICAgICAgICAgICAgICBjID0gKHUgKyB2KSA+PiAxO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFycltyZXN1bHRbY11dIDwgYXJySSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHUgPSBjICsgMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHYgPSBjO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChhcnJJIDwgYXJyW3Jlc3VsdFt1XV0pIHtcclxuICAgICAgICAgICAgICAgIGlmICh1ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBbaV0gPSByZXN1bHRbdSAtIDFdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVzdWx0W3VdID0gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHUgPSByZXN1bHQubGVuZ3RoO1xyXG4gICAgdiA9IHJlc3VsdFt1IC0gMV07XHJcbiAgICB3aGlsZSAodS0tID4gMCkge1xyXG4gICAgICAgIHJlc3VsdFt1XSA9IHY7XHJcbiAgICAgICAgdiA9IHBbdl07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XG5cbmNvbnN0IGlzVGVsZXBvcnQgPSAodHlwZSkgPT4gdHlwZS5fX2lzVGVsZXBvcnQ7XHJcbmNvbnN0IGlzVGVsZXBvcnREaXNhYmxlZCA9IChwcm9wcykgPT4gcHJvcHMgJiYgKHByb3BzLmRpc2FibGVkIHx8IHByb3BzLmRpc2FibGVkID09PSAnJyk7XHJcbmNvbnN0IGlzVGFyZ2V0U1ZHID0gKHRhcmdldCkgPT4gdHlwZW9mIFNWR0VsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHRhcmdldCBpbnN0YW5jZW9mIFNWR0VsZW1lbnQ7XHJcbmNvbnN0IHJlc29sdmVUYXJnZXQgPSAocHJvcHMsIHNlbGVjdCkgPT4ge1xyXG4gICAgY29uc3QgdGFyZ2V0U2VsZWN0b3IgPSBwcm9wcyAmJiBwcm9wcy50bztcclxuICAgIGlmIChpc1N0cmluZyh0YXJnZXRTZWxlY3RvcikpIHtcclxuICAgICAgICBpZiAoIXNlbGVjdCkge1xyXG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgIHdhcm4oYEN1cnJlbnQgcmVuZGVyZXIgZG9lcyBub3Qgc3VwcG9ydCBzdHJpbmcgdGFyZ2V0IGZvciBUZWxlcG9ydHMuIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGAobWlzc2luZyBxdWVyeVNlbGVjdG9yIHJlbmRlcmVyIG9wdGlvbilgKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBzZWxlY3QodGFyZ2V0U2VsZWN0b3IpO1xyXG4gICAgICAgICAgICBpZiAoIXRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgRmFpbGVkIHRvIGxvY2F0ZSBUZWxlcG9ydCB0YXJnZXQgd2l0aCBzZWxlY3RvciBcIiR7dGFyZ2V0U2VsZWN0b3J9XCIuIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgTm90ZSB0aGUgdGFyZ2V0IGVsZW1lbnQgbXVzdCBleGlzdCBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkIC0gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGBpLmUuIHRoZSB0YXJnZXQgY2Fubm90IGJlIHJlbmRlcmVkIGJ5IHRoZSBjb21wb25lbnQgaXRzZWxmLCBhbmQgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGBpZGVhbGx5IHNob3VsZCBiZSBvdXRzaWRlIG9mIHRoZSBlbnRpcmUgVnVlIGNvbXBvbmVudCB0cmVlLmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhdGFyZ2V0U2VsZWN0b3IgJiYgIWlzVGVsZXBvcnREaXNhYmxlZChwcm9wcykpIHtcclxuICAgICAgICAgICAgd2FybihgSW52YWxpZCBUZWxlcG9ydCB0YXJnZXQ6ICR7dGFyZ2V0U2VsZWN0b3J9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0YXJnZXRTZWxlY3RvcjtcclxuICAgIH1cclxufTtcclxuY29uc3QgVGVsZXBvcnRJbXBsID0ge1xyXG4gICAgX19pc1RlbGVwb3J0OiB0cnVlLFxyXG4gICAgcHJvY2VzcyhuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIGludGVybmFscykge1xyXG4gICAgICAgIGNvbnN0IHsgbWM6IG1vdW50Q2hpbGRyZW4sIHBjOiBwYXRjaENoaWxkcmVuLCBwYmM6IHBhdGNoQmxvY2tDaGlsZHJlbiwgbzogeyBpbnNlcnQsIHF1ZXJ5U2VsZWN0b3IsIGNyZWF0ZVRleHQsIGNyZWF0ZUNvbW1lbnQgfSB9ID0gaW50ZXJuYWxzO1xyXG4gICAgICAgIGNvbnN0IGRpc2FibGVkID0gaXNUZWxlcG9ydERpc2FibGVkKG4yLnByb3BzKTtcclxuICAgICAgICBsZXQgeyBzaGFwZUZsYWcsIGNoaWxkcmVuLCBkeW5hbWljQ2hpbGRyZW4gfSA9IG4yO1xyXG4gICAgICAgIC8vICMzMzAyXHJcbiAgICAgICAgLy8gSE1SIHVwZGF0ZWQsIGZvcmNlIGZ1bGwgZGlmZlxyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaXNIbXJVcGRhdGluZykge1xyXG4gICAgICAgICAgICBvcHRpbWl6ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgZHluYW1pY0NoaWxkcmVuID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG4xID09IG51bGwpIHtcclxuICAgICAgICAgICAgLy8gaW5zZXJ0IGFuY2hvcnMgaW4gdGhlIG1haW4gdmlld1xyXG4gICAgICAgICAgICBjb25zdCBwbGFjZWhvbGRlciA9IChuMi5lbCA9IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxyXG4gICAgICAgICAgICAgICAgPyBjcmVhdGVDb21tZW50KCd0ZWxlcG9ydCBzdGFydCcpXHJcbiAgICAgICAgICAgICAgICA6IGNyZWF0ZVRleHQoJycpKTtcclxuICAgICAgICAgICAgY29uc3QgbWFpbkFuY2hvciA9IChuMi5hbmNob3IgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcclxuICAgICAgICAgICAgICAgID8gY3JlYXRlQ29tbWVudCgndGVsZXBvcnQgZW5kJylcclxuICAgICAgICAgICAgICAgIDogY3JlYXRlVGV4dCgnJykpO1xyXG4gICAgICAgICAgICBpbnNlcnQocGxhY2Vob2xkZXIsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICAgICAgaW5zZXJ0KG1haW5BbmNob3IsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gKG4yLnRhcmdldCA9IHJlc29sdmVUYXJnZXQobjIucHJvcHMsIHF1ZXJ5U2VsZWN0b3IpKTtcclxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0QW5jaG9yID0gKG4yLnRhcmdldEFuY2hvciA9IGNyZWF0ZVRleHQoJycpKTtcclxuICAgICAgICAgICAgaWYgKHRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgaW5zZXJ0KHRhcmdldEFuY2hvciwgdGFyZ2V0KTtcclxuICAgICAgICAgICAgICAgIC8vICMyNjUyIHdlIGNvdWxkIGJlIHRlbGVwb3J0aW5nIGZyb20gYSBub24tU1ZHIHRyZWUgaW50byBhbiBTVkcgdHJlZVxyXG4gICAgICAgICAgICAgICAgaXNTVkcgPSBpc1NWRyB8fCBpc1RhcmdldFNWRyh0YXJnZXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhZGlzYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oJ0ludmFsaWQgVGVsZXBvcnQgdGFyZ2V0IG9uIG1vdW50OicsIHRhcmdldCwgYCgke3R5cGVvZiB0YXJnZXR9KWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IG1vdW50ID0gKGNvbnRhaW5lciwgYW5jaG9yKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBUZWxlcG9ydCAqYWx3YXlzKiBoYXMgQXJyYXkgY2hpbGRyZW4uIFRoaXMgaXMgZW5mb3JjZWQgaW4gYm90aCB0aGVcclxuICAgICAgICAgICAgICAgIC8vIGNvbXBpbGVyIGFuZCB2bm9kZSBjaGlsZHJlbiBub3JtYWxpemF0aW9uLlxyXG4gICAgICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDE2IC8qIEFSUkFZX0NISUxEUkVOICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbW91bnRDaGlsZHJlbihjaGlsZHJlbiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmIChkaXNhYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgbW91bnQoY29udGFpbmVyLCBtYWluQW5jaG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgIG1vdW50KHRhcmdldCwgdGFyZ2V0QW5jaG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gdXBkYXRlIGNvbnRlbnRcclxuICAgICAgICAgICAgbjIuZWwgPSBuMS5lbDtcclxuICAgICAgICAgICAgY29uc3QgbWFpbkFuY2hvciA9IChuMi5hbmNob3IgPSBuMS5hbmNob3IpO1xyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSAobjIudGFyZ2V0ID0gbjEudGFyZ2V0KTtcclxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0QW5jaG9yID0gKG4yLnRhcmdldEFuY2hvciA9IG4xLnRhcmdldEFuY2hvcik7XHJcbiAgICAgICAgICAgIGNvbnN0IHdhc0Rpc2FibGVkID0gaXNUZWxlcG9ydERpc2FibGVkKG4xLnByb3BzKTtcclxuICAgICAgICAgICAgY29uc3QgY3VycmVudENvbnRhaW5lciA9IHdhc0Rpc2FibGVkID8gY29udGFpbmVyIDogdGFyZ2V0O1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50QW5jaG9yID0gd2FzRGlzYWJsZWQgPyBtYWluQW5jaG9yIDogdGFyZ2V0QW5jaG9yO1xyXG4gICAgICAgICAgICBpc1NWRyA9IGlzU1ZHIHx8IGlzVGFyZ2V0U1ZHKHRhcmdldCk7XHJcbiAgICAgICAgICAgIGlmIChkeW5hbWljQ2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgICAgIC8vIGZhc3QgcGF0aCB3aGVuIHRoZSB0ZWxlcG9ydCBoYXBwZW5zIHRvIGJlIGEgYmxvY2sgcm9vdFxyXG4gICAgICAgICAgICAgICAgcGF0Y2hCbG9ja0NoaWxkcmVuKG4xLmR5bmFtaWNDaGlsZHJlbiwgZHluYW1pY0NoaWxkcmVuLCBjdXJyZW50Q29udGFpbmVyLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzKTtcclxuICAgICAgICAgICAgICAgIC8vIGV2ZW4gaW4gYmxvY2sgdHJlZSBtb2RlIHdlIG5lZWQgdG8gbWFrZSBzdXJlIGFsbCByb290LWxldmVsIG5vZGVzXHJcbiAgICAgICAgICAgICAgICAvLyBpbiB0aGUgdGVsZXBvcnQgaW5oZXJpdCBwcmV2aW91cyBET00gcmVmZXJlbmNlcyBzbyB0aGF0IHRoZXkgY2FuXHJcbiAgICAgICAgICAgICAgICAvLyBiZSBtb3ZlZCBpbiBmdXR1cmUgcGF0Y2hlcy5cclxuICAgICAgICAgICAgICAgIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4objEsIG4yLCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghb3B0aW1pemVkKSB7XHJcbiAgICAgICAgICAgICAgICBwYXRjaENoaWxkcmVuKG4xLCBuMiwgY3VycmVudENvbnRhaW5lciwgY3VycmVudEFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgZmFsc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkaXNhYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF3YXNEaXNhYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGVuYWJsZWQgLT4gZGlzYWJsZWRcclxuICAgICAgICAgICAgICAgICAgICAvLyBtb3ZlIGludG8gbWFpbiBjb250YWluZXJcclxuICAgICAgICAgICAgICAgICAgICBtb3ZlVGVsZXBvcnQobjIsIGNvbnRhaW5lciwgbWFpbkFuY2hvciwgaW50ZXJuYWxzLCAxIC8qIFRPR0dMRSAqLyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyB0YXJnZXQgY2hhbmdlZFxyXG4gICAgICAgICAgICAgICAgaWYgKChuMi5wcm9wcyAmJiBuMi5wcm9wcy50bykgIT09IChuMS5wcm9wcyAmJiBuMS5wcm9wcy50bykpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0VGFyZ2V0ID0gKG4yLnRhcmdldCA9IHJlc29sdmVUYXJnZXQobjIucHJvcHMsIHF1ZXJ5U2VsZWN0b3IpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dFRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlVGVsZXBvcnQobjIsIG5leHRUYXJnZXQsIG51bGwsIGludGVybmFscywgMCAvKiBUQVJHRVRfQ0hBTkdFICovKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oJ0ludmFsaWQgVGVsZXBvcnQgdGFyZ2V0IG9uIHVwZGF0ZTonLCB0YXJnZXQsIGAoJHt0eXBlb2YgdGFyZ2V0fSlgKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh3YXNEaXNhYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGRpc2FibGVkIC0+IGVuYWJsZWRcclxuICAgICAgICAgICAgICAgICAgICAvLyBtb3ZlIGludG8gdGVsZXBvcnQgdGFyZ2V0XHJcbiAgICAgICAgICAgICAgICAgICAgbW92ZVRlbGVwb3J0KG4yLCB0YXJnZXQsIHRhcmdldEFuY2hvciwgaW50ZXJuYWxzLCAxIC8qIFRPR0dMRSAqLyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgcmVtb3ZlKHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBvcHRpbWl6ZWQsIHsgdW06IHVubW91bnQsIG86IHsgcmVtb3ZlOiBob3N0UmVtb3ZlIH0gfSwgZG9SZW1vdmUpIHtcclxuICAgICAgICBjb25zdCB7IHNoYXBlRmxhZywgY2hpbGRyZW4sIGFuY2hvciwgdGFyZ2V0QW5jaG9yLCB0YXJnZXQsIHByb3BzIH0gPSB2bm9kZTtcclxuICAgICAgICBpZiAodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIGhvc3RSZW1vdmUodGFyZ2V0QW5jaG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYW4gdW5tb3VudGVkIHRlbGVwb3J0IHNob3VsZCBhbHdheXMgcmVtb3ZlIGl0cyBjaGlsZHJlbiBpZiBub3QgZGlzYWJsZWRcclxuICAgICAgICBpZiAoZG9SZW1vdmUgfHwgIWlzVGVsZXBvcnREaXNhYmxlZChwcm9wcykpIHtcclxuICAgICAgICAgICAgaG9zdFJlbW92ZShhbmNob3IpO1xyXG4gICAgICAgICAgICBpZiAoc2hhcGVGbGFnICYgMTYgLyogQVJSQVlfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHVubW91bnQoY2hpbGQsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUsICEhY2hpbGQuZHluYW1pY0NoaWxkcmVuKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBtb3ZlOiBtb3ZlVGVsZXBvcnQsXHJcbiAgICBoeWRyYXRlOiBoeWRyYXRlVGVsZXBvcnRcclxufTtcclxuZnVuY3Rpb24gbW92ZVRlbGVwb3J0KHZub2RlLCBjb250YWluZXIsIHBhcmVudEFuY2hvciwgeyBvOiB7IGluc2VydCB9LCBtOiBtb3ZlIH0sIG1vdmVUeXBlID0gMiAvKiBSRU9SREVSICovKSB7XHJcbiAgICAvLyBtb3ZlIHRhcmdldCBhbmNob3IgaWYgdGhpcyBpcyBhIHRhcmdldCBjaGFuZ2UuXHJcbiAgICBpZiAobW92ZVR5cGUgPT09IDAgLyogVEFSR0VUX0NIQU5HRSAqLykge1xyXG4gICAgICAgIGluc2VydCh2bm9kZS50YXJnZXRBbmNob3IsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgZWwsIGFuY2hvciwgc2hhcGVGbGFnLCBjaGlsZHJlbiwgcHJvcHMgfSA9IHZub2RlO1xyXG4gICAgY29uc3QgaXNSZW9yZGVyID0gbW92ZVR5cGUgPT09IDIgLyogUkVPUkRFUiAqLztcclxuICAgIC8vIG1vdmUgbWFpbiB2aWV3IGFuY2hvciBpZiB0aGlzIGlzIGEgcmUtb3JkZXIuXHJcbiAgICBpZiAoaXNSZW9yZGVyKSB7XHJcbiAgICAgICAgaW5zZXJ0KGVsLCBjb250YWluZXIsIHBhcmVudEFuY2hvcik7XHJcbiAgICB9XHJcbiAgICAvLyBpZiB0aGlzIGlzIGEgcmUtb3JkZXIgYW5kIHRlbGVwb3J0IGlzIGVuYWJsZWQgKGNvbnRlbnQgaXMgaW4gdGFyZ2V0KVxyXG4gICAgLy8gZG8gbm90IG1vdmUgY2hpbGRyZW4uIFNvIHRoZSBvcHBvc2l0ZSBpczogb25seSBtb3ZlIGNoaWxkcmVuIGlmIHRoaXNcclxuICAgIC8vIGlzIG5vdCBhIHJlb3JkZXIsIG9yIHRoZSB0ZWxlcG9ydCBpcyBkaXNhYmxlZFxyXG4gICAgaWYgKCFpc1Jlb3JkZXIgfHwgaXNUZWxlcG9ydERpc2FibGVkKHByb3BzKSkge1xyXG4gICAgICAgIC8vIFRlbGVwb3J0IGhhcyBlaXRoZXIgQXJyYXkgY2hpbGRyZW4gb3Igbm8gY2hpbGRyZW4uXHJcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDE2IC8qIEFSUkFZX0NISUxEUkVOICovKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIG1vdmUoY2hpbGRyZW5baV0sIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yLCAyIC8qIFJFT1JERVIgKi8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gbW92ZSBtYWluIHZpZXcgYW5jaG9yIGlmIHRoaXMgaXMgYSByZS1vcmRlci5cclxuICAgIGlmIChpc1Jlb3JkZXIpIHtcclxuICAgICAgICBpbnNlcnQoYW5jaG9yLCBjb250YWluZXIsIHBhcmVudEFuY2hvcik7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaHlkcmF0ZVRlbGVwb3J0KG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgeyBvOiB7IG5leHRTaWJsaW5nLCBwYXJlbnROb2RlLCBxdWVyeVNlbGVjdG9yIH0gfSwgaHlkcmF0ZUNoaWxkcmVuKSB7XHJcbiAgICBjb25zdCB0YXJnZXQgPSAodm5vZGUudGFyZ2V0ID0gcmVzb2x2ZVRhcmdldCh2bm9kZS5wcm9wcywgcXVlcnlTZWxlY3RvcikpO1xyXG4gICAgaWYgKHRhcmdldCkge1xyXG4gICAgICAgIC8vIGlmIG11bHRpcGxlIHRlbGVwb3J0cyByZW5kZXJlZCB0byB0aGUgc2FtZSB0YXJnZXQgZWxlbWVudCwgd2UgbmVlZCB0b1xyXG4gICAgICAgIC8vIHBpY2sgdXAgZnJvbSB3aGVyZSB0aGUgbGFzdCB0ZWxlcG9ydCBmaW5pc2hlZCBpbnN0ZWFkIG9mIHRoZSBmaXJzdCBub2RlXHJcbiAgICAgICAgY29uc3QgdGFyZ2V0Tm9kZSA9IHRhcmdldC5fbHBhIHx8IHRhcmdldC5maXJzdENoaWxkO1xyXG4gICAgICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxNiAvKiBBUlJBWV9DSElMRFJFTiAqLykge1xyXG4gICAgICAgICAgICBpZiAoaXNUZWxlcG9ydERpc2FibGVkKHZub2RlLnByb3BzKSkge1xyXG4gICAgICAgICAgICAgICAgdm5vZGUuYW5jaG9yID0gaHlkcmF0ZUNoaWxkcmVuKG5leHRTaWJsaW5nKG5vZGUpLCB2bm9kZSwgcGFyZW50Tm9kZShub2RlKSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgdm5vZGUudGFyZ2V0QW5jaG9yID0gdGFyZ2V0Tm9kZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZub2RlLmFuY2hvciA9IG5leHRTaWJsaW5nKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgLy8gbG9va2FoZWFkIHVudGlsIHdlIGZpbmQgdGhlIHRhcmdldCBhbmNob3JcclxuICAgICAgICAgICAgICAgIC8vIHdlIGNhbm5vdCByZWx5IG9uIHJldHVybiB2YWx1ZSBvZiBoeWRyYXRlQ2hpbGRyZW4oKSBiZWNhdXNlIHRoZXJlXHJcbiAgICAgICAgICAgICAgICAvLyBjb3VsZCBiZSBuZXN0ZWQgdGVsZXBvcnRzXHJcbiAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0QW5jaG9yID0gdGFyZ2V0Tm9kZTtcclxuICAgICAgICAgICAgICAgIHdoaWxlICh0YXJnZXRBbmNob3IpIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRBbmNob3IgPSBuZXh0U2libGluZyh0YXJnZXRBbmNob3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRBbmNob3IgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0QW5jaG9yLm5vZGVUeXBlID09PSA4ICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEFuY2hvci5kYXRhID09PSAndGVsZXBvcnQgYW5jaG9yJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2bm9kZS50YXJnZXRBbmNob3IgPSB0YXJnZXRBbmNob3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5fbHBhID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZub2RlLnRhcmdldEFuY2hvciAmJiBuZXh0U2libGluZyh2bm9kZS50YXJnZXRBbmNob3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBoeWRyYXRlQ2hpbGRyZW4odGFyZ2V0Tm9kZSwgdm5vZGUsIHRhcmdldCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZub2RlLmFuY2hvciAmJiBuZXh0U2libGluZyh2bm9kZS5hbmNob3IpO1xyXG59XHJcbi8vIEZvcmNlLWNhc3RlZCBwdWJsaWMgdHlwaW5nIGZvciBoIGFuZCBUU1ggcHJvcHMgaW5mZXJlbmNlXHJcbmNvbnN0IFRlbGVwb3J0ID0gVGVsZXBvcnRJbXBsO1xuXG5jb25zdCBGcmFnbWVudCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyAnRnJhZ21lbnQnIDogdW5kZWZpbmVkKTtcclxuY29uc3QgVGV4dCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyAnVGV4dCcgOiB1bmRlZmluZWQpO1xyXG5jb25zdCBDb21tZW50ID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/ICdDb21tZW50JyA6IHVuZGVmaW5lZCk7XHJcbmNvbnN0IFN0YXRpYyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyAnU3RhdGljJyA6IHVuZGVmaW5lZCk7XHJcbi8vIFNpbmNlIHYtaWYgYW5kIHYtZm9yIGFyZSB0aGUgdHdvIHBvc3NpYmxlIHdheXMgbm9kZSBzdHJ1Y3R1cmUgY2FuIGR5bmFtaWNhbGx5XHJcbi8vIGNoYW5nZSwgb25jZSB3ZSBjb25zaWRlciB2LWlmIGJyYW5jaGVzIGFuZCBlYWNoIHYtZm9yIGZyYWdtZW50IGEgYmxvY2ssIHdlXHJcbi8vIGNhbiBkaXZpZGUgYSB0ZW1wbGF0ZSBpbnRvIG5lc3RlZCBibG9ja3MsIGFuZCB3aXRoaW4gZWFjaCBibG9jayB0aGUgbm9kZVxyXG4vLyBzdHJ1Y3R1cmUgd291bGQgYmUgc3RhYmxlLiBUaGlzIGFsbG93cyB1cyB0byBza2lwIG1vc3QgY2hpbGRyZW4gZGlmZmluZ1xyXG4vLyBhbmQgb25seSB3b3JyeSBhYm91dCB0aGUgZHluYW1pYyBub2RlcyAoaW5kaWNhdGVkIGJ5IHBhdGNoIGZsYWdzKS5cclxuY29uc3QgYmxvY2tTdGFjayA9IFtdO1xyXG5sZXQgY3VycmVudEJsb2NrID0gbnVsbDtcclxuLyoqXHJcbiAqIE9wZW4gYSBibG9jay5cclxuICogVGhpcyBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgYGNyZWF0ZUJsb2NrYC4gSXQgY2Fubm90IGJlIHBhcnQgb2YgYGNyZWF0ZUJsb2NrYFxyXG4gKiBiZWNhdXNlIHRoZSBjaGlsZHJlbiBvZiB0aGUgYmxvY2sgYXJlIGV2YWx1YXRlZCBiZWZvcmUgYGNyZWF0ZUJsb2NrYCBpdHNlbGZcclxuICogaXMgY2FsbGVkLiBUaGUgZ2VuZXJhdGVkIGNvZGUgdHlwaWNhbGx5IGxvb2tzIGxpa2UgdGhpczpcclxuICpcclxuICogYGBganNcclxuICogZnVuY3Rpb24gcmVuZGVyKCkge1xyXG4gKiAgIHJldHVybiAob3BlbkJsb2NrKCksY3JlYXRlQmxvY2soJ2RpdicsIG51bGwsIFsuLi5dKSlcclxuICogfVxyXG4gKiBgYGBcclxuICogZGlzYWJsZVRyYWNraW5nIGlzIHRydWUgd2hlbiBjcmVhdGluZyBhIHYtZm9yIGZyYWdtZW50IGJsb2NrLCBzaW5jZSBhIHYtZm9yXHJcbiAqIGZyYWdtZW50IGFsd2F5cyBkaWZmcyBpdHMgY2hpbGRyZW4uXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBvcGVuQmxvY2soZGlzYWJsZVRyYWNraW5nID0gZmFsc2UpIHtcclxuICAgIGJsb2NrU3RhY2sucHVzaCgoY3VycmVudEJsb2NrID0gZGlzYWJsZVRyYWNraW5nID8gbnVsbCA6IFtdKSk7XHJcbn1cclxuZnVuY3Rpb24gY2xvc2VCbG9jaygpIHtcclxuICAgIGJsb2NrU3RhY2sucG9wKCk7XHJcbiAgICBjdXJyZW50QmxvY2sgPSBibG9ja1N0YWNrW2Jsb2NrU3RhY2subGVuZ3RoIC0gMV0gfHwgbnVsbDtcclxufVxyXG4vLyBXaGV0aGVyIHdlIHNob3VsZCBiZSB0cmFja2luZyBkeW5hbWljIGNoaWxkIG5vZGVzIGluc2lkZSBhIGJsb2NrLlxyXG4vLyBPbmx5IHRyYWNrcyB3aGVuIHRoaXMgdmFsdWUgaXMgPiAwXHJcbi8vIFdlIGFyZSBub3QgdXNpbmcgYSBzaW1wbGUgYm9vbGVhbiBiZWNhdXNlIHRoaXMgdmFsdWUgbWF5IG5lZWQgdG8gYmVcclxuLy8gaW5jcmVtZW50ZWQvZGVjcmVtZW50ZWQgYnkgbmVzdGVkIHVzYWdlIG9mIHYtb25jZSAoc2VlIGJlbG93KVxyXG5sZXQgaXNCbG9ja1RyZWVFbmFibGVkID0gMTtcclxuLyoqXHJcbiAqIEJsb2NrIHRyYWNraW5nIHNvbWV0aW1lcyBuZWVkcyB0byBiZSBkaXNhYmxlZCwgZm9yIGV4YW1wbGUgZHVyaW5nIHRoZVxyXG4gKiBjcmVhdGlvbiBvZiBhIHRyZWUgdGhhdCBuZWVkcyB0byBiZSBjYWNoZWQgYnkgdi1vbmNlLiBUaGUgY29tcGlsZXIgZ2VuZXJhdGVzXHJcbiAqIGNvZGUgbGlrZSB0aGlzOlxyXG4gKlxyXG4gKiBgYGAganNcclxuICogX2NhY2hlWzFdIHx8IChcclxuICogICBzZXRCbG9ja1RyYWNraW5nKC0xKSxcclxuICogICBfY2FjaGVbMV0gPSBjcmVhdGVWTm9kZSguLi4pLFxyXG4gKiAgIHNldEJsb2NrVHJhY2tpbmcoMSksXHJcbiAqICAgX2NhY2hlWzFdXHJcbiAqIClcclxuICogYGBgXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRCbG9ja1RyYWNraW5nKHZhbHVlKSB7XHJcbiAgICBpc0Jsb2NrVHJlZUVuYWJsZWQgKz0gdmFsdWU7XHJcbn1cclxuZnVuY3Rpb24gc2V0dXBCbG9jayh2bm9kZSkge1xyXG4gICAgLy8gc2F2ZSBjdXJyZW50IGJsb2NrIGNoaWxkcmVuIG9uIHRoZSBibG9jayB2bm9kZVxyXG4gICAgdm5vZGUuZHluYW1pY0NoaWxkcmVuID1cclxuICAgICAgICBpc0Jsb2NrVHJlZUVuYWJsZWQgPiAwID8gY3VycmVudEJsb2NrIHx8IEVNUFRZX0FSUiA6IG51bGw7XHJcbiAgICAvLyBjbG9zZSBibG9ja1xyXG4gICAgY2xvc2VCbG9jaygpO1xyXG4gICAgLy8gYSBibG9jayBpcyBhbHdheXMgZ29pbmcgdG8gYmUgcGF0Y2hlZCwgc28gdHJhY2sgaXQgYXMgYSBjaGlsZCBvZiBpdHNcclxuICAgIC8vIHBhcmVudCBibG9ja1xyXG4gICAgaWYgKGlzQmxvY2tUcmVlRW5hYmxlZCA+IDAgJiYgY3VycmVudEJsb2NrKSB7XHJcbiAgICAgICAgY3VycmVudEJsb2NrLnB1c2godm5vZGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZub2RlO1xyXG59XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudEJsb2NrKHR5cGUsIHByb3BzLCBjaGlsZHJlbiwgcGF0Y2hGbGFnLCBkeW5hbWljUHJvcHMsIHNoYXBlRmxhZykge1xyXG4gICAgcmV0dXJuIHNldHVwQmxvY2soY3JlYXRlQmFzZVZOb2RlKHR5cGUsIHByb3BzLCBjaGlsZHJlbiwgcGF0Y2hGbGFnLCBkeW5hbWljUHJvcHMsIHNoYXBlRmxhZywgdHJ1ZSAvKiBpc0Jsb2NrICovKSk7XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZSBhIGJsb2NrIHJvb3Qgdm5vZGUuIFRha2VzIHRoZSBzYW1lIGV4YWN0IGFyZ3VtZW50cyBhcyBgY3JlYXRlVk5vZGVgLlxyXG4gKiBBIGJsb2NrIHJvb3Qga2VlcHMgdHJhY2sgb2YgZHluYW1pYyBub2RlcyB3aXRoaW4gdGhlIGJsb2NrIGluIHRoZVxyXG4gKiBgZHluYW1pY0NoaWxkcmVuYCBhcnJheS5cclxuICpcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZUJsb2NrKHR5cGUsIHByb3BzLCBjaGlsZHJlbiwgcGF0Y2hGbGFnLCBkeW5hbWljUHJvcHMpIHtcclxuICAgIHJldHVybiBzZXR1cEJsb2NrKGNyZWF0ZVZOb2RlKHR5cGUsIHByb3BzLCBjaGlsZHJlbiwgcGF0Y2hGbGFnLCBkeW5hbWljUHJvcHMsIHRydWUgLyogaXNCbG9jazogcHJldmVudCBhIGJsb2NrIGZyb20gdHJhY2tpbmcgaXRzZWxmICovKSk7XHJcbn1cclxuZnVuY3Rpb24gaXNWTm9kZSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHZhbHVlID8gdmFsdWUuX192X2lzVk5vZGUgPT09IHRydWUgOiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBpc1NhbWVWTm9kZVR5cGUobjEsIG4yKSB7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgbjIuc2hhcGVGbGFnICYgNiAvKiBDT01QT05FTlQgKi8gJiZcclxuICAgICAgICBobXJEaXJ0eUNvbXBvbmVudHMuaGFzKG4yLnR5cGUpKSB7XHJcbiAgICAgICAgLy8gSE1SIG9ubHk6IGlmIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gaG90LXVwZGF0ZWQsIGZvcmNlIGEgcmVsb2FkLlxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiBuMS50eXBlID09PSBuMi50eXBlICYmIG4xLmtleSA9PT0gbjIua2V5O1xyXG59XHJcbmxldCB2bm9kZUFyZ3NUcmFuc2Zvcm1lcjtcclxuLyoqXHJcbiAqIEludGVybmFsIEFQSSBmb3IgcmVnaXN0ZXJpbmcgYW4gYXJndW1lbnRzIHRyYW5zZm9ybSBmb3IgY3JlYXRlVk5vZGVcclxuICogdXNlZCBmb3IgY3JlYXRpbmcgc3R1YnMgaW4gdGhlIHRlc3QtdXRpbHNcclxuICogSXQgaXMgKmludGVybmFsKiBidXQgbmVlZHMgdG8gYmUgZXhwb3NlZCBmb3IgdGVzdC11dGlscyB0byBwaWNrIHVwIHByb3BlclxyXG4gKiB0eXBpbmdzXHJcbiAqL1xyXG5mdW5jdGlvbiB0cmFuc2Zvcm1WTm9kZUFyZ3ModHJhbnNmb3JtZXIpIHtcclxuICAgIHZub2RlQXJnc1RyYW5zZm9ybWVyID0gdHJhbnNmb3JtZXI7XHJcbn1cclxuY29uc3QgY3JlYXRlVk5vZGVXaXRoQXJnc1RyYW5zZm9ybSA9ICguLi5hcmdzKSA9PiB7XHJcbiAgICByZXR1cm4gX2NyZWF0ZVZOb2RlKC4uLih2bm9kZUFyZ3NUcmFuc2Zvcm1lclxyXG4gICAgICAgID8gdm5vZGVBcmdzVHJhbnNmb3JtZXIoYXJncywgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlKVxyXG4gICAgICAgIDogYXJncykpO1xyXG59O1xyXG5jb25zdCBJbnRlcm5hbE9iamVjdEtleSA9IGBfX3ZJbnRlcm5hbGA7XHJcbmNvbnN0IG5vcm1hbGl6ZUtleSA9ICh7IGtleSB9KSA9PiBrZXkgIT0gbnVsbCA/IGtleSA6IG51bGw7XHJcbmNvbnN0IG5vcm1hbGl6ZVJlZiA9ICh7IHJlZiwgcmVmX2tleSwgcmVmX2ZvciB9KSA9PiB7XHJcbiAgICByZXR1cm4gKHJlZiAhPSBudWxsXHJcbiAgICAgICAgPyBpc1N0cmluZyhyZWYpIHx8IGlzUmVmKHJlZikgfHwgaXNGdW5jdGlvbihyZWYpXHJcbiAgICAgICAgICAgID8geyBpOiBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UsIHI6IHJlZiwgazogcmVmX2tleSwgZjogISFyZWZfZm9yIH1cclxuICAgICAgICAgICAgOiByZWZcclxuICAgICAgICA6IG51bGwpO1xyXG59O1xyXG5mdW5jdGlvbiBjcmVhdGVCYXNlVk5vZGUodHlwZSwgcHJvcHMgPSBudWxsLCBjaGlsZHJlbiA9IG51bGwsIHBhdGNoRmxhZyA9IDAsIGR5bmFtaWNQcm9wcyA9IG51bGwsIHNoYXBlRmxhZyA9IHR5cGUgPT09IEZyYWdtZW50ID8gMCA6IDEgLyogRUxFTUVOVCAqLywgaXNCbG9ja05vZGUgPSBmYWxzZSwgbmVlZEZ1bGxDaGlsZHJlbk5vcm1hbGl6YXRpb24gPSBmYWxzZSkge1xyXG4gICAgY29uc3Qgdm5vZGUgPSB7XHJcbiAgICAgICAgX192X2lzVk5vZGU6IHRydWUsXHJcbiAgICAgICAgX192X3NraXA6IHRydWUsXHJcbiAgICAgICAgdHlwZSxcclxuICAgICAgICBwcm9wcyxcclxuICAgICAgICBrZXk6IHByb3BzICYmIG5vcm1hbGl6ZUtleShwcm9wcyksXHJcbiAgICAgICAgcmVmOiBwcm9wcyAmJiBub3JtYWxpemVSZWYocHJvcHMpLFxyXG4gICAgICAgIHNjb3BlSWQ6IGN1cnJlbnRTY29wZUlkLFxyXG4gICAgICAgIHNsb3RTY29wZUlkczogbnVsbCxcclxuICAgICAgICBjaGlsZHJlbixcclxuICAgICAgICBjb21wb25lbnQ6IG51bGwsXHJcbiAgICAgICAgc3VzcGVuc2U6IG51bGwsXHJcbiAgICAgICAgc3NDb250ZW50OiBudWxsLFxyXG4gICAgICAgIHNzRmFsbGJhY2s6IG51bGwsXHJcbiAgICAgICAgZGlyczogbnVsbCxcclxuICAgICAgICB0cmFuc2l0aW9uOiBudWxsLFxyXG4gICAgICAgIGVsOiBudWxsLFxyXG4gICAgICAgIGFuY2hvcjogbnVsbCxcclxuICAgICAgICB0YXJnZXQ6IG51bGwsXHJcbiAgICAgICAgdGFyZ2V0QW5jaG9yOiBudWxsLFxyXG4gICAgICAgIHN0YXRpY0NvdW50OiAwLFxyXG4gICAgICAgIHNoYXBlRmxhZyxcclxuICAgICAgICBwYXRjaEZsYWcsXHJcbiAgICAgICAgZHluYW1pY1Byb3BzLFxyXG4gICAgICAgIGR5bmFtaWNDaGlsZHJlbjogbnVsbCxcclxuICAgICAgICBhcHBDb250ZXh0OiBudWxsXHJcbiAgICB9O1xyXG4gICAgaWYgKG5lZWRGdWxsQ2hpbGRyZW5Ob3JtYWxpemF0aW9uKSB7XHJcbiAgICAgICAgbm9ybWFsaXplQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuKTtcclxuICAgICAgICAvLyBub3JtYWxpemUgc3VzcGVuc2UgY2hpbGRyZW5cclxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgMTI4IC8qIFNVU1BFTlNFICovKSB7XHJcbiAgICAgICAgICAgIHR5cGUubm9ybWFsaXplKHZub2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChjaGlsZHJlbikge1xyXG4gICAgICAgIC8vIGNvbXBpbGVkIGVsZW1lbnQgdm5vZGUgLSBpZiBjaGlsZHJlbiBpcyBwYXNzZWQsIG9ubHkgcG9zc2libGUgdHlwZXMgYXJlXHJcbiAgICAgICAgLy8gc3RyaW5nIG9yIEFycmF5LlxyXG4gICAgICAgIHZub2RlLnNoYXBlRmxhZyB8PSBpc1N0cmluZyhjaGlsZHJlbilcclxuICAgICAgICAgICAgPyA4IC8qIFRFWFRfQ0hJTERSRU4gKi9cclxuICAgICAgICAgICAgOiAxNiAvKiBBUlJBWV9DSElMRFJFTiAqLztcclxuICAgIH1cclxuICAgIC8vIHZhbGlkYXRlIGtleVxyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB2bm9kZS5rZXkgIT09IHZub2RlLmtleSkge1xyXG4gICAgICAgIHdhcm4oYFZOb2RlIGNyZWF0ZWQgd2l0aCBpbnZhbGlkIGtleSAoTmFOKS4gVk5vZGUgdHlwZTpgLCB2bm9kZS50eXBlKTtcclxuICAgIH1cclxuICAgIC8vIHRyYWNrIHZub2RlIGZvciBibG9jayB0cmVlXHJcbiAgICBpZiAoaXNCbG9ja1RyZWVFbmFibGVkID4gMCAmJlxyXG4gICAgICAgIC8vIGF2b2lkIGEgYmxvY2sgbm9kZSBmcm9tIHRyYWNraW5nIGl0c2VsZlxyXG4gICAgICAgICFpc0Jsb2NrTm9kZSAmJlxyXG4gICAgICAgIC8vIGhhcyBjdXJyZW50IHBhcmVudCBibG9ja1xyXG4gICAgICAgIGN1cnJlbnRCbG9jayAmJlxyXG4gICAgICAgIC8vIHByZXNlbmNlIG9mIGEgcGF0Y2ggZmxhZyBpbmRpY2F0ZXMgdGhpcyBub2RlIG5lZWRzIHBhdGNoaW5nIG9uIHVwZGF0ZXMuXHJcbiAgICAgICAgLy8gY29tcG9uZW50IG5vZGVzIGFsc28gc2hvdWxkIGFsd2F5cyBiZSBwYXRjaGVkLCBiZWNhdXNlIGV2ZW4gaWYgdGhlXHJcbiAgICAgICAgLy8gY29tcG9uZW50IGRvZXNuJ3QgbmVlZCB0byB1cGRhdGUsIGl0IG5lZWRzIHRvIHBlcnNpc3QgdGhlIGluc3RhbmNlIG9uIHRvXHJcbiAgICAgICAgLy8gdGhlIG5leHQgdm5vZGUgc28gdGhhdCBpdCBjYW4gYmUgcHJvcGVybHkgdW5tb3VudGVkIGxhdGVyLlxyXG4gICAgICAgICh2bm9kZS5wYXRjaEZsYWcgPiAwIHx8IHNoYXBlRmxhZyAmIDYgLyogQ09NUE9ORU5UICovKSAmJlxyXG4gICAgICAgIC8vIHRoZSBFVkVOVFMgZmxhZyBpcyBvbmx5IGZvciBoeWRyYXRpb24gYW5kIGlmIGl0IGlzIHRoZSBvbmx5IGZsYWcsIHRoZVxyXG4gICAgICAgIC8vIHZub2RlIHNob3VsZCBub3QgYmUgY29uc2lkZXJlZCBkeW5hbWljIGR1ZSB0byBoYW5kbGVyIGNhY2hpbmcuXHJcbiAgICAgICAgdm5vZGUucGF0Y2hGbGFnICE9PSAzMiAvKiBIWURSQVRFX0VWRU5UUyAqLykge1xyXG4gICAgICAgIGN1cnJlbnRCbG9jay5wdXNoKHZub2RlKTtcclxuICAgIH1cclxuICAgIHJldHVybiB2bm9kZTtcclxufVxyXG5jb25zdCBjcmVhdGVWTm9kZSA9ICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBjcmVhdGVWTm9kZVdpdGhBcmdzVHJhbnNmb3JtIDogX2NyZWF0ZVZOb2RlKTtcclxuZnVuY3Rpb24gX2NyZWF0ZVZOb2RlKHR5cGUsIHByb3BzID0gbnVsbCwgY2hpbGRyZW4gPSBudWxsLCBwYXRjaEZsYWcgPSAwLCBkeW5hbWljUHJvcHMgPSBudWxsLCBpc0Jsb2NrTm9kZSA9IGZhbHNlKSB7XHJcbiAgICBpZiAoIXR5cGUgfHwgdHlwZSA9PT0gTlVMTF9EWU5BTUlDX0NPTVBPTkVOVCkge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIXR5cGUpIHtcclxuICAgICAgICAgICAgd2FybihgSW52YWxpZCB2bm9kZSB0eXBlIHdoZW4gY3JlYXRpbmcgdm5vZGU6ICR7dHlwZX0uYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHR5cGUgPSBDb21tZW50O1xyXG4gICAgfVxyXG4gICAgaWYgKGlzVk5vZGUodHlwZSkpIHtcclxuICAgICAgICAvLyBjcmVhdGVWTm9kZSByZWNlaXZpbmcgYW4gZXhpc3Rpbmcgdm5vZGUuIFRoaXMgaGFwcGVucyBpbiBjYXNlcyBsaWtlXHJcbiAgICAgICAgLy8gPGNvbXBvbmVudCA6aXM9XCJ2bm9kZVwiLz5cclxuICAgICAgICAvLyAjMjA3OCBtYWtlIHN1cmUgdG8gbWVyZ2UgcmVmcyBkdXJpbmcgdGhlIGNsb25lIGluc3RlYWQgb2Ygb3ZlcndyaXRpbmcgaXRcclxuICAgICAgICBjb25zdCBjbG9uZWQgPSBjbG9uZVZOb2RlKHR5cGUsIHByb3BzLCB0cnVlIC8qIG1lcmdlUmVmOiB0cnVlICovKTtcclxuICAgICAgICBpZiAoY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgbm9ybWFsaXplQ2hpbGRyZW4oY2xvbmVkLCBjaGlsZHJlbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0Jsb2NrVHJlZUVuYWJsZWQgPiAwICYmICFpc0Jsb2NrTm9kZSAmJiBjdXJyZW50QmxvY2spIHtcclxuICAgICAgICAgICAgaWYgKGNsb25lZC5zaGFwZUZsYWcgJiA2IC8qIENPTVBPTkVOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudEJsb2NrW2N1cnJlbnRCbG9jay5pbmRleE9mKHR5cGUpXSA9IGNsb25lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRCbG9jay5wdXNoKGNsb25lZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2xvbmVkLnBhdGNoRmxhZyB8PSAtMiAvKiBCQUlMICovO1xyXG4gICAgICAgIHJldHVybiBjbG9uZWQ7XHJcbiAgICB9XHJcbiAgICAvLyBjbGFzcyBjb21wb25lbnQgbm9ybWFsaXphdGlvbi5cclxuICAgIGlmIChpc0NsYXNzQ29tcG9uZW50KHR5cGUpKSB7XHJcbiAgICAgICAgdHlwZSA9IHR5cGUuX192Y2NPcHRzO1xyXG4gICAgfVxyXG4gICAgLy8gY2xhc3MgJiBzdHlsZSBub3JtYWxpemF0aW9uLlxyXG4gICAgaWYgKHByb3BzKSB7XHJcbiAgICAgICAgLy8gZm9yIHJlYWN0aXZlIG9yIHByb3h5IG9iamVjdHMsIHdlIG5lZWQgdG8gY2xvbmUgaXQgdG8gZW5hYmxlIG11dGF0aW9uLlxyXG4gICAgICAgIHByb3BzID0gZ3VhcmRSZWFjdGl2ZVByb3BzKHByb3BzKTtcclxuICAgICAgICBsZXQgeyBjbGFzczoga2xhc3MsIHN0eWxlIH0gPSBwcm9wcztcclxuICAgICAgICBpZiAoa2xhc3MgJiYgIWlzU3RyaW5nKGtsYXNzKSkge1xyXG4gICAgICAgICAgICBwcm9wcy5jbGFzcyA9IG5vcm1hbGl6ZUNsYXNzKGtsYXNzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzT2JqZWN0KHN0eWxlKSkge1xyXG4gICAgICAgICAgICAvLyByZWFjdGl2ZSBzdGF0ZSBvYmplY3RzIG5lZWQgdG8gYmUgY2xvbmVkIHNpbmNlIHRoZXkgYXJlIGxpa2VseSB0byBiZVxyXG4gICAgICAgICAgICAvLyBtdXRhdGVkXHJcbiAgICAgICAgICAgIGlmIChpc1Byb3h5KHN0eWxlKSAmJiAhaXNBcnJheShzdHlsZSkpIHtcclxuICAgICAgICAgICAgICAgIHN0eWxlID0gZXh0ZW5kKHt9LCBzdHlsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcHJvcHMuc3R5bGUgPSBub3JtYWxpemVTdHlsZShzdHlsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gZW5jb2RlIHRoZSB2bm9kZSB0eXBlIGluZm9ybWF0aW9uIGludG8gYSBiaXRtYXBcclxuICAgIGNvbnN0IHNoYXBlRmxhZyA9IGlzU3RyaW5nKHR5cGUpXHJcbiAgICAgICAgPyAxIC8qIEVMRU1FTlQgKi9cclxuICAgICAgICA6IGlzU3VzcGVuc2UodHlwZSlcclxuICAgICAgICAgICAgPyAxMjggLyogU1VTUEVOU0UgKi9cclxuICAgICAgICAgICAgOiBpc1RlbGVwb3J0KHR5cGUpXHJcbiAgICAgICAgICAgICAgICA/IDY0IC8qIFRFTEVQT1JUICovXHJcbiAgICAgICAgICAgICAgICA6IGlzT2JqZWN0KHR5cGUpXHJcbiAgICAgICAgICAgICAgICAgICAgPyA0IC8qIFNUQVRFRlVMX0NPTVBPTkVOVCAqL1xyXG4gICAgICAgICAgICAgICAgICAgIDogaXNGdW5jdGlvbih0eXBlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IDIgLyogRlVOQ1RJT05BTF9DT01QT05FTlQgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgOiAwO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBzaGFwZUZsYWcgJiA0IC8qIFNUQVRFRlVMX0NPTVBPTkVOVCAqLyAmJiBpc1Byb3h5KHR5cGUpKSB7XHJcbiAgICAgICAgdHlwZSA9IHRvUmF3KHR5cGUpO1xyXG4gICAgICAgIHdhcm4oYFZ1ZSByZWNlaXZlZCBhIENvbXBvbmVudCB3aGljaCB3YXMgbWFkZSBhIHJlYWN0aXZlIG9iamVjdC4gVGhpcyBjYW4gYCArXHJcbiAgICAgICAgICAgIGBsZWFkIHRvIHVubmVjZXNzYXJ5IHBlcmZvcm1hbmNlIG92ZXJoZWFkLCBhbmQgc2hvdWxkIGJlIGF2b2lkZWQgYnkgYCArXHJcbiAgICAgICAgICAgIGBtYXJraW5nIHRoZSBjb21wb25lbnQgd2l0aCBcXGBtYXJrUmF3XFxgIG9yIHVzaW5nIFxcYHNoYWxsb3dSZWZcXGAgYCArXHJcbiAgICAgICAgICAgIGBpbnN0ZWFkIG9mIFxcYHJlZlxcYC5gLCBgXFxuQ29tcG9uZW50IHRoYXQgd2FzIG1hZGUgcmVhY3RpdmU6IGAsIHR5cGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNyZWF0ZUJhc2VWTm9kZSh0eXBlLCBwcm9wcywgY2hpbGRyZW4sIHBhdGNoRmxhZywgZHluYW1pY1Byb3BzLCBzaGFwZUZsYWcsIGlzQmxvY2tOb2RlLCB0cnVlKTtcclxufVxyXG5mdW5jdGlvbiBndWFyZFJlYWN0aXZlUHJvcHMocHJvcHMpIHtcclxuICAgIGlmICghcHJvcHMpXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICByZXR1cm4gaXNQcm94eShwcm9wcykgfHwgSW50ZXJuYWxPYmplY3RLZXkgaW4gcHJvcHNcclxuICAgICAgICA/IGV4dGVuZCh7fSwgcHJvcHMpXHJcbiAgICAgICAgOiBwcm9wcztcclxufVxyXG5mdW5jdGlvbiBjbG9uZVZOb2RlKHZub2RlLCBleHRyYVByb3BzLCBtZXJnZVJlZiA9IGZhbHNlKSB7XHJcbiAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgTk9UIHVzaW5nIHNwcmVhZCBvciBleHRlbmQgdG8gYXZvaWQgdGhlIHJ1bnRpbWVcclxuICAgIC8vIGtleSBlbnVtZXJhdGlvbiBjb3N0LlxyXG4gICAgY29uc3QgeyBwcm9wcywgcmVmLCBwYXRjaEZsYWcsIGNoaWxkcmVuIH0gPSB2bm9kZTtcclxuICAgIGNvbnN0IG1lcmdlZFByb3BzID0gZXh0cmFQcm9wcyA/IG1lcmdlUHJvcHMocHJvcHMgfHwge30sIGV4dHJhUHJvcHMpIDogcHJvcHM7XHJcbiAgICBjb25zdCBjbG9uZWQgPSB7XHJcbiAgICAgICAgX192X2lzVk5vZGU6IHRydWUsXHJcbiAgICAgICAgX192X3NraXA6IHRydWUsXHJcbiAgICAgICAgdHlwZTogdm5vZGUudHlwZSxcclxuICAgICAgICBwcm9wczogbWVyZ2VkUHJvcHMsXHJcbiAgICAgICAga2V5OiBtZXJnZWRQcm9wcyAmJiBub3JtYWxpemVLZXkobWVyZ2VkUHJvcHMpLFxyXG4gICAgICAgIHJlZjogZXh0cmFQcm9wcyAmJiBleHRyYVByb3BzLnJlZlxyXG4gICAgICAgICAgICA/IC8vICMyMDc4IGluIHRoZSBjYXNlIG9mIDxjb21wb25lbnQgOmlzPVwidm5vZGVcIiByZWY9XCJleHRyYVwiLz5cclxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSB2bm9kZSBpdHNlbGYgYWxyZWFkeSBoYXMgYSByZWYsIGNsb25lVk5vZGUgd2lsbCBuZWVkIHRvIG1lcmdlXHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgcmVmcyBzbyB0aGUgc2luZ2xlIHZub2RlIGNhbiBiZSBzZXQgb24gbXVsdGlwbGUgcmVmc1xyXG4gICAgICAgICAgICAgICAgbWVyZ2VSZWYgJiYgcmVmXHJcbiAgICAgICAgICAgICAgICAgICAgPyBpc0FycmF5KHJlZilcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyByZWYuY29uY2F0KG5vcm1hbGl6ZVJlZihleHRyYVByb3BzKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBbcmVmLCBub3JtYWxpemVSZWYoZXh0cmFQcm9wcyldXHJcbiAgICAgICAgICAgICAgICAgICAgOiBub3JtYWxpemVSZWYoZXh0cmFQcm9wcylcclxuICAgICAgICAgICAgOiByZWYsXHJcbiAgICAgICAgc2NvcGVJZDogdm5vZGUuc2NvcGVJZCxcclxuICAgICAgICBzbG90U2NvcGVJZHM6IHZub2RlLnNsb3RTY29wZUlkcyxcclxuICAgICAgICBjaGlsZHJlbjogKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHBhdGNoRmxhZyA9PT0gLTEgLyogSE9JU1RFRCAqLyAmJiBpc0FycmF5KGNoaWxkcmVuKVxyXG4gICAgICAgICAgICA/IGNoaWxkcmVuLm1hcChkZWVwQ2xvbmVWTm9kZSlcclxuICAgICAgICAgICAgOiBjaGlsZHJlbixcclxuICAgICAgICB0YXJnZXQ6IHZub2RlLnRhcmdldCxcclxuICAgICAgICB0YXJnZXRBbmNob3I6IHZub2RlLnRhcmdldEFuY2hvcixcclxuICAgICAgICBzdGF0aWNDb3VudDogdm5vZGUuc3RhdGljQ291bnQsXHJcbiAgICAgICAgc2hhcGVGbGFnOiB2bm9kZS5zaGFwZUZsYWcsXHJcbiAgICAgICAgLy8gaWYgdGhlIHZub2RlIGlzIGNsb25lZCB3aXRoIGV4dHJhIHByb3BzLCB3ZSBjYW4gbm8gbG9uZ2VyIGFzc3VtZSBpdHNcclxuICAgICAgICAvLyBleGlzdGluZyBwYXRjaCBmbGFnIHRvIGJlIHJlbGlhYmxlIGFuZCBuZWVkIHRvIGFkZCB0aGUgRlVMTF9QUk9QUyBmbGFnLlxyXG4gICAgICAgIC8vIG5vdGU6IHByZXNlcnZlIGZsYWcgZm9yIGZyYWdtZW50cyBzaW5jZSB0aGV5IHVzZSB0aGUgZmxhZyBmb3IgY2hpbGRyZW5cclxuICAgICAgICAvLyBmYXN0IHBhdGhzIG9ubHkuXHJcbiAgICAgICAgcGF0Y2hGbGFnOiBleHRyYVByb3BzICYmIHZub2RlLnR5cGUgIT09IEZyYWdtZW50XHJcbiAgICAgICAgICAgID8gcGF0Y2hGbGFnID09PSAtMSAvLyBob2lzdGVkIG5vZGVcclxuICAgICAgICAgICAgICAgID8gMTYgLyogRlVMTF9QUk9QUyAqL1xyXG4gICAgICAgICAgICAgICAgOiBwYXRjaEZsYWcgfCAxNiAvKiBGVUxMX1BST1BTICovXHJcbiAgICAgICAgICAgIDogcGF0Y2hGbGFnLFxyXG4gICAgICAgIGR5bmFtaWNQcm9wczogdm5vZGUuZHluYW1pY1Byb3BzLFxyXG4gICAgICAgIGR5bmFtaWNDaGlsZHJlbjogdm5vZGUuZHluYW1pY0NoaWxkcmVuLFxyXG4gICAgICAgIGFwcENvbnRleHQ6IHZub2RlLmFwcENvbnRleHQsXHJcbiAgICAgICAgZGlyczogdm5vZGUuZGlycyxcclxuICAgICAgICB0cmFuc2l0aW9uOiB2bm9kZS50cmFuc2l0aW9uLFxyXG4gICAgICAgIC8vIFRoZXNlIHNob3VsZCB0ZWNobmljYWxseSBvbmx5IGJlIG5vbi1udWxsIG9uIG1vdW50ZWQgVk5vZGVzLiBIb3dldmVyLFxyXG4gICAgICAgIC8vIHRoZXkgKnNob3VsZCogYmUgY29waWVkIGZvciBrZXB0LWFsaXZlIHZub2Rlcy4gU28gd2UganVzdCBhbHdheXMgY29weVxyXG4gICAgICAgIC8vIHRoZW0gc2luY2UgdGhlbSBiZWluZyBub24tbnVsbCBkdXJpbmcgYSBtb3VudCBkb2Vzbid0IGFmZmVjdCB0aGUgbG9naWMgYXNcclxuICAgICAgICAvLyB0aGV5IHdpbGwgc2ltcGx5IGJlIG92ZXJ3cml0dGVuLlxyXG4gICAgICAgIGNvbXBvbmVudDogdm5vZGUuY29tcG9uZW50LFxyXG4gICAgICAgIHN1c3BlbnNlOiB2bm9kZS5zdXNwZW5zZSxcclxuICAgICAgICBzc0NvbnRlbnQ6IHZub2RlLnNzQ29udGVudCAmJiBjbG9uZVZOb2RlKHZub2RlLnNzQ29udGVudCksXHJcbiAgICAgICAgc3NGYWxsYmFjazogdm5vZGUuc3NGYWxsYmFjayAmJiBjbG9uZVZOb2RlKHZub2RlLnNzRmFsbGJhY2spLFxyXG4gICAgICAgIGVsOiB2bm9kZS5lbCxcclxuICAgICAgICBhbmNob3I6IHZub2RlLmFuY2hvclxyXG4gICAgfTtcclxuICAgIHJldHVybiBjbG9uZWQ7XHJcbn1cclxuLyoqXHJcbiAqIERldiBvbmx5LCBmb3IgSE1SIG9mIGhvaXN0ZWQgdm5vZGVzIHJldXNlZCBpbiB2LWZvclxyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vdml0ZWpzL3ZpdGUvaXNzdWVzLzIwMjJcclxuICovXHJcbmZ1bmN0aW9uIGRlZXBDbG9uZVZOb2RlKHZub2RlKSB7XHJcbiAgICBjb25zdCBjbG9uZWQgPSBjbG9uZVZOb2RlKHZub2RlKTtcclxuICAgIGlmIChpc0FycmF5KHZub2RlLmNoaWxkcmVuKSkge1xyXG4gICAgICAgIGNsb25lZC5jaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuLm1hcChkZWVwQ2xvbmVWTm9kZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY2xvbmVkO1xyXG59XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlVGV4dFZOb2RlKHRleHQgPSAnICcsIGZsYWcgPSAwKSB7XHJcbiAgICByZXR1cm4gY3JlYXRlVk5vZGUoVGV4dCwgbnVsbCwgdGV4dCwgZmxhZyk7XHJcbn1cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVTdGF0aWNWTm9kZShjb250ZW50LCBudW1iZXJPZk5vZGVzKSB7XHJcbiAgICAvLyBBIHN0YXRpYyB2bm9kZSBjYW4gY29udGFpbiBtdWx0aXBsZSBzdHJpbmdpZmllZCBlbGVtZW50cywgYW5kIHRoZSBudW1iZXJcclxuICAgIC8vIG9mIGVsZW1lbnRzIGlzIG5lY2Vzc2FyeSBmb3IgaHlkcmF0aW9uLlxyXG4gICAgY29uc3Qgdm5vZGUgPSBjcmVhdGVWTm9kZShTdGF0aWMsIG51bGwsIGNvbnRlbnQpO1xyXG4gICAgdm5vZGUuc3RhdGljQ291bnQgPSBudW1iZXJPZk5vZGVzO1xyXG4gICAgcmV0dXJuIHZub2RlO1xyXG59XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlQ29tbWVudFZOb2RlKHRleHQgPSAnJywgXHJcbi8vIHdoZW4gdXNlZCBhcyB0aGUgdi1lbHNlIGJyYW5jaCwgdGhlIGNvbW1lbnQgbm9kZSBtdXN0IGJlIGNyZWF0ZWQgYXMgYVxyXG4vLyBibG9jayB0byBlbnN1cmUgY29ycmVjdCB1cGRhdGVzLlxyXG5hc0Jsb2NrID0gZmFsc2UpIHtcclxuICAgIHJldHVybiBhc0Jsb2NrXHJcbiAgICAgICAgPyAob3BlbkJsb2NrKCksIGNyZWF0ZUJsb2NrKENvbW1lbnQsIG51bGwsIHRleHQpKVxyXG4gICAgICAgIDogY3JlYXRlVk5vZGUoQ29tbWVudCwgbnVsbCwgdGV4dCk7XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplVk5vZGUoY2hpbGQpIHtcclxuICAgIGlmIChjaGlsZCA9PSBudWxsIHx8IHR5cGVvZiBjaGlsZCA9PT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgLy8gZW1wdHkgcGxhY2Vob2xkZXJcclxuICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUoQ29tbWVudCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0FycmF5KGNoaWxkKSkge1xyXG4gICAgICAgIC8vIGZyYWdtZW50XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKEZyYWdtZW50LCBudWxsLCBcclxuICAgICAgICAvLyAjMzY2NiwgYXZvaWQgcmVmZXJlbmNlIHBvbGx1dGlvbiB3aGVuIHJldXNpbmcgdm5vZGVcclxuICAgICAgICBjaGlsZC5zbGljZSgpKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAvLyBhbHJlYWR5IHZub2RlLCB0aGlzIHNob3VsZCBiZSB0aGUgbW9zdCBjb21tb24gc2luY2UgY29tcGlsZWQgdGVtcGxhdGVzXHJcbiAgICAgICAgLy8gYWx3YXlzIHByb2R1Y2UgYWxsLXZub2RlIGNoaWxkcmVuIGFycmF5c1xyXG4gICAgICAgIHJldHVybiBjbG9uZUlmTW91bnRlZChjaGlsZCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBzdHJpbmdzIGFuZCBudW1iZXJzXHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKFRleHQsIG51bGwsIFN0cmluZyhjaGlsZCkpO1xyXG4gICAgfVxyXG59XHJcbi8vIG9wdGltaXplZCBub3JtYWxpemF0aW9uIGZvciB0ZW1wbGF0ZS1jb21waWxlZCByZW5kZXIgZm5zXHJcbmZ1bmN0aW9uIGNsb25lSWZNb3VudGVkKGNoaWxkKSB7XHJcbiAgICByZXR1cm4gY2hpbGQuZWwgPT09IG51bGwgfHwgY2hpbGQubWVtbyA/IGNoaWxkIDogY2xvbmVWTm9kZShjaGlsZCk7XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuKSB7XHJcbiAgICBsZXQgdHlwZSA9IDA7XHJcbiAgICBjb25zdCB7IHNoYXBlRmxhZyB9ID0gdm5vZGU7XHJcbiAgICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xyXG4gICAgICAgIGNoaWxkcmVuID0gbnVsbDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzQXJyYXkoY2hpbGRyZW4pKSB7XHJcbiAgICAgICAgdHlwZSA9IDE2IC8qIEFSUkFZX0NISUxEUkVOICovO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIGNoaWxkcmVuID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiAoMSAvKiBFTEVNRU5UICovIHwgNjQgLyogVEVMRVBPUlQgKi8pKSB7XHJcbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSBzbG90IHRvIHBsYWluIGNoaWxkcmVuIGZvciBwbGFpbiBlbGVtZW50IGFuZCBUZWxlcG9ydFxyXG4gICAgICAgICAgICBjb25zdCBzbG90ID0gY2hpbGRyZW4uZGVmYXVsdDtcclxuICAgICAgICAgICAgaWYgKHNsb3QpIHtcclxuICAgICAgICAgICAgICAgIC8vIF9jIG1hcmtlciBpcyBhZGRlZCBieSB3aXRoQ3R4KCkgaW5kaWNhdGluZyB0aGlzIGlzIGEgY29tcGlsZWQgc2xvdFxyXG4gICAgICAgICAgICAgICAgc2xvdC5fYyAmJiAoc2xvdC5fZCA9IGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZUNoaWxkcmVuKHZub2RlLCBzbG90KCkpO1xyXG4gICAgICAgICAgICAgICAgc2xvdC5fYyAmJiAoc2xvdC5fZCA9IHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHR5cGUgPSAzMiAvKiBTTE9UU19DSElMRFJFTiAqLztcclxuICAgICAgICAgICAgY29uc3Qgc2xvdEZsYWcgPSBjaGlsZHJlbi5fO1xyXG4gICAgICAgICAgICBpZiAoIXNsb3RGbGFnICYmICEoSW50ZXJuYWxPYmplY3RLZXkgaW4gY2hpbGRyZW4pKSB7XHJcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5fY3R4ID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHNsb3RGbGFnID09PSAzIC8qIEZPUldBUkRFRCAqLyAmJiBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgIC8vIGEgY2hpbGQgY29tcG9uZW50IHJlY2VpdmVzIGZvcndhcmRlZCBzbG90cyBmcm9tIHRoZSBwYXJlbnQuXHJcbiAgICAgICAgICAgICAgICAvLyBpdHMgc2xvdCB0eXBlIGlzIGRldGVybWluZWQgYnkgaXRzIHBhcmVudCdzIHNsb3QgdHlwZS5cclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2Uuc2xvdHMuXyA9PT0gMSAvKiBTVEFCTEUgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5fID0gMSAvKiBTVEFCTEUgKi87XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5fID0gMiAvKiBEWU5BTUlDICovO1xyXG4gICAgICAgICAgICAgICAgICAgIHZub2RlLnBhdGNoRmxhZyB8PSAxMDI0IC8qIERZTkFNSUNfU0xPVFMgKi87XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKGNoaWxkcmVuKSkge1xyXG4gICAgICAgIGNoaWxkcmVuID0geyBkZWZhdWx0OiBjaGlsZHJlbiwgX2N0eDogY3VycmVudFJlbmRlcmluZ0luc3RhbmNlIH07XHJcbiAgICAgICAgdHlwZSA9IDMyIC8qIFNMT1RTX0NISUxEUkVOICovO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY2hpbGRyZW4gPSBTdHJpbmcoY2hpbGRyZW4pO1xyXG4gICAgICAgIC8vIGZvcmNlIHRlbGVwb3J0IGNoaWxkcmVuIHRvIGFycmF5IHNvIGl0IGNhbiBiZSBtb3ZlZCBhcm91bmRcclxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgNjQgLyogVEVMRVBPUlQgKi8pIHtcclxuICAgICAgICAgICAgdHlwZSA9IDE2IC8qIEFSUkFZX0NISUxEUkVOICovO1xyXG4gICAgICAgICAgICBjaGlsZHJlbiA9IFtjcmVhdGVUZXh0Vk5vZGUoY2hpbGRyZW4pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHR5cGUgPSA4IC8qIFRFWFRfQ0hJTERSRU4gKi87XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdm5vZGUuY2hpbGRyZW4gPSBjaGlsZHJlbjtcclxuICAgIHZub2RlLnNoYXBlRmxhZyB8PSB0eXBlO1xyXG59XHJcbmZ1bmN0aW9uIG1lcmdlUHJvcHMoLi4uYXJncykge1xyXG4gICAgY29uc3QgcmV0ID0ge307XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCB0b01lcmdlID0gYXJnc1tpXTtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB0b01lcmdlKSB7XHJcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdjbGFzcycpIHtcclxuICAgICAgICAgICAgICAgIGlmIChyZXQuY2xhc3MgIT09IHRvTWVyZ2UuY2xhc3MpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXQuY2xhc3MgPSBub3JtYWxpemVDbGFzcyhbcmV0LmNsYXNzLCB0b01lcmdlLmNsYXNzXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAnc3R5bGUnKSB7XHJcbiAgICAgICAgICAgICAgICByZXQuc3R5bGUgPSBub3JtYWxpemVTdHlsZShbcmV0LnN0eWxlLCB0b01lcmdlLnN0eWxlXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNPbihrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZyA9IHJldFtrZXldO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaW5jb21pbmcgPSB0b01lcmdlW2tleV07XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5jb21pbmcgJiZcclxuICAgICAgICAgICAgICAgICAgICBleGlzdGluZyAhPT0gaW5jb21pbmcgJiZcclxuICAgICAgICAgICAgICAgICAgICAhKGlzQXJyYXkoZXhpc3RpbmcpICYmIGV4aXN0aW5nLmluY2x1ZGVzKGluY29taW5nKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXRba2V5XSA9IGV4aXN0aW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gW10uY29uY2F0KGV4aXN0aW5nLCBpbmNvbWluZylcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBpbmNvbWluZztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICByZXRba2V5XSA9IHRvTWVyZ2Vba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXQ7XHJcbn1cclxuZnVuY3Rpb24gaW52b2tlVk5vZGVIb29rKGhvb2ssIGluc3RhbmNlLCB2bm9kZSwgcHJldlZOb2RlID0gbnVsbCkge1xyXG4gICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoaG9vaywgaW5zdGFuY2UsIDcgLyogVk5PREVfSE9PSyAqLywgW1xyXG4gICAgICAgIHZub2RlLFxyXG4gICAgICAgIHByZXZWTm9kZVxyXG4gICAgXSk7XHJcbn1cblxuY29uc3QgZW1wdHlBcHBDb250ZXh0ID0gY3JlYXRlQXBwQ29udGV4dCgpO1xyXG5sZXQgdWlkJDEgPSAwO1xyXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnRJbnN0YW5jZSh2bm9kZSwgcGFyZW50LCBzdXNwZW5zZSkge1xyXG4gICAgY29uc3QgdHlwZSA9IHZub2RlLnR5cGU7XHJcbiAgICAvLyBpbmhlcml0IHBhcmVudCBhcHAgY29udGV4dCAtIG9yIC0gaWYgcm9vdCwgYWRvcHQgZnJvbSByb290IHZub2RlXHJcbiAgICBjb25zdCBhcHBDb250ZXh0ID0gKHBhcmVudCA/IHBhcmVudC5hcHBDb250ZXh0IDogdm5vZGUuYXBwQ29udGV4dCkgfHwgZW1wdHlBcHBDb250ZXh0O1xyXG4gICAgY29uc3QgaW5zdGFuY2UgPSB7XHJcbiAgICAgICAgdWlkOiB1aWQkMSsrLFxyXG4gICAgICAgIHZub2RlLFxyXG4gICAgICAgIHR5cGUsXHJcbiAgICAgICAgcGFyZW50LFxyXG4gICAgICAgIGFwcENvbnRleHQsXHJcbiAgICAgICAgcm9vdDogbnVsbCxcclxuICAgICAgICBuZXh0OiBudWxsLFxyXG4gICAgICAgIHN1YlRyZWU6IG51bGwsXHJcbiAgICAgICAgZWZmZWN0OiBudWxsLFxyXG4gICAgICAgIHVwZGF0ZTogbnVsbCxcclxuICAgICAgICBzY29wZTogbmV3IEVmZmVjdFNjb3BlKHRydWUgLyogZGV0YWNoZWQgKi8pLFxyXG4gICAgICAgIHJlbmRlcjogbnVsbCxcclxuICAgICAgICBwcm94eTogbnVsbCxcclxuICAgICAgICBleHBvc2VkOiBudWxsLFxyXG4gICAgICAgIGV4cG9zZVByb3h5OiBudWxsLFxyXG4gICAgICAgIHdpdGhQcm94eTogbnVsbCxcclxuICAgICAgICBwcm92aWRlczogcGFyZW50ID8gcGFyZW50LnByb3ZpZGVzIDogT2JqZWN0LmNyZWF0ZShhcHBDb250ZXh0LnByb3ZpZGVzKSxcclxuICAgICAgICBhY2Nlc3NDYWNoZTogbnVsbCxcclxuICAgICAgICByZW5kZXJDYWNoZTogW10sXHJcbiAgICAgICAgLy8gbG9jYWwgcmVzb2x2ZWQgYXNzZXRzXHJcbiAgICAgICAgY29tcG9uZW50czogbnVsbCxcclxuICAgICAgICBkaXJlY3RpdmVzOiBudWxsLFxyXG4gICAgICAgIC8vIHJlc29sdmVkIHByb3BzIGFuZCBlbWl0cyBvcHRpb25zXHJcbiAgICAgICAgcHJvcHNPcHRpb25zOiBub3JtYWxpemVQcm9wc09wdGlvbnModHlwZSwgYXBwQ29udGV4dCksXHJcbiAgICAgICAgZW1pdHNPcHRpb25zOiBub3JtYWxpemVFbWl0c09wdGlvbnModHlwZSwgYXBwQ29udGV4dCksXHJcbiAgICAgICAgLy8gZW1pdFxyXG4gICAgICAgIGVtaXQ6IG51bGwsXHJcbiAgICAgICAgZW1pdHRlZDogbnVsbCxcclxuICAgICAgICAvLyBwcm9wcyBkZWZhdWx0IHZhbHVlXHJcbiAgICAgICAgcHJvcHNEZWZhdWx0czogRU1QVFlfT0JKLFxyXG4gICAgICAgIC8vIGluaGVyaXRBdHRyc1xyXG4gICAgICAgIGluaGVyaXRBdHRyczogdHlwZS5pbmhlcml0QXR0cnMsXHJcbiAgICAgICAgLy8gc3RhdGVcclxuICAgICAgICBjdHg6IEVNUFRZX09CSixcclxuICAgICAgICBkYXRhOiBFTVBUWV9PQkosXHJcbiAgICAgICAgcHJvcHM6IEVNUFRZX09CSixcclxuICAgICAgICBhdHRyczogRU1QVFlfT0JKLFxyXG4gICAgICAgIHNsb3RzOiBFTVBUWV9PQkosXHJcbiAgICAgICAgcmVmczogRU1QVFlfT0JKLFxyXG4gICAgICAgIHNldHVwU3RhdGU6IEVNUFRZX09CSixcclxuICAgICAgICBzZXR1cENvbnRleHQ6IG51bGwsXHJcbiAgICAgICAgLy8gc3VzcGVuc2UgcmVsYXRlZFxyXG4gICAgICAgIHN1c3BlbnNlLFxyXG4gICAgICAgIHN1c3BlbnNlSWQ6IHN1c3BlbnNlID8gc3VzcGVuc2UucGVuZGluZ0lkIDogMCxcclxuICAgICAgICBhc3luY0RlcDogbnVsbCxcclxuICAgICAgICBhc3luY1Jlc29sdmVkOiBmYWxzZSxcclxuICAgICAgICAvLyBsaWZlY3ljbGUgaG9va3NcclxuICAgICAgICAvLyBub3QgdXNpbmcgZW51bXMgaGVyZSBiZWNhdXNlIGl0IHJlc3VsdHMgaW4gY29tcHV0ZWQgcHJvcGVydGllc1xyXG4gICAgICAgIGlzTW91bnRlZDogZmFsc2UsXHJcbiAgICAgICAgaXNVbm1vdW50ZWQ6IGZhbHNlLFxyXG4gICAgICAgIGlzRGVhY3RpdmF0ZWQ6IGZhbHNlLFxyXG4gICAgICAgIGJjOiBudWxsLFxyXG4gICAgICAgIGM6IG51bGwsXHJcbiAgICAgICAgYm06IG51bGwsXHJcbiAgICAgICAgbTogbnVsbCxcclxuICAgICAgICBidTogbnVsbCxcclxuICAgICAgICB1OiBudWxsLFxyXG4gICAgICAgIHVtOiBudWxsLFxyXG4gICAgICAgIGJ1bTogbnVsbCxcclxuICAgICAgICBkYTogbnVsbCxcclxuICAgICAgICBhOiBudWxsLFxyXG4gICAgICAgIHJ0ZzogbnVsbCxcclxuICAgICAgICBydGM6IG51bGwsXHJcbiAgICAgICAgZWM6IG51bGwsXHJcbiAgICAgICAgc3A6IG51bGxcclxuICAgIH07XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgaW5zdGFuY2UuY3R4ID0gY3JlYXRlRGV2UmVuZGVyQ29udGV4dChpbnN0YW5jZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpbnN0YW5jZS5jdHggPSB7IF86IGluc3RhbmNlIH07XHJcbiAgICB9XHJcbiAgICBpbnN0YW5jZS5yb290ID0gcGFyZW50ID8gcGFyZW50LnJvb3QgOiBpbnN0YW5jZTtcclxuICAgIGluc3RhbmNlLmVtaXQgPSBlbWl0JDEuYmluZChudWxsLCBpbnN0YW5jZSk7XHJcbiAgICAvLyBhcHBseSBjdXN0b20gZWxlbWVudCBzcGVjaWFsIGhhbmRsaW5nXHJcbiAgICBpZiAodm5vZGUuY2UpIHtcclxuICAgICAgICB2bm9kZS5jZShpbnN0YW5jZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaW5zdGFuY2U7XHJcbn1cclxubGV0IGN1cnJlbnRJbnN0YW5jZSA9IG51bGw7XHJcbmNvbnN0IGdldEN1cnJlbnRJbnN0YW5jZSA9ICgpID0+IGN1cnJlbnRJbnN0YW5jZSB8fCBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2U7XHJcbmNvbnN0IHNldEN1cnJlbnRJbnN0YW5jZSA9IChpbnN0YW5jZSkgPT4ge1xyXG4gICAgY3VycmVudEluc3RhbmNlID0gaW5zdGFuY2U7XHJcbiAgICBpbnN0YW5jZS5zY29wZS5vbigpO1xyXG59O1xyXG5jb25zdCB1bnNldEN1cnJlbnRJbnN0YW5jZSA9ICgpID0+IHtcclxuICAgIGN1cnJlbnRJbnN0YW5jZSAmJiBjdXJyZW50SW5zdGFuY2Uuc2NvcGUub2ZmKCk7XHJcbiAgICBjdXJyZW50SW5zdGFuY2UgPSBudWxsO1xyXG59O1xyXG5jb25zdCBpc0J1aWx0SW5UYWcgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoJ3Nsb3QsY29tcG9uZW50Jyk7XHJcbmZ1bmN0aW9uIHZhbGlkYXRlQ29tcG9uZW50TmFtZShuYW1lLCBjb25maWcpIHtcclxuICAgIGNvbnN0IGFwcElzTmF0aXZlVGFnID0gY29uZmlnLmlzTmF0aXZlVGFnIHx8IE5PO1xyXG4gICAgaWYgKGlzQnVpbHRJblRhZyhuYW1lKSB8fCBhcHBJc05hdGl2ZVRhZyhuYW1lKSkge1xyXG4gICAgICAgIHdhcm4oJ0RvIG5vdCB1c2UgYnVpbHQtaW4gb3IgcmVzZXJ2ZWQgSFRNTCBlbGVtZW50cyBhcyBjb21wb25lbnQgaWQ6ICcgKyBuYW1lKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpc1N0YXRlZnVsQ29tcG9uZW50KGluc3RhbmNlKSB7XHJcbiAgICByZXR1cm4gaW5zdGFuY2Uudm5vZGUuc2hhcGVGbGFnICYgNCAvKiBTVEFURUZVTF9DT01QT05FTlQgKi87XHJcbn1cclxubGV0IGlzSW5TU1JDb21wb25lbnRTZXR1cCA9IGZhbHNlO1xyXG5mdW5jdGlvbiBzZXR1cENvbXBvbmVudChpbnN0YW5jZSwgaXNTU1IgPSBmYWxzZSkge1xyXG4gICAgaXNJblNTUkNvbXBvbmVudFNldHVwID0gaXNTU1I7XHJcbiAgICBjb25zdCB7IHByb3BzLCBjaGlsZHJlbiB9ID0gaW5zdGFuY2Uudm5vZGU7XHJcbiAgICBjb25zdCBpc1N0YXRlZnVsID0gaXNTdGF0ZWZ1bENvbXBvbmVudChpbnN0YW5jZSk7XHJcbiAgICBpbml0UHJvcHMoaW5zdGFuY2UsIHByb3BzLCBpc1N0YXRlZnVsLCBpc1NTUik7XHJcbiAgICBpbml0U2xvdHMoaW5zdGFuY2UsIGNoaWxkcmVuKTtcclxuICAgIGNvbnN0IHNldHVwUmVzdWx0ID0gaXNTdGF0ZWZ1bFxyXG4gICAgICAgID8gc2V0dXBTdGF0ZWZ1bENvbXBvbmVudChpbnN0YW5jZSwgaXNTU1IpXHJcbiAgICAgICAgOiB1bmRlZmluZWQ7XHJcbiAgICBpc0luU1NSQ29tcG9uZW50U2V0dXAgPSBmYWxzZTtcclxuICAgIHJldHVybiBzZXR1cFJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBzZXR1cFN0YXRlZnVsQ29tcG9uZW50KGluc3RhbmNlLCBpc1NTUikge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgY29uc3QgQ29tcG9uZW50ID0gaW5zdGFuY2UudHlwZTtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICBpZiAoQ29tcG9uZW50Lm5hbWUpIHtcclxuICAgICAgICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKENvbXBvbmVudC5uYW1lLCBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChDb21wb25lbnQuY29tcG9uZW50cykge1xyXG4gICAgICAgICAgICBjb25zdCBuYW1lcyA9IE9iamVjdC5rZXlzKENvbXBvbmVudC5jb21wb25lbnRzKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKG5hbWVzW2ldLCBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKENvbXBvbmVudC5kaXJlY3RpdmVzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5hbWVzID0gT2JqZWN0LmtleXMoQ29tcG9uZW50LmRpcmVjdGl2ZXMpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZURpcmVjdGl2ZU5hbWUobmFtZXNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChDb21wb25lbnQuY29tcGlsZXJPcHRpb25zICYmIGlzUnVudGltZU9ubHkoKSkge1xyXG4gICAgICAgICAgICB3YXJuKGBcImNvbXBpbGVyT3B0aW9uc1wiIGlzIG9ubHkgc3VwcG9ydGVkIHdoZW4gdXNpbmcgYSBidWlsZCBvZiBWdWUgdGhhdCBgICtcclxuICAgICAgICAgICAgICAgIGBpbmNsdWRlcyB0aGUgcnVudGltZSBjb21waWxlci4gU2luY2UgeW91IGFyZSB1c2luZyBhIHJ1bnRpbWUtb25seSBgICtcclxuICAgICAgICAgICAgICAgIGBidWlsZCwgdGhlIG9wdGlvbnMgc2hvdWxkIGJlIHBhc3NlZCB2aWEgeW91ciBidWlsZCB0b29sIGNvbmZpZyBpbnN0ZWFkLmApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIDAuIGNyZWF0ZSByZW5kZXIgcHJveHkgcHJvcGVydHkgYWNjZXNzIGNhY2hlXHJcbiAgICBpbnN0YW5jZS5hY2Nlc3NDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICAvLyAxLiBjcmVhdGUgcHVibGljIGluc3RhbmNlIC8gcmVuZGVyIHByb3h5XHJcbiAgICAvLyBhbHNvIG1hcmsgaXQgcmF3IHNvIGl0J3MgbmV2ZXIgb2JzZXJ2ZWRcclxuICAgIGluc3RhbmNlLnByb3h5ID0gbWFya1JhdyhuZXcgUHJveHkoaW5zdGFuY2UuY3R4LCBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMpKTtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICBleHBvc2VQcm9wc09uUmVuZGVyQ29udGV4dChpbnN0YW5jZSk7XHJcbiAgICB9XHJcbiAgICAvLyAyLiBjYWxsIHNldHVwKClcclxuICAgIGNvbnN0IHsgc2V0dXAgfSA9IENvbXBvbmVudDtcclxuICAgIGlmIChzZXR1cCkge1xyXG4gICAgICAgIGNvbnN0IHNldHVwQ29udGV4dCA9IChpbnN0YW5jZS5zZXR1cENvbnRleHQgPVxyXG4gICAgICAgICAgICBzZXR1cC5sZW5ndGggPiAxID8gY3JlYXRlU2V0dXBDb250ZXh0KGluc3RhbmNlKSA6IG51bGwpO1xyXG4gICAgICAgIHNldEN1cnJlbnRJbnN0YW5jZShpbnN0YW5jZSk7XHJcbiAgICAgICAgcGF1c2VUcmFja2luZygpO1xyXG4gICAgICAgIGNvbnN0IHNldHVwUmVzdWx0ID0gY2FsbFdpdGhFcnJvckhhbmRsaW5nKHNldHVwLCBpbnN0YW5jZSwgMCAvKiBTRVRVUF9GVU5DVElPTiAqLywgWyhwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IHNoYWxsb3dSZWFkb25seShpbnN0YW5jZS5wcm9wcykgOiBpbnN0YW5jZS5wcm9wcywgc2V0dXBDb250ZXh0XSk7XHJcbiAgICAgICAgcmVzZXRUcmFja2luZygpO1xyXG4gICAgICAgIHVuc2V0Q3VycmVudEluc3RhbmNlKCk7XHJcbiAgICAgICAgaWYgKGlzUHJvbWlzZShzZXR1cFJlc3VsdCkpIHtcclxuICAgICAgICAgICAgc2V0dXBSZXN1bHQudGhlbih1bnNldEN1cnJlbnRJbnN0YW5jZSwgdW5zZXRDdXJyZW50SW5zdGFuY2UpO1xyXG4gICAgICAgICAgICBpZiAoaXNTU1IpIHtcclxuICAgICAgICAgICAgICAgIC8vIHJldHVybiB0aGUgcHJvbWlzZSBzbyBzZXJ2ZXItcmVuZGVyZXIgY2FuIHdhaXQgb24gaXRcclxuICAgICAgICAgICAgICAgIHJldHVybiBzZXR1cFJlc3VsdFxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKChyZXNvbHZlZFJlc3VsdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZVNldHVwUmVzdWx0KGluc3RhbmNlLCByZXNvbHZlZFJlc3VsdCwgaXNTU1IpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoZSwgaW5zdGFuY2UsIDAgLyogU0VUVVBfRlVOQ1RJT04gKi8pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBhc3luYyBzZXR1cCByZXR1cm5lZCBQcm9taXNlLlxyXG4gICAgICAgICAgICAgICAgLy8gYmFpbCBoZXJlIGFuZCB3YWl0IGZvciByZS1lbnRyeS5cclxuICAgICAgICAgICAgICAgIGluc3RhbmNlLmFzeW5jRGVwID0gc2V0dXBSZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFpbnN0YW5jZS5zdXNwZW5zZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSAoX2EgPSBDb21wb25lbnQubmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ0Fub255bW91cyc7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgQ29tcG9uZW50IDwke25hbWV9Pjogc2V0dXAgZnVuY3Rpb24gcmV0dXJuZWQgYSBwcm9taXNlLCBidXQgbm8gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGA8U3VzcGVuc2U+IGJvdW5kYXJ5IHdhcyBmb3VuZCBpbiB0aGUgcGFyZW50IGNvbXBvbmVudCB0cmVlLiBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYEEgY29tcG9uZW50IHdpdGggYXN5bmMgc2V0dXAoKSBtdXN0IGJlIG5lc3RlZCBpbiBhIDxTdXNwZW5zZT4gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGBpbiBvcmRlciB0byBiZSByZW5kZXJlZC5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaGFuZGxlU2V0dXBSZXN1bHQoaW5zdGFuY2UsIHNldHVwUmVzdWx0LCBpc1NTUik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZmluaXNoQ29tcG9uZW50U2V0dXAoaW5zdGFuY2UsIGlzU1NSKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBoYW5kbGVTZXR1cFJlc3VsdChpbnN0YW5jZSwgc2V0dXBSZXN1bHQsIGlzU1NSKSB7XHJcbiAgICBpZiAoaXNGdW5jdGlvbihzZXR1cFJlc3VsdCkpIHtcclxuICAgICAgICAvLyBzZXR1cCByZXR1cm5lZCBhbiBpbmxpbmUgcmVuZGVyIGZ1bmN0aW9uXHJcbiAgICAgICAgaWYgKGluc3RhbmNlLnR5cGUuX19zc3JJbmxpbmVSZW5kZXIpIHtcclxuICAgICAgICAgICAgLy8gd2hlbiB0aGUgZnVuY3Rpb24ncyBuYW1lIGlzIGBzc3JSZW5kZXJgIChjb21waWxlZCBieSBTRkMgaW5saW5lIG1vZGUpLFxyXG4gICAgICAgICAgICAvLyBzZXQgaXQgYXMgc3NyUmVuZGVyIGluc3RlYWQuXHJcbiAgICAgICAgICAgIGluc3RhbmNlLnNzclJlbmRlciA9IHNldHVwUmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaW5zdGFuY2UucmVuZGVyID0gc2V0dXBSZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNPYmplY3Qoc2V0dXBSZXN1bHQpKSB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBpc1ZOb2RlKHNldHVwUmVzdWx0KSkge1xyXG4gICAgICAgICAgICB3YXJuKGBzZXR1cCgpIHNob3VsZCBub3QgcmV0dXJuIFZOb2RlcyBkaXJlY3RseSAtIGAgK1xyXG4gICAgICAgICAgICAgICAgYHJldHVybiBhIHJlbmRlciBmdW5jdGlvbiBpbnN0ZWFkLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBzZXR1cCByZXR1cm5lZCBiaW5kaW5ncy5cclxuICAgICAgICAvLyBhc3N1bWluZyBhIHJlbmRlciBmdW5jdGlvbiBjb21waWxlZCBmcm9tIHRlbXBsYXRlIGlzIHByZXNlbnQuXHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgICAgICAgICAgaW5zdGFuY2UuZGV2dG9vbHNSYXdTZXR1cFN0YXRlID0gc2V0dXBSZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluc3RhbmNlLnNldHVwU3RhdGUgPSBwcm94eVJlZnMoc2V0dXBSZXN1bHQpO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgZXhwb3NlU2V0dXBTdGF0ZU9uUmVuZGVyQ29udGV4dChpbnN0YW5jZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHNldHVwUmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB3YXJuKGBzZXR1cCgpIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0LiBSZWNlaXZlZDogJHtzZXR1cFJlc3VsdCA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiBzZXR1cFJlc3VsdH1gKTtcclxuICAgIH1cclxuICAgIGZpbmlzaENvbXBvbmVudFNldHVwKGluc3RhbmNlLCBpc1NTUik7XHJcbn1cclxubGV0IGNvbXBpbGU7XHJcbmxldCBpbnN0YWxsV2l0aFByb3h5O1xyXG4vKipcclxuICogRm9yIHJ1bnRpbWUtZG9tIHRvIHJlZ2lzdGVyIHRoZSBjb21waWxlci5cclxuICogTm90ZSB0aGUgZXhwb3J0ZWQgbWV0aG9kIHVzZXMgYW55IHRvIGF2b2lkIGQudHMgcmVseWluZyBvbiB0aGUgY29tcGlsZXIgdHlwZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiByZWdpc3RlclJ1bnRpbWVDb21waWxlcihfY29tcGlsZSkge1xyXG4gICAgY29tcGlsZSA9IF9jb21waWxlO1xyXG4gICAgaW5zdGFsbFdpdGhQcm94eSA9IGkgPT4ge1xyXG4gICAgICAgIGlmIChpLnJlbmRlci5fcmMpIHtcclxuICAgICAgICAgICAgaS53aXRoUHJveHkgPSBuZXcgUHJveHkoaS5jdHgsIFJ1bnRpbWVDb21waWxlZFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG4vLyBkZXYgb25seVxyXG5jb25zdCBpc1J1bnRpbWVPbmx5ID0gKCkgPT4gIWNvbXBpbGU7XHJcbmZ1bmN0aW9uIGZpbmlzaENvbXBvbmVudFNldHVwKGluc3RhbmNlLCBpc1NTUiwgc2tpcE9wdGlvbnMpIHtcclxuICAgIGNvbnN0IENvbXBvbmVudCA9IGluc3RhbmNlLnR5cGU7XHJcbiAgICAvLyB0ZW1wbGF0ZSAvIHJlbmRlciBmdW5jdGlvbiBub3JtYWxpemF0aW9uXHJcbiAgICAvLyBjb3VsZCBiZSBhbHJlYWR5IHNldCB3aGVuIHJldHVybmVkIGZyb20gc2V0dXAoKVxyXG4gICAgaWYgKCFpbnN0YW5jZS5yZW5kZXIpIHtcclxuICAgICAgICAvLyBvbmx5IGRvIG9uLXRoZS1mbHkgY29tcGlsZSBpZiBub3QgaW4gU1NSIC0gU1NSIG9uLXRoZS1mbHkgY29tcGlsYXRpb25cclxuICAgICAgICAvLyBpcyBkb25lIGJ5IHNlcnZlci1yZW5kZXJlclxyXG4gICAgICAgIGlmICghaXNTU1IgJiYgY29tcGlsZSAmJiAhQ29tcG9uZW50LnJlbmRlcikge1xyXG4gICAgICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IENvbXBvbmVudC50ZW1wbGF0ZTtcclxuICAgICAgICAgICAgaWYgKHRlbXBsYXRlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgY29tcGlsZWApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBpc0N1c3RvbUVsZW1lbnQsIGNvbXBpbGVyT3B0aW9ucyB9ID0gaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWc7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRlbGltaXRlcnMsIGNvbXBpbGVyT3B0aW9uczogY29tcG9uZW50Q29tcGlsZXJPcHRpb25zIH0gPSBDb21wb25lbnQ7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmaW5hbENvbXBpbGVyT3B0aW9ucyA9IGV4dGVuZChleHRlbmQoe1xyXG4gICAgICAgICAgICAgICAgICAgIGlzQ3VzdG9tRWxlbWVudCxcclxuICAgICAgICAgICAgICAgICAgICBkZWxpbWl0ZXJzXHJcbiAgICAgICAgICAgICAgICB9LCBjb21waWxlck9wdGlvbnMpLCBjb21wb25lbnRDb21waWxlck9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LnJlbmRlciA9IGNvbXBpbGUodGVtcGxhdGUsIGZpbmFsQ29tcGlsZXJPcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgY29tcGlsZWApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluc3RhbmNlLnJlbmRlciA9IChDb21wb25lbnQucmVuZGVyIHx8IE5PT1ApO1xyXG4gICAgICAgIC8vIGZvciBydW50aW1lLWNvbXBpbGVkIHJlbmRlciBmdW5jdGlvbnMgdXNpbmcgYHdpdGhgIGJsb2NrcywgdGhlIHJlbmRlclxyXG4gICAgICAgIC8vIHByb3h5IHVzZWQgbmVlZHMgYSBkaWZmZXJlbnQgYGhhc2AgaGFuZGxlciB3aGljaCBpcyBtb3JlIHBlcmZvcm1hbnQgYW5kXHJcbiAgICAgICAgLy8gYWxzbyBvbmx5IGFsbG93cyBhIHdoaXRlbGlzdCBvZiBnbG9iYWxzIHRvIGZhbGx0aHJvdWdoLlxyXG4gICAgICAgIGlmIChpbnN0YWxsV2l0aFByb3h5KSB7XHJcbiAgICAgICAgICAgIGluc3RhbGxXaXRoUHJveHkoaW5zdGFuY2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIHN1cHBvcnQgZm9yIDIueCBvcHRpb25zXHJcbiAgICBpZiAoX19WVUVfT1BUSU9OU19BUElfXyAmJiAhKGZhbHNlICkpIHtcclxuICAgICAgICBzZXRDdXJyZW50SW5zdGFuY2UoaW5zdGFuY2UpO1xyXG4gICAgICAgIHBhdXNlVHJhY2tpbmcoKTtcclxuICAgICAgICBhcHBseU9wdGlvbnMoaW5zdGFuY2UpO1xyXG4gICAgICAgIHJlc2V0VHJhY2tpbmcoKTtcclxuICAgICAgICB1bnNldEN1cnJlbnRJbnN0YW5jZSgpO1xyXG4gICAgfVxyXG4gICAgLy8gd2FybiBtaXNzaW5nIHRlbXBsYXRlL3JlbmRlclxyXG4gICAgLy8gdGhlIHJ1bnRpbWUgY29tcGlsYXRpb24gb2YgdGVtcGxhdGUgaW4gU1NSIGlzIGRvbmUgYnkgc2VydmVyLXJlbmRlclxyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhQ29tcG9uZW50LnJlbmRlciAmJiBpbnN0YW5jZS5yZW5kZXIgPT09IE5PT1AgJiYgIWlzU1NSKSB7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgaWYgKCFjb21waWxlICYmIENvbXBvbmVudC50ZW1wbGF0ZSkge1xyXG4gICAgICAgICAgICB3YXJuKGBDb21wb25lbnQgcHJvdmlkZWQgdGVtcGxhdGUgb3B0aW9uIGJ1dCBgICtcclxuICAgICAgICAgICAgICAgIGBydW50aW1lIGNvbXBpbGF0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBidWlsZCBvZiBWdWUuYCArXHJcbiAgICAgICAgICAgICAgICAoYCBDb25maWd1cmUgeW91ciBidW5kbGVyIHRvIGFsaWFzIFwidnVlXCIgdG8gXCJ2dWUvZGlzdC92dWUuZXNtLWJ1bmRsZXIuanNcIi5gXHJcbiAgICAgICAgICAgICAgICAgICAgKSAvKiBzaG91bGQgbm90IGhhcHBlbiAqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB3YXJuKGBDb21wb25lbnQgaXMgbWlzc2luZyB0ZW1wbGF0ZSBvciByZW5kZXIgZnVuY3Rpb24uYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUF0dHJzUHJveHkoaW5zdGFuY2UpIHtcclxuICAgIHJldHVybiBuZXcgUHJveHkoaW5zdGFuY2UuYXR0cnMsIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxyXG4gICAgICAgID8ge1xyXG4gICAgICAgICAgICBnZXQodGFyZ2V0LCBrZXkpIHtcclxuICAgICAgICAgICAgICAgIG1hcmtBdHRyc0FjY2Vzc2VkKCk7XHJcbiAgICAgICAgICAgICAgICB0cmFjayhpbnN0YW5jZSwgXCJnZXRcIiAvKiBHRVQgKi8sICckYXR0cnMnKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRba2V5XTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0KCkge1xyXG4gICAgICAgICAgICAgICAgd2Fybihgc2V0dXBDb250ZXh0LmF0dHJzIGlzIHJlYWRvbmx5LmApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkZWxldGVQcm9wZXJ0eSgpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oYHNldHVwQ29udGV4dC5hdHRycyBpcyByZWFkb25seS5gKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICA6IHtcclxuICAgICAgICAgICAgZ2V0KHRhcmdldCwga2V5KSB7XHJcbiAgICAgICAgICAgICAgICB0cmFjayhpbnN0YW5jZSwgXCJnZXRcIiAvKiBHRVQgKi8sICckYXR0cnMnKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVNldHVwQ29udGV4dChpbnN0YW5jZSkge1xyXG4gICAgY29uc3QgZXhwb3NlID0gZXhwb3NlZCA9PiB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBpbnN0YW5jZS5leHBvc2VkKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYGV4cG9zZSgpIHNob3VsZCBiZSBjYWxsZWQgb25seSBvbmNlIHBlciBzZXR1cCgpLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbnN0YW5jZS5leHBvc2VkID0gZXhwb3NlZCB8fCB7fTtcclxuICAgIH07XHJcbiAgICBsZXQgYXR0cnM7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgLy8gV2UgdXNlIGdldHRlcnMgaW4gZGV2IGluIGNhc2UgbGlicyBsaWtlIHRlc3QtdXRpbHMgb3ZlcndyaXRlIGluc3RhbmNlXHJcbiAgICAgICAgLy8gcHJvcGVydGllcyAob3ZlcndyaXRlcyBzaG91bGQgbm90IGJlIGRvbmUgaW4gcHJvZClcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XHJcbiAgICAgICAgICAgIGdldCBhdHRycygpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhdHRycyB8fCAoYXR0cnMgPSBjcmVhdGVBdHRyc1Byb3h5KGluc3RhbmNlKSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGdldCBzbG90cygpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzaGFsbG93UmVhZG9ubHkoaW5zdGFuY2Uuc2xvdHMpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBnZXQgZW1pdCgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoZXZlbnQsIC4uLmFyZ3MpID0+IGluc3RhbmNlLmVtaXQoZXZlbnQsIC4uLmFyZ3MpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBleHBvc2VcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGdldCBhdHRycygpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhdHRycyB8fCAoYXR0cnMgPSBjcmVhdGVBdHRyc1Byb3h5KGluc3RhbmNlKSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNsb3RzOiBpbnN0YW5jZS5zbG90cyxcclxuICAgICAgICAgICAgZW1pdDogaW5zdGFuY2UuZW1pdCxcclxuICAgICAgICAgICAgZXhwb3NlXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRFeHBvc2VQcm94eShpbnN0YW5jZSkge1xyXG4gICAgaWYgKGluc3RhbmNlLmV4cG9zZWQpIHtcclxuICAgICAgICByZXR1cm4gKGluc3RhbmNlLmV4cG9zZVByb3h5IHx8XHJcbiAgICAgICAgICAgIChpbnN0YW5jZS5leHBvc2VQcm94eSA9IG5ldyBQcm94eShwcm94eVJlZnMobWFya1JhdyhpbnN0YW5jZS5leHBvc2VkKSksIHtcclxuICAgICAgICAgICAgICAgIGdldCh0YXJnZXQsIGtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgaW4gdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoa2V5IGluIHB1YmxpY1Byb3BlcnRpZXNNYXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHB1YmxpY1Byb3BlcnRpZXNNYXBba2V5XShpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KSkpO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IGNsYXNzaWZ5UkUgPSAvKD86XnxbLV9dKShcXHcpL2c7XHJcbmNvbnN0IGNsYXNzaWZ5ID0gKHN0cikgPT4gc3RyLnJlcGxhY2UoY2xhc3NpZnlSRSwgYyA9PiBjLnRvVXBwZXJDYXNlKCkpLnJlcGxhY2UoL1stX10vZywgJycpO1xyXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCkge1xyXG4gICAgcmV0dXJuIGlzRnVuY3Rpb24oQ29tcG9uZW50KVxyXG4gICAgICAgID8gQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lXHJcbiAgICAgICAgOiBDb21wb25lbnQubmFtZTtcclxufVxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5mdW5jdGlvbiBmb3JtYXRDb21wb25lbnROYW1lKGluc3RhbmNlLCBDb21wb25lbnQsIGlzUm9vdCA9IGZhbHNlKSB7XHJcbiAgICBsZXQgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KTtcclxuICAgIGlmICghbmFtZSAmJiBDb21wb25lbnQuX19maWxlKSB7XHJcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBDb21wb25lbnQuX19maWxlLm1hdGNoKC8oW14vXFxcXF0rKVxcLlxcdyskLyk7XHJcbiAgICAgICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgICAgICAgIG5hbWUgPSBtYXRjaFsxXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoIW5hbWUgJiYgaW5zdGFuY2UgJiYgaW5zdGFuY2UucGFyZW50KSB7XHJcbiAgICAgICAgLy8gdHJ5IHRvIGluZmVyIHRoZSBuYW1lIGJhc2VkIG9uIHJldmVyc2UgcmVzb2x1dGlvblxyXG4gICAgICAgIGNvbnN0IGluZmVyRnJvbVJlZ2lzdHJ5ID0gKHJlZ2lzdHJ5KSA9PiB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHJlZ2lzdHJ5KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVnaXN0cnlba2V5XSA9PT0gQ29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgbmFtZSA9XHJcbiAgICAgICAgICAgIGluZmVyRnJvbVJlZ2lzdHJ5KGluc3RhbmNlLmNvbXBvbmVudHMgfHxcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlLnBhcmVudC50eXBlLmNvbXBvbmVudHMpIHx8IGluZmVyRnJvbVJlZ2lzdHJ5KGluc3RhbmNlLmFwcENvbnRleHQuY29tcG9uZW50cyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmFtZSA/IGNsYXNzaWZ5KG5hbWUpIDogaXNSb290ID8gYEFwcGAgOiBgQW5vbnltb3VzYDtcclxufVxyXG5mdW5jdGlvbiBpc0NsYXNzQ29tcG9uZW50KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gaXNGdW5jdGlvbih2YWx1ZSkgJiYgJ19fdmNjT3B0cycgaW4gdmFsdWU7XHJcbn1cblxuY29uc3QgY29tcHV0ZWQgPSAoKGdldHRlck9yT3B0aW9ucywgZGVidWdPcHRpb25zKSA9PiB7XHJcbiAgICAvLyBAdHMtaWdub3JlXHJcbiAgICByZXR1cm4gY29tcHV0ZWQkMShnZXR0ZXJPck9wdGlvbnMsIGRlYnVnT3B0aW9ucywgaXNJblNTUkNvbXBvbmVudFNldHVwKTtcclxufSk7XG5cbi8vIGRldiBvbmx5XHJcbmNvbnN0IHdhcm5SdW50aW1lVXNhZ2UgPSAobWV0aG9kKSA9PiB3YXJuKGAke21ldGhvZH0oKSBpcyBhIGNvbXBpbGVyLWhpbnQgaGVscGVyIHRoYXQgaXMgb25seSB1c2FibGUgaW5zaWRlIGAgK1xyXG4gICAgYDxzY3JpcHQgc2V0dXA+IG9mIGEgc2luZ2xlIGZpbGUgY29tcG9uZW50LiBJdHMgYXJndW1lbnRzIHNob3VsZCBiZSBgICtcclxuICAgIGBjb21waWxlZCBhd2F5IGFuZCBwYXNzaW5nIGl0IGF0IHJ1bnRpbWUgaGFzIG5vIGVmZmVjdC5gKTtcclxuLy8gaW1wbGVtZW50YXRpb25cclxuZnVuY3Rpb24gZGVmaW5lUHJvcHMoKSB7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgd2FyblJ1bnRpbWVVc2FnZShgZGVmaW5lUHJvcHNgKTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcbi8vIGltcGxlbWVudGF0aW9uXHJcbmZ1bmN0aW9uIGRlZmluZUVtaXRzKCkge1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIHdhcm5SdW50aW1lVXNhZ2UoYGRlZmluZUVtaXRzYCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG4vKipcclxuICogVnVlIGA8c2NyaXB0IHNldHVwPmAgY29tcGlsZXIgbWFjcm8gZm9yIGRlY2xhcmluZyBhIGNvbXBvbmVudCdzIGV4cG9zZWRcclxuICogaW5zdGFuY2UgcHJvcGVydGllcyB3aGVuIGl0IGlzIGFjY2Vzc2VkIGJ5IGEgcGFyZW50IGNvbXBvbmVudCB2aWEgdGVtcGxhdGVcclxuICogcmVmcy5cclxuICpcclxuICogYDxzY3JpcHQgc2V0dXA+YCBjb21wb25lbnRzIGFyZSBjbG9zZWQgYnkgZGVmYXVsdCAtIGkuZS4gdmFyaWFibGVzIGluc2lkZVxyXG4gKiB0aGUgYDxzY3JpcHQgc2V0dXA+YCBzY29wZSBpcyBub3QgZXhwb3NlZCB0byBwYXJlbnQgdW5sZXNzIGV4cGxpY2l0bHkgZXhwb3NlZFxyXG4gKiB2aWEgYGRlZmluZUV4cG9zZWAuXHJcbiAqXHJcbiAqIFRoaXMgaXMgb25seSB1c2FibGUgaW5zaWRlIGA8c2NyaXB0IHNldHVwPmAsIGlzIGNvbXBpbGVkIGF3YXkgaW4gdGhlXHJcbiAqIG91dHB1dCBhbmQgc2hvdWxkICoqbm90KiogYmUgYWN0dWFsbHkgY2FsbGVkIGF0IHJ1bnRpbWUuXHJcbiAqL1xyXG5mdW5jdGlvbiBkZWZpbmVFeHBvc2UoZXhwb3NlZCkge1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIHdhcm5SdW50aW1lVXNhZ2UoYGRlZmluZUV4cG9zZWApO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBWdWUgYDxzY3JpcHQgc2V0dXA+YCBjb21waWxlciBtYWNybyBmb3IgcHJvdmlkaW5nIHByb3BzIGRlZmF1bHQgdmFsdWVzIHdoZW5cclxuICogdXNpbmcgdHlwZS1iYXNlZCBgZGVmaW5lUHJvcHNgIGRlY2xhcmF0aW9uLlxyXG4gKlxyXG4gKiBFeGFtcGxlIHVzYWdlOlxyXG4gKiBgYGB0c1xyXG4gKiB3aXRoRGVmYXVsdHMoZGVmaW5lUHJvcHM8e1xyXG4gKiAgIHNpemU/OiBudW1iZXJcclxuICogICBsYWJlbHM/OiBzdHJpbmdbXVxyXG4gKiB9PigpLCB7XHJcbiAqICAgc2l6ZTogMyxcclxuICogICBsYWJlbHM6ICgpID0+IFsnZGVmYXVsdCBsYWJlbCddXHJcbiAqIH0pXHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBUaGlzIGlzIG9ubHkgdXNhYmxlIGluc2lkZSBgPHNjcmlwdCBzZXR1cD5gLCBpcyBjb21waWxlZCBhd2F5IGluIHRoZSBvdXRwdXRcclxuICogYW5kIHNob3VsZCAqKm5vdCoqIGJlIGFjdHVhbGx5IGNhbGxlZCBhdCBydW50aW1lLlxyXG4gKi9cclxuZnVuY3Rpb24gd2l0aERlZmF1bHRzKHByb3BzLCBkZWZhdWx0cykge1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIHdhcm5SdW50aW1lVXNhZ2UoYHdpdGhEZWZhdWx0c2ApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuZnVuY3Rpb24gdXNlU2xvdHMoKSB7XHJcbiAgICByZXR1cm4gZ2V0Q29udGV4dCgpLnNsb3RzO1xyXG59XHJcbmZ1bmN0aW9uIHVzZUF0dHJzKCkge1xyXG4gICAgcmV0dXJuIGdldENvbnRleHQoKS5hdHRycztcclxufVxyXG5mdW5jdGlvbiBnZXRDb250ZXh0KCkge1xyXG4gICAgY29uc3QgaSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaSkge1xyXG4gICAgICAgIHdhcm4oYHVzZUNvbnRleHQoKSBjYWxsZWQgd2l0aG91dCBhY3RpdmUgaW5zdGFuY2UuYCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaS5zZXR1cENvbnRleHQgfHwgKGkuc2V0dXBDb250ZXh0ID0gY3JlYXRlU2V0dXBDb250ZXh0KGkpKTtcclxufVxyXG4vKipcclxuICogUnVudGltZSBoZWxwZXIgZm9yIG1lcmdpbmcgZGVmYXVsdCBkZWNsYXJhdGlvbnMuIEltcG9ydGVkIGJ5IGNvbXBpbGVkIGNvZGVcclxuICogb25seS5cclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBtZXJnZURlZmF1bHRzKHJhdywgZGVmYXVsdHMpIHtcclxuICAgIGNvbnN0IHByb3BzID0gaXNBcnJheShyYXcpXHJcbiAgICAgICAgPyByYXcucmVkdWNlKChub3JtYWxpemVkLCBwKSA9PiAoKG5vcm1hbGl6ZWRbcF0gPSB7fSksIG5vcm1hbGl6ZWQpLCB7fSlcclxuICAgICAgICA6IHJhdztcclxuICAgIGZvciAoY29uc3Qga2V5IGluIGRlZmF1bHRzKSB7XHJcbiAgICAgICAgY29uc3Qgb3B0ID0gcHJvcHNba2V5XTtcclxuICAgICAgICBpZiAob3B0KSB7XHJcbiAgICAgICAgICAgIGlmIChpc0FycmF5KG9wdCkgfHwgaXNGdW5jdGlvbihvcHQpKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9wc1trZXldID0geyB0eXBlOiBvcHQsIGRlZmF1bHQ6IGRlZmF1bHRzW2tleV0gfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG9wdC5kZWZhdWx0ID0gZGVmYXVsdHNba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChvcHQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcHJvcHNba2V5XSA9IHsgZGVmYXVsdDogZGVmYXVsdHNba2V5XSB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgd2FybihgcHJvcHMgZGVmYXVsdCBrZXkgXCIke2tleX1cIiBoYXMgbm8gY29ycmVzcG9uZGluZyBkZWNsYXJhdGlvbi5gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJvcHM7XHJcbn1cclxuLyoqXHJcbiAqIFVzZWQgdG8gY3JlYXRlIGEgcHJveHkgZm9yIHRoZSByZXN0IGVsZW1lbnQgd2hlbiBkZXN0cnVjdHVyaW5nIHByb3BzIHdpdGhcclxuICogZGVmaW5lUHJvcHMoKS5cclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVQcm9wc1Jlc3RQcm94eShwcm9wcywgZXhjbHVkZWRLZXlzKSB7XHJcbiAgICBjb25zdCByZXQgPSB7fTtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XHJcbiAgICAgICAgaWYgKCFleGNsdWRlZEtleXMuaW5jbHVkZXMoa2V5KSkge1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmV0LCBrZXksIHtcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IHByb3BzW2tleV1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJldDtcclxufVxyXG4vKipcclxuICogYDxzY3JpcHQgc2V0dXA+YCBoZWxwZXIgZm9yIHBlcnNpc3RpbmcgdGhlIGN1cnJlbnQgaW5zdGFuY2UgY29udGV4dCBvdmVyXHJcbiAqIGFzeW5jL2F3YWl0IGZsb3dzLlxyXG4gKlxyXG4gKiBgQHZ1ZS9jb21waWxlci1zZmNgIGNvbnZlcnRzIHRoZSBmb2xsb3dpbmc6XHJcbiAqXHJcbiAqIGBgYHRzXHJcbiAqIGNvbnN0IHggPSBhd2FpdCBmb28oKVxyXG4gKiBgYGBcclxuICpcclxuICogaW50bzpcclxuICpcclxuICogYGBgdHNcclxuICogbGV0IF9fdGVtcCwgX19yZXN0b3JlXHJcbiAqIGNvbnN0IHggPSAoKFtfX3RlbXAsIF9fcmVzdG9yZV0gPSB3aXRoQXN5bmNDb250ZXh0KCgpID0+IGZvbygpKSksX190ZW1wPWF3YWl0IF9fdGVtcCxfX3Jlc3RvcmUoKSxfX3RlbXApXHJcbiAqIGBgYFxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIHdpdGhBc3luY0NvbnRleHQoZ2V0QXdhaXRhYmxlKSB7XHJcbiAgICBjb25zdCBjdHggPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWN0eCkge1xyXG4gICAgICAgIHdhcm4oYHdpdGhBc3luY0NvbnRleHQgY2FsbGVkIHdpdGhvdXQgYWN0aXZlIGN1cnJlbnQgaW5zdGFuY2UuIGAgK1xyXG4gICAgICAgICAgICBgVGhpcyBpcyBsaWtlbHkgYSBidWcuYCk7XHJcbiAgICB9XHJcbiAgICBsZXQgYXdhaXRhYmxlID0gZ2V0QXdhaXRhYmxlKCk7XHJcbiAgICB1bnNldEN1cnJlbnRJbnN0YW5jZSgpO1xyXG4gICAgaWYgKGlzUHJvbWlzZShhd2FpdGFibGUpKSB7XHJcbiAgICAgICAgYXdhaXRhYmxlID0gYXdhaXRhYmxlLmNhdGNoKGUgPT4ge1xyXG4gICAgICAgICAgICBzZXRDdXJyZW50SW5zdGFuY2UoY3R4KTtcclxuICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBbYXdhaXRhYmxlLCAoKSA9PiBzZXRDdXJyZW50SW5zdGFuY2UoY3R4KV07XHJcbn1cblxuLy8gQWN0dWFsIGltcGxlbWVudGF0aW9uXHJcbmZ1bmN0aW9uIGgodHlwZSwgcHJvcHNPckNoaWxkcmVuLCBjaGlsZHJlbikge1xyXG4gICAgY29uc3QgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XHJcbiAgICBpZiAobCA9PT0gMikge1xyXG4gICAgICAgIGlmIChpc09iamVjdChwcm9wc09yQ2hpbGRyZW4pICYmICFpc0FycmF5KHByb3BzT3JDaGlsZHJlbikpIHtcclxuICAgICAgICAgICAgLy8gc2luZ2xlIHZub2RlIHdpdGhvdXQgcHJvcHNcclxuICAgICAgICAgICAgaWYgKGlzVk5vZGUocHJvcHNPckNoaWxkcmVuKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKHR5cGUsIG51bGwsIFtwcm9wc09yQ2hpbGRyZW5dKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBwcm9wcyB3aXRob3V0IGNoaWxkcmVuXHJcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVWTm9kZSh0eXBlLCBwcm9wc09yQ2hpbGRyZW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gb21pdCBwcm9wc1xyXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUodHlwZSwgbnVsbCwgcHJvcHNPckNoaWxkcmVuKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAobCA+IDMpIHtcclxuICAgICAgICAgICAgY2hpbGRyZW4gPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChsID09PSAzICYmIGlzVk5vZGUoY2hpbGRyZW4pKSB7XHJcbiAgICAgICAgICAgIGNoaWxkcmVuID0gW2NoaWxkcmVuXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKHR5cGUsIHByb3BzT3JDaGlsZHJlbiwgY2hpbGRyZW4pO1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IHNzckNvbnRleHRLZXkgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHNzckNvbnRleHRgIDogYGApO1xyXG5jb25zdCB1c2VTU1JDb250ZXh0ID0gKCkgPT4ge1xyXG4gICAge1xyXG4gICAgICAgIGNvbnN0IGN0eCA9IGluamVjdChzc3JDb250ZXh0S2V5KTtcclxuICAgICAgICBpZiAoIWN0eCkge1xyXG4gICAgICAgICAgICB3YXJuKGBTZXJ2ZXIgcmVuZGVyaW5nIGNvbnRleHQgbm90IHByb3ZpZGVkLiBNYWtlIHN1cmUgdG8gb25seSBjYWxsIGAgK1xyXG4gICAgICAgICAgICAgICAgYHVzZVNTUkNvbnRleHQoKSBjb25kaXRpb25hbGx5IGluIHRoZSBzZXJ2ZXIgYnVpbGQuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjdHg7XHJcbiAgICB9XHJcbn07XG5cbmZ1bmN0aW9uIGlzU2hhbGxvdyh2YWx1ZSkge1xyXG4gICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlW1wiX192X2lzU2hhbGxvd1wiIC8qIElTX1NIQUxMT1cgKi9dKTtcclxufVxuXG5mdW5jdGlvbiBpbml0Q3VzdG9tRm9ybWF0dGVyKCkge1xyXG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzICovXHJcbiAgICBpZiAoIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IHZ1ZVN0eWxlID0geyBzdHlsZTogJ2NvbG9yOiMzYmE3NzYnIH07XHJcbiAgICBjb25zdCBudW1iZXJTdHlsZSA9IHsgc3R5bGU6ICdjb2xvcjojMGIxYmM5JyB9O1xyXG4gICAgY29uc3Qgc3RyaW5nU3R5bGUgPSB7IHN0eWxlOiAnY29sb3I6I2I2MmUyNCcgfTtcclxuICAgIGNvbnN0IGtleXdvcmRTdHlsZSA9IHsgc3R5bGU6ICdjb2xvcjojOWQyODhjJyB9O1xyXG4gICAgLy8gY3VzdG9tIGZvcm1hdHRlciBmb3IgQ2hyb21lXHJcbiAgICAvLyBodHRwczovL3d3dy5tYXR0emV1bmVydC5jb20vMjAxNi8wMi8xOS9jdXN0b20tY2hyb21lLWRldnRvb2xzLW9iamVjdC1mb3JtYXR0ZXJzLmh0bWxcclxuICAgIGNvbnN0IGZvcm1hdHRlciA9IHtcclxuICAgICAgICBoZWFkZXIob2JqKSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE8gYWxzbyBmb3JtYXQgQ29tcG9uZW50UHVibGljSW5zdGFuY2UgJiBjdHguc2xvdHMvYXR0cnMgaW4gc2V0dXBcclxuICAgICAgICAgICAgaWYgKCFpc09iamVjdChvYmopKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob2JqLl9faXNWdWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbJ2RpdicsIHZ1ZVN0eWxlLCBgVnVlSW5zdGFuY2VgXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc1JlZihvYmopKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgICAgICdkaXYnLFxyXG4gICAgICAgICAgICAgICAgICAgIHt9LFxyXG4gICAgICAgICAgICAgICAgICAgIFsnc3BhbicsIHZ1ZVN0eWxlLCBnZW5SZWZGbGFnKG9iaildLFxyXG4gICAgICAgICAgICAgICAgICAgICc8JyxcclxuICAgICAgICAgICAgICAgICAgICBmb3JtYXRWYWx1ZShvYmoudmFsdWUpLFxyXG4gICAgICAgICAgICAgICAgICAgIGA+YFxyXG4gICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc1JlYWN0aXZlKG9iaikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICAgICAgJ2RpdicsXHJcbiAgICAgICAgICAgICAgICAgICAge30sXHJcbiAgICAgICAgICAgICAgICAgICAgWydzcGFuJywgdnVlU3R5bGUsIGlzU2hhbGxvdyhvYmopID8gJ1NoYWxsb3dSZWFjdGl2ZScgOiAnUmVhY3RpdmUnXSxcclxuICAgICAgICAgICAgICAgICAgICAnPCcsXHJcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0VmFsdWUob2JqKSxcclxuICAgICAgICAgICAgICAgICAgICBgPiR7aXNSZWFkb25seShvYmopID8gYCAocmVhZG9ubHkpYCA6IGBgfWBcclxuICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNSZWFkb25seShvYmopKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgICAgICdkaXYnLFxyXG4gICAgICAgICAgICAgICAgICAgIHt9LFxyXG4gICAgICAgICAgICAgICAgICAgIFsnc3BhbicsIHZ1ZVN0eWxlLCBpc1NoYWxsb3cob2JqKSA/ICdTaGFsbG93UmVhZG9ubHknIDogJ1JlYWRvbmx5J10sXHJcbiAgICAgICAgICAgICAgICAgICAgJzwnLFxyXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdFZhbHVlKG9iaiksXHJcbiAgICAgICAgICAgICAgICAgICAgJz4nXHJcbiAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaGFzQm9keShvYmopIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9iaiAmJiBvYmouX19pc1Z1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJvZHkob2JqKSB7XHJcbiAgICAgICAgICAgIGlmIChvYmogJiYgb2JqLl9faXNWdWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICAgICAgJ2RpdicsXHJcbiAgICAgICAgICAgICAgICAgICAge30sXHJcbiAgICAgICAgICAgICAgICAgICAgLi4uZm9ybWF0SW5zdGFuY2Uob2JqLiQpXHJcbiAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGZ1bmN0aW9uIGZvcm1hdEluc3RhbmNlKGluc3RhbmNlKSB7XHJcbiAgICAgICAgY29uc3QgYmxvY2tzID0gW107XHJcbiAgICAgICAgaWYgKGluc3RhbmNlLnR5cGUucHJvcHMgJiYgaW5zdGFuY2UucHJvcHMpIHtcclxuICAgICAgICAgICAgYmxvY2tzLnB1c2goY3JlYXRlSW5zdGFuY2VCbG9jaygncHJvcHMnLCB0b1JhdyhpbnN0YW5jZS5wcm9wcykpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGluc3RhbmNlLnNldHVwU3RhdGUgIT09IEVNUFRZX09CSikge1xyXG4gICAgICAgICAgICBibG9ja3MucHVzaChjcmVhdGVJbnN0YW5jZUJsb2NrKCdzZXR1cCcsIGluc3RhbmNlLnNldHVwU3RhdGUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGluc3RhbmNlLmRhdGEgIT09IEVNUFRZX09CSikge1xyXG4gICAgICAgICAgICBibG9ja3MucHVzaChjcmVhdGVJbnN0YW5jZUJsb2NrKCdkYXRhJywgdG9SYXcoaW5zdGFuY2UuZGF0YSkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY29tcHV0ZWQgPSBleHRyYWN0S2V5cyhpbnN0YW5jZSwgJ2NvbXB1dGVkJyk7XHJcbiAgICAgICAgaWYgKGNvbXB1dGVkKSB7XHJcbiAgICAgICAgICAgIGJsb2Nrcy5wdXNoKGNyZWF0ZUluc3RhbmNlQmxvY2soJ2NvbXB1dGVkJywgY29tcHV0ZWQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaW5qZWN0ZWQgPSBleHRyYWN0S2V5cyhpbnN0YW5jZSwgJ2luamVjdCcpO1xyXG4gICAgICAgIGlmIChpbmplY3RlZCkge1xyXG4gICAgICAgICAgICBibG9ja3MucHVzaChjcmVhdGVJbnN0YW5jZUJsb2NrKCdpbmplY3RlZCcsIGluamVjdGVkKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJsb2Nrcy5wdXNoKFtcclxuICAgICAgICAgICAgJ2RpdicsXHJcbiAgICAgICAgICAgIHt9LFxyXG4gICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICAnc3BhbicsXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IGtleXdvcmRTdHlsZS5zdHlsZSArICc7b3BhY2l0eTowLjY2J1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICckIChpbnRlcm5hbCk6ICdcclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgWydvYmplY3QnLCB7IG9iamVjdDogaW5zdGFuY2UgfV1cclxuICAgICAgICBdKTtcclxuICAgICAgICByZXR1cm4gYmxvY2tzO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VCbG9jayh0eXBlLCB0YXJnZXQpIHtcclxuICAgICAgICB0YXJnZXQgPSBleHRlbmQoe30sIHRhcmdldCk7XHJcbiAgICAgICAgaWYgKCFPYmplY3Qua2V5cyh0YXJnZXQpLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gWydzcGFuJywge31dO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAnZGl2JyxcclxuICAgICAgICAgICAgeyBzdHlsZTogJ2xpbmUtaGVpZ2h0OjEuMjVlbTttYXJnaW4tYm90dG9tOjAuNmVtJyB9LFxyXG4gICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICAnZGl2JyxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZTogJ2NvbG9yOiM0NzY1ODInXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgdHlwZVxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICAnZGl2JyxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZTogJ3BhZGRpbmctbGVmdDoxLjI1ZW0nXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgLi4uT2JqZWN0LmtleXModGFyZ2V0KS5tYXAoa2V5ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnZGl2JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAge30sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFsnc3BhbicsIGtleXdvcmRTdHlsZSwga2V5ICsgJzogJ10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdFZhbHVlKHRhcmdldFtrZXldLCBmYWxzZSlcclxuICAgICAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIF07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBmb3JtYXRWYWx1ZSh2LCBhc1JhdyA9IHRydWUpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHYgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbJ3NwYW4nLCBudW1iZXJTdHlsZSwgdl07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICByZXR1cm4gWydzcGFuJywgc3RyaW5nU3R5bGUsIEpTT04uc3RyaW5naWZ5KHYpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHYgPT09ICdib29sZWFuJykge1xyXG4gICAgICAgICAgICByZXR1cm4gWydzcGFuJywga2V5d29yZFN0eWxlLCB2XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNPYmplY3QodikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFsnb2JqZWN0JywgeyBvYmplY3Q6IGFzUmF3ID8gdG9SYXcodikgOiB2IH1dO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIFsnc3BhbicsIHN0cmluZ1N0eWxlLCBTdHJpbmcodildO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGV4dHJhY3RLZXlzKGluc3RhbmNlLCB0eXBlKSB7XHJcbiAgICAgICAgY29uc3QgQ29tcCA9IGluc3RhbmNlLnR5cGU7XHJcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oQ29tcCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBleHRyYWN0ZWQgPSB7fTtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBpbnN0YW5jZS5jdHgpIHtcclxuICAgICAgICAgICAgaWYgKGlzS2V5T2ZUeXBlKENvbXAsIGtleSwgdHlwZSkpIHtcclxuICAgICAgICAgICAgICAgIGV4dHJhY3RlZFtrZXldID0gaW5zdGFuY2UuY3R4W2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGV4dHJhY3RlZDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGlzS2V5T2ZUeXBlKENvbXAsIGtleSwgdHlwZSkge1xyXG4gICAgICAgIGNvbnN0IG9wdHMgPSBDb21wW3R5cGVdO1xyXG4gICAgICAgIGlmICgoaXNBcnJheShvcHRzKSAmJiBvcHRzLmluY2x1ZGVzKGtleSkpIHx8XHJcbiAgICAgICAgICAgIChpc09iamVjdChvcHRzKSAmJiBrZXkgaW4gb3B0cykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChDb21wLmV4dGVuZHMgJiYgaXNLZXlPZlR5cGUoQ29tcC5leHRlbmRzLCBrZXksIHR5cGUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoQ29tcC5taXhpbnMgJiYgQ29tcC5taXhpbnMuc29tZShtID0+IGlzS2V5T2ZUeXBlKG0sIGtleSwgdHlwZSkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGdlblJlZkZsYWcodikge1xyXG4gICAgICAgIGlmIChpc1NoYWxsb3codikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGBTaGFsbG93UmVmYDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHYuZWZmZWN0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBgQ29tcHV0ZWRSZWZgO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYFJlZmA7XHJcbiAgICB9XHJcbiAgICBpZiAod2luZG93LmRldnRvb2xzRm9ybWF0dGVycykge1xyXG4gICAgICAgIHdpbmRvdy5kZXZ0b29sc0Zvcm1hdHRlcnMucHVzaChmb3JtYXR0ZXIpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgd2luZG93LmRldnRvb2xzRm9ybWF0dGVycyA9IFtmb3JtYXR0ZXJdO1xyXG4gICAgfVxyXG59XG5cbmZ1bmN0aW9uIHdpdGhNZW1vKG1lbW8sIHJlbmRlciwgY2FjaGUsIGluZGV4KSB7XHJcbiAgICBjb25zdCBjYWNoZWQgPSBjYWNoZVtpbmRleF07XHJcbiAgICBpZiAoY2FjaGVkICYmIGlzTWVtb1NhbWUoY2FjaGVkLCBtZW1vKSkge1xyXG4gICAgICAgIHJldHVybiBjYWNoZWQ7XHJcbiAgICB9XHJcbiAgICBjb25zdCByZXQgPSByZW5kZXIoKTtcclxuICAgIC8vIHNoYWxsb3cgY2xvbmVcclxuICAgIHJldC5tZW1vID0gbWVtby5zbGljZSgpO1xyXG4gICAgcmV0dXJuIChjYWNoZVtpbmRleF0gPSByZXQpO1xyXG59XHJcbmZ1bmN0aW9uIGlzTWVtb1NhbWUoY2FjaGVkLCBtZW1vKSB7XHJcbiAgICBjb25zdCBwcmV2ID0gY2FjaGVkLm1lbW87XHJcbiAgICBpZiAocHJldi5sZW5ndGggIT0gbWVtby5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZXYubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAoaGFzQ2hhbmdlZChwcmV2W2ldLCBtZW1vW2ldKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gbWFrZSBzdXJlIHRvIGxldCBwYXJlbnQgYmxvY2sgdHJhY2sgaXQgd2hlbiByZXR1cm5pbmcgY2FjaGVkXHJcbiAgICBpZiAoaXNCbG9ja1RyZWVFbmFibGVkID4gMCAmJiBjdXJyZW50QmxvY2spIHtcclxuICAgICAgICBjdXJyZW50QmxvY2sucHVzaChjYWNoZWQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cblxuLy8gQ29yZSBBUEkgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbmNvbnN0IHZlcnNpb24gPSBcIjMuMi4zNlwiO1xyXG5jb25zdCBfc3NyVXRpbHMgPSB7XHJcbiAgICBjcmVhdGVDb21wb25lbnRJbnN0YW5jZSxcclxuICAgIHNldHVwQ29tcG9uZW50LFxyXG4gICAgcmVuZGVyQ29tcG9uZW50Um9vdCxcclxuICAgIHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSxcclxuICAgIGlzVk5vZGUsXHJcbiAgICBub3JtYWxpemVWTm9kZVxyXG59O1xyXG4vKipcclxuICogU1NSIHV0aWxzIGZvciBcXEB2dWUvc2VydmVyLXJlbmRlcmVyLiBPbmx5IGV4cG9zZWQgaW4gY2pzIGJ1aWxkcy5cclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jb25zdCBzc3JVdGlscyA9IChfc3NyVXRpbHMgKTtcclxuLyoqXHJcbiAqIEBpbnRlcm5hbCBvbmx5IGV4cG9zZWQgaW4gY29tcGF0IGJ1aWxkc1xyXG4gKi9cclxuY29uc3QgcmVzb2x2ZUZpbHRlciA9IG51bGw7XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWwgb25seSBleHBvc2VkIGluIGNvbXBhdCBidWlsZHMuXHJcbiAqL1xyXG5jb25zdCBjb21wYXRVdGlscyA9IChudWxsKTtcblxuZXhwb3J0IHsgQmFzZVRyYW5zaXRpb24sIENvbW1lbnQsIEZyYWdtZW50LCBLZWVwQWxpdmUsIFN0YXRpYywgU3VzcGVuc2UsIFRlbGVwb3J0LCBUZXh0LCBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZywgY2FsbFdpdGhFcnJvckhhbmRsaW5nLCBjbG9uZVZOb2RlLCBjb21wYXRVdGlscywgY29tcHV0ZWQsIGNyZWF0ZUJsb2NrLCBjcmVhdGVDb21tZW50Vk5vZGUsIGNyZWF0ZUVsZW1lbnRCbG9jaywgY3JlYXRlQmFzZVZOb2RlIGFzIGNyZWF0ZUVsZW1lbnRWTm9kZSwgY3JlYXRlSHlkcmF0aW9uUmVuZGVyZXIsIGNyZWF0ZVByb3BzUmVzdFByb3h5LCBjcmVhdGVSZW5kZXJlciwgY3JlYXRlU2xvdHMsIGNyZWF0ZVN0YXRpY1ZOb2RlLCBjcmVhdGVUZXh0Vk5vZGUsIGNyZWF0ZVZOb2RlLCBkZWZpbmVBc3luY0NvbXBvbmVudCwgZGVmaW5lQ29tcG9uZW50LCBkZWZpbmVFbWl0cywgZGVmaW5lRXhwb3NlLCBkZWZpbmVQcm9wcywgZGV2dG9vbHMsIGdldEN1cnJlbnRJbnN0YW5jZSwgZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuLCBndWFyZFJlYWN0aXZlUHJvcHMsIGgsIGhhbmRsZUVycm9yLCBpbml0Q3VzdG9tRm9ybWF0dGVyLCBpbmplY3QsIGlzTWVtb1NhbWUsIGlzUnVudGltZU9ubHksIGlzVk5vZGUsIG1lcmdlRGVmYXVsdHMsIG1lcmdlUHJvcHMsIG5leHRUaWNrLCBvbkFjdGl2YXRlZCwgb25CZWZvcmVNb3VudCwgb25CZWZvcmVVbm1vdW50LCBvbkJlZm9yZVVwZGF0ZSwgb25EZWFjdGl2YXRlZCwgb25FcnJvckNhcHR1cmVkLCBvbk1vdW50ZWQsIG9uUmVuZGVyVHJhY2tlZCwgb25SZW5kZXJUcmlnZ2VyZWQsIG9uU2VydmVyUHJlZmV0Y2gsIG9uVW5tb3VudGVkLCBvblVwZGF0ZWQsIG9wZW5CbG9jaywgcG9wU2NvcGVJZCwgcHJvdmlkZSwgcHVzaFNjb3BlSWQsIHF1ZXVlUG9zdEZsdXNoQ2IsIHJlZ2lzdGVyUnVudGltZUNvbXBpbGVyLCByZW5kZXJMaXN0LCByZW5kZXJTbG90LCByZXNvbHZlQ29tcG9uZW50LCByZXNvbHZlRGlyZWN0aXZlLCByZXNvbHZlRHluYW1pY0NvbXBvbmVudCwgcmVzb2x2ZUZpbHRlciwgcmVzb2x2ZVRyYW5zaXRpb25Ib29rcywgc2V0QmxvY2tUcmFja2luZywgc2V0RGV2dG9vbHNIb29rLCBzZXRUcmFuc2l0aW9uSG9va3MsIHNzckNvbnRleHRLZXksIHNzclV0aWxzLCB0b0hhbmRsZXJzLCB0cmFuc2Zvcm1WTm9kZUFyZ3MsIHVzZUF0dHJzLCB1c2VTU1JDb250ZXh0LCB1c2VTbG90cywgdXNlVHJhbnNpdGlvblN0YXRlLCB2ZXJzaW9uLCB3YXJuLCB3YXRjaCwgd2F0Y2hFZmZlY3QsIHdhdGNoUG9zdEVmZmVjdCwgd2F0Y2hTeW5jRWZmZWN0LCB3aXRoQXN5bmNDb250ZXh0LCB3aXRoQ3R4LCB3aXRoRGVmYXVsdHMsIHdpdGhEaXJlY3RpdmVzLCB3aXRoTWVtbywgd2l0aFNjb3BlSWQgfTtcbiIsImltcG9ydCB7IGNhbWVsaXplLCB3YXJuLCBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZywgZGVmaW5lQ29tcG9uZW50LCBuZXh0VGljaywgY3JlYXRlVk5vZGUsIGdldEN1cnJlbnRJbnN0YW5jZSwgd2F0Y2hQb3N0RWZmZWN0LCBvbk1vdW50ZWQsIG9uVW5tb3VudGVkLCBGcmFnbWVudCwgU3RhdGljLCBoLCBCYXNlVHJhbnNpdGlvbiwgdXNlVHJhbnNpdGlvblN0YXRlLCBvblVwZGF0ZWQsIHRvUmF3LCBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4sIHNldFRyYW5zaXRpb25Ib29rcywgcmVzb2x2ZVRyYW5zaXRpb25Ib29rcywgY3JlYXRlUmVuZGVyZXIsIGlzUnVudGltZU9ubHksIGNyZWF0ZUh5ZHJhdGlvblJlbmRlcmVyIH0gZnJvbSAnQHZ1ZS9ydW50aW1lLWNvcmUnO1xuZXhwb3J0ICogZnJvbSAnQHZ1ZS9ydW50aW1lLWNvcmUnO1xuaW1wb3J0IHsgaXNTdHJpbmcsIGlzQXJyYXksIGh5cGhlbmF0ZSwgY2FwaXRhbGl6ZSwgaXNTcGVjaWFsQm9vbGVhbkF0dHIsIGluY2x1ZGVCb29sZWFuQXR0ciwgaXNPbiwgaXNNb2RlbExpc3RlbmVyLCBpc0Z1bmN0aW9uLCB0b051bWJlciwgY2FtZWxpemUgYXMgY2FtZWxpemUkMSwgZXh0ZW5kLCBFTVBUWV9PQkosIGlzT2JqZWN0LCBpbnZva2VBcnJheUZucywgbG9vc2VJbmRleE9mLCBpc1NldCwgbG9vc2VFcXVhbCwgaXNIVE1MVGFnLCBpc1NWR1RhZyB9IGZyb20gJ0B2dWUvc2hhcmVkJztcblxuY29uc3Qgc3ZnTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xyXG5jb25zdCBkb2MgPSAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IGRvY3VtZW50IDogbnVsbCk7XHJcbmNvbnN0IHRlbXBsYXRlQ29udGFpbmVyID0gZG9jICYmIC8qI19fUFVSRV9fKi8gZG9jLmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XHJcbmNvbnN0IG5vZGVPcHMgPSB7XHJcbiAgICBpbnNlcnQ6IChjaGlsZCwgcGFyZW50LCBhbmNob3IpID0+IHtcclxuICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLCBhbmNob3IgfHwgbnVsbCk7XHJcbiAgICB9LFxyXG4gICAgcmVtb3ZlOiBjaGlsZCA9PiB7XHJcbiAgICAgICAgY29uc3QgcGFyZW50ID0gY2hpbGQucGFyZW50Tm9kZTtcclxuICAgICAgICBpZiAocGFyZW50KSB7XHJcbiAgICAgICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChjaGlsZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGNyZWF0ZUVsZW1lbnQ6ICh0YWcsIGlzU1ZHLCBpcywgcHJvcHMpID0+IHtcclxuICAgICAgICBjb25zdCBlbCA9IGlzU1ZHXHJcbiAgICAgICAgICAgID8gZG9jLmNyZWF0ZUVsZW1lbnROUyhzdmdOUywgdGFnKVxyXG4gICAgICAgICAgICA6IGRvYy5jcmVhdGVFbGVtZW50KHRhZywgaXMgPyB7IGlzIH0gOiB1bmRlZmluZWQpO1xyXG4gICAgICAgIGlmICh0YWcgPT09ICdzZWxlY3QnICYmIHByb3BzICYmIHByb3BzLm11bHRpcGxlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdtdWx0aXBsZScsIHByb3BzLm11bHRpcGxlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGVsO1xyXG4gICAgfSxcclxuICAgIGNyZWF0ZVRleHQ6IHRleHQgPT4gZG9jLmNyZWF0ZVRleHROb2RlKHRleHQpLFxyXG4gICAgY3JlYXRlQ29tbWVudDogdGV4dCA9PiBkb2MuY3JlYXRlQ29tbWVudCh0ZXh0KSxcclxuICAgIHNldFRleHQ6IChub2RlLCB0ZXh0KSA9PiB7XHJcbiAgICAgICAgbm9kZS5ub2RlVmFsdWUgPSB0ZXh0O1xyXG4gICAgfSxcclxuICAgIHNldEVsZW1lbnRUZXh0OiAoZWwsIHRleHQpID0+IHtcclxuICAgICAgICBlbC50ZXh0Q29udGVudCA9IHRleHQ7XHJcbiAgICB9LFxyXG4gICAgcGFyZW50Tm9kZTogbm9kZSA9PiBub2RlLnBhcmVudE5vZGUsXHJcbiAgICBuZXh0U2libGluZzogbm9kZSA9PiBub2RlLm5leHRTaWJsaW5nLFxyXG4gICAgcXVlcnlTZWxlY3Rvcjogc2VsZWN0b3IgPT4gZG9jLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpLFxyXG4gICAgc2V0U2NvcGVJZChlbCwgaWQpIHtcclxuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoaWQsICcnKTtcclxuICAgIH0sXHJcbiAgICBjbG9uZU5vZGUoZWwpIHtcclxuICAgICAgICBjb25zdCBjbG9uZWQgPSBlbC5jbG9uZU5vZGUodHJ1ZSk7XHJcbiAgICAgICAgLy8gIzMwNzJcclxuICAgICAgICAvLyAtIGluIGBwYXRjaERPTVByb3BgLCB3ZSBzdG9yZSB0aGUgYWN0dWFsIHZhbHVlIGluIHRoZSBgZWwuX3ZhbHVlYCBwcm9wZXJ0eS5cclxuICAgICAgICAvLyAtIG5vcm1hbGx5LCBlbGVtZW50cyB1c2luZyBgOnZhbHVlYCBiaW5kaW5ncyB3aWxsIG5vdCBiZSBob2lzdGVkLCBidXQgaWZcclxuICAgICAgICAvLyAgIHRoZSBib3VuZCB2YWx1ZSBpcyBhIGNvbnN0YW50LCBlLmcuIGA6dmFsdWU9XCJ0cnVlXCJgIC0gdGhleSBkbyBnZXRcclxuICAgICAgICAvLyAgIGhvaXN0ZWQuXHJcbiAgICAgICAgLy8gLSBpbiBwcm9kdWN0aW9uLCBob2lzdGVkIG5vZGVzIGFyZSBjbG9uZWQgd2hlbiBzdWJzZXF1ZW50IGluc2VydHMsIGJ1dFxyXG4gICAgICAgIC8vICAgY2xvbmVOb2RlKCkgZG9lcyBub3QgY29weSB0aGUgY3VzdG9tIHByb3BlcnR5IHdlIGF0dGFjaGVkLlxyXG4gICAgICAgIC8vIC0gVGhpcyBtYXkgbmVlZCB0byBhY2NvdW50IGZvciBvdGhlciBjdXN0b20gRE9NIHByb3BlcnRpZXMgd2UgYXR0YWNoIHRvXHJcbiAgICAgICAgLy8gICBlbGVtZW50cyBpbiBhZGRpdGlvbiB0byBgX3ZhbHVlYCBpbiB0aGUgZnV0dXJlLlxyXG4gICAgICAgIGlmIChgX3ZhbHVlYCBpbiBlbCkge1xyXG4gICAgICAgICAgICBjbG9uZWQuX3ZhbHVlID0gZWwuX3ZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2xvbmVkO1xyXG4gICAgfSxcclxuICAgIC8vIF9fVU5TQUZFX19cclxuICAgIC8vIFJlYXNvbjogaW5uZXJIVE1MLlxyXG4gICAgLy8gU3RhdGljIGNvbnRlbnQgaGVyZSBjYW4gb25seSBjb21lIGZyb20gY29tcGlsZWQgdGVtcGxhdGVzLlxyXG4gICAgLy8gQXMgbG9uZyBhcyB0aGUgdXNlciBvbmx5IHVzZXMgdHJ1c3RlZCB0ZW1wbGF0ZXMsIHRoaXMgaXMgc2FmZS5cclxuICAgIGluc2VydFN0YXRpY0NvbnRlbnQoY29udGVudCwgcGFyZW50LCBhbmNob3IsIGlzU1ZHLCBzdGFydCwgZW5kKSB7XHJcbiAgICAgICAgLy8gPHBhcmVudD4gYmVmb3JlIHwgZmlyc3QgLi4uIGxhc3QgfCBhbmNob3IgPC9wYXJlbnQ+XHJcbiAgICAgICAgY29uc3QgYmVmb3JlID0gYW5jaG9yID8gYW5jaG9yLnByZXZpb3VzU2libGluZyA6IHBhcmVudC5sYXN0Q2hpbGQ7XHJcbiAgICAgICAgLy8gIzUzMDggY2FuIG9ubHkgdGFrZSBjYWNoZWQgcGF0aCBpZjpcclxuICAgICAgICAvLyAtIGhhcyBhIHNpbmdsZSByb290IG5vZGVcclxuICAgICAgICAvLyAtIG5leHRTaWJsaW5nIGluZm8gaXMgc3RpbGwgYXZhaWxhYmxlXHJcbiAgICAgICAgaWYgKHN0YXJ0ICYmIChzdGFydCA9PT0gZW5kIHx8IHN0YXJ0Lm5leHRTaWJsaW5nKSkge1xyXG4gICAgICAgICAgICAvLyBjYWNoZWRcclxuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoc3RhcnQuY2xvbmVOb2RlKHRydWUpLCBhbmNob3IpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0ID09PSBlbmQgfHwgIShzdGFydCA9IHN0YXJ0Lm5leHRTaWJsaW5nKSlcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gZnJlc2ggaW5zZXJ0XHJcbiAgICAgICAgICAgIHRlbXBsYXRlQ29udGFpbmVyLmlubmVySFRNTCA9IGlzU1ZHID8gYDxzdmc+JHtjb250ZW50fTwvc3ZnPmAgOiBjb250ZW50O1xyXG4gICAgICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IHRlbXBsYXRlQ29udGFpbmVyLmNvbnRlbnQ7XHJcbiAgICAgICAgICAgIGlmIChpc1NWRykge1xyXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIG91dGVyIHN2ZyB3cmFwcGVyXHJcbiAgICAgICAgICAgICAgICBjb25zdCB3cmFwcGVyID0gdGVtcGxhdGUuZmlyc3RDaGlsZDtcclxuICAgICAgICAgICAgICAgIHdoaWxlICh3cmFwcGVyLmZpcnN0Q2hpbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZS5hcHBlbmRDaGlsZCh3cmFwcGVyLmZpcnN0Q2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGVtcGxhdGUucmVtb3ZlQ2hpbGQod3JhcHBlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZSh0ZW1wbGF0ZSwgYW5jaG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgLy8gZmlyc3RcclxuICAgICAgICAgICAgYmVmb3JlID8gYmVmb3JlLm5leHRTaWJsaW5nIDogcGFyZW50LmZpcnN0Q2hpbGQsXHJcbiAgICAgICAgICAgIC8vIGxhc3RcclxuICAgICAgICAgICAgYW5jaG9yID8gYW5jaG9yLnByZXZpb3VzU2libGluZyA6IHBhcmVudC5sYXN0Q2hpbGRcclxuICAgICAgICBdO1xyXG4gICAgfVxyXG59O1xuXG4vLyBjb21waWxlciBzaG91bGQgbm9ybWFsaXplIGNsYXNzICsgOmNsYXNzIGJpbmRpbmdzIG9uIHRoZSBzYW1lIGVsZW1lbnRcclxuLy8gaW50byBhIHNpbmdsZSBiaW5kaW5nIFsnc3RhdGljQ2xhc3MnLCBkeW5hbWljXVxyXG5mdW5jdGlvbiBwYXRjaENsYXNzKGVsLCB2YWx1ZSwgaXNTVkcpIHtcclxuICAgIC8vIGRpcmVjdGx5IHNldHRpbmcgY2xhc3NOYW1lIHNob3VsZCBiZSBmYXN0ZXIgdGhhbiBzZXRBdHRyaWJ1dGUgaW4gdGhlb3J5XHJcbiAgICAvLyBpZiB0aGlzIGlzIGFuIGVsZW1lbnQgZHVyaW5nIGEgdHJhbnNpdGlvbiwgdGFrZSB0aGUgdGVtcG9yYXJ5IHRyYW5zaXRpb25cclxuICAgIC8vIGNsYXNzZXMgaW50byBhY2NvdW50LlxyXG4gICAgY29uc3QgdHJhbnNpdGlvbkNsYXNzZXMgPSBlbC5fdnRjO1xyXG4gICAgaWYgKHRyYW5zaXRpb25DbGFzc2VzKSB7XHJcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgPyBbdmFsdWUsIC4uLnRyYW5zaXRpb25DbGFzc2VzXSA6IFsuLi50cmFuc2l0aW9uQ2xhc3Nlc10pLmpvaW4oJyAnKTtcclxuICAgIH1cclxuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNTVkcpIHtcclxuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZWwuY2xhc3NOYW1lID0gdmFsdWU7XHJcbiAgICB9XHJcbn1cblxuZnVuY3Rpb24gcGF0Y2hTdHlsZShlbCwgcHJldiwgbmV4dCkge1xyXG4gICAgY29uc3Qgc3R5bGUgPSBlbC5zdHlsZTtcclxuICAgIGNvbnN0IGlzQ3NzU3RyaW5nID0gaXNTdHJpbmcobmV4dCk7XHJcbiAgICBpZiAobmV4dCAmJiAhaXNDc3NTdHJpbmcpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBuZXh0KSB7XHJcbiAgICAgICAgICAgIHNldFN0eWxlKHN0eWxlLCBrZXksIG5leHRba2V5XSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcmV2ICYmICFpc1N0cmluZyhwcmV2KSkge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcmV2KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV4dFtrZXldID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXRTdHlsZShzdHlsZSwga2V5LCAnJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBjdXJyZW50RGlzcGxheSA9IHN0eWxlLmRpc3BsYXk7XHJcbiAgICAgICAgaWYgKGlzQ3NzU3RyaW5nKSB7XHJcbiAgICAgICAgICAgIGlmIChwcmV2ICE9PSBuZXh0KSB7XHJcbiAgICAgICAgICAgICAgICBzdHlsZS5jc3NUZXh0ID0gbmV4dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwcmV2KSB7XHJcbiAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaW5kaWNhdGVzIHRoYXQgdGhlIGBkaXNwbGF5YCBvZiB0aGUgZWxlbWVudCBpcyBjb250cm9sbGVkIGJ5IGB2LXNob3dgLFxyXG4gICAgICAgIC8vIHNvIHdlIGFsd2F5cyBrZWVwIHRoZSBjdXJyZW50IGBkaXNwbGF5YCB2YWx1ZSByZWdhcmRsZXNzIG9mIHRoZSBgc3R5bGVgXHJcbiAgICAgICAgLy8gdmFsdWUsIHRodXMgaGFuZGluZyBvdmVyIGNvbnRyb2wgdG8gYHYtc2hvd2AuXHJcbiAgICAgICAgaWYgKCdfdm9kJyBpbiBlbCkge1xyXG4gICAgICAgICAgICBzdHlsZS5kaXNwbGF5ID0gY3VycmVudERpc3BsYXk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmNvbnN0IGltcG9ydGFudFJFID0gL1xccyohaW1wb3J0YW50JC87XHJcbmZ1bmN0aW9uIHNldFN0eWxlKHN0eWxlLCBuYW1lLCB2YWwpIHtcclxuICAgIGlmIChpc0FycmF5KHZhbCkpIHtcclxuICAgICAgICB2YWwuZm9yRWFjaCh2ID0+IHNldFN0eWxlKHN0eWxlLCBuYW1lLCB2KSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAodmFsID09IG51bGwpXHJcbiAgICAgICAgICAgIHZhbCA9ICcnO1xyXG4gICAgICAgIGlmIChuYW1lLnN0YXJ0c1dpdGgoJy0tJykpIHtcclxuICAgICAgICAgICAgLy8gY3VzdG9tIHByb3BlcnR5IGRlZmluaXRpb25cclxuICAgICAgICAgICAgc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByZWZpeGVkID0gYXV0b1ByZWZpeChzdHlsZSwgbmFtZSk7XHJcbiAgICAgICAgICAgIGlmIChpbXBvcnRhbnRSRS50ZXN0KHZhbCkpIHtcclxuICAgICAgICAgICAgICAgIC8vICFpbXBvcnRhbnRcclxuICAgICAgICAgICAgICAgIHN0eWxlLnNldFByb3BlcnR5KGh5cGhlbmF0ZShwcmVmaXhlZCksIHZhbC5yZXBsYWNlKGltcG9ydGFudFJFLCAnJyksICdpbXBvcnRhbnQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHN0eWxlW3ByZWZpeGVkXSA9IHZhbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5jb25zdCBwcmVmaXhlcyA9IFsnV2Via2l0JywgJ01veicsICdtcyddO1xyXG5jb25zdCBwcmVmaXhDYWNoZSA9IHt9O1xyXG5mdW5jdGlvbiBhdXRvUHJlZml4KHN0eWxlLCByYXdOYW1lKSB7XHJcbiAgICBjb25zdCBjYWNoZWQgPSBwcmVmaXhDYWNoZVtyYXdOYW1lXTtcclxuICAgIGlmIChjYWNoZWQpIHtcclxuICAgICAgICByZXR1cm4gY2FjaGVkO1xyXG4gICAgfVxyXG4gICAgbGV0IG5hbWUgPSBjYW1lbGl6ZShyYXdOYW1lKTtcclxuICAgIGlmIChuYW1lICE9PSAnZmlsdGVyJyAmJiBuYW1lIGluIHN0eWxlKSB7XHJcbiAgICAgICAgcmV0dXJuIChwcmVmaXhDYWNoZVtyYXdOYW1lXSA9IG5hbWUpO1xyXG4gICAgfVxyXG4gICAgbmFtZSA9IGNhcGl0YWxpemUobmFtZSk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZWZpeGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgcHJlZml4ZWQgPSBwcmVmaXhlc1tpXSArIG5hbWU7XHJcbiAgICAgICAgaWYgKHByZWZpeGVkIGluIHN0eWxlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAocHJlZml4Q2FjaGVbcmF3TmFtZV0gPSBwcmVmaXhlZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJhd05hbWU7XHJcbn1cblxuY29uc3QgeGxpbmtOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJztcclxuZnVuY3Rpb24gcGF0Y2hBdHRyKGVsLCBrZXksIHZhbHVlLCBpc1NWRywgaW5zdGFuY2UpIHtcclxuICAgIGlmIChpc1NWRyAmJiBrZXkuc3RhcnRzV2l0aCgneGxpbms6JykpIHtcclxuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBrZXkuc2xpY2UoNiwga2V5Lmxlbmd0aCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlTlMoeGxpbmtOUywga2V5LCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gbm90ZSB3ZSBhcmUgb25seSBjaGVja2luZyBib29sZWFuIGF0dHJpYnV0ZXMgdGhhdCBkb24ndCBoYXZlIGFcclxuICAgICAgICAvLyBjb3JyZXNwb25kaW5nIGRvbSBwcm9wIG9mIHRoZSBzYW1lIG5hbWUgaGVyZS5cclxuICAgICAgICBjb25zdCBpc0Jvb2xlYW4gPSBpc1NwZWNpYWxCb29sZWFuQXR0cihrZXkpO1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IChpc0Jvb2xlYW4gJiYgIWluY2x1ZGVCb29sZWFuQXR0cih2YWx1ZSkpKSB7XHJcbiAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwgaXNCb29sZWFuID8gJycgOiB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbi8vIF9fVU5TQUZFX19cclxuLy8gZnVuY3Rpb25zLiBUaGUgdXNlciBpcyByZXNwb25zaWJsZSBmb3IgdXNpbmcgdGhlbSB3aXRoIG9ubHkgdHJ1c3RlZCBjb250ZW50LlxyXG5mdW5jdGlvbiBwYXRjaERPTVByb3AoZWwsIGtleSwgdmFsdWUsIFxyXG4vLyB0aGUgZm9sbG93aW5nIGFyZ3MgYXJlIHBhc3NlZCBvbmx5IGR1ZSB0byBwb3RlbnRpYWwgaW5uZXJIVE1ML3RleHRDb250ZW50XHJcbi8vIG92ZXJyaWRpbmcgZXhpc3RpbmcgVk5vZGVzLCBpbiB3aGljaCBjYXNlIHRoZSBvbGQgdHJlZSBtdXN0IGJlIHByb3Blcmx5XHJcbi8vIHVubW91bnRlZC5cclxucHJldkNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB1bm1vdW50Q2hpbGRyZW4pIHtcclxuICAgIGlmIChrZXkgPT09ICdpbm5lckhUTUwnIHx8IGtleSA9PT0gJ3RleHRDb250ZW50Jykge1xyXG4gICAgICAgIGlmIChwcmV2Q2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgdW5tb3VudENoaWxkcmVuKHByZXZDaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsW2tleV0gPSB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoa2V5ID09PSAndmFsdWUnICYmXHJcbiAgICAgICAgZWwudGFnTmFtZSAhPT0gJ1BST0dSRVNTJyAmJlxyXG4gICAgICAgIC8vIGN1c3RvbSBlbGVtZW50cyBtYXkgdXNlIF92YWx1ZSBpbnRlcm5hbGx5XHJcbiAgICAgICAgIWVsLnRhZ05hbWUuaW5jbHVkZXMoJy0nKSkge1xyXG4gICAgICAgIC8vIHN0b3JlIHZhbHVlIGFzIF92YWx1ZSBhcyB3ZWxsIHNpbmNlXHJcbiAgICAgICAgLy8gbm9uLXN0cmluZyB2YWx1ZXMgd2lsbCBiZSBzdHJpbmdpZmllZC5cclxuICAgICAgICBlbC5fdmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xyXG4gICAgICAgIGlmIChlbC52YWx1ZSAhPT0gbmV3VmFsdWUgfHxcclxuICAgICAgICAgICAgLy8gIzQ5NTY6IGFsd2F5cyBzZXQgZm9yIE9QVElPTiBlbGVtZW50cyBiZWNhdXNlIGl0cyB2YWx1ZSBmYWxscyBiYWNrIHRvXHJcbiAgICAgICAgICAgIC8vIHRleHRDb250ZW50IGlmIG5vIHZhbHVlIGF0dHJpYnV0ZSBpcyBwcmVzZW50LiBBbmQgc2V0dGluZyAudmFsdWUgZm9yXHJcbiAgICAgICAgICAgIC8vIE9QVElPTiBoYXMgbm8gc2lkZSBlZmZlY3RcclxuICAgICAgICAgICAgZWwudGFnTmFtZSA9PT0gJ09QVElPTicpIHtcclxuICAgICAgICAgICAgZWwudmFsdWUgPSBuZXdWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcclxuICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGxldCBuZWVkUmVtb3ZlID0gZmFsc2U7XHJcbiAgICBpZiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09IG51bGwpIHtcclxuICAgICAgICBjb25zdCB0eXBlID0gdHlwZW9mIGVsW2tleV07XHJcbiAgICAgICAgaWYgKHR5cGUgPT09ICdib29sZWFuJykge1xyXG4gICAgICAgICAgICAvLyBlLmcuIDxzZWxlY3QgbXVsdGlwbGU+IGNvbXBpbGVzIHRvIHsgbXVsdGlwbGU6ICcnIH1cclxuICAgICAgICAgICAgdmFsdWUgPSBpbmNsdWRlQm9vbGVhbkF0dHIodmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PSBudWxsICYmIHR5cGUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIC8vIGUuZy4gPGRpdiA6aWQ9XCJudWxsXCI+XHJcbiAgICAgICAgICAgIHZhbHVlID0gJyc7XHJcbiAgICAgICAgICAgIG5lZWRSZW1vdmUgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAvLyBlLmcuIDxpbWcgOndpZHRoPVwibnVsbFwiPlxyXG4gICAgICAgICAgICAvLyB0aGUgdmFsdWUgb2Ygc29tZSBJREwgYXR0ciBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwLCBlLmcuIGlucHV0LnNpemUgPSAwIC0+IGVycm9yXHJcbiAgICAgICAgICAgIHZhbHVlID0gMDtcclxuICAgICAgICAgICAgbmVlZFJlbW92ZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gc29tZSBwcm9wZXJ0aWVzIHBlcmZvcm0gdmFsdWUgdmFsaWRhdGlvbiBhbmQgdGhyb3csXHJcbiAgICAvLyBzb21lIHByb3BlcnRpZXMgaGFzIGdldHRlciwgbm8gc2V0dGVyLCB3aWxsIGVycm9yIGluICd1c2Ugc3RyaWN0J1xyXG4gICAgLy8gZWcuIDxzZWxlY3QgOnR5cGU9XCJudWxsXCI+PC9zZWxlY3Q+IDxzZWxlY3QgOndpbGxWYWxpZGF0ZT1cIm51bGxcIj48L3NlbGVjdD5cclxuICAgIHRyeSB7XHJcbiAgICAgICAgZWxba2V5XSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYEZhaWxlZCBzZXR0aW5nIHByb3AgXCIke2tleX1cIiBvbiA8JHtlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCl9PjogYCArXHJcbiAgICAgICAgICAgICAgICBgdmFsdWUgJHt2YWx1ZX0gaXMgaW52YWxpZC5gLCBlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBuZWVkUmVtb3ZlICYmIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xyXG59XG5cbi8vIEFzeW5jIGVkZ2UgY2FzZSBmaXggcmVxdWlyZXMgc3RvcmluZyBhbiBldmVudCBsaXN0ZW5lcidzIGF0dGFjaCB0aW1lc3RhbXAuXHJcbmNvbnN0IFtfZ2V0Tm93LCBza2lwVGltZXN0YW1wQ2hlY2tdID0gLyojX19QVVJFX18qLyAoKCkgPT4ge1xyXG4gICAgbGV0IF9nZXROb3cgPSBEYXRlLm5vdztcclxuICAgIGxldCBza2lwVGltZXN0YW1wQ2hlY2sgPSBmYWxzZTtcclxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIC8vIERldGVybWluZSB3aGF0IGV2ZW50IHRpbWVzdGFtcCB0aGUgYnJvd3NlciBpcyB1c2luZy4gQW5ub3lpbmdseSwgdGhlXHJcbiAgICAgICAgLy8gdGltZXN0YW1wIGNhbiBlaXRoZXIgYmUgaGktcmVzIChyZWxhdGl2ZSB0byBwYWdlIGxvYWQpIG9yIGxvdy1yZXNcclxuICAgICAgICAvLyAocmVsYXRpdmUgdG8gVU5JWCBlcG9jaCksIHNvIGluIG9yZGVyIHRvIGNvbXBhcmUgdGltZSB3ZSBoYXZlIHRvIHVzZSB0aGVcclxuICAgICAgICAvLyBzYW1lIHRpbWVzdGFtcCB0eXBlIHdoZW4gc2F2aW5nIHRoZSBmbHVzaCB0aW1lc3RhbXAuXHJcbiAgICAgICAgaWYgKERhdGUubm93KCkgPiBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKS50aW1lU3RhbXApIHtcclxuICAgICAgICAgICAgLy8gaWYgdGhlIGxvdy1yZXMgdGltZXN0YW1wIHdoaWNoIGlzIGJpZ2dlciB0aGFuIHRoZSBldmVudCB0aW1lc3RhbXBcclxuICAgICAgICAgICAgLy8gKHdoaWNoIGlzIGV2YWx1YXRlZCBBRlRFUikgaXQgbWVhbnMgdGhlIGV2ZW50IGlzIHVzaW5nIGEgaGktcmVzIHRpbWVzdGFtcCxcclxuICAgICAgICAgICAgLy8gYW5kIHdlIG5lZWQgdG8gdXNlIHRoZSBoaS1yZXMgdmVyc2lvbiBmb3IgZXZlbnQgbGlzdGVuZXJzIGFzIHdlbGwuXHJcbiAgICAgICAgICAgIF9nZXROb3cgPSBwZXJmb3JtYW5jZS5ub3cuYmluZChwZXJmb3JtYW5jZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vICMzNDg1OiBGaXJlZm94IDw9IDUzIGhhcyBpbmNvcnJlY3QgRXZlbnQudGltZVN0YW1wIGltcGxlbWVudGF0aW9uXHJcbiAgICAgICAgLy8gYW5kIGRvZXMgbm90IGZpcmUgbWljcm90YXNrcyBpbiBiZXR3ZWVuIGV2ZW50IHByb3BhZ2F0aW9uLCBzbyBzYWZlIHRvIGV4Y2x1ZGUuXHJcbiAgICAgICAgY29uc3QgZmZNYXRjaCA9IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvaSk7XHJcbiAgICAgICAgc2tpcFRpbWVzdGFtcENoZWNrID0gISEoZmZNYXRjaCAmJiBOdW1iZXIoZmZNYXRjaFsxXSkgPD0gNTMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFtfZ2V0Tm93LCBza2lwVGltZXN0YW1wQ2hlY2tdO1xyXG59KSgpO1xyXG4vLyBUbyBhdm9pZCB0aGUgb3ZlcmhlYWQgb2YgcmVwZWF0ZWRseSBjYWxsaW5nIHBlcmZvcm1hbmNlLm5vdygpLCB3ZSBjYWNoZVxyXG4vLyBhbmQgdXNlIHRoZSBzYW1lIHRpbWVzdGFtcCBmb3IgYWxsIGV2ZW50IGxpc3RlbmVycyBhdHRhY2hlZCBpbiB0aGUgc2FtZSB0aWNrLlxyXG5sZXQgY2FjaGVkTm93ID0gMDtcclxuY29uc3QgcCA9IC8qI19fUFVSRV9fKi8gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbmNvbnN0IHJlc2V0ID0gKCkgPT4ge1xyXG4gICAgY2FjaGVkTm93ID0gMDtcclxufTtcclxuY29uc3QgZ2V0Tm93ID0gKCkgPT4gY2FjaGVkTm93IHx8IChwLnRoZW4ocmVzZXQpLCAoY2FjaGVkTm93ID0gX2dldE5vdygpKSk7XHJcbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIoZWwsIGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKSB7XHJcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcclxufVxyXG5mdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKGVsLCBldmVudCwgaGFuZGxlciwgb3B0aW9ucykge1xyXG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XHJcbn1cclxuZnVuY3Rpb24gcGF0Y2hFdmVudChlbCwgcmF3TmFtZSwgcHJldlZhbHVlLCBuZXh0VmFsdWUsIGluc3RhbmNlID0gbnVsbCkge1xyXG4gICAgLy8gdmVpID0gdnVlIGV2ZW50IGludm9rZXJzXHJcbiAgICBjb25zdCBpbnZva2VycyA9IGVsLl92ZWkgfHwgKGVsLl92ZWkgPSB7fSk7XHJcbiAgICBjb25zdCBleGlzdGluZ0ludm9rZXIgPSBpbnZva2Vyc1tyYXdOYW1lXTtcclxuICAgIGlmIChuZXh0VmFsdWUgJiYgZXhpc3RpbmdJbnZva2VyKSB7XHJcbiAgICAgICAgLy8gcGF0Y2hcclxuICAgICAgICBleGlzdGluZ0ludm9rZXIudmFsdWUgPSBuZXh0VmFsdWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBbbmFtZSwgb3B0aW9uc10gPSBwYXJzZU5hbWUocmF3TmFtZSk7XHJcbiAgICAgICAgaWYgKG5leHRWYWx1ZSkge1xyXG4gICAgICAgICAgICAvLyBhZGRcclxuICAgICAgICAgICAgY29uc3QgaW52b2tlciA9IChpbnZva2Vyc1tyYXdOYW1lXSA9IGNyZWF0ZUludm9rZXIobmV4dFZhbHVlLCBpbnN0YW5jZSkpO1xyXG4gICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCBuYW1lLCBpbnZva2VyLCBvcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZXhpc3RpbmdJbnZva2VyKSB7XHJcbiAgICAgICAgICAgIC8vIHJlbW92ZVxyXG4gICAgICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyKGVsLCBuYW1lLCBleGlzdGluZ0ludm9rZXIsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICBpbnZva2Vyc1tyYXdOYW1lXSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuY29uc3Qgb3B0aW9uc01vZGlmaWVyUkUgPSAvKD86T25jZXxQYXNzaXZlfENhcHR1cmUpJC87XHJcbmZ1bmN0aW9uIHBhcnNlTmFtZShuYW1lKSB7XHJcbiAgICBsZXQgb3B0aW9ucztcclxuICAgIGlmIChvcHRpb25zTW9kaWZpZXJSRS50ZXN0KG5hbWUpKSB7XHJcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIGxldCBtO1xyXG4gICAgICAgIHdoaWxlICgobSA9IG5hbWUubWF0Y2gob3B0aW9uc01vZGlmaWVyUkUpKSkge1xyXG4gICAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgwLCBuYW1lLmxlbmd0aCAtIG1bMF0ubGVuZ3RoKTtcclxuICAgICAgICAgICAgb3B0aW9uc1ttWzBdLnRvTG93ZXJDYXNlKCldID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gW2h5cGhlbmF0ZShuYW1lLnNsaWNlKDIpKSwgb3B0aW9uc107XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlSW52b2tlcihpbml0aWFsVmFsdWUsIGluc3RhbmNlKSB7XHJcbiAgICBjb25zdCBpbnZva2VyID0gKGUpID0+IHtcclxuICAgICAgICAvLyBhc3luYyBlZGdlIGNhc2UgIzY1NjY6IGlubmVyIGNsaWNrIGV2ZW50IHRyaWdnZXJzIHBhdGNoLCBldmVudCBoYW5kbGVyXHJcbiAgICAgICAgLy8gYXR0YWNoZWQgdG8gb3V0ZXIgZWxlbWVudCBkdXJpbmcgcGF0Y2gsIGFuZCB0cmlnZ2VyZWQgYWdhaW4uIFRoaXNcclxuICAgICAgICAvLyBoYXBwZW5zIGJlY2F1c2UgYnJvd3NlcnMgZmlyZSBtaWNyb3Rhc2sgdGlja3MgYmV0d2VlbiBldmVudCBwcm9wYWdhdGlvbi5cclxuICAgICAgICAvLyB0aGUgc29sdXRpb24gaXMgc2ltcGxlOiB3ZSBzYXZlIHRoZSB0aW1lc3RhbXAgd2hlbiBhIGhhbmRsZXIgaXMgYXR0YWNoZWQsXHJcbiAgICAgICAgLy8gYW5kIHRoZSBoYW5kbGVyIHdvdWxkIG9ubHkgZmlyZSBpZiB0aGUgZXZlbnQgcGFzc2VkIHRvIGl0IHdhcyBmaXJlZFxyXG4gICAgICAgIC8vIEFGVEVSIGl0IHdhcyBhdHRhY2hlZC5cclxuICAgICAgICBjb25zdCB0aW1lU3RhbXAgPSBlLnRpbWVTdGFtcCB8fCBfZ2V0Tm93KCk7XHJcbiAgICAgICAgaWYgKHNraXBUaW1lc3RhbXBDaGVjayB8fCB0aW1lU3RhbXAgPj0gaW52b2tlci5hdHRhY2hlZCAtIDEpIHtcclxuICAgICAgICAgICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcocGF0Y2hTdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oZSwgaW52b2tlci52YWx1ZSksIGluc3RhbmNlLCA1IC8qIE5BVElWRV9FVkVOVF9IQU5ETEVSICovLCBbZV0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBpbnZva2VyLnZhbHVlID0gaW5pdGlhbFZhbHVlO1xyXG4gICAgaW52b2tlci5hdHRhY2hlZCA9IGdldE5vdygpO1xyXG4gICAgcmV0dXJuIGludm9rZXI7XHJcbn1cclxuZnVuY3Rpb24gcGF0Y2hTdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oZSwgdmFsdWUpIHtcclxuICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsU3RvcCA9IGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uO1xyXG4gICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBvcmlnaW5hbFN0b3AuY2FsbChlKTtcclxuICAgICAgICAgICAgZS5fc3RvcHBlZCA9IHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gdmFsdWUubWFwKGZuID0+IChlKSA9PiAhZS5fc3RvcHBlZCAmJiBmbiAmJiBmbihlKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbn1cblxuY29uc3QgbmF0aXZlT25SRSA9IC9eb25bYS16XS87XHJcbmNvbnN0IHBhdGNoUHJvcCA9IChlbCwga2V5LCBwcmV2VmFsdWUsIG5leHRWYWx1ZSwgaXNTVkcgPSBmYWxzZSwgcHJldkNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB1bm1vdW50Q2hpbGRyZW4pID0+IHtcclxuICAgIGlmIChrZXkgPT09ICdjbGFzcycpIHtcclxuICAgICAgICBwYXRjaENsYXNzKGVsLCBuZXh0VmFsdWUsIGlzU1ZHKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGtleSA9PT0gJ3N0eWxlJykge1xyXG4gICAgICAgIHBhdGNoU3R5bGUoZWwsIHByZXZWYWx1ZSwgbmV4dFZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzT24oa2V5KSkge1xyXG4gICAgICAgIC8vIGlnbm9yZSB2LW1vZGVsIGxpc3RlbmVyc1xyXG4gICAgICAgIGlmICghaXNNb2RlbExpc3RlbmVyKGtleSkpIHtcclxuICAgICAgICAgICAgcGF0Y2hFdmVudChlbCwga2V5LCBwcmV2VmFsdWUsIG5leHRWYWx1ZSwgcGFyZW50Q29tcG9uZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChrZXlbMF0gPT09ICcuJ1xyXG4gICAgICAgID8gKChrZXkgPSBrZXkuc2xpY2UoMSkpLCB0cnVlKVxyXG4gICAgICAgIDoga2V5WzBdID09PSAnXidcclxuICAgICAgICAgICAgPyAoKGtleSA9IGtleS5zbGljZSgxKSksIGZhbHNlKVxyXG4gICAgICAgICAgICA6IHNob3VsZFNldEFzUHJvcChlbCwga2V5LCBuZXh0VmFsdWUsIGlzU1ZHKSkge1xyXG4gICAgICAgIHBhdGNoRE9NUHJvcChlbCwga2V5LCBuZXh0VmFsdWUsIHByZXZDaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdW5tb3VudENoaWxkcmVuKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIHNwZWNpYWwgY2FzZSBmb3IgPGlucHV0IHYtbW9kZWwgdHlwZT1cImNoZWNrYm94XCI+IHdpdGhcclxuICAgICAgICAvLyA6dHJ1ZS12YWx1ZSAmIDpmYWxzZS12YWx1ZVxyXG4gICAgICAgIC8vIHN0b3JlIHZhbHVlIGFzIGRvbSBwcm9wZXJ0aWVzIHNpbmNlIG5vbi1zdHJpbmcgdmFsdWVzIHdpbGwgYmVcclxuICAgICAgICAvLyBzdHJpbmdpZmllZC5cclxuICAgICAgICBpZiAoa2V5ID09PSAndHJ1ZS12YWx1ZScpIHtcclxuICAgICAgICAgICAgZWwuX3RydWVWYWx1ZSA9IG5leHRWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAnZmFsc2UtdmFsdWUnKSB7XHJcbiAgICAgICAgICAgIGVsLl9mYWxzZVZhbHVlID0gbmV4dFZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwYXRjaEF0dHIoZWwsIGtleSwgbmV4dFZhbHVlLCBpc1NWRyk7XHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uIHNob3VsZFNldEFzUHJvcChlbCwga2V5LCB2YWx1ZSwgaXNTVkcpIHtcclxuICAgIGlmIChpc1NWRykge1xyXG4gICAgICAgIC8vIG1vc3Qga2V5cyBtdXN0IGJlIHNldCBhcyBhdHRyaWJ1dGUgb24gc3ZnIGVsZW1lbnRzIHRvIHdvcmtcclxuICAgICAgICAvLyAuLi5leGNlcHQgaW5uZXJIVE1MICYgdGV4dENvbnRlbnRcclxuICAgICAgICBpZiAoa2V5ID09PSAnaW5uZXJIVE1MJyB8fCBrZXkgPT09ICd0ZXh0Q29udGVudCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIG9yIG5hdGl2ZSBvbmNsaWNrIHdpdGggZnVuY3Rpb24gdmFsdWVzXHJcbiAgICAgICAgaWYgKGtleSBpbiBlbCAmJiBuYXRpdmVPblJFLnRlc3Qoa2V5KSAmJiBpc0Z1bmN0aW9uKHZhbHVlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLy8gdGhlc2UgYXJlIGVudW1lcmF0ZWQgYXR0cnMsIGhvd2V2ZXIgdGhlaXIgY29ycmVzcG9uZGluZyBET00gcHJvcGVydGllc1xyXG4gICAgLy8gYXJlIGFjdHVhbGx5IGJvb2xlYW5zIC0gdGhpcyBsZWFkcyB0byBzZXR0aW5nIGl0IHdpdGggYSBzdHJpbmcgXCJmYWxzZVwiXHJcbiAgICAvLyB2YWx1ZSBsZWFkaW5nIGl0IHRvIGJlIGNvZXJjZWQgdG8gYHRydWVgLCBzbyB3ZSBuZWVkIHRvIGFsd2F5cyB0cmVhdFxyXG4gICAgLy8gdGhlbSBhcyBhdHRyaWJ1dGVzLlxyXG4gICAgLy8gTm90ZSB0aGF0IGBjb250ZW50RWRpdGFibGVgIGRvZXNuJ3QgaGF2ZSB0aGlzIHByb2JsZW06IGl0cyBET01cclxuICAgIC8vIHByb3BlcnR5IGlzIGFsc28gZW51bWVyYXRlZCBzdHJpbmcgdmFsdWVzLlxyXG4gICAgaWYgKGtleSA9PT0gJ3NwZWxsY2hlY2snIHx8IGtleSA9PT0gJ2RyYWdnYWJsZScgfHwga2V5ID09PSAndHJhbnNsYXRlJykge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8vICMxNzg3LCAjMjg0MCBmb3JtIHByb3BlcnR5IG9uIGZvcm0gZWxlbWVudHMgaXMgcmVhZG9ubHkgYW5kIG11c3QgYmUgc2V0IGFzXHJcbiAgICAvLyBhdHRyaWJ1dGUuXHJcbiAgICBpZiAoa2V5ID09PSAnZm9ybScpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvLyAjMTUyNiA8aW5wdXQgbGlzdD4gbXVzdCBiZSBzZXQgYXMgYXR0cmlidXRlXHJcbiAgICBpZiAoa2V5ID09PSAnbGlzdCcgJiYgZWwudGFnTmFtZSA9PT0gJ0lOUFVUJykge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8vICMyNzY2IDx0ZXh0YXJlYSB0eXBlPiBtdXN0IGJlIHNldCBhcyBhdHRyaWJ1dGVcclxuICAgIGlmIChrZXkgPT09ICd0eXBlJyAmJiBlbC50YWdOYW1lID09PSAnVEVYVEFSRUEnKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLy8gbmF0aXZlIG9uY2xpY2sgd2l0aCBzdHJpbmcgdmFsdWUsIG11c3QgYmUgc2V0IGFzIGF0dHJpYnV0ZVxyXG4gICAgaWYgKG5hdGl2ZU9uUkUudGVzdChrZXkpICYmIGlzU3RyaW5nKHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiBrZXkgaW4gZWw7XHJcbn1cblxuZnVuY3Rpb24gZGVmaW5lQ3VzdG9tRWxlbWVudChvcHRpb25zLCBoeWRyYXRlKSB7XHJcbiAgICBjb25zdCBDb21wID0gZGVmaW5lQ29tcG9uZW50KG9wdGlvbnMpO1xyXG4gICAgY2xhc3MgVnVlQ3VzdG9tRWxlbWVudCBleHRlbmRzIFZ1ZUVsZW1lbnQge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKGluaXRpYWxQcm9wcykge1xyXG4gICAgICAgICAgICBzdXBlcihDb21wLCBpbml0aWFsUHJvcHMsIGh5ZHJhdGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFZ1ZUN1c3RvbUVsZW1lbnQuZGVmID0gQ29tcDtcclxuICAgIHJldHVybiBWdWVDdXN0b21FbGVtZW50O1xyXG59XHJcbmNvbnN0IGRlZmluZVNTUkN1c3RvbUVsZW1lbnQgPSAoKG9wdGlvbnMpID0+IHtcclxuICAgIC8vIEB0cy1pZ25vcmVcclxuICAgIHJldHVybiBkZWZpbmVDdXN0b21FbGVtZW50KG9wdGlvbnMsIGh5ZHJhdGUpO1xyXG59KTtcclxuY29uc3QgQmFzZUNsYXNzID0gKHR5cGVvZiBIVE1MRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgPyBIVE1MRWxlbWVudCA6IGNsYXNzIHtcclxufSk7XHJcbmNsYXNzIFZ1ZUVsZW1lbnQgZXh0ZW5kcyBCYXNlQ2xhc3Mge1xyXG4gICAgY29uc3RydWN0b3IoX2RlZiwgX3Byb3BzID0ge30sIGh5ZHJhdGUpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuX2RlZiA9IF9kZWY7XHJcbiAgICAgICAgdGhpcy5fcHJvcHMgPSBfcHJvcHM7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGludGVybmFsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5faW5zdGFuY2UgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3Jlc29sdmVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fbnVtYmVyUHJvcHMgPSBudWxsO1xyXG4gICAgICAgIGlmICh0aGlzLnNoYWRvd1Jvb3QgJiYgaHlkcmF0ZSkge1xyXG4gICAgICAgICAgICBoeWRyYXRlKHRoaXMuX2NyZWF0ZVZOb2RlKCksIHRoaXMuc2hhZG93Um9vdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHRoaXMuc2hhZG93Um9vdCkge1xyXG4gICAgICAgICAgICAgICAgd2FybihgQ3VzdG9tIGVsZW1lbnQgaGFzIHByZS1yZW5kZXJlZCBkZWNsYXJhdGl2ZSBzaGFkb3cgcm9vdCBidXQgaXMgbm90IGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBkZWZpbmVkIGFzIGh5ZHJhdGFibGUuIFVzZSBcXGBkZWZpbmVTU1JDdXN0b21FbGVtZW50XFxgLmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuYXR0YWNoU2hhZG93KHsgbW9kZTogJ29wZW4nIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbm5lY3RlZENhbGxiYWNrKCkge1xyXG4gICAgICAgIHRoaXMuX2Nvbm5lY3RlZCA9IHRydWU7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9pbnN0YW5jZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZXNvbHZlRGVmKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XHJcbiAgICAgICAgdGhpcy5fY29ubmVjdGVkID0gZmFsc2U7XHJcbiAgICAgICAgbmV4dFRpY2soKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2Nvbm5lY3RlZCkge1xyXG4gICAgICAgICAgICAgICAgcmVuZGVyKG51bGwsIHRoaXMuc2hhZG93Um9vdCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogcmVzb2x2ZSBpbm5lciBjb21wb25lbnQgZGVmaW5pdGlvbiAoaGFuZGxlIHBvc3NpYmxlIGFzeW5jIGNvbXBvbmVudClcclxuICAgICAqL1xyXG4gICAgX3Jlc29sdmVEZWYoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3Jlc29sdmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcmVzb2x2ZWQgPSB0cnVlO1xyXG4gICAgICAgIC8vIHNldCBpbml0aWFsIGF0dHJzXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5fc2V0QXR0cih0aGlzLmF0dHJpYnV0ZXNbaV0ubmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHdhdGNoIGZ1dHVyZSBhdHRyIGNoYW5nZXNcclxuICAgICAgICBuZXcgTXV0YXRpb25PYnNlcnZlcihtdXRhdGlvbnMgPT4ge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG0gb2YgbXV0YXRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRBdHRyKG0uYXR0cmlidXRlTmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KS5vYnNlcnZlKHRoaXMsIHsgYXR0cmlidXRlczogdHJ1ZSB9KTtcclxuICAgICAgICBjb25zdCByZXNvbHZlID0gKGRlZikgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB7IHByb3BzLCBzdHlsZXMgfSA9IGRlZjtcclxuICAgICAgICAgICAgY29uc3QgaGFzT3B0aW9ucyA9ICFpc0FycmF5KHByb3BzKTtcclxuICAgICAgICAgICAgY29uc3QgcmF3S2V5cyA9IHByb3BzID8gKGhhc09wdGlvbnMgPyBPYmplY3Qua2V5cyhwcm9wcykgOiBwcm9wcykgOiBbXTtcclxuICAgICAgICAgICAgLy8gY2FzdCBOdW1iZXItdHlwZSBwcm9wcyBzZXQgYmVmb3JlIHJlc29sdmVcclxuICAgICAgICAgICAgbGV0IG51bWJlclByb3BzO1xyXG4gICAgICAgICAgICBpZiAoaGFzT3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5fcHJvcHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcHQgPSBwcm9wc1trZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHQgPT09IE51bWJlciB8fCAob3B0ICYmIG9wdC50eXBlID09PSBOdW1iZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb3BzW2tleV0gPSB0b051bWJlcih0aGlzLl9wcm9wc1trZXldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgKG51bWJlclByb3BzIHx8IChudW1iZXJQcm9wcyA9IE9iamVjdC5jcmVhdGUobnVsbCkpKVtrZXldID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fbnVtYmVyUHJvcHMgPSBudW1iZXJQcm9wcztcclxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgYXJlIHByb3BzIHNldCBwcmUtdXBncmFkZSBvciBjb25uZWN0XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHRoaXMpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoa2V5WzBdICE9PSAnXycpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRQcm9wKGtleSwgdGhpc1trZXldLCB0cnVlLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gZGVmaW5pbmcgZ2V0dGVyL3NldHRlcnMgb24gcHJvdG90eXBlXHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHJhd0tleXMubWFwKGNhbWVsaXplJDEpKSB7XHJcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywga2V5LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2V0KCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0UHJvcChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0KHZhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRQcm9wKGtleSwgdmFsKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBhcHBseSBDU1NcclxuICAgICAgICAgICAgdGhpcy5fYXBwbHlTdHlsZXMoc3R5bGVzKTtcclxuICAgICAgICAgICAgLy8gaW5pdGlhbCByZW5kZXJcclxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBhc3luY0RlZiA9IHRoaXMuX2RlZi5fX2FzeW5jTG9hZGVyO1xyXG4gICAgICAgIGlmIChhc3luY0RlZikge1xyXG4gICAgICAgICAgICBhc3luY0RlZigpLnRoZW4ocmVzb2x2ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXNvbHZlKHRoaXMuX2RlZik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3NldEF0dHIoa2V5KSB7XHJcbiAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5nZXRBdHRyaWJ1dGUoa2V5KTtcclxuICAgICAgICBpZiAodGhpcy5fbnVtYmVyUHJvcHMgJiYgdGhpcy5fbnVtYmVyUHJvcHNba2V5XSkge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHRvTnVtYmVyKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fc2V0UHJvcChjYW1lbGl6ZSQxKGtleSksIHZhbHVlLCBmYWxzZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBfZ2V0UHJvcChrZXkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcHJvcHNba2V5XTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIF9zZXRQcm9wKGtleSwgdmFsLCBzaG91bGRSZWZsZWN0ID0gdHJ1ZSwgc2hvdWxkVXBkYXRlID0gdHJ1ZSkge1xyXG4gICAgICAgIGlmICh2YWwgIT09IHRoaXMuX3Byb3BzW2tleV0pIHtcclxuICAgICAgICAgICAgdGhpcy5fcHJvcHNba2V5XSA9IHZhbDtcclxuICAgICAgICAgICAgaWYgKHNob3VsZFVwZGF0ZSAmJiB0aGlzLl9pbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gcmVmbGVjdFxyXG4gICAgICAgICAgICBpZiAoc2hvdWxkUmVmbGVjdCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbCA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKGh5cGhlbmF0ZShrZXkpLCAnJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKGh5cGhlbmF0ZShrZXkpLCB2YWwgKyAnJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghdmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoaHlwaGVuYXRlKGtleSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3VwZGF0ZSgpIHtcclxuICAgICAgICByZW5kZXIodGhpcy5fY3JlYXRlVk5vZGUoKSwgdGhpcy5zaGFkb3dSb290KTtcclxuICAgIH1cclxuICAgIF9jcmVhdGVWTm9kZSgpIHtcclxuICAgICAgICBjb25zdCB2bm9kZSA9IGNyZWF0ZVZOb2RlKHRoaXMuX2RlZiwgZXh0ZW5kKHt9LCB0aGlzLl9wcm9wcykpO1xyXG4gICAgICAgIGlmICghdGhpcy5faW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgdm5vZGUuY2UgPSBpbnN0YW5jZSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IGluc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuaXNDRSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAvLyBITVJcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5jZVJlbG9hZCA9IG5ld1N0eWxlcyA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsd2F5cyByZXNldCBzdHlsZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3N0eWxlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3R5bGVzLmZvckVhY2gocyA9PiB0aGlzLnNoYWRvd1Jvb3QucmVtb3ZlQ2hpbGQocykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3R5bGVzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXBwbHlTdHlsZXMobmV3U3R5bGVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBpcyBhbiBhc3luYyBjb21wb25lbnQsIGNlUmVsb2FkIGlzIGNhbGxlZCBmcm9tIHRoZSBpbm5lclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb21wb25lbnQgc28gbm8gbmVlZCB0byByZWxvYWQgdGhlIGFzeW5jIHdyYXBwZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9kZWYuX19hc3luY0xvYWRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVsb2FkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBpbnRlcmNlcHQgZW1pdFxyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuZW1pdCA9IChldmVudCwgLi4uYXJncykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoZXZlbnQsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsOiBhcmdzXHJcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8vIGxvY2F0ZSBuZWFyZXN0IFZ1ZSBjdXN0b20gZWxlbWVudCBwYXJlbnQgZm9yIHByb3ZpZGUvaW5qZWN0XHJcbiAgICAgICAgICAgICAgICBsZXQgcGFyZW50ID0gdGhpcztcclxuICAgICAgICAgICAgICAgIHdoaWxlICgocGFyZW50ID1cclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQgJiYgKHBhcmVudC5wYXJlbnROb2RlIHx8IHBhcmVudC5ob3N0KSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50IGluc3RhbmNlb2YgVnVlRWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5wYXJlbnQgPSBwYXJlbnQuX2luc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2bm9kZTtcclxuICAgIH1cclxuICAgIF9hcHBseVN0eWxlcyhzdHlsZXMpIHtcclxuICAgICAgICBpZiAoc3R5bGVzKSB7XHJcbiAgICAgICAgICAgIHN0eWxlcy5mb3JFYWNoKGNzcyA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcclxuICAgICAgICAgICAgICAgIHMudGV4dENvbnRlbnQgPSBjc3M7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQocyk7XHJcbiAgICAgICAgICAgICAgICAvLyByZWNvcmQgZm9yIEhNUlxyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICh0aGlzLl9zdHlsZXMgfHwgKHRoaXMuX3N0eWxlcyA9IFtdKSkucHVzaChzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmZ1bmN0aW9uIHVzZUNzc01vZHVsZShuYW1lID0gJyRzdHlsZScpIHtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXHJcbiAgICB7XHJcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcclxuICAgICAgICBpZiAoIWluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB3YXJuKGB1c2VDc3NNb2R1bGUgbXVzdCBiZSBjYWxsZWQgaW5zaWRlIHNldHVwKClgKTtcclxuICAgICAgICAgICAgcmV0dXJuIEVNUFRZX09CSjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbW9kdWxlcyA9IGluc3RhbmNlLnR5cGUuX19jc3NNb2R1bGVzO1xyXG4gICAgICAgIGlmICghbW9kdWxlcykge1xyXG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgd2FybihgQ3VycmVudCBpbnN0YW5jZSBkb2VzIG5vdCBoYXZlIENTUyBtb2R1bGVzIGluamVjdGVkLmApO1xyXG4gICAgICAgICAgICByZXR1cm4gRU1QVFlfT0JKO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBtb2QgPSBtb2R1bGVzW25hbWVdO1xyXG4gICAgICAgIGlmICghbW9kKSB7XHJcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgd2FybihgQ3VycmVudCBpbnN0YW5jZSBkb2VzIG5vdCBoYXZlIENTUyBtb2R1bGUgbmFtZWQgXCIke25hbWV9XCIuYCk7XHJcbiAgICAgICAgICAgIHJldHVybiBFTVBUWV9PQko7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtb2Q7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBTRkMncyBDU1MgdmFyaWFibGUgaW5qZWN0aW9uIGZlYXR1cmUuXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiB1c2VDc3NWYXJzKGdldHRlcikge1xyXG4gICAgY29uc3QgaW5zdGFuY2UgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICBpZiAoIWluc3RhbmNlKSB7XHJcbiAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgIHdhcm4oYHVzZUNzc1ZhcnMgaXMgY2FsbGVkIHdpdGhvdXQgY3VycmVudCBhY3RpdmUgY29tcG9uZW50IGluc3RhbmNlLmApO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IHNldFZhcnMgPSAoKSA9PiBzZXRWYXJzT25WTm9kZShpbnN0YW5jZS5zdWJUcmVlLCBnZXR0ZXIoaW5zdGFuY2UucHJveHkpKTtcclxuICAgIHdhdGNoUG9zdEVmZmVjdChzZXRWYXJzKTtcclxuICAgIG9uTW91bnRlZCgoKSA9PiB7XHJcbiAgICAgICAgY29uc3Qgb2IgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihzZXRWYXJzKTtcclxuICAgICAgICBvYi5vYnNlcnZlKGluc3RhbmNlLnN1YlRyZWUuZWwucGFyZW50Tm9kZSwgeyBjaGlsZExpc3Q6IHRydWUgfSk7XHJcbiAgICAgICAgb25Vbm1vdW50ZWQoKCkgPT4gb2IuZGlzY29ubmVjdCgpKTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHNldFZhcnNPblZOb2RlKHZub2RlLCB2YXJzKSB7XHJcbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMTI4IC8qIFNVU1BFTlNFICovKSB7XHJcbiAgICAgICAgY29uc3Qgc3VzcGVuc2UgPSB2bm9kZS5zdXNwZW5zZTtcclxuICAgICAgICB2bm9kZSA9IHN1c3BlbnNlLmFjdGl2ZUJyYW5jaDtcclxuICAgICAgICBpZiAoc3VzcGVuc2UucGVuZGluZ0JyYW5jaCAmJiAhc3VzcGVuc2UuaXNIeWRyYXRpbmcpIHtcclxuICAgICAgICAgICAgc3VzcGVuc2UuZWZmZWN0cy5wdXNoKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHNldFZhcnNPblZOb2RlKHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCwgdmFycyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIGRyaWxsIGRvd24gSE9DcyB1bnRpbCBpdCdzIGEgbm9uLWNvbXBvbmVudCB2bm9kZVxyXG4gICAgd2hpbGUgKHZub2RlLmNvbXBvbmVudCkge1xyXG4gICAgICAgIHZub2RlID0gdm5vZGUuY29tcG9uZW50LnN1YlRyZWU7XHJcbiAgICB9XHJcbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMSAvKiBFTEVNRU5UICovICYmIHZub2RlLmVsKSB7XHJcbiAgICAgICAgc2V0VmFyc09uTm9kZSh2bm9kZS5lbCwgdmFycyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh2bm9kZS50eXBlID09PSBGcmFnbWVudCkge1xyXG4gICAgICAgIHZub2RlLmNoaWxkcmVuLmZvckVhY2goYyA9PiBzZXRWYXJzT25WTm9kZShjLCB2YXJzKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh2bm9kZS50eXBlID09PSBTdGF0aWMpIHtcclxuICAgICAgICBsZXQgeyBlbCwgYW5jaG9yIH0gPSB2bm9kZTtcclxuICAgICAgICB3aGlsZSAoZWwpIHtcclxuICAgICAgICAgICAgc2V0VmFyc09uTm9kZShlbCwgdmFycyk7XHJcbiAgICAgICAgICAgIGlmIChlbCA9PT0gYW5jaG9yKVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGVsID0gZWwubmV4dFNpYmxpbmc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHNldFZhcnNPbk5vZGUoZWwsIHZhcnMpIHtcclxuICAgIGlmIChlbC5ub2RlVHlwZSA9PT0gMSkge1xyXG4gICAgICAgIGNvbnN0IHN0eWxlID0gZWwuc3R5bGU7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdmFycykge1xyXG4gICAgICAgICAgICBzdHlsZS5zZXRQcm9wZXJ0eShgLS0ke2tleX1gLCB2YXJzW2tleV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5jb25zdCBUUkFOU0lUSU9OID0gJ3RyYW5zaXRpb24nO1xyXG5jb25zdCBBTklNQVRJT04gPSAnYW5pbWF0aW9uJztcclxuLy8gRE9NIFRyYW5zaXRpb24gaXMgYSBoaWdoZXItb3JkZXItY29tcG9uZW50IGJhc2VkIG9uIHRoZSBwbGF0Zm9ybS1hZ25vc3RpY1xyXG4vLyBiYXNlIFRyYW5zaXRpb24gY29tcG9uZW50LCB3aXRoIERPTS1zcGVjaWZpYyBsb2dpYy5cclxuY29uc3QgVHJhbnNpdGlvbiA9IChwcm9wcywgeyBzbG90cyB9KSA9PiBoKEJhc2VUcmFuc2l0aW9uLCByZXNvbHZlVHJhbnNpdGlvblByb3BzKHByb3BzKSwgc2xvdHMpO1xyXG5UcmFuc2l0aW9uLmRpc3BsYXlOYW1lID0gJ1RyYW5zaXRpb24nO1xyXG5jb25zdCBET01UcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzID0ge1xyXG4gICAgbmFtZTogU3RyaW5nLFxyXG4gICAgdHlwZTogU3RyaW5nLFxyXG4gICAgY3NzOiB7XHJcbiAgICAgICAgdHlwZTogQm9vbGVhbixcclxuICAgICAgICBkZWZhdWx0OiB0cnVlXHJcbiAgICB9LFxyXG4gICAgZHVyYXRpb246IFtTdHJpbmcsIE51bWJlciwgT2JqZWN0XSxcclxuICAgIGVudGVyRnJvbUNsYXNzOiBTdHJpbmcsXHJcbiAgICBlbnRlckFjdGl2ZUNsYXNzOiBTdHJpbmcsXHJcbiAgICBlbnRlclRvQ2xhc3M6IFN0cmluZyxcclxuICAgIGFwcGVhckZyb21DbGFzczogU3RyaW5nLFxyXG4gICAgYXBwZWFyQWN0aXZlQ2xhc3M6IFN0cmluZyxcclxuICAgIGFwcGVhclRvQ2xhc3M6IFN0cmluZyxcclxuICAgIGxlYXZlRnJvbUNsYXNzOiBTdHJpbmcsXHJcbiAgICBsZWF2ZUFjdGl2ZUNsYXNzOiBTdHJpbmcsXHJcbiAgICBsZWF2ZVRvQ2xhc3M6IFN0cmluZ1xyXG59O1xyXG5jb25zdCBUcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzID0gKFRyYW5zaXRpb24ucHJvcHMgPVxyXG4gICAgLyojX19QVVJFX18qLyBleHRlbmQoe30sIEJhc2VUcmFuc2l0aW9uLnByb3BzLCBET01UcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzKSk7XHJcbi8qKlxyXG4gKiAjMzIyNyBJbmNvbWluZyBob29rcyBtYXkgYmUgbWVyZ2VkIGludG8gYXJyYXlzIHdoZW4gd3JhcHBpbmcgVHJhbnNpdGlvblxyXG4gKiB3aXRoIGN1c3RvbSBIT0NzLlxyXG4gKi9cclxuY29uc3QgY2FsbEhvb2sgPSAoaG9vaywgYXJncyA9IFtdKSA9PiB7XHJcbiAgICBpZiAoaXNBcnJheShob29rKSkge1xyXG4gICAgICAgIGhvb2suZm9yRWFjaChoID0+IGgoLi4uYXJncykpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaG9vaykge1xyXG4gICAgICAgIGhvb2soLi4uYXJncyk7XHJcbiAgICB9XHJcbn07XHJcbi8qKlxyXG4gKiBDaGVjayBpZiBhIGhvb2sgZXhwZWN0cyBhIGNhbGxiYWNrICgybmQgYXJnKSwgd2hpY2ggbWVhbnMgdGhlIHVzZXJcclxuICogaW50ZW5kcyB0byBleHBsaWNpdGx5IGNvbnRyb2wgdGhlIGVuZCBvZiB0aGUgdHJhbnNpdGlvbi5cclxuICovXHJcbmNvbnN0IGhhc0V4cGxpY2l0Q2FsbGJhY2sgPSAoaG9vaykgPT4ge1xyXG4gICAgcmV0dXJuIGhvb2tcclxuICAgICAgICA/IGlzQXJyYXkoaG9vaylcclxuICAgICAgICAgICAgPyBob29rLnNvbWUoaCA9PiBoLmxlbmd0aCA+IDEpXHJcbiAgICAgICAgICAgIDogaG9vay5sZW5ndGggPiAxXHJcbiAgICAgICAgOiBmYWxzZTtcclxufTtcclxuZnVuY3Rpb24gcmVzb2x2ZVRyYW5zaXRpb25Qcm9wcyhyYXdQcm9wcykge1xyXG4gICAgY29uc3QgYmFzZVByb3BzID0ge307XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiByYXdQcm9wcykge1xyXG4gICAgICAgIGlmICghKGtleSBpbiBET01UcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzKSkge1xyXG4gICAgICAgICAgICBiYXNlUHJvcHNba2V5XSA9IHJhd1Byb3BzW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHJhd1Byb3BzLmNzcyA9PT0gZmFsc2UpIHtcclxuICAgICAgICByZXR1cm4gYmFzZVByb3BzO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyBuYW1lID0gJ3YnLCB0eXBlLCBkdXJhdGlvbiwgZW50ZXJGcm9tQ2xhc3MgPSBgJHtuYW1lfS1lbnRlci1mcm9tYCwgZW50ZXJBY3RpdmVDbGFzcyA9IGAke25hbWV9LWVudGVyLWFjdGl2ZWAsIGVudGVyVG9DbGFzcyA9IGAke25hbWV9LWVudGVyLXRvYCwgYXBwZWFyRnJvbUNsYXNzID0gZW50ZXJGcm9tQ2xhc3MsIGFwcGVhckFjdGl2ZUNsYXNzID0gZW50ZXJBY3RpdmVDbGFzcywgYXBwZWFyVG9DbGFzcyA9IGVudGVyVG9DbGFzcywgbGVhdmVGcm9tQ2xhc3MgPSBgJHtuYW1lfS1sZWF2ZS1mcm9tYCwgbGVhdmVBY3RpdmVDbGFzcyA9IGAke25hbWV9LWxlYXZlLWFjdGl2ZWAsIGxlYXZlVG9DbGFzcyA9IGAke25hbWV9LWxlYXZlLXRvYCB9ID0gcmF3UHJvcHM7XHJcbiAgICBjb25zdCBkdXJhdGlvbnMgPSBub3JtYWxpemVEdXJhdGlvbihkdXJhdGlvbik7XHJcbiAgICBjb25zdCBlbnRlckR1cmF0aW9uID0gZHVyYXRpb25zICYmIGR1cmF0aW9uc1swXTtcclxuICAgIGNvbnN0IGxlYXZlRHVyYXRpb24gPSBkdXJhdGlvbnMgJiYgZHVyYXRpb25zWzFdO1xyXG4gICAgY29uc3QgeyBvbkJlZm9yZUVudGVyLCBvbkVudGVyLCBvbkVudGVyQ2FuY2VsbGVkLCBvbkxlYXZlLCBvbkxlYXZlQ2FuY2VsbGVkLCBvbkJlZm9yZUFwcGVhciA9IG9uQmVmb3JlRW50ZXIsIG9uQXBwZWFyID0gb25FbnRlciwgb25BcHBlYXJDYW5jZWxsZWQgPSBvbkVudGVyQ2FuY2VsbGVkIH0gPSBiYXNlUHJvcHM7XHJcbiAgICBjb25zdCBmaW5pc2hFbnRlciA9IChlbCwgaXNBcHBlYXIsIGRvbmUpID0+IHtcclxuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGlzQXBwZWFyID8gYXBwZWFyVG9DbGFzcyA6IGVudGVyVG9DbGFzcyk7XHJcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBpc0FwcGVhciA/IGFwcGVhckFjdGl2ZUNsYXNzIDogZW50ZXJBY3RpdmVDbGFzcyk7XHJcbiAgICAgICAgZG9uZSAmJiBkb25lKCk7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgZmluaXNoTGVhdmUgPSAoZWwsIGRvbmUpID0+IHtcclxuICAgICAgICBlbC5faXNMZWF2aW5nID0gZmFsc2U7XHJcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUZyb21DbGFzcyk7XHJcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xyXG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XHJcbiAgICAgICAgZG9uZSAmJiBkb25lKCk7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgbWFrZUVudGVySG9vayA9IChpc0FwcGVhcikgPT4ge1xyXG4gICAgICAgIHJldHVybiAoZWwsIGRvbmUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgaG9vayA9IGlzQXBwZWFyID8gb25BcHBlYXIgOiBvbkVudGVyO1xyXG4gICAgICAgICAgICBjb25zdCByZXNvbHZlID0gKCkgPT4gZmluaXNoRW50ZXIoZWwsIGlzQXBwZWFyLCBkb25lKTtcclxuICAgICAgICAgICAgY2FsbEhvb2soaG9vaywgW2VsLCByZXNvbHZlXSk7XHJcbiAgICAgICAgICAgIG5leHRGcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGlzQXBwZWFyID8gYXBwZWFyRnJvbUNsYXNzIDogZW50ZXJGcm9tQ2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBpc0FwcGVhciA/IGFwcGVhclRvQ2xhc3MgOiBlbnRlclRvQ2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFoYXNFeHBsaWNpdENhbGxiYWNrKGhvb2spKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBlbnRlckR1cmF0aW9uLCByZXNvbHZlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZXh0ZW5kKGJhc2VQcm9wcywge1xyXG4gICAgICAgIG9uQmVmb3JlRW50ZXIoZWwpIHtcclxuICAgICAgICAgICAgY2FsbEhvb2sob25CZWZvcmVFbnRlciwgW2VsXSk7XHJcbiAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgZW50ZXJGcm9tQ2xhc3MpO1xyXG4gICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGVudGVyQWN0aXZlQ2xhc3MpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25CZWZvcmVBcHBlYXIoZWwpIHtcclxuICAgICAgICAgICAgY2FsbEhvb2sob25CZWZvcmVBcHBlYXIsIFtlbF0pO1xyXG4gICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGFwcGVhckZyb21DbGFzcyk7XHJcbiAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYXBwZWFyQWN0aXZlQ2xhc3MpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25FbnRlcjogbWFrZUVudGVySG9vayhmYWxzZSksXHJcbiAgICAgICAgb25BcHBlYXI6IG1ha2VFbnRlckhvb2sodHJ1ZSksXHJcbiAgICAgICAgb25MZWF2ZShlbCwgZG9uZSkge1xyXG4gICAgICAgICAgICBlbC5faXNMZWF2aW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZSA9ICgpID0+IGZpbmlzaExlYXZlKGVsLCBkb25lKTtcclxuICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUZyb21DbGFzcyk7XHJcbiAgICAgICAgICAgIC8vIGZvcmNlIHJlZmxvdyBzbyAqLWxlYXZlLWZyb20gY2xhc3NlcyBpbW1lZGlhdGVseSB0YWtlIGVmZmVjdCAoIzI1OTMpXHJcbiAgICAgICAgICAgIGZvcmNlUmVmbG93KCk7XHJcbiAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XHJcbiAgICAgICAgICAgIG5leHRGcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWVsLl9pc0xlYXZpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBjYW5jZWxsZWRcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlRnJvbUNsYXNzKTtcclxuICAgICAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcclxuICAgICAgICAgICAgICAgIGlmICghaGFzRXhwbGljaXRDYWxsYmFjayhvbkxlYXZlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgbGVhdmVEdXJhdGlvbiwgcmVzb2x2ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjYWxsSG9vayhvbkxlYXZlLCBbZWwsIHJlc29sdmVdKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uRW50ZXJDYW5jZWxsZWQoZWwpIHtcclxuICAgICAgICAgICAgZmluaXNoRW50ZXIoZWwsIGZhbHNlKTtcclxuICAgICAgICAgICAgY2FsbEhvb2sob25FbnRlckNhbmNlbGxlZCwgW2VsXSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbkFwcGVhckNhbmNlbGxlZChlbCkge1xyXG4gICAgICAgICAgICBmaW5pc2hFbnRlcihlbCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGNhbGxIb29rKG9uQXBwZWFyQ2FuY2VsbGVkLCBbZWxdKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uTGVhdmVDYW5jZWxsZWQoZWwpIHtcclxuICAgICAgICAgICAgZmluaXNoTGVhdmUoZWwpO1xyXG4gICAgICAgICAgICBjYWxsSG9vayhvbkxlYXZlQ2FuY2VsbGVkLCBbZWxdKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBub3JtYWxpemVEdXJhdGlvbihkdXJhdGlvbikge1xyXG4gICAgaWYgKGR1cmF0aW9uID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzT2JqZWN0KGR1cmF0aW9uKSkge1xyXG4gICAgICAgIHJldHVybiBbTnVtYmVyT2YoZHVyYXRpb24uZW50ZXIpLCBOdW1iZXJPZihkdXJhdGlvbi5sZWF2ZSldO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3QgbiA9IE51bWJlck9mKGR1cmF0aW9uKTtcclxuICAgICAgICByZXR1cm4gW24sIG5dO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIE51bWJlck9mKHZhbCkge1xyXG4gICAgY29uc3QgcmVzID0gdG9OdW1iZXIodmFsKTtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpXHJcbiAgICAgICAgdmFsaWRhdGVEdXJhdGlvbihyZXMpO1xyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG5mdW5jdGlvbiB2YWxpZGF0ZUR1cmF0aW9uKHZhbCkge1xyXG4gICAgaWYgKHR5cGVvZiB2YWwgIT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgd2FybihgPHRyYW5zaXRpb24+IGV4cGxpY2l0IGR1cmF0aW9uIGlzIG5vdCBhIHZhbGlkIG51bWJlciAtIGAgK1xyXG4gICAgICAgICAgICBgZ290ICR7SlNPTi5zdHJpbmdpZnkodmFsKX0uYCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc05hTih2YWwpKSB7XHJcbiAgICAgICAgd2FybihgPHRyYW5zaXRpb24+IGV4cGxpY2l0IGR1cmF0aW9uIGlzIE5hTiAtIGAgK1xyXG4gICAgICAgICAgICAndGhlIGR1cmF0aW9uIGV4cHJlc3Npb24gbWlnaHQgYmUgaW5jb3JyZWN0LicpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgY2xzKSB7XHJcbiAgICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKGMgPT4gYyAmJiBlbC5jbGFzc0xpc3QuYWRkKGMpKTtcclxuICAgIChlbC5fdnRjIHx8XHJcbiAgICAgICAgKGVsLl92dGMgPSBuZXcgU2V0KCkpKS5hZGQoY2xzKTtcclxufVxyXG5mdW5jdGlvbiByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGNscykge1xyXG4gICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChjID0+IGMgJiYgZWwuY2xhc3NMaXN0LnJlbW92ZShjKSk7XHJcbiAgICBjb25zdCB7IF92dGMgfSA9IGVsO1xyXG4gICAgaWYgKF92dGMpIHtcclxuICAgICAgICBfdnRjLmRlbGV0ZShjbHMpO1xyXG4gICAgICAgIGlmICghX3Z0Yy5zaXplKSB7XHJcbiAgICAgICAgICAgIGVsLl92dGMgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIG5leHRGcmFtZShjYikge1xyXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2IpO1xyXG4gICAgfSk7XHJcbn1cclxubGV0IGVuZElkID0gMDtcclxuZnVuY3Rpb24gd2hlblRyYW5zaXRpb25FbmRzKGVsLCBleHBlY3RlZFR5cGUsIGV4cGxpY2l0VGltZW91dCwgcmVzb2x2ZSkge1xyXG4gICAgY29uc3QgaWQgPSAoZWwuX2VuZElkID0gKytlbmRJZCk7XHJcbiAgICBjb25zdCByZXNvbHZlSWZOb3RTdGFsZSA9ICgpID0+IHtcclxuICAgICAgICBpZiAoaWQgPT09IGVsLl9lbmRJZCkge1xyXG4gICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGlmIChleHBsaWNpdFRpbWVvdXQpIHtcclxuICAgICAgICByZXR1cm4gc2V0VGltZW91dChyZXNvbHZlSWZOb3RTdGFsZSwgZXhwbGljaXRUaW1lb3V0KTtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgdHlwZSwgdGltZW91dCwgcHJvcENvdW50IH0gPSBnZXRUcmFuc2l0aW9uSW5mbyhlbCwgZXhwZWN0ZWRUeXBlKTtcclxuICAgIGlmICghdHlwZSkge1xyXG4gICAgICAgIHJldHVybiByZXNvbHZlKCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBlbmRFdmVudCA9IHR5cGUgKyAnZW5kJztcclxuICAgIGxldCBlbmRlZCA9IDA7XHJcbiAgICBjb25zdCBlbmQgPSAoKSA9PiB7XHJcbiAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihlbmRFdmVudCwgb25FbmQpO1xyXG4gICAgICAgIHJlc29sdmVJZk5vdFN0YWxlKCk7XHJcbiAgICB9O1xyXG4gICAgY29uc3Qgb25FbmQgPSAoZSkgPT4ge1xyXG4gICAgICAgIGlmIChlLnRhcmdldCA9PT0gZWwgJiYgKytlbmRlZCA+PSBwcm9wQ291bnQpIHtcclxuICAgICAgICAgICAgZW5kKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgIGlmIChlbmRlZCA8IHByb3BDb3VudCkge1xyXG4gICAgICAgICAgICBlbmQoKTtcclxuICAgICAgICB9XHJcbiAgICB9LCB0aW1lb3V0ICsgMSk7XHJcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKGVuZEV2ZW50LCBvbkVuZCk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSkge1xyXG4gICAgY29uc3Qgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xyXG4gICAgLy8gSlNET00gbWF5IHJldHVybiB1bmRlZmluZWQgZm9yIHRyYW5zaXRpb24gcHJvcGVydGllc1xyXG4gICAgY29uc3QgZ2V0U3R5bGVQcm9wZXJ0aWVzID0gKGtleSkgPT4gKHN0eWxlc1trZXldIHx8ICcnKS5zcGxpdCgnLCAnKTtcclxuICAgIGNvbnN0IHRyYW5zaXRpb25EZWxheXMgPSBnZXRTdHlsZVByb3BlcnRpZXMoVFJBTlNJVElPTiArICdEZWxheScpO1xyXG4gICAgY29uc3QgdHJhbnNpdGlvbkR1cmF0aW9ucyA9IGdldFN0eWxlUHJvcGVydGllcyhUUkFOU0lUSU9OICsgJ0R1cmF0aW9uJyk7XHJcbiAgICBjb25zdCB0cmFuc2l0aW9uVGltZW91dCA9IGdldFRpbWVvdXQodHJhbnNpdGlvbkRlbGF5cywgdHJhbnNpdGlvbkR1cmF0aW9ucyk7XHJcbiAgICBjb25zdCBhbmltYXRpb25EZWxheXMgPSBnZXRTdHlsZVByb3BlcnRpZXMoQU5JTUFUSU9OICsgJ0RlbGF5Jyk7XHJcbiAgICBjb25zdCBhbmltYXRpb25EdXJhdGlvbnMgPSBnZXRTdHlsZVByb3BlcnRpZXMoQU5JTUFUSU9OICsgJ0R1cmF0aW9uJyk7XHJcbiAgICBjb25zdCBhbmltYXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dChhbmltYXRpb25EZWxheXMsIGFuaW1hdGlvbkR1cmF0aW9ucyk7XHJcbiAgICBsZXQgdHlwZSA9IG51bGw7XHJcbiAgICBsZXQgdGltZW91dCA9IDA7XHJcbiAgICBsZXQgcHJvcENvdW50ID0gMDtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKGV4cGVjdGVkVHlwZSA9PT0gVFJBTlNJVElPTikge1xyXG4gICAgICAgIGlmICh0cmFuc2l0aW9uVGltZW91dCA+IDApIHtcclxuICAgICAgICAgICAgdHlwZSA9IFRSQU5TSVRJT047XHJcbiAgICAgICAgICAgIHRpbWVvdXQgPSB0cmFuc2l0aW9uVGltZW91dDtcclxuICAgICAgICAgICAgcHJvcENvdW50ID0gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSBBTklNQVRJT04pIHtcclxuICAgICAgICBpZiAoYW5pbWF0aW9uVGltZW91dCA+IDApIHtcclxuICAgICAgICAgICAgdHlwZSA9IEFOSU1BVElPTjtcclxuICAgICAgICAgICAgdGltZW91dCA9IGFuaW1hdGlvblRpbWVvdXQ7XHJcbiAgICAgICAgICAgIHByb3BDb3VudCA9IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGltZW91dCA9IE1hdGgubWF4KHRyYW5zaXRpb25UaW1lb3V0LCBhbmltYXRpb25UaW1lb3V0KTtcclxuICAgICAgICB0eXBlID1cclxuICAgICAgICAgICAgdGltZW91dCA+IDBcclxuICAgICAgICAgICAgICAgID8gdHJhbnNpdGlvblRpbWVvdXQgPiBhbmltYXRpb25UaW1lb3V0XHJcbiAgICAgICAgICAgICAgICAgICAgPyBUUkFOU0lUSU9OXHJcbiAgICAgICAgICAgICAgICAgICAgOiBBTklNQVRJT05cclxuICAgICAgICAgICAgICAgIDogbnVsbDtcclxuICAgICAgICBwcm9wQ291bnQgPSB0eXBlXHJcbiAgICAgICAgICAgID8gdHlwZSA9PT0gVFJBTlNJVElPTlxyXG4gICAgICAgICAgICAgICAgPyB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aFxyXG4gICAgICAgICAgICAgICAgOiBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoXHJcbiAgICAgICAgICAgIDogMDtcclxuICAgIH1cclxuICAgIGNvbnN0IGhhc1RyYW5zZm9ybSA9IHR5cGUgPT09IFRSQU5TSVRJT04gJiZcclxuICAgICAgICAvXFxiKHRyYW5zZm9ybXxhbGwpKCx8JCkvLnRlc3Qoc3R5bGVzW1RSQU5TSVRJT04gKyAnUHJvcGVydHknXSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGUsXHJcbiAgICAgICAgdGltZW91dCxcclxuICAgICAgICBwcm9wQ291bnQsXHJcbiAgICAgICAgaGFzVHJhbnNmb3JtXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGdldFRpbWVvdXQoZGVsYXlzLCBkdXJhdGlvbnMpIHtcclxuICAgIHdoaWxlIChkZWxheXMubGVuZ3RoIDwgZHVyYXRpb25zLmxlbmd0aCkge1xyXG4gICAgICAgIGRlbGF5cyA9IGRlbGF5cy5jb25jYXQoZGVsYXlzKTtcclxuICAgIH1cclxuICAgIHJldHVybiBNYXRoLm1heCguLi5kdXJhdGlvbnMubWFwKChkLCBpKSA9PiB0b01zKGQpICsgdG9NcyhkZWxheXNbaV0pKSk7XHJcbn1cclxuLy8gT2xkIHZlcnNpb25zIG9mIENocm9taXVtIChiZWxvdyA2MS4wLjMxNjMuMTAwKSBmb3JtYXRzIGZsb2F0aW5nIHBvaW50ZXJcclxuLy8gbnVtYmVycyBpbiBhIGxvY2FsZS1kZXBlbmRlbnQgd2F5LCB1c2luZyBhIGNvbW1hIGluc3RlYWQgb2YgYSBkb3QuXHJcbi8vIElmIGNvbW1hIGlzIG5vdCByZXBsYWNlZCB3aXRoIGEgZG90LCB0aGUgaW5wdXQgd2lsbCBiZSByb3VuZGVkIGRvd25cclxuLy8gKGkuZS4gYWN0aW5nIGFzIGEgZmxvb3IgZnVuY3Rpb24pIGNhdXNpbmcgdW5leHBlY3RlZCBiZWhhdmlvcnNcclxuZnVuY3Rpb24gdG9NcyhzKSB7XHJcbiAgICByZXR1cm4gTnVtYmVyKHMuc2xpY2UoMCwgLTEpLnJlcGxhY2UoJywnLCAnLicpKSAqIDEwMDA7XHJcbn1cclxuLy8gc3luY2hyb25vdXNseSBmb3JjZSBsYXlvdXQgdG8gcHV0IGVsZW1lbnRzIGludG8gYSBjZXJ0YWluIHN0YXRlXHJcbmZ1bmN0aW9uIGZvcmNlUmVmbG93KCkge1xyXG4gICAgcmV0dXJuIGRvY3VtZW50LmJvZHkub2Zmc2V0SGVpZ2h0O1xyXG59XG5cbmNvbnN0IHBvc2l0aW9uTWFwID0gbmV3IFdlYWtNYXAoKTtcclxuY29uc3QgbmV3UG9zaXRpb25NYXAgPSBuZXcgV2Vha01hcCgpO1xyXG5jb25zdCBUcmFuc2l0aW9uR3JvdXBJbXBsID0ge1xyXG4gICAgbmFtZTogJ1RyYW5zaXRpb25Hcm91cCcsXHJcbiAgICBwcm9wczogLyojX19QVVJFX18qLyBleHRlbmQoe30sIFRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMsIHtcclxuICAgICAgICB0YWc6IFN0cmluZyxcclxuICAgICAgICBtb3ZlQ2xhc3M6IFN0cmluZ1xyXG4gICAgfSksXHJcbiAgICBzZXR1cChwcm9wcywgeyBzbG90cyB9KSB7XHJcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcclxuICAgICAgICBjb25zdCBzdGF0ZSA9IHVzZVRyYW5zaXRpb25TdGF0ZSgpO1xyXG4gICAgICAgIGxldCBwcmV2Q2hpbGRyZW47XHJcbiAgICAgICAgbGV0IGNoaWxkcmVuO1xyXG4gICAgICAgIG9uVXBkYXRlZCgoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIGNoaWxkcmVuIGlzIGd1YXJhbnRlZWQgdG8gZXhpc3QgYWZ0ZXIgaW5pdGlhbCByZW5kZXJcclxuICAgICAgICAgICAgaWYgKCFwcmV2Q2hpbGRyZW4ubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgbW92ZUNsYXNzID0gcHJvcHMubW92ZUNsYXNzIHx8IGAke3Byb3BzLm5hbWUgfHwgJ3YnfS1tb3ZlYDtcclxuICAgICAgICAgICAgaWYgKCFoYXNDU1NUcmFuc2Zvcm0ocHJldkNoaWxkcmVuWzBdLmVsLCBpbnN0YW5jZS52bm9kZS5lbCwgbW92ZUNsYXNzKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHdlIGRpdmlkZSB0aGUgd29yayBpbnRvIHRocmVlIGxvb3BzIHRvIGF2b2lkIG1peGluZyBET00gcmVhZHMgYW5kIHdyaXRlc1xyXG4gICAgICAgICAgICAvLyBpbiBlYWNoIGl0ZXJhdGlvbiAtIHdoaWNoIGhlbHBzIHByZXZlbnQgbGF5b3V0IHRocmFzaGluZy5cclxuICAgICAgICAgICAgcHJldkNoaWxkcmVuLmZvckVhY2goY2FsbFBlbmRpbmdDYnMpO1xyXG4gICAgICAgICAgICBwcmV2Q2hpbGRyZW4uZm9yRWFjaChyZWNvcmRQb3NpdGlvbik7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vdmVkQ2hpbGRyZW4gPSBwcmV2Q2hpbGRyZW4uZmlsdGVyKGFwcGx5VHJhbnNsYXRpb24pO1xyXG4gICAgICAgICAgICAvLyBmb3JjZSByZWZsb3cgdG8gcHV0IGV2ZXJ5dGhpbmcgaW4gcG9zaXRpb25cclxuICAgICAgICAgICAgZm9yY2VSZWZsb3coKTtcclxuICAgICAgICAgICAgbW92ZWRDaGlsZHJlbi5mb3JFYWNoKGMgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZWwgPSBjLmVsO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3R5bGUgPSBlbC5zdHlsZTtcclxuICAgICAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcclxuICAgICAgICAgICAgICAgIHN0eWxlLnRyYW5zZm9ybSA9IHN0eWxlLndlYmtpdFRyYW5zZm9ybSA9IHN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcnO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2IgPSAoZWwuX21vdmVDYiA9IChlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUgJiYgZS50YXJnZXQgIT09IGVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlIHx8IC90cmFuc2Zvcm0kLy50ZXN0KGUucHJvcGVydHlOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgY2IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5fbW92ZUNiID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGNiKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcmF3UHJvcHMgPSB0b1Jhdyhwcm9wcyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNzc1RyYW5zaXRpb25Qcm9wcyA9IHJlc29sdmVUcmFuc2l0aW9uUHJvcHMocmF3UHJvcHMpO1xyXG4gICAgICAgICAgICBsZXQgdGFnID0gcmF3UHJvcHMudGFnIHx8IEZyYWdtZW50O1xyXG4gICAgICAgICAgICBwcmV2Q2hpbGRyZW4gPSBjaGlsZHJlbjtcclxuICAgICAgICAgICAgY2hpbGRyZW4gPSBzbG90cy5kZWZhdWx0ID8gZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuKHNsb3RzLmRlZmF1bHQoKSkgOiBbXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5rZXkgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldFRyYW5zaXRpb25Ib29rcyhjaGlsZCwgcmVzb2x2ZVRyYW5zaXRpb25Ib29rcyhjaGlsZCwgY3NzVHJhbnNpdGlvblByb3BzLCBzdGF0ZSwgaW5zdGFuY2UpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYDxUcmFuc2l0aW9uR3JvdXA+IGNoaWxkcmVuIG11c3QgYmUga2V5ZWQuYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHByZXZDaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmV2Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IHByZXZDaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgICAgICAgICBzZXRUcmFuc2l0aW9uSG9va3MoY2hpbGQsIHJlc29sdmVUcmFuc2l0aW9uSG9va3MoY2hpbGQsIGNzc1RyYW5zaXRpb25Qcm9wcywgc3RhdGUsIGluc3RhbmNlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25NYXAuc2V0KGNoaWxkLCBjaGlsZC5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKHRhZywgbnVsbCwgY2hpbGRyZW4pO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IFRyYW5zaXRpb25Hcm91cCA9IFRyYW5zaXRpb25Hcm91cEltcGw7XHJcbmZ1bmN0aW9uIGNhbGxQZW5kaW5nQ2JzKGMpIHtcclxuICAgIGNvbnN0IGVsID0gYy5lbDtcclxuICAgIGlmIChlbC5fbW92ZUNiKSB7XHJcbiAgICAgICAgZWwuX21vdmVDYigpO1xyXG4gICAgfVxyXG4gICAgaWYgKGVsLl9lbnRlckNiKSB7XHJcbiAgICAgICAgZWwuX2VudGVyQ2IoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiByZWNvcmRQb3NpdGlvbihjKSB7XHJcbiAgICBuZXdQb3NpdGlvbk1hcC5zZXQoYywgYy5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XHJcbn1cclxuZnVuY3Rpb24gYXBwbHlUcmFuc2xhdGlvbihjKSB7XHJcbiAgICBjb25zdCBvbGRQb3MgPSBwb3NpdGlvbk1hcC5nZXQoYyk7XHJcbiAgICBjb25zdCBuZXdQb3MgPSBuZXdQb3NpdGlvbk1hcC5nZXQoYyk7XHJcbiAgICBjb25zdCBkeCA9IG9sZFBvcy5sZWZ0IC0gbmV3UG9zLmxlZnQ7XHJcbiAgICBjb25zdCBkeSA9IG9sZFBvcy50b3AgLSBuZXdQb3MudG9wO1xyXG4gICAgaWYgKGR4IHx8IGR5KSB7XHJcbiAgICAgICAgY29uc3QgcyA9IGMuZWwuc3R5bGU7XHJcbiAgICAgICAgcy50cmFuc2Zvcm0gPSBzLndlYmtpdFRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoJHtkeH1weCwke2R5fXB4KWA7XHJcbiAgICAgICAgcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnMHMnO1xyXG4gICAgICAgIHJldHVybiBjO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGhhc0NTU1RyYW5zZm9ybShlbCwgcm9vdCwgbW92ZUNsYXNzKSB7XHJcbiAgICAvLyBEZXRlY3Qgd2hldGhlciBhbiBlbGVtZW50IHdpdGggdGhlIG1vdmUgY2xhc3MgYXBwbGllZCBoYXNcclxuICAgIC8vIENTUyB0cmFuc2l0aW9ucy4gU2luY2UgdGhlIGVsZW1lbnQgbWF5IGJlIGluc2lkZSBhbiBlbnRlcmluZ1xyXG4gICAgLy8gdHJhbnNpdGlvbiBhdCB0aGlzIHZlcnkgbW9tZW50LCB3ZSBtYWtlIGEgY2xvbmUgb2YgaXQgYW5kIHJlbW92ZVxyXG4gICAgLy8gYWxsIG90aGVyIHRyYW5zaXRpb24gY2xhc3NlcyBhcHBsaWVkIHRvIGVuc3VyZSBvbmx5IHRoZSBtb3ZlIGNsYXNzXHJcbiAgICAvLyBpcyBhcHBsaWVkLlxyXG4gICAgY29uc3QgY2xvbmUgPSBlbC5jbG9uZU5vZGUoKTtcclxuICAgIGlmIChlbC5fdnRjKSB7XHJcbiAgICAgICAgZWwuX3Z0Yy5mb3JFYWNoKGNscyA9PiB7XHJcbiAgICAgICAgICAgIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goYyA9PiBjICYmIGNsb25lLmNsYXNzTGlzdC5yZW1vdmUoYykpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgbW92ZUNsYXNzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChjID0+IGMgJiYgY2xvbmUuY2xhc3NMaXN0LmFkZChjKSk7XHJcbiAgICBjbG9uZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgY29uc3QgY29udGFpbmVyID0gKHJvb3Qubm9kZVR5cGUgPT09IDEgPyByb290IDogcm9vdC5wYXJlbnROb2RlKTtcclxuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjbG9uZSk7XHJcbiAgICBjb25zdCB7IGhhc1RyYW5zZm9ybSB9ID0gZ2V0VHJhbnNpdGlvbkluZm8oY2xvbmUpO1xyXG4gICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNsb25lKTtcclxuICAgIHJldHVybiBoYXNUcmFuc2Zvcm07XHJcbn1cblxuY29uc3QgZ2V0TW9kZWxBc3NpZ25lciA9ICh2bm9kZSkgPT4ge1xyXG4gICAgY29uc3QgZm4gPSB2bm9kZS5wcm9wc1snb25VcGRhdGU6bW9kZWxWYWx1ZSddIHx8XHJcbiAgICAgICAgKGZhbHNlICk7XHJcbiAgICByZXR1cm4gaXNBcnJheShmbikgPyB2YWx1ZSA9PiBpbnZva2VBcnJheUZucyhmbiwgdmFsdWUpIDogZm47XHJcbn07XHJcbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25TdGFydChlKSB7XHJcbiAgICBlLnRhcmdldC5jb21wb3NpbmcgPSB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25FbmQoZSkge1xyXG4gICAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXQ7XHJcbiAgICBpZiAodGFyZ2V0LmNvbXBvc2luZykge1xyXG4gICAgICAgIHRhcmdldC5jb21wb3NpbmcgPSBmYWxzZTtcclxuICAgICAgICB0YXJnZXQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2lucHV0JykpO1xyXG4gICAgfVxyXG59XHJcbi8vIFdlIGFyZSBleHBvcnRpbmcgdGhlIHYtbW9kZWwgcnVudGltZSBkaXJlY3RseSBhcyB2bm9kZSBob29rcyBzbyB0aGF0IGl0IGNhblxyXG4vLyBiZSB0cmVlLXNoYWtlbiBpbiBjYXNlIHYtbW9kZWwgaXMgbmV2ZXIgdXNlZC5cclxuY29uc3Qgdk1vZGVsVGV4dCA9IHtcclxuICAgIGNyZWF0ZWQoZWwsIHsgbW9kaWZpZXJzOiB7IGxhenksIHRyaW0sIG51bWJlciB9IH0sIHZub2RlKSB7XHJcbiAgICAgICAgZWwuX2Fzc2lnbiA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xyXG4gICAgICAgIGNvbnN0IGNhc3RUb051bWJlciA9IG51bWJlciB8fCAodm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHMudHlwZSA9PT0gJ251bWJlcicpO1xyXG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIGxhenkgPyAnY2hhbmdlJyA6ICdpbnB1dCcsIGUgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZS50YXJnZXQuY29tcG9zaW5nKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICBsZXQgZG9tVmFsdWUgPSBlbC52YWx1ZTtcclxuICAgICAgICAgICAgaWYgKHRyaW0pIHtcclxuICAgICAgICAgICAgICAgIGRvbVZhbHVlID0gZG9tVmFsdWUudHJpbSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjYXN0VG9OdW1iZXIpIHtcclxuICAgICAgICAgICAgICAgIGRvbVZhbHVlID0gdG9OdW1iZXIoZG9tVmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsLl9hc3NpZ24oZG9tVmFsdWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICh0cmltKSB7XHJcbiAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsICdjaGFuZ2UnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBlbC52YWx1ZSA9IGVsLnZhbHVlLnRyaW0oKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbGF6eSkge1xyXG4gICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCAnY29tcG9zaXRpb25zdGFydCcsIG9uQ29tcG9zaXRpb25TdGFydCk7XHJcbiAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsICdjb21wb3NpdGlvbmVuZCcsIG9uQ29tcG9zaXRpb25FbmQpO1xyXG4gICAgICAgICAgICAvLyBTYWZhcmkgPCAxMC4yICYgVUlXZWJWaWV3IGRvZXNuJ3QgZmlyZSBjb21wb3NpdGlvbmVuZCB3aGVuXHJcbiAgICAgICAgICAgIC8vIHN3aXRjaGluZyBmb2N1cyBiZWZvcmUgY29uZmlybWluZyBjb21wb3NpdGlvbiBjaG9pY2VcclxuICAgICAgICAgICAgLy8gdGhpcyBhbHNvIGZpeGVzIHRoZSBpc3N1ZSB3aGVyZSBzb21lIGJyb3dzZXJzIGUuZy4gaU9TIENocm9tZVxyXG4gICAgICAgICAgICAvLyBmaXJlcyBcImNoYW5nZVwiIGluc3RlYWQgb2YgXCJpbnB1dFwiIG9uIGF1dG9jb21wbGV0ZS5cclxuICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgJ2NoYW5nZScsIG9uQ29tcG9zaXRpb25FbmQpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICAvLyBzZXQgdmFsdWUgb24gbW91bnRlZCBzbyBpdCdzIGFmdGVyIG1pbi9tYXggZm9yIHR5cGU9XCJyYW5nZVwiXHJcbiAgICBtb3VudGVkKGVsLCB7IHZhbHVlIH0pIHtcclxuICAgICAgICBlbC52YWx1ZSA9IHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xyXG4gICAgfSxcclxuICAgIGJlZm9yZVVwZGF0ZShlbCwgeyB2YWx1ZSwgbW9kaWZpZXJzOiB7IGxhenksIHRyaW0sIG51bWJlciB9IH0sIHZub2RlKSB7XHJcbiAgICAgICAgZWwuX2Fzc2lnbiA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xyXG4gICAgICAgIC8vIGF2b2lkIGNsZWFyaW5nIHVucmVzb2x2ZWQgdGV4dC4gIzIzMDJcclxuICAgICAgICBpZiAoZWwuY29tcG9zaW5nKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGVsICYmIGVsLnR5cGUgIT09ICdyYW5nZScpIHtcclxuICAgICAgICAgICAgaWYgKGxhenkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHJpbSAmJiBlbC52YWx1ZS50cmltKCkgPT09IHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKChudW1iZXIgfHwgZWwudHlwZSA9PT0gJ251bWJlcicpICYmIHRvTnVtYmVyKGVsLnZhbHVlKSA9PT0gdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xyXG4gICAgICAgIGlmIChlbC52YWx1ZSAhPT0gbmV3VmFsdWUpIHtcclxuICAgICAgICAgICAgZWwudmFsdWUgPSBuZXdWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IHZNb2RlbENoZWNrYm94ID0ge1xyXG4gICAgLy8gIzQwOTYgYXJyYXkgY2hlY2tib3hlcyBuZWVkIHRvIGJlIGRlZXAgdHJhdmVyc2VkXHJcbiAgICBkZWVwOiB0cnVlLFxyXG4gICAgY3JlYXRlZChlbCwgXywgdm5vZGUpIHtcclxuICAgICAgICBlbC5fYXNzaWduID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XHJcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgJ2NoYW5nZScsICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbW9kZWxWYWx1ZSA9IGVsLl9tb2RlbFZhbHVlO1xyXG4gICAgICAgICAgICBjb25zdCBlbGVtZW50VmFsdWUgPSBnZXRWYWx1ZShlbCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrZWQgPSBlbC5jaGVja2VkO1xyXG4gICAgICAgICAgICBjb25zdCBhc3NpZ24gPSBlbC5fYXNzaWduO1xyXG4gICAgICAgICAgICBpZiAoaXNBcnJheShtb2RlbFZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBsb29zZUluZGV4T2YobW9kZWxWYWx1ZSwgZWxlbWVudFZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZvdW5kID0gaW5kZXggIT09IC0xO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrZWQgJiYgIWZvdW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXNzaWduKG1vZGVsVmFsdWUuY29uY2F0KGVsZW1lbnRWYWx1ZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWNoZWNrZWQgJiYgZm91bmQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWx0ZXJlZCA9IFsuLi5tb2RlbFZhbHVlXTtcclxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJlZC5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFzc2lnbihmaWx0ZXJlZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNTZXQobW9kZWxWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNsb25lZCA9IG5ldyBTZXQobW9kZWxWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsb25lZC5hZGQoZWxlbWVudFZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsb25lZC5kZWxldGUoZWxlbWVudFZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGFzc2lnbihjbG9uZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYXNzaWduKGdldENoZWNrYm94VmFsdWUoZWwsIGNoZWNrZWQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIC8vIHNldCBpbml0aWFsIGNoZWNrZWQgb24gbW91bnQgdG8gd2FpdCBmb3IgdHJ1ZS12YWx1ZS9mYWxzZS12YWx1ZVxyXG4gICAgbW91bnRlZDogc2V0Q2hlY2tlZCxcclxuICAgIGJlZm9yZVVwZGF0ZShlbCwgYmluZGluZywgdm5vZGUpIHtcclxuICAgICAgICBlbC5fYXNzaWduID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XHJcbiAgICAgICAgc2V0Q2hlY2tlZChlbCwgYmluZGluZywgdm5vZGUpO1xyXG4gICAgfVxyXG59O1xyXG5mdW5jdGlvbiBzZXRDaGVja2VkKGVsLCB7IHZhbHVlLCBvbGRWYWx1ZSB9LCB2bm9kZSkge1xyXG4gICAgZWwuX21vZGVsVmFsdWUgPSB2YWx1ZTtcclxuICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIGVsLmNoZWNrZWQgPSBsb29zZUluZGV4T2YodmFsdWUsIHZub2RlLnByb3BzLnZhbHVlKSA+IC0xO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNTZXQodmFsdWUpKSB7XHJcbiAgICAgICAgZWwuY2hlY2tlZCA9IHZhbHVlLmhhcyh2bm9kZS5wcm9wcy52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh2YWx1ZSAhPT0gb2xkVmFsdWUpIHtcclxuICAgICAgICBlbC5jaGVja2VkID0gbG9vc2VFcXVhbCh2YWx1ZSwgZ2V0Q2hlY2tib3hWYWx1ZShlbCwgdHJ1ZSkpO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IHZNb2RlbFJhZGlvID0ge1xyXG4gICAgY3JlYXRlZChlbCwgeyB2YWx1ZSB9LCB2bm9kZSkge1xyXG4gICAgICAgIGVsLmNoZWNrZWQgPSBsb29zZUVxdWFsKHZhbHVlLCB2bm9kZS5wcm9wcy52YWx1ZSk7XHJcbiAgICAgICAgZWwuX2Fzc2lnbiA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xyXG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsICdjaGFuZ2UnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGVsLl9hc3NpZ24oZ2V0VmFsdWUoZWwpKTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcbiAgICBiZWZvcmVVcGRhdGUoZWwsIHsgdmFsdWUsIG9sZFZhbHVlIH0sIHZub2RlKSB7XHJcbiAgICAgICAgZWwuX2Fzc2lnbiA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xyXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gb2xkVmFsdWUpIHtcclxuICAgICAgICAgICAgZWwuY2hlY2tlZCA9IGxvb3NlRXF1YWwodmFsdWUsIHZub2RlLnByb3BzLnZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IHZNb2RlbFNlbGVjdCA9IHtcclxuICAgIC8vIDxzZWxlY3QgbXVsdGlwbGU+IHZhbHVlIG5lZWQgdG8gYmUgZGVlcCB0cmF2ZXJzZWRcclxuICAgIGRlZXA6IHRydWUsXHJcbiAgICBjcmVhdGVkKGVsLCB7IHZhbHVlLCBtb2RpZmllcnM6IHsgbnVtYmVyIH0gfSwgdm5vZGUpIHtcclxuICAgICAgICBjb25zdCBpc1NldE1vZGVsID0gaXNTZXQodmFsdWUpO1xyXG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsICdjaGFuZ2UnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkVmFsID0gQXJyYXkucHJvdG90eXBlLmZpbHRlclxyXG4gICAgICAgICAgICAgICAgLmNhbGwoZWwub3B0aW9ucywgKG8pID0+IG8uc2VsZWN0ZWQpXHJcbiAgICAgICAgICAgICAgICAubWFwKChvKSA9PiBudW1iZXIgPyB0b051bWJlcihnZXRWYWx1ZShvKSkgOiBnZXRWYWx1ZShvKSk7XHJcbiAgICAgICAgICAgIGVsLl9hc3NpZ24oZWwubXVsdGlwbGVcclxuICAgICAgICAgICAgICAgID8gaXNTZXRNb2RlbFxyXG4gICAgICAgICAgICAgICAgICAgID8gbmV3IFNldChzZWxlY3RlZFZhbClcclxuICAgICAgICAgICAgICAgICAgICA6IHNlbGVjdGVkVmFsXHJcbiAgICAgICAgICAgICAgICA6IHNlbGVjdGVkVmFsWzBdKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBlbC5fYXNzaWduID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XHJcbiAgICB9LFxyXG4gICAgLy8gc2V0IHZhbHVlIGluIG1vdW50ZWQgJiB1cGRhdGVkIGJlY2F1c2UgPHNlbGVjdD4gcmVsaWVzIG9uIGl0cyBjaGlsZHJlblxyXG4gICAgLy8gPG9wdGlvbj5zLlxyXG4gICAgbW91bnRlZChlbCwgeyB2YWx1ZSB9KSB7XHJcbiAgICAgICAgc2V0U2VsZWN0ZWQoZWwsIHZhbHVlKTtcclxuICAgIH0sXHJcbiAgICBiZWZvcmVVcGRhdGUoZWwsIF9iaW5kaW5nLCB2bm9kZSkge1xyXG4gICAgICAgIGVsLl9hc3NpZ24gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcclxuICAgIH0sXHJcbiAgICB1cGRhdGVkKGVsLCB7IHZhbHVlIH0pIHtcclxuICAgICAgICBzZXRTZWxlY3RlZChlbCwgdmFsdWUpO1xyXG4gICAgfVxyXG59O1xyXG5mdW5jdGlvbiBzZXRTZWxlY3RlZChlbCwgdmFsdWUpIHtcclxuICAgIGNvbnN0IGlzTXVsdGlwbGUgPSBlbC5tdWx0aXBsZTtcclxuICAgIGlmIChpc011bHRpcGxlICYmICFpc0FycmF5KHZhbHVlKSAmJiAhaXNTZXQodmFsdWUpKSB7XHJcbiAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgIHdhcm4oYDxzZWxlY3QgbXVsdGlwbGUgdi1tb2RlbD4gZXhwZWN0cyBhbiBBcnJheSBvciBTZXQgdmFsdWUgZm9yIGl0cyBiaW5kaW5nLCBgICtcclxuICAgICAgICAgICAgICAgIGBidXQgZ290ICR7T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSl9LmApO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGZvciAobGV0IGkgPSAwLCBsID0gZWwub3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBjb25zdCBvcHRpb24gPSBlbC5vcHRpb25zW2ldO1xyXG4gICAgICAgIGNvbnN0IG9wdGlvblZhbHVlID0gZ2V0VmFsdWUob3B0aW9uKTtcclxuICAgICAgICBpZiAoaXNNdWx0aXBsZSkge1xyXG4gICAgICAgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IGxvb3NlSW5kZXhPZih2YWx1ZSwgb3B0aW9uVmFsdWUpID4gLTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSB2YWx1ZS5oYXMob3B0aW9uVmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAobG9vc2VFcXVhbChnZXRWYWx1ZShvcHRpb24pLCB2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlbC5zZWxlY3RlZEluZGV4ICE9PSBpKVxyXG4gICAgICAgICAgICAgICAgICAgIGVsLnNlbGVjdGVkSW5kZXggPSBpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCFpc011bHRpcGxlICYmIGVsLnNlbGVjdGVkSW5kZXggIT09IC0xKSB7XHJcbiAgICAgICAgZWwuc2VsZWN0ZWRJbmRleCA9IC0xO1xyXG4gICAgfVxyXG59XHJcbi8vIHJldHJpZXZlIHJhdyB2YWx1ZSBzZXQgdmlhIDp2YWx1ZSBiaW5kaW5nc1xyXG5mdW5jdGlvbiBnZXRWYWx1ZShlbCkge1xyXG4gICAgcmV0dXJuICdfdmFsdWUnIGluIGVsID8gZWwuX3ZhbHVlIDogZWwudmFsdWU7XHJcbn1cclxuLy8gcmV0cmlldmUgcmF3IHZhbHVlIGZvciB0cnVlLXZhbHVlIGFuZCBmYWxzZS12YWx1ZSBzZXQgdmlhIDp0cnVlLXZhbHVlIG9yIDpmYWxzZS12YWx1ZSBiaW5kaW5nc1xyXG5mdW5jdGlvbiBnZXRDaGVja2JveFZhbHVlKGVsLCBjaGVja2VkKSB7XHJcbiAgICBjb25zdCBrZXkgPSBjaGVja2VkID8gJ190cnVlVmFsdWUnIDogJ19mYWxzZVZhbHVlJztcclxuICAgIHJldHVybiBrZXkgaW4gZWwgPyBlbFtrZXldIDogY2hlY2tlZDtcclxufVxyXG5jb25zdCB2TW9kZWxEeW5hbWljID0ge1xyXG4gICAgY3JlYXRlZChlbCwgYmluZGluZywgdm5vZGUpIHtcclxuICAgICAgICBjYWxsTW9kZWxIb29rKGVsLCBiaW5kaW5nLCB2bm9kZSwgbnVsbCwgJ2NyZWF0ZWQnKTtcclxuICAgIH0sXHJcbiAgICBtb3VudGVkKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xyXG4gICAgICAgIGNhbGxNb2RlbEhvb2soZWwsIGJpbmRpbmcsIHZub2RlLCBudWxsLCAnbW91bnRlZCcpO1xyXG4gICAgfSxcclxuICAgIGJlZm9yZVVwZGF0ZShlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSkge1xyXG4gICAgICAgIGNhbGxNb2RlbEhvb2soZWwsIGJpbmRpbmcsIHZub2RlLCBwcmV2Vk5vZGUsICdiZWZvcmVVcGRhdGUnKTtcclxuICAgIH0sXHJcbiAgICB1cGRhdGVkKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlKSB7XHJcbiAgICAgICAgY2FsbE1vZGVsSG9vayhlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSwgJ3VwZGF0ZWQnKTtcclxuICAgIH1cclxufTtcclxuZnVuY3Rpb24gcmVzb2x2ZUR5bmFtaWNNb2RlbCh0YWdOYW1lLCB0eXBlKSB7XHJcbiAgICBzd2l0Y2ggKHRhZ05hbWUpIHtcclxuICAgICAgICBjYXNlICdTRUxFQ1QnOlxyXG4gICAgICAgICAgICByZXR1cm4gdk1vZGVsU2VsZWN0O1xyXG4gICAgICAgIGNhc2UgJ1RFWFRBUkVBJzpcclxuICAgICAgICAgICAgcmV0dXJuIHZNb2RlbFRleHQ7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdjaGVja2JveCc6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZNb2RlbENoZWNrYm94O1xyXG4gICAgICAgICAgICAgICAgY2FzZSAncmFkaW8nOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2TW9kZWxSYWRpbztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZNb2RlbFRleHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjYWxsTW9kZWxIb29rKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlLCBob29rKSB7XHJcbiAgICBjb25zdCBtb2RlbFRvVXNlID0gcmVzb2x2ZUR5bmFtaWNNb2RlbChlbC50YWdOYW1lLCB2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wcy50eXBlKTtcclxuICAgIGNvbnN0IGZuID0gbW9kZWxUb1VzZVtob29rXTtcclxuICAgIGZuICYmIGZuKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlKTtcclxufVxyXG4vLyBTU1Igdm5vZGUgdHJhbnNmb3Jtcywgb25seSB1c2VkIHdoZW4gdXNlciBpbmNsdWRlcyBjbGllbnQtb3JpZW50ZWQgcmVuZGVyXHJcbi8vIGZ1bmN0aW9uIGluIFNTUlxyXG5mdW5jdGlvbiBpbml0Vk1vZGVsRm9yU1NSKCkge1xyXG4gICAgdk1vZGVsVGV4dC5nZXRTU1JQcm9wcyA9ICh7IHZhbHVlIH0pID0+ICh7IHZhbHVlIH0pO1xyXG4gICAgdk1vZGVsUmFkaW8uZ2V0U1NSUHJvcHMgPSAoeyB2YWx1ZSB9LCB2bm9kZSkgPT4ge1xyXG4gICAgICAgIGlmICh2bm9kZS5wcm9wcyAmJiBsb29zZUVxdWFsKHZub2RlLnByb3BzLnZhbHVlLCB2YWx1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgY2hlY2tlZDogdHJ1ZSB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB2TW9kZWxDaGVja2JveC5nZXRTU1JQcm9wcyA9ICh7IHZhbHVlIH0sIHZub2RlKSA9PiB7XHJcbiAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIGlmICh2bm9kZS5wcm9wcyAmJiBsb29zZUluZGV4T2YodmFsdWUsIHZub2RlLnByb3BzLnZhbHVlKSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyBjaGVja2VkOiB0cnVlIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNTZXQodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIGlmICh2bm9kZS5wcm9wcyAmJiB2YWx1ZS5oYXModm5vZGUucHJvcHMudmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyBjaGVja2VkOiB0cnVlIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgY2hlY2tlZDogdHJ1ZSB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB2TW9kZWxEeW5hbWljLmdldFNTUlByb3BzID0gKGJpbmRpbmcsIHZub2RlKSA9PiB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2bm9kZS50eXBlICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG1vZGVsVG9Vc2UgPSByZXNvbHZlRHluYW1pY01vZGVsKFxyXG4gICAgICAgIC8vIHJlc29sdmVEeW5hbWljTW9kZWwgZXhwZWN0cyBhbiB1cHBlcmNhc2UgdGFnIG5hbWUsIGJ1dCB2bm9kZS50eXBlIGlzIGxvd2VyY2FzZVxyXG4gICAgICAgIHZub2RlLnR5cGUudG9VcHBlckNhc2UoKSwgdm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHMudHlwZSk7XHJcbiAgICAgICAgaWYgKG1vZGVsVG9Vc2UuZ2V0U1NSUHJvcHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1vZGVsVG9Vc2UuZ2V0U1NSUHJvcHMoYmluZGluZywgdm5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cblxuY29uc3Qgc3lzdGVtTW9kaWZpZXJzID0gWydjdHJsJywgJ3NoaWZ0JywgJ2FsdCcsICdtZXRhJ107XHJcbmNvbnN0IG1vZGlmaWVyR3VhcmRzID0ge1xyXG4gICAgc3RvcDogZSA9PiBlLnN0b3BQcm9wYWdhdGlvbigpLFxyXG4gICAgcHJldmVudDogZSA9PiBlLnByZXZlbnREZWZhdWx0KCksXHJcbiAgICBzZWxmOiBlID0+IGUudGFyZ2V0ICE9PSBlLmN1cnJlbnRUYXJnZXQsXHJcbiAgICBjdHJsOiBlID0+ICFlLmN0cmxLZXksXHJcbiAgICBzaGlmdDogZSA9PiAhZS5zaGlmdEtleSxcclxuICAgIGFsdDogZSA9PiAhZS5hbHRLZXksXHJcbiAgICBtZXRhOiBlID0+ICFlLm1ldGFLZXksXHJcbiAgICBsZWZ0OiBlID0+ICdidXR0b24nIGluIGUgJiYgZS5idXR0b24gIT09IDAsXHJcbiAgICBtaWRkbGU6IGUgPT4gJ2J1dHRvbicgaW4gZSAmJiBlLmJ1dHRvbiAhPT0gMSxcclxuICAgIHJpZ2h0OiBlID0+ICdidXR0b24nIGluIGUgJiYgZS5idXR0b24gIT09IDIsXHJcbiAgICBleGFjdDogKGUsIG1vZGlmaWVycykgPT4gc3lzdGVtTW9kaWZpZXJzLnNvbWUobSA9PiBlW2Ake219S2V5YF0gJiYgIW1vZGlmaWVycy5pbmNsdWRlcyhtKSlcclxufTtcclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jb25zdCB3aXRoTW9kaWZpZXJzID0gKGZuLCBtb2RpZmllcnMpID0+IHtcclxuICAgIHJldHVybiAoZXZlbnQsIC4uLmFyZ3MpID0+IHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1vZGlmaWVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBndWFyZCA9IG1vZGlmaWVyR3VhcmRzW21vZGlmaWVyc1tpXV07XHJcbiAgICAgICAgICAgIGlmIChndWFyZCAmJiBndWFyZChldmVudCwgbW9kaWZpZXJzKSlcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZuKGV2ZW50LCAuLi5hcmdzKTtcclxuICAgIH07XHJcbn07XHJcbi8vIEtlcHQgZm9yIDIueCBjb21wYXQuXHJcbi8vIE5vdGU6IElFMTEgY29tcGF0IGZvciBgc3BhY2ViYXJgIGFuZCBgZGVsYCBpcyByZW1vdmVkIGZvciBub3cuXHJcbmNvbnN0IGtleU5hbWVzID0ge1xyXG4gICAgZXNjOiAnZXNjYXBlJyxcclxuICAgIHNwYWNlOiAnICcsXHJcbiAgICB1cDogJ2Fycm93LXVwJyxcclxuICAgIGxlZnQ6ICdhcnJvdy1sZWZ0JyxcclxuICAgIHJpZ2h0OiAnYXJyb3ctcmlnaHQnLFxyXG4gICAgZG93bjogJ2Fycm93LWRvd24nLFxyXG4gICAgZGVsZXRlOiAnYmFja3NwYWNlJ1xyXG59O1xyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbmNvbnN0IHdpdGhLZXlzID0gKGZuLCBtb2RpZmllcnMpID0+IHtcclxuICAgIHJldHVybiAoZXZlbnQpID0+IHtcclxuICAgICAgICBpZiAoISgna2V5JyBpbiBldmVudCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBldmVudEtleSA9IGh5cGhlbmF0ZShldmVudC5rZXkpO1xyXG4gICAgICAgIGlmIChtb2RpZmllcnMuc29tZShrID0+IGsgPT09IGV2ZW50S2V5IHx8IGtleU5hbWVzW2tdID09PSBldmVudEtleSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZuKGV2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59O1xuXG5jb25zdCB2U2hvdyA9IHtcclxuICAgIGJlZm9yZU1vdW50KGVsLCB7IHZhbHVlIH0sIHsgdHJhbnNpdGlvbiB9KSB7XHJcbiAgICAgICAgZWwuX3ZvZCA9IGVsLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJyA/ICcnIDogZWwuc3R5bGUuZGlzcGxheTtcclxuICAgICAgICBpZiAodHJhbnNpdGlvbiAmJiB2YWx1ZSkge1xyXG4gICAgICAgICAgICB0cmFuc2l0aW9uLmJlZm9yZUVudGVyKGVsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHNldERpc3BsYXkoZWwsIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgbW91bnRlZChlbCwgeyB2YWx1ZSB9LCB7IHRyYW5zaXRpb24gfSkge1xyXG4gICAgICAgIGlmICh0cmFuc2l0aW9uICYmIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRyYW5zaXRpb24uZW50ZXIoZWwpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICB1cGRhdGVkKGVsLCB7IHZhbHVlLCBvbGRWYWx1ZSB9LCB7IHRyYW5zaXRpb24gfSkge1xyXG4gICAgICAgIGlmICghdmFsdWUgPT09ICFvbGRWYWx1ZSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGlmICh0cmFuc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbi5iZWZvcmVFbnRlcihlbCk7XHJcbiAgICAgICAgICAgICAgICBzZXREaXNwbGF5KGVsLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb24uZW50ZXIoZWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbi5sZWF2ZShlbCwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldERpc3BsYXkoZWwsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzZXREaXNwbGF5KGVsLCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGJlZm9yZVVubW91bnQoZWwsIHsgdmFsdWUgfSkge1xyXG4gICAgICAgIHNldERpc3BsYXkoZWwsIHZhbHVlKTtcclxuICAgIH1cclxufTtcclxuZnVuY3Rpb24gc2V0RGlzcGxheShlbCwgdmFsdWUpIHtcclxuICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IGVsLl92b2QgOiAnbm9uZSc7XHJcbn1cclxuLy8gU1NSIHZub2RlIHRyYW5zZm9ybXMsIG9ubHkgdXNlZCB3aGVuIHVzZXIgaW5jbHVkZXMgY2xpZW50LW9yaWVudGVkIHJlbmRlclxyXG4vLyBmdW5jdGlvbiBpbiBTU1JcclxuZnVuY3Rpb24gaW5pdFZTaG93Rm9yU1NSKCkge1xyXG4gICAgdlNob3cuZ2V0U1NSUHJvcHMgPSAoeyB2YWx1ZSB9KSA9PiB7XHJcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4geyBzdHlsZTogeyBkaXNwbGF5OiAnbm9uZScgfSB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cblxuY29uc3QgcmVuZGVyZXJPcHRpb25zID0gLyojX19QVVJFX18qLyBleHRlbmQoeyBwYXRjaFByb3AgfSwgbm9kZU9wcyk7XHJcbi8vIGxhenkgY3JlYXRlIHRoZSByZW5kZXJlciAtIHRoaXMgbWFrZXMgY29yZSByZW5kZXJlciBsb2dpYyB0cmVlLXNoYWthYmxlXHJcbi8vIGluIGNhc2UgdGhlIHVzZXIgb25seSBpbXBvcnRzIHJlYWN0aXZpdHkgdXRpbGl0aWVzIGZyb20gVnVlLlxyXG5sZXQgcmVuZGVyZXI7XHJcbmxldCBlbmFibGVkSHlkcmF0aW9uID0gZmFsc2U7XHJcbmZ1bmN0aW9uIGVuc3VyZVJlbmRlcmVyKCkge1xyXG4gICAgcmV0dXJuIChyZW5kZXJlciB8fFxyXG4gICAgICAgIChyZW5kZXJlciA9IGNyZWF0ZVJlbmRlcmVyKHJlbmRlcmVyT3B0aW9ucykpKTtcclxufVxyXG5mdW5jdGlvbiBlbnN1cmVIeWRyYXRpb25SZW5kZXJlcigpIHtcclxuICAgIHJlbmRlcmVyID0gZW5hYmxlZEh5ZHJhdGlvblxyXG4gICAgICAgID8gcmVuZGVyZXJcclxuICAgICAgICA6IGNyZWF0ZUh5ZHJhdGlvblJlbmRlcmVyKHJlbmRlcmVyT3B0aW9ucyk7XHJcbiAgICBlbmFibGVkSHlkcmF0aW9uID0gdHJ1ZTtcclxuICAgIHJldHVybiByZW5kZXJlcjtcclxufVxyXG4vLyB1c2UgZXhwbGljaXQgdHlwZSBjYXN0cyBoZXJlIHRvIGF2b2lkIGltcG9ydCgpIGNhbGxzIGluIHJvbGxlZC11cCBkLnRzXHJcbmNvbnN0IHJlbmRlciA9ICgoLi4uYXJncykgPT4ge1xyXG4gICAgZW5zdXJlUmVuZGVyZXIoKS5yZW5kZXIoLi4uYXJncyk7XHJcbn0pO1xyXG5jb25zdCBoeWRyYXRlID0gKCguLi5hcmdzKSA9PiB7XHJcbiAgICBlbnN1cmVIeWRyYXRpb25SZW5kZXJlcigpLmh5ZHJhdGUoLi4uYXJncyk7XHJcbn0pO1xyXG5jb25zdCBjcmVhdGVBcHAgPSAoKC4uLmFyZ3MpID0+IHtcclxuICAgIGNvbnN0IGFwcCA9IGVuc3VyZVJlbmRlcmVyKCkuY3JlYXRlQXBwKC4uLmFyZ3MpO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGluamVjdE5hdGl2ZVRhZ0NoZWNrKGFwcCk7XHJcbiAgICAgICAgaW5qZWN0Q29tcGlsZXJPcHRpb25zQ2hlY2soYXBwKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgbW91bnQgfSA9IGFwcDtcclxuICAgIGFwcC5tb3VudCA9IChjb250YWluZXJPclNlbGVjdG9yKSA9PiB7XHJcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gbm9ybWFsaXplQ29udGFpbmVyKGNvbnRhaW5lck9yU2VsZWN0b3IpO1xyXG4gICAgICAgIGlmICghY29udGFpbmVyKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgY29uc3QgY29tcG9uZW50ID0gYXBwLl9jb21wb25lbnQ7XHJcbiAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKGNvbXBvbmVudCkgJiYgIWNvbXBvbmVudC5yZW5kZXIgJiYgIWNvbXBvbmVudC50ZW1wbGF0ZSkge1xyXG4gICAgICAgICAgICAvLyBfX1VOU0FGRV9fXHJcbiAgICAgICAgICAgIC8vIFJlYXNvbjogcG90ZW50aWFsIGV4ZWN1dGlvbiBvZiBKUyBleHByZXNzaW9ucyBpbiBpbi1ET00gdGVtcGxhdGUuXHJcbiAgICAgICAgICAgIC8vIFRoZSB1c2VyIG11c3QgbWFrZSBzdXJlIHRoZSBpbi1ET00gdGVtcGxhdGUgaXMgdHJ1c3RlZC4gSWYgaXQnc1xyXG4gICAgICAgICAgICAvLyByZW5kZXJlZCBieSB0aGUgc2VydmVyLCB0aGUgdGVtcGxhdGUgc2hvdWxkIG5vdCBjb250YWluIGFueSB1c2VyIGRhdGEuXHJcbiAgICAgICAgICAgIGNvbXBvbmVudC50ZW1wbGF0ZSA9IGNvbnRhaW5lci5pbm5lckhUTUw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNsZWFyIGNvbnRlbnQgYmVmb3JlIG1vdW50aW5nXHJcbiAgICAgICAgY29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xyXG4gICAgICAgIGNvbnN0IHByb3h5ID0gbW91bnQoY29udGFpbmVyLCBmYWxzZSwgY29udGFpbmVyIGluc3RhbmNlb2YgU1ZHRWxlbWVudCk7XHJcbiAgICAgICAgaWYgKGNvbnRhaW5lciBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgY29udGFpbmVyLnJlbW92ZUF0dHJpYnV0ZSgndi1jbG9haycpO1xyXG4gICAgICAgICAgICBjb250YWluZXIuc2V0QXR0cmlidXRlKCdkYXRhLXYtYXBwJywgJycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcHJveHk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGFwcDtcclxufSk7XHJcbmNvbnN0IGNyZWF0ZVNTUkFwcCA9ICgoLi4uYXJncykgPT4ge1xyXG4gICAgY29uc3QgYXBwID0gZW5zdXJlSHlkcmF0aW9uUmVuZGVyZXIoKS5jcmVhdGVBcHAoLi4uYXJncyk7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgaW5qZWN0TmF0aXZlVGFnQ2hlY2soYXBwKTtcclxuICAgICAgICBpbmplY3RDb21waWxlck9wdGlvbnNDaGVjayhhcHApO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyBtb3VudCB9ID0gYXBwO1xyXG4gICAgYXBwLm1vdW50ID0gKGNvbnRhaW5lck9yU2VsZWN0b3IpID0+IHtcclxuICAgICAgICBjb25zdCBjb250YWluZXIgPSBub3JtYWxpemVDb250YWluZXIoY29udGFpbmVyT3JTZWxlY3Rvcik7XHJcbiAgICAgICAgaWYgKGNvbnRhaW5lcikge1xyXG4gICAgICAgICAgICByZXR1cm4gbW91bnQoY29udGFpbmVyLCB0cnVlLCBjb250YWluZXIgaW5zdGFuY2VvZiBTVkdFbGVtZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGFwcDtcclxufSk7XHJcbmZ1bmN0aW9uIGluamVjdE5hdGl2ZVRhZ0NoZWNrKGFwcCkge1xyXG4gICAgLy8gSW5qZWN0IGBpc05hdGl2ZVRhZ2BcclxuICAgIC8vIHRoaXMgaXMgdXNlZCBmb3IgY29tcG9uZW50IG5hbWUgdmFsaWRhdGlvbiAoZGV2IG9ubHkpXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXBwLmNvbmZpZywgJ2lzTmF0aXZlVGFnJywge1xyXG4gICAgICAgIHZhbHVlOiAodGFnKSA9PiBpc0hUTUxUYWcodGFnKSB8fCBpc1NWR1RhZyh0YWcpLFxyXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZVxyXG4gICAgfSk7XHJcbn1cclxuLy8gZGV2IG9ubHlcclxuZnVuY3Rpb24gaW5qZWN0Q29tcGlsZXJPcHRpb25zQ2hlY2soYXBwKSB7XHJcbiAgICBpZiAoaXNSdW50aW1lT25seSgpKSB7XHJcbiAgICAgICAgY29uc3QgaXNDdXN0b21FbGVtZW50ID0gYXBwLmNvbmZpZy5pc0N1c3RvbUVsZW1lbnQ7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFwcC5jb25maWcsICdpc0N1c3RvbUVsZW1lbnQnLCB7XHJcbiAgICAgICAgICAgIGdldCgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpc0N1c3RvbUVsZW1lbnQ7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNldCgpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oYFRoZSBcXGBpc0N1c3RvbUVsZW1lbnRcXGAgY29uZmlnIG9wdGlvbiBpcyBkZXByZWNhdGVkLiBVc2UgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYFxcYGNvbXBpbGVyT3B0aW9ucy5pc0N1c3RvbUVsZW1lbnRcXGAgaW5zdGVhZC5gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IGNvbXBpbGVyT3B0aW9ucyA9IGFwcC5jb25maWcuY29tcGlsZXJPcHRpb25zO1xyXG4gICAgICAgIGNvbnN0IG1zZyA9IGBUaGUgXFxgY29tcGlsZXJPcHRpb25zXFxgIGNvbmZpZyBvcHRpb24gaXMgb25seSByZXNwZWN0ZWQgd2hlbiB1c2luZyBgICtcclxuICAgICAgICAgICAgYGEgYnVpbGQgb2YgVnVlLmpzIHRoYXQgaW5jbHVkZXMgdGhlIHJ1bnRpbWUgY29tcGlsZXIgKGFrYSBcImZ1bGwgYnVpbGRcIikuIGAgK1xyXG4gICAgICAgICAgICBgU2luY2UgeW91IGFyZSB1c2luZyB0aGUgcnVudGltZS1vbmx5IGJ1aWxkLCBcXGBjb21waWxlck9wdGlvbnNcXGAgYCArXHJcbiAgICAgICAgICAgIGBtdXN0IGJlIHBhc3NlZCB0byBcXGBAdnVlL2NvbXBpbGVyLWRvbVxcYCBpbiB0aGUgYnVpbGQgc2V0dXAgaW5zdGVhZC5cXG5gICtcclxuICAgICAgICAgICAgYC0gRm9yIHZ1ZS1sb2FkZXI6IHBhc3MgaXQgdmlhIHZ1ZS1sb2FkZXIncyBcXGBjb21waWxlck9wdGlvbnNcXGAgbG9hZGVyIG9wdGlvbi5cXG5gICtcclxuICAgICAgICAgICAgYC0gRm9yIHZ1ZS1jbGk6IHNlZSBodHRwczovL2NsaS52dWVqcy5vcmcvZ3VpZGUvd2VicGFjay5odG1sI21vZGlmeWluZy1vcHRpb25zLW9mLWEtbG9hZGVyXFxuYCArXHJcbiAgICAgICAgICAgIGAtIEZvciB2aXRlOiBwYXNzIGl0IHZpYSBAdml0ZWpzL3BsdWdpbi12dWUgb3B0aW9ucy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92aXRlanMvdml0ZS90cmVlL21haW4vcGFja2FnZXMvcGx1Z2luLXZ1ZSNleGFtcGxlLWZvci1wYXNzaW5nLW9wdGlvbnMtdG8tdnVlY29tcGlsZXItZG9tYDtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXBwLmNvbmZpZywgJ2NvbXBpbGVyT3B0aW9ucycsIHtcclxuICAgICAgICAgICAgZ2V0KCkge1xyXG4gICAgICAgICAgICAgICAgd2Fybihtc2cpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBpbGVyT3B0aW9ucztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0KCkge1xyXG4gICAgICAgICAgICAgICAgd2Fybihtc2cpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplQ29udGFpbmVyKGNvbnRhaW5lcikge1xyXG4gICAgaWYgKGlzU3RyaW5nKGNvbnRhaW5lcikpIHtcclxuICAgICAgICBjb25zdCByZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGNvbnRhaW5lcik7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhcmVzKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYEZhaWxlZCB0byBtb3VudCBhcHA6IG1vdW50IHRhcmdldCBzZWxlY3RvciBcIiR7Y29udGFpbmVyfVwiIHJldHVybmVkIG51bGwuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgd2luZG93LlNoYWRvd1Jvb3QgJiZcclxuICAgICAgICBjb250YWluZXIgaW5zdGFuY2VvZiB3aW5kb3cuU2hhZG93Um9vdCAmJlxyXG4gICAgICAgIGNvbnRhaW5lci5tb2RlID09PSAnY2xvc2VkJykge1xyXG4gICAgICAgIHdhcm4oYG1vdW50aW5nIG9uIGEgU2hhZG93Um9vdCB3aXRoIFxcYHttb2RlOiBcImNsb3NlZFwifVxcYCBtYXkgbGVhZCB0byB1bnByZWRpY3RhYmxlIGJ1Z3NgKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjb250YWluZXI7XHJcbn1cclxubGV0IHNzckRpcmVjdGl2ZUluaXRpYWxpemVkID0gZmFsc2U7XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNvbnN0IGluaXREaXJlY3RpdmVzRm9yU1NSID0gKCkgPT4ge1xyXG4gICAgICAgIGlmICghc3NyRGlyZWN0aXZlSW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICAgICAgc3NyRGlyZWN0aXZlSW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBpbml0Vk1vZGVsRm9yU1NSKCk7XHJcbiAgICAgICAgICAgIGluaXRWU2hvd0ZvclNTUigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcblxuZXhwb3J0IHsgVHJhbnNpdGlvbiwgVHJhbnNpdGlvbkdyb3VwLCBWdWVFbGVtZW50LCBjcmVhdGVBcHAsIGNyZWF0ZVNTUkFwcCwgZGVmaW5lQ3VzdG9tRWxlbWVudCwgZGVmaW5lU1NSQ3VzdG9tRWxlbWVudCwgaHlkcmF0ZSwgaW5pdERpcmVjdGl2ZXNGb3JTU1IsIHJlbmRlciwgdXNlQ3NzTW9kdWxlLCB1c2VDc3NWYXJzLCB2TW9kZWxDaGVja2JveCwgdk1vZGVsRHluYW1pYywgdk1vZGVsUmFkaW8sIHZNb2RlbFNlbGVjdCwgdk1vZGVsVGV4dCwgdlNob3csIHdpdGhLZXlzLCB3aXRoTW9kaWZpZXJzIH07XG4iLCIvKipcclxuICogTWFrZSBhIG1hcCBhbmQgcmV0dXJuIGEgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGEga2V5XHJcbiAqIGlzIGluIHRoYXQgbWFwLlxyXG4gKiBJTVBPUlRBTlQ6IGFsbCBjYWxscyBvZiB0aGlzIGZ1bmN0aW9uIG11c3QgYmUgcHJlZml4ZWQgd2l0aFxyXG4gKiBcXC9cXCojXFxfXFxfUFVSRVxcX1xcX1xcKlxcL1xyXG4gKiBTbyB0aGF0IHJvbGx1cCBjYW4gdHJlZS1zaGFrZSB0aGVtIGlmIG5lY2Vzc2FyeS5cclxuICovXHJcbmZ1bmN0aW9uIG1ha2VNYXAoc3RyLCBleHBlY3RzTG93ZXJDYXNlKSB7XHJcbiAgICBjb25zdCBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgY29uc3QgbGlzdCA9IHN0ci5zcGxpdCgnLCcpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbWFwW2xpc3RbaV1dID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBleHBlY3RzTG93ZXJDYXNlID8gdmFsID0+ICEhbWFwW3ZhbC50b0xvd2VyQ2FzZSgpXSA6IHZhbCA9PiAhIW1hcFt2YWxdO1xyXG59XG5cbi8qKlxyXG4gKiBkZXYgb25seSBmbGFnIC0+IG5hbWUgbWFwcGluZ1xyXG4gKi9cclxuY29uc3QgUGF0Y2hGbGFnTmFtZXMgPSB7XHJcbiAgICBbMSAvKiBURVhUICovXTogYFRFWFRgLFxyXG4gICAgWzIgLyogQ0xBU1MgKi9dOiBgQ0xBU1NgLFxyXG4gICAgWzQgLyogU1RZTEUgKi9dOiBgU1RZTEVgLFxyXG4gICAgWzggLyogUFJPUFMgKi9dOiBgUFJPUFNgLFxyXG4gICAgWzE2IC8qIEZVTExfUFJPUFMgKi9dOiBgRlVMTF9QUk9QU2AsXHJcbiAgICBbMzIgLyogSFlEUkFURV9FVkVOVFMgKi9dOiBgSFlEUkFURV9FVkVOVFNgLFxyXG4gICAgWzY0IC8qIFNUQUJMRV9GUkFHTUVOVCAqL106IGBTVEFCTEVfRlJBR01FTlRgLFxyXG4gICAgWzEyOCAvKiBLRVlFRF9GUkFHTUVOVCAqL106IGBLRVlFRF9GUkFHTUVOVGAsXHJcbiAgICBbMjU2IC8qIFVOS0VZRURfRlJBR01FTlQgKi9dOiBgVU5LRVlFRF9GUkFHTUVOVGAsXHJcbiAgICBbNTEyIC8qIE5FRURfUEFUQ0ggKi9dOiBgTkVFRF9QQVRDSGAsXHJcbiAgICBbMTAyNCAvKiBEWU5BTUlDX1NMT1RTICovXTogYERZTkFNSUNfU0xPVFNgLFxyXG4gICAgWzIwNDggLyogREVWX1JPT1RfRlJBR01FTlQgKi9dOiBgREVWX1JPT1RfRlJBR01FTlRgLFxyXG4gICAgWy0xIC8qIEhPSVNURUQgKi9dOiBgSE9JU1RFRGAsXHJcbiAgICBbLTIgLyogQkFJTCAqL106IGBCQUlMYFxyXG59O1xuXG4vKipcclxuICogRGV2IG9ubHlcclxuICovXHJcbmNvbnN0IHNsb3RGbGFnc1RleHQgPSB7XHJcbiAgICBbMSAvKiBTVEFCTEUgKi9dOiAnU1RBQkxFJyxcclxuICAgIFsyIC8qIERZTkFNSUMgKi9dOiAnRFlOQU1JQycsXHJcbiAgICBbMyAvKiBGT1JXQVJERUQgKi9dOiAnRk9SV0FSREVEJ1xyXG59O1xuXG5jb25zdCBHTE9CQUxTX1dISVRFX0xJU1RFRCA9ICdJbmZpbml0eSx1bmRlZmluZWQsTmFOLGlzRmluaXRlLGlzTmFOLHBhcnNlRmxvYXQscGFyc2VJbnQsZGVjb2RlVVJJLCcgK1xyXG4gICAgJ2RlY29kZVVSSUNvbXBvbmVudCxlbmNvZGVVUkksZW5jb2RlVVJJQ29tcG9uZW50LE1hdGgsTnVtYmVyLERhdGUsQXJyYXksJyArXHJcbiAgICAnT2JqZWN0LEJvb2xlYW4sU3RyaW5nLFJlZ0V4cCxNYXAsU2V0LEpTT04sSW50bCxCaWdJbnQnO1xyXG5jb25zdCBpc0dsb2JhbGx5V2hpdGVsaXN0ZWQgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoR0xPQkFMU19XSElURV9MSVNURUQpO1xuXG5jb25zdCByYW5nZSA9IDI7XHJcbmZ1bmN0aW9uIGdlbmVyYXRlQ29kZUZyYW1lKHNvdXJjZSwgc3RhcnQgPSAwLCBlbmQgPSBzb3VyY2UubGVuZ3RoKSB7XHJcbiAgICAvLyBTcGxpdCB0aGUgY29udGVudCBpbnRvIGluZGl2aWR1YWwgbGluZXMgYnV0IGNhcHR1cmUgdGhlIG5ld2xpbmUgc2VxdWVuY2VcclxuICAgIC8vIHRoYXQgc2VwYXJhdGVkIGVhY2ggbGluZS4gVGhpcyBpcyBpbXBvcnRhbnQgYmVjYXVzZSB0aGUgYWN0dWFsIHNlcXVlbmNlIGlzXHJcbiAgICAvLyBuZWVkZWQgdG8gcHJvcGVybHkgdGFrZSBpbnRvIGFjY291bnQgdGhlIGZ1bGwgbGluZSBsZW5ndGggZm9yIG9mZnNldFxyXG4gICAgLy8gY29tcGFyaXNvblxyXG4gICAgbGV0IGxpbmVzID0gc291cmNlLnNwbGl0KC8oXFxyP1xcbikvKTtcclxuICAgIC8vIFNlcGFyYXRlIHRoZSBsaW5lcyBhbmQgbmV3bGluZSBzZXF1ZW5jZXMgaW50byBzZXBhcmF0ZSBhcnJheXMgZm9yIGVhc2llciByZWZlcmVuY2luZ1xyXG4gICAgY29uc3QgbmV3bGluZVNlcXVlbmNlcyA9IGxpbmVzLmZpbHRlcigoXywgaWR4KSA9PiBpZHggJSAyID09PSAxKTtcclxuICAgIGxpbmVzID0gbGluZXMuZmlsdGVyKChfLCBpZHgpID0+IGlkeCAlIDIgPT09IDApO1xyXG4gICAgbGV0IGNvdW50ID0gMDtcclxuICAgIGNvbnN0IHJlcyA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvdW50ICs9XHJcbiAgICAgICAgICAgIGxpbmVzW2ldLmxlbmd0aCArXHJcbiAgICAgICAgICAgICAgICAoKG5ld2xpbmVTZXF1ZW5jZXNbaV0gJiYgbmV3bGluZVNlcXVlbmNlc1tpXS5sZW5ndGgpIHx8IDApO1xyXG4gICAgICAgIGlmIChjb3VudCA+PSBzdGFydCkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gaSAtIHJhbmdlOyBqIDw9IGkgKyByYW5nZSB8fCBlbmQgPiBjb3VudDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaiA8IDAgfHwgaiA+PSBsaW5lcy5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lID0gaiArIDE7XHJcbiAgICAgICAgICAgICAgICByZXMucHVzaChgJHtsaW5lfSR7JyAnLnJlcGVhdChNYXRoLm1heCgzIC0gU3RyaW5nKGxpbmUpLmxlbmd0aCwgMCkpfXwgICR7bGluZXNbal19YCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lTGVuZ3RoID0gbGluZXNbal0ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3TGluZVNlcUxlbmd0aCA9IChuZXdsaW5lU2VxdWVuY2VzW2pdICYmIG5ld2xpbmVTZXF1ZW5jZXNbal0ubGVuZ3RoKSB8fCAwO1xyXG4gICAgICAgICAgICAgICAgaWYgKGogPT09IGkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBwdXNoIHVuZGVybGluZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhZCA9IHN0YXJ0IC0gKGNvdW50IC0gKGxpbmVMZW5ndGggKyBuZXdMaW5lU2VxTGVuZ3RoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gTWF0aC5tYXgoMSwgZW5kID4gY291bnQgPyBsaW5lTGVuZ3RoIC0gcGFkIDogZW5kIC0gc3RhcnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKGAgICB8ICBgICsgJyAnLnJlcGVhdChwYWQpICsgJ14nLnJlcGVhdChsZW5ndGgpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGogPiBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZCA+IGNvdW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IE1hdGgubWF4KE1hdGgubWluKGVuZCAtIGNvdW50LCBsaW5lTGVuZ3RoKSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKGAgICB8ICBgICsgJ14nLnJlcGVhdChsZW5ndGgpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY291bnQgKz0gbGluZUxlbmd0aCArIG5ld0xpbmVTZXFMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcy5qb2luKCdcXG4nKTtcclxufVxuXG4vKipcclxuICogT24gdGhlIGNsaWVudCB3ZSBvbmx5IG5lZWQgdG8gb2ZmZXIgc3BlY2lhbCBjYXNlcyBmb3IgYm9vbGVhbiBhdHRyaWJ1dGVzIHRoYXRcclxuICogaGF2ZSBkaWZmZXJlbnQgbmFtZXMgZnJvbSB0aGVpciBjb3JyZXNwb25kaW5nIGRvbSBwcm9wZXJ0aWVzOlxyXG4gKiAtIGl0ZW1zY29wZSAtPiBOL0FcclxuICogLSBhbGxvd2Z1bGxzY3JlZW4gLT4gYWxsb3dGdWxsc2NyZWVuXHJcbiAqIC0gZm9ybW5vdmFsaWRhdGUgLT4gZm9ybU5vVmFsaWRhdGVcclxuICogLSBpc21hcCAtPiBpc01hcFxyXG4gKiAtIG5vbW9kdWxlIC0+IG5vTW9kdWxlXHJcbiAqIC0gbm92YWxpZGF0ZSAtPiBub1ZhbGlkYXRlXHJcbiAqIC0gcmVhZG9ubHkgLT4gcmVhZE9ubHlcclxuICovXHJcbmNvbnN0IHNwZWNpYWxCb29sZWFuQXR0cnMgPSBgaXRlbXNjb3BlLGFsbG93ZnVsbHNjcmVlbixmb3Jtbm92YWxpZGF0ZSxpc21hcCxub21vZHVsZSxub3ZhbGlkYXRlLHJlYWRvbmx5YDtcclxuY29uc3QgaXNTcGVjaWFsQm9vbGVhbkF0dHIgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoc3BlY2lhbEJvb2xlYW5BdHRycyk7XHJcbi8qKlxyXG4gKiBUaGUgZnVsbCBsaXN0IGlzIG5lZWRlZCBkdXJpbmcgU1NSIHRvIHByb2R1Y2UgdGhlIGNvcnJlY3QgaW5pdGlhbCBtYXJrdXAuXHJcbiAqL1xyXG5jb25zdCBpc0Jvb2xlYW5BdHRyID0gLyojX19QVVJFX18qLyBtYWtlTWFwKHNwZWNpYWxCb29sZWFuQXR0cnMgK1xyXG4gICAgYCxhc3luYyxhdXRvZm9jdXMsYXV0b3BsYXksY29udHJvbHMsZGVmYXVsdCxkZWZlcixkaXNhYmxlZCxoaWRkZW4sYCArXHJcbiAgICBgbG9vcCxvcGVuLHJlcXVpcmVkLHJldmVyc2VkLHNjb3BlZCxzZWFtbGVzcyxgICtcclxuICAgIGBjaGVja2VkLG11dGVkLG11bHRpcGxlLHNlbGVjdGVkYCk7XHJcbi8qKlxyXG4gKiBCb29sZWFuIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGluY2x1ZGVkIGlmIHRoZSB2YWx1ZSBpcyB0cnV0aHkgb3IgJycuXHJcbiAqIGUuZy4gYDxzZWxlY3QgbXVsdGlwbGU+YCBjb21waWxlcyB0byBgeyBtdWx0aXBsZTogJycgfWBcclxuICovXHJcbmZ1bmN0aW9uIGluY2x1ZGVCb29sZWFuQXR0cih2YWx1ZSkge1xyXG4gICAgcmV0dXJuICEhdmFsdWUgfHwgdmFsdWUgPT09ICcnO1xyXG59XHJcbmNvbnN0IHVuc2FmZUF0dHJDaGFyUkUgPSAvWz4vPVwiJ1xcdTAwMDlcXHUwMDBhXFx1MDAwY1xcdTAwMjBdLztcclxuY29uc3QgYXR0clZhbGlkYXRpb25DYWNoZSA9IHt9O1xyXG5mdW5jdGlvbiBpc1NTUlNhZmVBdHRyTmFtZShuYW1lKSB7XHJcbiAgICBpZiAoYXR0clZhbGlkYXRpb25DYWNoZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xyXG4gICAgICAgIHJldHVybiBhdHRyVmFsaWRhdGlvbkNhY2hlW25hbWVdO1xyXG4gICAgfVxyXG4gICAgY29uc3QgaXNVbnNhZmUgPSB1bnNhZmVBdHRyQ2hhclJFLnRlc3QobmFtZSk7XHJcbiAgICBpZiAoaXNVbnNhZmUpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKGB1bnNhZmUgYXR0cmlidXRlIG5hbWU6ICR7bmFtZX1gKTtcclxuICAgIH1cclxuICAgIHJldHVybiAoYXR0clZhbGlkYXRpb25DYWNoZVtuYW1lXSA9ICFpc1Vuc2FmZSk7XHJcbn1cclxuY29uc3QgcHJvcHNUb0F0dHJNYXAgPSB7XHJcbiAgICBhY2NlcHRDaGFyc2V0OiAnYWNjZXB0LWNoYXJzZXQnLFxyXG4gICAgY2xhc3NOYW1lOiAnY2xhc3MnLFxyXG4gICAgaHRtbEZvcjogJ2ZvcicsXHJcbiAgICBodHRwRXF1aXY6ICdodHRwLWVxdWl2J1xyXG59O1xyXG4vKipcclxuICogQ1NTIHByb3BlcnRpZXMgdGhhdCBhY2NlcHQgcGxhaW4gbnVtYmVyc1xyXG4gKi9cclxuY29uc3QgaXNOb1VuaXROdW1lcmljU3R5bGVQcm9wID0gLyojX19QVVJFX18qLyBtYWtlTWFwKGBhbmltYXRpb24taXRlcmF0aW9uLWNvdW50LGJvcmRlci1pbWFnZS1vdXRzZXQsYm9yZGVyLWltYWdlLXNsaWNlLGAgK1xyXG4gICAgYGJvcmRlci1pbWFnZS13aWR0aCxib3gtZmxleCxib3gtZmxleC1ncm91cCxib3gtb3JkaW5hbC1ncm91cCxjb2x1bW4tY291bnQsYCArXHJcbiAgICBgY29sdW1ucyxmbGV4LGZsZXgtZ3JvdyxmbGV4LXBvc2l0aXZlLGZsZXgtc2hyaW5rLGZsZXgtbmVnYXRpdmUsZmxleC1vcmRlcixgICtcclxuICAgIGBncmlkLXJvdyxncmlkLXJvdy1lbmQsZ3JpZC1yb3ctc3BhbixncmlkLXJvdy1zdGFydCxncmlkLWNvbHVtbixgICtcclxuICAgIGBncmlkLWNvbHVtbi1lbmQsZ3JpZC1jb2x1bW4tc3BhbixncmlkLWNvbHVtbi1zdGFydCxmb250LXdlaWdodCxsaW5lLWNsYW1wLGAgK1xyXG4gICAgYGxpbmUtaGVpZ2h0LG9wYWNpdHksb3JkZXIsb3JwaGFucyx0YWItc2l6ZSx3aWRvd3Msei1pbmRleCx6b29tLGAgK1xyXG4gICAgLy8gU1ZHXHJcbiAgICBgZmlsbC1vcGFjaXR5LGZsb29kLW9wYWNpdHksc3RvcC1vcGFjaXR5LHN0cm9rZS1kYXNoYXJyYXksc3Ryb2tlLWRhc2hvZmZzZXQsYCArXHJcbiAgICBgc3Ryb2tlLW1pdGVybGltaXQsc3Ryb2tlLW9wYWNpdHksc3Ryb2tlLXdpZHRoYCk7XHJcbi8qKlxyXG4gKiBLbm93biBhdHRyaWJ1dGVzLCB0aGlzIGlzIHVzZWQgZm9yIHN0cmluZ2lmaWNhdGlvbiBvZiBydW50aW1lIHN0YXRpYyBub2Rlc1xyXG4gKiBzbyB0aGF0IHdlIGRvbid0IHN0cmluZ2lmeSBiaW5kaW5ncyB0aGF0IGNhbm5vdCBiZSBzZXQgZnJvbSBIVE1MLlxyXG4gKiBEb24ndCBhbHNvIGZvcmdldCB0byBhbGxvdyBgZGF0YS0qYCBhbmQgYGFyaWEtKmAhXHJcbiAqIEdlbmVyYXRlZCBmcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvQXR0cmlidXRlc1xyXG4gKi9cclxuY29uc3QgaXNLbm93bkh0bWxBdHRyID0gLyojX19QVVJFX18qLyBtYWtlTWFwKGBhY2NlcHQsYWNjZXB0LWNoYXJzZXQsYWNjZXNza2V5LGFjdGlvbixhbGlnbixhbGxvdyxhbHQsYXN5bmMsYCArXHJcbiAgICBgYXV0b2NhcGl0YWxpemUsYXV0b2NvbXBsZXRlLGF1dG9mb2N1cyxhdXRvcGxheSxiYWNrZ3JvdW5kLGJnY29sb3IsYCArXHJcbiAgICBgYm9yZGVyLGJ1ZmZlcmVkLGNhcHR1cmUsY2hhbGxlbmdlLGNoYXJzZXQsY2hlY2tlZCxjaXRlLGNsYXNzLGNvZGUsYCArXHJcbiAgICBgY29kZWJhc2UsY29sb3IsY29scyxjb2xzcGFuLGNvbnRlbnQsY29udGVudGVkaXRhYmxlLGNvbnRleHRtZW51LGNvbnRyb2xzLGAgK1xyXG4gICAgYGNvb3Jkcyxjcm9zc29yaWdpbixjc3AsZGF0YSxkYXRldGltZSxkZWNvZGluZyxkZWZhdWx0LGRlZmVyLGRpcixkaXJuYW1lLGAgK1xyXG4gICAgYGRpc2FibGVkLGRvd25sb2FkLGRyYWdnYWJsZSxkcm9wem9uZSxlbmN0eXBlLGVudGVya2V5aGludCxmb3IsZm9ybSxgICtcclxuICAgIGBmb3JtYWN0aW9uLGZvcm1lbmN0eXBlLGZvcm1tZXRob2QsZm9ybW5vdmFsaWRhdGUsZm9ybXRhcmdldCxoZWFkZXJzLGAgK1xyXG4gICAgYGhlaWdodCxoaWRkZW4saGlnaCxocmVmLGhyZWZsYW5nLGh0dHAtZXF1aXYsaWNvbixpZCxpbXBvcnRhbmNlLGludGVncml0eSxgICtcclxuICAgIGBpc21hcCxpdGVtcHJvcCxrZXl0eXBlLGtpbmQsbGFiZWwsbGFuZyxsYW5ndWFnZSxsb2FkaW5nLGxpc3QsbG9vcCxsb3csYCArXHJcbiAgICBgbWFuaWZlc3QsbWF4LG1heGxlbmd0aCxtaW5sZW5ndGgsbWVkaWEsbWluLG11bHRpcGxlLG11dGVkLG5hbWUsbm92YWxpZGF0ZSxgICtcclxuICAgIGBvcGVuLG9wdGltdW0scGF0dGVybixwaW5nLHBsYWNlaG9sZGVyLHBvc3RlcixwcmVsb2FkLHJhZGlvZ3JvdXAscmVhZG9ubHksYCArXHJcbiAgICBgcmVmZXJyZXJwb2xpY3kscmVsLHJlcXVpcmVkLHJldmVyc2VkLHJvd3Mscm93c3BhbixzYW5kYm94LHNjb3BlLHNjb3BlZCxgICtcclxuICAgIGBzZWxlY3RlZCxzaGFwZSxzaXplLHNpemVzLHNsb3Qsc3BhbixzcGVsbGNoZWNrLHNyYyxzcmNkb2Msc3JjbGFuZyxzcmNzZXQsYCArXHJcbiAgICBgc3RhcnQsc3RlcCxzdHlsZSxzdW1tYXJ5LHRhYmluZGV4LHRhcmdldCx0aXRsZSx0cmFuc2xhdGUsdHlwZSx1c2VtYXAsYCArXHJcbiAgICBgdmFsdWUsd2lkdGgsd3JhcGApO1xyXG4vKipcclxuICogR2VuZXJhdGVkIGZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZVxyXG4gKi9cclxuY29uc3QgaXNLbm93blN2Z0F0dHIgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoYHhtbG5zLGFjY2VudC1oZWlnaHQsYWNjdW11bGF0ZSxhZGRpdGl2ZSxhbGlnbm1lbnQtYmFzZWxpbmUsYWxwaGFiZXRpYyxhbXBsaXR1ZGUsYCArXHJcbiAgICBgYXJhYmljLWZvcm0sYXNjZW50LGF0dHJpYnV0ZU5hbWUsYXR0cmlidXRlVHlwZSxhemltdXRoLGJhc2VGcmVxdWVuY3ksYCArXHJcbiAgICBgYmFzZWxpbmUtc2hpZnQsYmFzZVByb2ZpbGUsYmJveCxiZWdpbixiaWFzLGJ5LGNhbGNNb2RlLGNhcC1oZWlnaHQsY2xhc3MsYCArXHJcbiAgICBgY2xpcCxjbGlwUGF0aFVuaXRzLGNsaXAtcGF0aCxjbGlwLXJ1bGUsY29sb3IsY29sb3ItaW50ZXJwb2xhdGlvbixgICtcclxuICAgIGBjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMsY29sb3ItcHJvZmlsZSxjb2xvci1yZW5kZXJpbmcsYCArXHJcbiAgICBgY29udGVudFNjcmlwdFR5cGUsY29udGVudFN0eWxlVHlwZSxjcm9zc29yaWdpbixjdXJzb3IsY3gsY3ksZCxkZWNlbGVyYXRlLGAgK1xyXG4gICAgYGRlc2NlbnQsZGlmZnVzZUNvbnN0YW50LGRpcmVjdGlvbixkaXNwbGF5LGRpdmlzb3IsZG9taW5hbnQtYmFzZWxpbmUsZHVyLGR4LGAgK1xyXG4gICAgYGR5LGVkZ2VNb2RlLGVsZXZhdGlvbixlbmFibGUtYmFja2dyb3VuZCxlbmQsZXhwb25lbnQsZmlsbCxmaWxsLW9wYWNpdHksYCArXHJcbiAgICBgZmlsbC1ydWxlLGZpbHRlcixmaWx0ZXJSZXMsZmlsdGVyVW5pdHMsZmxvb2QtY29sb3IsZmxvb2Qtb3BhY2l0eSxgICtcclxuICAgIGBmb250LWZhbWlseSxmb250LXNpemUsZm9udC1zaXplLWFkanVzdCxmb250LXN0cmV0Y2gsZm9udC1zdHlsZSxgICtcclxuICAgIGBmb250LXZhcmlhbnQsZm9udC13ZWlnaHQsZm9ybWF0LGZyb20sZnIsZngsZnksZzEsZzIsZ2x5cGgtbmFtZSxgICtcclxuICAgIGBnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsLGdseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsLGdseXBoUmVmLGAgK1xyXG4gICAgYGdyYWRpZW50VHJhbnNmb3JtLGdyYWRpZW50VW5pdHMsaGFuZ2luZyxoZWlnaHQsaHJlZixocmVmbGFuZyxob3Jpei1hZHYteCxgICtcclxuICAgIGBob3Jpei1vcmlnaW4teCxpZCxpZGVvZ3JhcGhpYyxpbWFnZS1yZW5kZXJpbmcsaW4saW4yLGludGVyY2VwdCxrLGsxLGsyLGszLGAgK1xyXG4gICAgYGs0LGtlcm5lbE1hdHJpeCxrZXJuZWxVbml0TGVuZ3RoLGtlcm5pbmcsa2V5UG9pbnRzLGtleVNwbGluZXMsa2V5VGltZXMsYCArXHJcbiAgICBgbGFuZyxsZW5ndGhBZGp1c3QsbGV0dGVyLXNwYWNpbmcsbGlnaHRpbmctY29sb3IsbGltaXRpbmdDb25lQW5nbGUsbG9jYWwsYCArXHJcbiAgICBgbWFya2VyLWVuZCxtYXJrZXItbWlkLG1hcmtlci1zdGFydCxtYXJrZXJIZWlnaHQsbWFya2VyVW5pdHMsbWFya2VyV2lkdGgsYCArXHJcbiAgICBgbWFzayxtYXNrQ29udGVudFVuaXRzLG1hc2tVbml0cyxtYXRoZW1hdGljYWwsbWF4LG1lZGlhLG1ldGhvZCxtaW4sbW9kZSxgICtcclxuICAgIGBuYW1lLG51bU9jdGF2ZXMsb2Zmc2V0LG9wYWNpdHksb3BlcmF0b3Isb3JkZXIsb3JpZW50LG9yaWVudGF0aW9uLG9yaWdpbixgICtcclxuICAgIGBvdmVyZmxvdyxvdmVybGluZS1wb3NpdGlvbixvdmVybGluZS10aGlja25lc3MscGFub3NlLTEscGFpbnQtb3JkZXIscGF0aCxgICtcclxuICAgIGBwYXRoTGVuZ3RoLHBhdHRlcm5Db250ZW50VW5pdHMscGF0dGVyblRyYW5zZm9ybSxwYXR0ZXJuVW5pdHMscGluZyxgICtcclxuICAgIGBwb2ludGVyLWV2ZW50cyxwb2ludHMscG9pbnRzQXRYLHBvaW50c0F0WSxwb2ludHNBdFoscHJlc2VydmVBbHBoYSxgICtcclxuICAgIGBwcmVzZXJ2ZUFzcGVjdFJhdGlvLHByaW1pdGl2ZVVuaXRzLHIscmFkaXVzLHJlZmVycmVyUG9saWN5LHJlZlgscmVmWSxyZWwsYCArXHJcbiAgICBgcmVuZGVyaW5nLWludGVudCxyZXBlYXRDb3VudCxyZXBlYXREdXIscmVxdWlyZWRFeHRlbnNpb25zLHJlcXVpcmVkRmVhdHVyZXMsYCArXHJcbiAgICBgcmVzdGFydCxyZXN1bHQscm90YXRlLHJ4LHJ5LHNjYWxlLHNlZWQsc2hhcGUtcmVuZGVyaW5nLHNsb3BlLHNwYWNpbmcsYCArXHJcbiAgICBgc3BlY3VsYXJDb25zdGFudCxzcGVjdWxhckV4cG9uZW50LHNwZWVkLHNwcmVhZE1ldGhvZCxzdGFydE9mZnNldCxgICtcclxuICAgIGBzdGREZXZpYXRpb24sc3RlbWgsc3RlbXYsc3RpdGNoVGlsZXMsc3RvcC1jb2xvcixzdG9wLW9wYWNpdHksYCArXHJcbiAgICBgc3RyaWtldGhyb3VnaC1wb3NpdGlvbixzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcyxzdHJpbmcsc3Ryb2tlLGAgK1xyXG4gICAgYHN0cm9rZS1kYXNoYXJyYXksc3Ryb2tlLWRhc2hvZmZzZXQsc3Ryb2tlLWxpbmVjYXAsc3Ryb2tlLWxpbmVqb2luLGAgK1xyXG4gICAgYHN0cm9rZS1taXRlcmxpbWl0LHN0cm9rZS1vcGFjaXR5LHN0cm9rZS13aWR0aCxzdHlsZSxzdXJmYWNlU2NhbGUsYCArXHJcbiAgICBgc3lzdGVtTGFuZ3VhZ2UsdGFiaW5kZXgsdGFibGVWYWx1ZXMsdGFyZ2V0LHRhcmdldFgsdGFyZ2V0WSx0ZXh0LWFuY2hvcixgICtcclxuICAgIGB0ZXh0LWRlY29yYXRpb24sdGV4dC1yZW5kZXJpbmcsdGV4dExlbmd0aCx0byx0cmFuc2Zvcm0sdHJhbnNmb3JtLW9yaWdpbixgICtcclxuICAgIGB0eXBlLHUxLHUyLHVuZGVybGluZS1wb3NpdGlvbix1bmRlcmxpbmUtdGhpY2tuZXNzLHVuaWNvZGUsdW5pY29kZS1iaWRpLGAgK1xyXG4gICAgYHVuaWNvZGUtcmFuZ2UsdW5pdHMtcGVyLWVtLHYtYWxwaGFiZXRpYyx2LWhhbmdpbmcsdi1pZGVvZ3JhcGhpYyxgICtcclxuICAgIGB2LW1hdGhlbWF0aWNhbCx2YWx1ZXMsdmVjdG9yLWVmZmVjdCx2ZXJzaW9uLHZlcnQtYWR2LXksdmVydC1vcmlnaW4teCxgICtcclxuICAgIGB2ZXJ0LW9yaWdpbi15LHZpZXdCb3gsdmlld1RhcmdldCx2aXNpYmlsaXR5LHdpZHRoLHdpZHRocyx3b3JkLXNwYWNpbmcsYCArXHJcbiAgICBgd3JpdGluZy1tb2RlLHgseC1oZWlnaHQseDEseDIseENoYW5uZWxTZWxlY3Rvcix4bGluazphY3R1YXRlLHhsaW5rOmFyY3JvbGUsYCArXHJcbiAgICBgeGxpbms6aHJlZix4bGluazpyb2xlLHhsaW5rOnNob3cseGxpbms6dGl0bGUseGxpbms6dHlwZSx4bWw6YmFzZSx4bWw6bGFuZyxgICtcclxuICAgIGB4bWw6c3BhY2UseSx5MSx5Mix5Q2hhbm5lbFNlbGVjdG9yLHosem9vbUFuZFBhbmApO1xuXG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZSh2YWx1ZSkge1xyXG4gICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgY29uc3QgcmVzID0ge307XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBpdGVtID0gdmFsdWVbaV07XHJcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBpc1N0cmluZyhpdGVtKVxyXG4gICAgICAgICAgICAgICAgPyBwYXJzZVN0cmluZ1N0eWxlKGl0ZW0pXHJcbiAgICAgICAgICAgICAgICA6IG5vcm1hbGl6ZVN0eWxlKGl0ZW0pO1xyXG4gICAgICAgICAgICBpZiAobm9ybWFsaXplZCkge1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbm9ybWFsaXplZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc1trZXldID0gbm9ybWFsaXplZFtrZXldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgbGlzdERlbGltaXRlclJFID0gLzsoPyFbXihdKlxcKSkvZztcclxuY29uc3QgcHJvcGVydHlEZWxpbWl0ZXJSRSA9IC86KC4rKS87XHJcbmZ1bmN0aW9uIHBhcnNlU3RyaW5nU3R5bGUoY3NzVGV4dCkge1xyXG4gICAgY29uc3QgcmV0ID0ge307XHJcbiAgICBjc3NUZXh0LnNwbGl0KGxpc3REZWxpbWl0ZXJSRSkuZm9yRWFjaChpdGVtID0+IHtcclxuICAgICAgICBpZiAoaXRlbSkge1xyXG4gICAgICAgICAgICBjb25zdCB0bXAgPSBpdGVtLnNwbGl0KHByb3BlcnR5RGVsaW1pdGVyUkUpO1xyXG4gICAgICAgICAgICB0bXAubGVuZ3RoID4gMSAmJiAocmV0W3RtcFswXS50cmltKCldID0gdG1wWzFdLnRyaW0oKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmV0O1xyXG59XHJcbmZ1bmN0aW9uIHN0cmluZ2lmeVN0eWxlKHN0eWxlcykge1xyXG4gICAgbGV0IHJldCA9ICcnO1xyXG4gICAgaWYgKCFzdHlsZXMgfHwgaXNTdHJpbmcoc3R5bGVzKSkge1xyXG4gICAgICAgIHJldHVybiByZXQ7XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzdHlsZXMpIHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IHN0eWxlc1trZXldO1xyXG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRLZXkgPSBrZXkuc3RhcnRzV2l0aChgLS1gKSA/IGtleSA6IGh5cGhlbmF0ZShrZXkpO1xyXG4gICAgICAgIGlmIChpc1N0cmluZyh2YWx1ZSkgfHxcclxuICAgICAgICAgICAgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNOb1VuaXROdW1lcmljU3R5bGVQcm9wKG5vcm1hbGl6ZWRLZXkpKSkge1xyXG4gICAgICAgICAgICAvLyBvbmx5IHJlbmRlciB2YWxpZCB2YWx1ZXNcclxuICAgICAgICAgICAgcmV0ICs9IGAke25vcm1hbGl6ZWRLZXl9OiR7dmFsdWV9O2A7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJldDtcclxufVxyXG5mdW5jdGlvbiBub3JtYWxpemVDbGFzcyh2YWx1ZSkge1xyXG4gICAgbGV0IHJlcyA9ICcnO1xyXG4gICAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xyXG4gICAgICAgIHJlcyA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVDbGFzcyh2YWx1ZVtpXSk7XHJcbiAgICAgICAgICAgIGlmIChub3JtYWxpemVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXMgKz0gbm9ybWFsaXplZCArICcgJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xyXG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiB2YWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAodmFsdWVbbmFtZV0pIHtcclxuICAgICAgICAgICAgICAgIHJlcyArPSBuYW1lICsgJyAnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcy50cmltKCk7XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplUHJvcHMocHJvcHMpIHtcclxuICAgIGlmICghcHJvcHMpXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICBsZXQgeyBjbGFzczoga2xhc3MsIHN0eWxlIH0gPSBwcm9wcztcclxuICAgIGlmIChrbGFzcyAmJiAhaXNTdHJpbmcoa2xhc3MpKSB7XHJcbiAgICAgICAgcHJvcHMuY2xhc3MgPSBub3JtYWxpemVDbGFzcyhrbGFzcyk7XHJcbiAgICB9XHJcbiAgICBpZiAoc3R5bGUpIHtcclxuICAgICAgICBwcm9wcy5zdHlsZSA9IG5vcm1hbGl6ZVN0eWxlKHN0eWxlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBwcm9wcztcclxufVxuXG4vLyBUaGVzZSB0YWcgY29uZmlncyBhcmUgc2hhcmVkIGJldHdlZW4gY29tcGlsZXItZG9tIGFuZCBydW50aW1lLWRvbSwgc28gdGhleVxyXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnRcclxuY29uc3QgSFRNTF9UQUdTID0gJ2h0bWwsYm9keSxiYXNlLGhlYWQsbGluayxtZXRhLHN0eWxlLHRpdGxlLGFkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsJyArXHJcbiAgICAnaGVhZGVyLGgxLGgyLGgzLGg0LGg1LGg2LG5hdixzZWN0aW9uLGRpdixkZCxkbCxkdCxmaWdjYXB0aW9uLCcgK1xyXG4gICAgJ2ZpZ3VyZSxwaWN0dXJlLGhyLGltZyxsaSxtYWluLG9sLHAscHJlLHVsLGEsYixhYmJyLGJkaSxiZG8sYnIsY2l0ZSxjb2RlLCcgK1xyXG4gICAgJ2RhdGEsZGZuLGVtLGksa2JkLG1hcmsscSxycCxydCxydWJ5LHMsc2FtcCxzbWFsbCxzcGFuLHN0cm9uZyxzdWIsc3VwLCcgK1xyXG4gICAgJ3RpbWUsdSx2YXIsd2JyLGFyZWEsYXVkaW8sbWFwLHRyYWNrLHZpZGVvLGVtYmVkLG9iamVjdCxwYXJhbSxzb3VyY2UsJyArXHJcbiAgICAnY2FudmFzLHNjcmlwdCxub3NjcmlwdCxkZWwsaW5zLGNhcHRpb24sY29sLGNvbGdyb3VwLHRhYmxlLHRoZWFkLHRib2R5LHRkLCcgK1xyXG4gICAgJ3RoLHRyLGJ1dHRvbixkYXRhbGlzdCxmaWVsZHNldCxmb3JtLGlucHV0LGxhYmVsLGxlZ2VuZCxtZXRlcixvcHRncm91cCwnICtcclxuICAgICdvcHRpb24sb3V0cHV0LHByb2dyZXNzLHNlbGVjdCx0ZXh0YXJlYSxkZXRhaWxzLGRpYWxvZyxtZW51LCcgK1xyXG4gICAgJ3N1bW1hcnksdGVtcGxhdGUsYmxvY2txdW90ZSxpZnJhbWUsdGZvb3QnO1xyXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9TVkcvRWxlbWVudFxyXG5jb25zdCBTVkdfVEFHUyA9ICdzdmcsYW5pbWF0ZSxhbmltYXRlTW90aW9uLGFuaW1hdGVUcmFuc2Zvcm0sY2lyY2xlLGNsaXBQYXRoLGNvbG9yLXByb2ZpbGUsJyArXHJcbiAgICAnZGVmcyxkZXNjLGRpc2NhcmQsZWxsaXBzZSxmZUJsZW5kLGZlQ29sb3JNYXRyaXgsZmVDb21wb25lbnRUcmFuc2ZlciwnICtcclxuICAgICdmZUNvbXBvc2l0ZSxmZUNvbnZvbHZlTWF0cml4LGZlRGlmZnVzZUxpZ2h0aW5nLGZlRGlzcGxhY2VtZW50TWFwLCcgK1xyXG4gICAgJ2ZlRGlzdGFuY2VMaWdodCxmZURyb3BTaGFkb3csZmVGbG9vZCxmZUZ1bmNBLGZlRnVuY0IsZmVGdW5jRyxmZUZ1bmNSLCcgK1xyXG4gICAgJ2ZlR2F1c3NpYW5CbHVyLGZlSW1hZ2UsZmVNZXJnZSxmZU1lcmdlTm9kZSxmZU1vcnBob2xvZ3ksZmVPZmZzZXQsJyArXHJcbiAgICAnZmVQb2ludExpZ2h0LGZlU3BlY3VsYXJMaWdodGluZyxmZVNwb3RMaWdodCxmZVRpbGUsZmVUdXJidWxlbmNlLGZpbHRlciwnICtcclxuICAgICdmb3JlaWduT2JqZWN0LGcsaGF0Y2gsaGF0Y2hwYXRoLGltYWdlLGxpbmUsbGluZWFyR3JhZGllbnQsbWFya2VyLG1hc2ssJyArXHJcbiAgICAnbWVzaCxtZXNoZ3JhZGllbnQsbWVzaHBhdGNoLG1lc2hyb3csbWV0YWRhdGEsbXBhdGgscGF0aCxwYXR0ZXJuLCcgK1xyXG4gICAgJ3BvbHlnb24scG9seWxpbmUscmFkaWFsR3JhZGllbnQscmVjdCxzZXQsc29saWRjb2xvcixzdG9wLHN3aXRjaCxzeW1ib2wsJyArXHJcbiAgICAndGV4dCx0ZXh0UGF0aCx0aXRsZSx0c3Bhbix1bmtub3duLHVzZSx2aWV3JztcclxuY29uc3QgVk9JRF9UQUdTID0gJ2FyZWEsYmFzZSxicixjb2wsZW1iZWQsaHIsaW1nLGlucHV0LGxpbmssbWV0YSxwYXJhbSxzb3VyY2UsdHJhY2ssd2JyJztcclxuLyoqXHJcbiAqIENvbXBpbGVyIG9ubHkuXHJcbiAqIERvIE5PVCB1c2UgaW4gcnVudGltZSBjb2RlIHBhdGhzIHVubGVzcyBiZWhpbmQgYChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKWAgZmxhZy5cclxuICovXHJcbmNvbnN0IGlzSFRNTFRhZyA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChIVE1MX1RBR1MpO1xyXG4vKipcclxuICogQ29tcGlsZXIgb25seS5cclxuICogRG8gTk9UIHVzZSBpbiBydW50aW1lIGNvZGUgcGF0aHMgdW5sZXNzIGJlaGluZCBgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpYCBmbGFnLlxyXG4gKi9cclxuY29uc3QgaXNTVkdUYWcgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoU1ZHX1RBR1MpO1xyXG4vKipcclxuICogQ29tcGlsZXIgb25seS5cclxuICogRG8gTk9UIHVzZSBpbiBydW50aW1lIGNvZGUgcGF0aHMgdW5sZXNzIGJlaGluZCBgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpYCBmbGFnLlxyXG4gKi9cclxuY29uc3QgaXNWb2lkVGFnID0gLyojX19QVVJFX18qLyBtYWtlTWFwKFZPSURfVEFHUyk7XG5cbmNvbnN0IGVzY2FwZVJFID0gL1tcIicmPD5dLztcclxuZnVuY3Rpb24gZXNjYXBlSHRtbChzdHJpbmcpIHtcclxuICAgIGNvbnN0IHN0ciA9ICcnICsgc3RyaW5nO1xyXG4gICAgY29uc3QgbWF0Y2ggPSBlc2NhcGVSRS5leGVjKHN0cik7XHJcbiAgICBpZiAoIW1hdGNoKSB7XHJcbiAgICAgICAgcmV0dXJuIHN0cjtcclxuICAgIH1cclxuICAgIGxldCBodG1sID0gJyc7XHJcbiAgICBsZXQgZXNjYXBlZDtcclxuICAgIGxldCBpbmRleDtcclxuICAgIGxldCBsYXN0SW5kZXggPSAwO1xyXG4gICAgZm9yIChpbmRleCA9IG1hdGNoLmluZGV4OyBpbmRleCA8IHN0ci5sZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgICBzd2l0Y2ggKHN0ci5jaGFyQ29kZUF0KGluZGV4KSkge1xyXG4gICAgICAgICAgICBjYXNlIDM0OiAvLyBcIlxyXG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9ICcmcXVvdDsnO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMzg6IC8vICZcclxuICAgICAgICAgICAgICAgIGVzY2FwZWQgPSAnJmFtcDsnO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMzk6IC8vICdcclxuICAgICAgICAgICAgICAgIGVzY2FwZWQgPSAnJiMzOTsnO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgNjA6IC8vIDxcclxuICAgICAgICAgICAgICAgIGVzY2FwZWQgPSAnJmx0Oyc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSA2MjogLy8gPlxyXG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9ICcmZ3Q7JztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsYXN0SW5kZXggIT09IGluZGV4KSB7XHJcbiAgICAgICAgICAgIGh0bWwgKz0gc3RyLnNsaWNlKGxhc3RJbmRleCwgaW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsYXN0SW5kZXggPSBpbmRleCArIDE7XHJcbiAgICAgICAgaHRtbCArPSBlc2NhcGVkO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxhc3RJbmRleCAhPT0gaW5kZXggPyBodG1sICsgc3RyLnNsaWNlKGxhc3RJbmRleCwgaW5kZXgpIDogaHRtbDtcclxufVxyXG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUyL3N5bnRheC5odG1sI2NvbW1lbnRzXHJcbmNvbnN0IGNvbW1lbnRTdHJpcFJFID0gL14tPz58PCEtLXwtLT58LS0hPnw8IS0kL2c7XHJcbmZ1bmN0aW9uIGVzY2FwZUh0bWxDb21tZW50KHNyYykge1xyXG4gICAgcmV0dXJuIHNyYy5yZXBsYWNlKGNvbW1lbnRTdHJpcFJFLCAnJyk7XHJcbn1cblxuZnVuY3Rpb24gbG9vc2VDb21wYXJlQXJyYXlzKGEsIGIpIHtcclxuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgbGV0IGVxdWFsID0gdHJ1ZTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBlcXVhbCAmJiBpIDwgYS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGVxdWFsID0gbG9vc2VFcXVhbChhW2ldLCBiW2ldKTtcclxuICAgIH1cclxuICAgIHJldHVybiBlcXVhbDtcclxufVxyXG5mdW5jdGlvbiBsb29zZUVxdWFsKGEsIGIpIHtcclxuICAgIGlmIChhID09PSBiKVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgbGV0IGFWYWxpZFR5cGUgPSBpc0RhdGUoYSk7XHJcbiAgICBsZXQgYlZhbGlkVHlwZSA9IGlzRGF0ZShiKTtcclxuICAgIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcclxuICAgICAgICByZXR1cm4gYVZhbGlkVHlwZSAmJiBiVmFsaWRUeXBlID8gYS5nZXRUaW1lKCkgPT09IGIuZ2V0VGltZSgpIDogZmFsc2U7XHJcbiAgICB9XHJcbiAgICBhVmFsaWRUeXBlID0gaXNTeW1ib2woYSk7XHJcbiAgICBiVmFsaWRUeXBlID0gaXNTeW1ib2woYik7XHJcbiAgICBpZiAoYVZhbGlkVHlwZSB8fCBiVmFsaWRUeXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIGEgPT09IGI7XHJcbiAgICB9XHJcbiAgICBhVmFsaWRUeXBlID0gaXNBcnJheShhKTtcclxuICAgIGJWYWxpZFR5cGUgPSBpc0FycmF5KGIpO1xyXG4gICAgaWYgKGFWYWxpZFR5cGUgfHwgYlZhbGlkVHlwZSkge1xyXG4gICAgICAgIHJldHVybiBhVmFsaWRUeXBlICYmIGJWYWxpZFR5cGUgPyBsb29zZUNvbXBhcmVBcnJheXMoYSwgYikgOiBmYWxzZTtcclxuICAgIH1cclxuICAgIGFWYWxpZFR5cGUgPSBpc09iamVjdChhKTtcclxuICAgIGJWYWxpZFR5cGUgPSBpc09iamVjdChiKTtcclxuICAgIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWY6IHRoaXMgaWYgd2lsbCBwcm9iYWJseSBuZXZlciBiZSBjYWxsZWQgKi9cclxuICAgICAgICBpZiAoIWFWYWxpZFR5cGUgfHwgIWJWYWxpZFR5cGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBhS2V5c0NvdW50ID0gT2JqZWN0LmtleXMoYSkubGVuZ3RoO1xyXG4gICAgICAgIGNvbnN0IGJLZXlzQ291bnQgPSBPYmplY3Qua2V5cyhiKS5sZW5ndGg7XHJcbiAgICAgICAgaWYgKGFLZXlzQ291bnQgIT09IGJLZXlzQ291bnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBhKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFIYXNLZXkgPSBhLmhhc093blByb3BlcnR5KGtleSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGJIYXNLZXkgPSBiLmhhc093blByb3BlcnR5KGtleSk7XHJcbiAgICAgICAgICAgIGlmICgoYUhhc0tleSAmJiAhYkhhc0tleSkgfHxcclxuICAgICAgICAgICAgICAgICghYUhhc0tleSAmJiBiSGFzS2V5KSB8fFxyXG4gICAgICAgICAgICAgICAgIWxvb3NlRXF1YWwoYVtrZXldLCBiW2tleV0pKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gU3RyaW5nKGEpID09PSBTdHJpbmcoYik7XHJcbn1cclxuZnVuY3Rpb24gbG9vc2VJbmRleE9mKGFyciwgdmFsKSB7XHJcbiAgICByZXR1cm4gYXJyLmZpbmRJbmRleChpdGVtID0+IGxvb3NlRXF1YWwoaXRlbSwgdmFsKSk7XHJcbn1cblxuLyoqXHJcbiAqIEZvciBjb252ZXJ0aW5nIHt7IGludGVycG9sYXRpb24gfX0gdmFsdWVzIHRvIGRpc3BsYXllZCBzdHJpbmdzLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29uc3QgdG9EaXNwbGF5U3RyaW5nID0gKHZhbCkgPT4ge1xyXG4gICAgcmV0dXJuIGlzU3RyaW5nKHZhbClcclxuICAgICAgICA/IHZhbFxyXG4gICAgICAgIDogdmFsID09IG51bGxcclxuICAgICAgICAgICAgPyAnJ1xyXG4gICAgICAgICAgICA6IGlzQXJyYXkodmFsKSB8fFxyXG4gICAgICAgICAgICAgICAgKGlzT2JqZWN0KHZhbCkgJiZcclxuICAgICAgICAgICAgICAgICAgICAodmFsLnRvU3RyaW5nID09PSBvYmplY3RUb1N0cmluZyB8fCAhaXNGdW5jdGlvbih2YWwudG9TdHJpbmcpKSlcclxuICAgICAgICAgICAgICAgID8gSlNPTi5zdHJpbmdpZnkodmFsLCByZXBsYWNlciwgMilcclxuICAgICAgICAgICAgICAgIDogU3RyaW5nKHZhbCk7XHJcbn07XHJcbmNvbnN0IHJlcGxhY2VyID0gKF9rZXksIHZhbCkgPT4ge1xyXG4gICAgLy8gY2FuJ3QgdXNlIGlzUmVmIGhlcmUgc2luY2UgQHZ1ZS9zaGFyZWQgaGFzIG5vIGRlcHNcclxuICAgIGlmICh2YWwgJiYgdmFsLl9fdl9pc1JlZikge1xyXG4gICAgICAgIHJldHVybiByZXBsYWNlcihfa2V5LCB2YWwudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNNYXAodmFsKSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIFtgTWFwKCR7dmFsLnNpemV9KWBdOiBbLi4udmFsLmVudHJpZXMoKV0ucmVkdWNlKChlbnRyaWVzLCBba2V5LCB2YWxdKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBlbnRyaWVzW2Ake2tleX0gPT5gXSA9IHZhbDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbnRyaWVzO1xyXG4gICAgICAgICAgICB9LCB7fSlcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNTZXQodmFsKSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIFtgU2V0KCR7dmFsLnNpemV9KWBdOiBbLi4udmFsLnZhbHVlcygpXVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc09iamVjdCh2YWwpICYmICFpc0FycmF5KHZhbCkgJiYgIWlzUGxhaW5PYmplY3QodmFsKSkge1xyXG4gICAgICAgIHJldHVybiBTdHJpbmcodmFsKTtcclxuICAgIH1cclxuICAgIHJldHVybiB2YWw7XHJcbn07XG5cbmNvbnN0IEVNUFRZX09CSiA9IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxyXG4gICAgPyBPYmplY3QuZnJlZXplKHt9KVxyXG4gICAgOiB7fTtcclxuY29uc3QgRU1QVFlfQVJSID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gT2JqZWN0LmZyZWV6ZShbXSkgOiBbXTtcclxuY29uc3QgTk9PUCA9ICgpID0+IHsgfTtcclxuLyoqXHJcbiAqIEFsd2F5cyByZXR1cm4gZmFsc2UuXHJcbiAqL1xyXG5jb25zdCBOTyA9ICgpID0+IGZhbHNlO1xyXG5jb25zdCBvblJFID0gL15vblteYS16XS87XHJcbmNvbnN0IGlzT24gPSAoa2V5KSA9PiBvblJFLnRlc3Qoa2V5KTtcclxuY29uc3QgaXNNb2RlbExpc3RlbmVyID0gKGtleSkgPT4ga2V5LnN0YXJ0c1dpdGgoJ29uVXBkYXRlOicpO1xyXG5jb25zdCBleHRlbmQgPSBPYmplY3QuYXNzaWduO1xyXG5jb25zdCByZW1vdmUgPSAoYXJyLCBlbCkgPT4ge1xyXG4gICAgY29uc3QgaSA9IGFyci5pbmRleE9mKGVsKTtcclxuICAgIGlmIChpID4gLTEpIHtcclxuICAgICAgICBhcnIuc3BsaWNlKGksIDEpO1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XHJcbmNvbnN0IGhhc093biA9ICh2YWwsIGtleSkgPT4gaGFzT3duUHJvcGVydHkuY2FsbCh2YWwsIGtleSk7XHJcbmNvbnN0IGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xyXG5jb25zdCBpc01hcCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSAnW29iamVjdCBNYXBdJztcclxuY29uc3QgaXNTZXQgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gJ1tvYmplY3QgU2V0XSc7XHJcbmNvbnN0IGlzRGF0ZSA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSAnW29iamVjdCBEYXRlXSc7XHJcbmNvbnN0IGlzRnVuY3Rpb24gPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nO1xyXG5jb25zdCBpc1N0cmluZyA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnO1xyXG5jb25zdCBpc1N5bWJvbCA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdzeW1ib2wnO1xyXG5jb25zdCBpc09iamVjdCA9ICh2YWwpID0+IHZhbCAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0JztcclxuY29uc3QgaXNQcm9taXNlID0gKHZhbCkgPT4ge1xyXG4gICAgcmV0dXJuIGlzT2JqZWN0KHZhbCkgJiYgaXNGdW5jdGlvbih2YWwudGhlbikgJiYgaXNGdW5jdGlvbih2YWwuY2F0Y2gpO1xyXG59O1xyXG5jb25zdCBvYmplY3RUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XHJcbmNvbnN0IHRvVHlwZVN0cmluZyA9ICh2YWx1ZSkgPT4gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XHJcbmNvbnN0IHRvUmF3VHlwZSA9ICh2YWx1ZSkgPT4ge1xyXG4gICAgLy8gZXh0cmFjdCBcIlJhd1R5cGVcIiBmcm9tIHN0cmluZ3MgbGlrZSBcIltvYmplY3QgUmF3VHlwZV1cIlxyXG4gICAgcmV0dXJuIHRvVHlwZVN0cmluZyh2YWx1ZSkuc2xpY2UoOCwgLTEpO1xyXG59O1xyXG5jb25zdCBpc1BsYWluT2JqZWN0ID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xyXG5jb25zdCBpc0ludGVnZXJLZXkgPSAoa2V5KSA9PiBpc1N0cmluZyhrZXkpICYmXHJcbiAgICBrZXkgIT09ICdOYU4nICYmXHJcbiAgICBrZXlbMF0gIT09ICctJyAmJlxyXG4gICAgJycgKyBwYXJzZUludChrZXksIDEwKSA9PT0ga2V5O1xyXG5jb25zdCBpc1Jlc2VydmVkUHJvcCA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChcclxuLy8gdGhlIGxlYWRpbmcgY29tbWEgaXMgaW50ZW50aW9uYWwgc28gZW1wdHkgc3RyaW5nIFwiXCIgaXMgYWxzbyBpbmNsdWRlZFxyXG4nLGtleSxyZWYscmVmX2ZvcixyZWZfa2V5LCcgK1xyXG4gICAgJ29uVm5vZGVCZWZvcmVNb3VudCxvblZub2RlTW91bnRlZCwnICtcclxuICAgICdvblZub2RlQmVmb3JlVXBkYXRlLG9uVm5vZGVVcGRhdGVkLCcgK1xyXG4gICAgJ29uVm5vZGVCZWZvcmVVbm1vdW50LG9uVm5vZGVVbm1vdW50ZWQnKTtcclxuY29uc3QgaXNCdWlsdEluRGlyZWN0aXZlID0gLyojX19QVVJFX18qLyBtYWtlTWFwKCdiaW5kLGNsb2FrLGVsc2UtaWYsZWxzZSxmb3IsaHRtbCxpZixtb2RlbCxvbixvbmNlLHByZSxzaG93LHNsb3QsdGV4dCxtZW1vJyk7XHJcbmNvbnN0IGNhY2hlU3RyaW5nRnVuY3Rpb24gPSAoZm4pID0+IHtcclxuICAgIGNvbnN0IGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIHJldHVybiAoKHN0cikgPT4ge1xyXG4gICAgICAgIGNvbnN0IGhpdCA9IGNhY2hlW3N0cl07XHJcbiAgICAgICAgcmV0dXJuIGhpdCB8fCAoY2FjaGVbc3RyXSA9IGZuKHN0cikpO1xyXG4gICAgfSk7XHJcbn07XHJcbmNvbnN0IGNhbWVsaXplUkUgPSAvLShcXHcpL2c7XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29uc3QgY2FtZWxpemUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKChzdHIpID0+IHtcclxuICAgIHJldHVybiBzdHIucmVwbGFjZShjYW1lbGl6ZVJFLCAoXywgYykgPT4gKGMgPyBjLnRvVXBwZXJDYXNlKCkgOiAnJykpO1xyXG59KTtcclxuY29uc3QgaHlwaGVuYXRlUkUgPSAvXFxCKFtBLVpdKS9nO1xyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbmNvbnN0IGh5cGhlbmF0ZSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oKHN0cikgPT4gc3RyLnJlcGxhY2UoaHlwaGVuYXRlUkUsICctJDEnKS50b0xvd2VyQ2FzZSgpKTtcclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jb25zdCBjYXBpdGFsaXplID0gY2FjaGVTdHJpbmdGdW5jdGlvbigoc3RyKSA9PiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSkpO1xyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbmNvbnN0IHRvSGFuZGxlcktleSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oKHN0cikgPT4gc3RyID8gYG9uJHtjYXBpdGFsaXplKHN0cil9YCA6IGBgKTtcclxuLy8gY29tcGFyZSB3aGV0aGVyIGEgdmFsdWUgaGFzIGNoYW5nZWQsIGFjY291bnRpbmcgZm9yIE5hTi5cclxuY29uc3QgaGFzQ2hhbmdlZCA9ICh2YWx1ZSwgb2xkVmFsdWUpID0+ICFPYmplY3QuaXModmFsdWUsIG9sZFZhbHVlKTtcclxuY29uc3QgaW52b2tlQXJyYXlGbnMgPSAoZm5zLCBhcmcpID0+IHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZm5zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgZm5zW2ldKGFyZyk7XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IGRlZiA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICB2YWx1ZVxyXG4gICAgfSk7XHJcbn07XHJcbmNvbnN0IHRvTnVtYmVyID0gKHZhbCkgPT4ge1xyXG4gICAgY29uc3QgbiA9IHBhcnNlRmxvYXQodmFsKTtcclxuICAgIHJldHVybiBpc05hTihuKSA/IHZhbCA6IG47XHJcbn07XHJcbmxldCBfZ2xvYmFsVGhpcztcclxuY29uc3QgZ2V0R2xvYmFsVGhpcyA9ICgpID0+IHtcclxuICAgIHJldHVybiAoX2dsb2JhbFRoaXMgfHxcclxuICAgICAgICAoX2dsb2JhbFRoaXMgPVxyXG4gICAgICAgICAgICB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICAgICAgICAgID8gZ2xvYmFsVGhpc1xyXG4gICAgICAgICAgICAgICAgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICAgICAgICAgICAgICA/IHNlbGZcclxuICAgICAgICAgICAgICAgICAgICA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gd2luZG93XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZ2xvYmFsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHt9KSk7XHJcbn07XHJcbmNvbnN0IGlkZW50UkUgPSAvXltfJGEtekEtWlxceEEwLVxcdUZGRkZdW18kYS16QS1aMC05XFx4QTAtXFx1RkZGRl0qJC87XHJcbmZ1bmN0aW9uIGdlblByb3BzQWNjZXNzRXhwKG5hbWUpIHtcclxuICAgIHJldHVybiBpZGVudFJFLnRlc3QobmFtZSlcclxuICAgICAgICA/IGBfX3Byb3BzLiR7bmFtZX1gXHJcbiAgICAgICAgOiBgX19wcm9wc1ske0pTT04uc3RyaW5naWZ5KG5hbWUpfV1gO1xyXG59XG5cbmV4cG9ydCB7IEVNUFRZX0FSUiwgRU1QVFlfT0JKLCBOTywgTk9PUCwgUGF0Y2hGbGFnTmFtZXMsIGNhbWVsaXplLCBjYXBpdGFsaXplLCBkZWYsIGVzY2FwZUh0bWwsIGVzY2FwZUh0bWxDb21tZW50LCBleHRlbmQsIGdlblByb3BzQWNjZXNzRXhwLCBnZW5lcmF0ZUNvZGVGcmFtZSwgZ2V0R2xvYmFsVGhpcywgaGFzQ2hhbmdlZCwgaGFzT3duLCBoeXBoZW5hdGUsIGluY2x1ZGVCb29sZWFuQXR0ciwgaW52b2tlQXJyYXlGbnMsIGlzQXJyYXksIGlzQm9vbGVhbkF0dHIsIGlzQnVpbHRJbkRpcmVjdGl2ZSwgaXNEYXRlLCBpc0Z1bmN0aW9uLCBpc0dsb2JhbGx5V2hpdGVsaXN0ZWQsIGlzSFRNTFRhZywgaXNJbnRlZ2VyS2V5LCBpc0tub3duSHRtbEF0dHIsIGlzS25vd25TdmdBdHRyLCBpc01hcCwgaXNNb2RlbExpc3RlbmVyLCBpc05vVW5pdE51bWVyaWNTdHlsZVByb3AsIGlzT2JqZWN0LCBpc09uLCBpc1BsYWluT2JqZWN0LCBpc1Byb21pc2UsIGlzUmVzZXJ2ZWRQcm9wLCBpc1NTUlNhZmVBdHRyTmFtZSwgaXNTVkdUYWcsIGlzU2V0LCBpc1NwZWNpYWxCb29sZWFuQXR0ciwgaXNTdHJpbmcsIGlzU3ltYm9sLCBpc1ZvaWRUYWcsIGxvb3NlRXF1YWwsIGxvb3NlSW5kZXhPZiwgbWFrZU1hcCwgbm9ybWFsaXplQ2xhc3MsIG5vcm1hbGl6ZVByb3BzLCBub3JtYWxpemVTdHlsZSwgb2JqZWN0VG9TdHJpbmcsIHBhcnNlU3RyaW5nU3R5bGUsIHByb3BzVG9BdHRyTWFwLCByZW1vdmUsIHNsb3RGbGFnc1RleHQsIHN0cmluZ2lmeVN0eWxlLCB0b0Rpc3BsYXlTdHJpbmcsIHRvSGFuZGxlcktleSwgdG9OdW1iZXIsIHRvUmF3VHlwZSwgdG9UeXBlU3RyaW5nIH07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2F4aW9zJyk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgc2V0dGxlID0gcmVxdWlyZSgnLi8uLi9jb3JlL3NldHRsZScpO1xudmFyIGNvb2tpZXMgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvY29va2llcycpO1xudmFyIGJ1aWxkVVJMID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2J1aWxkVVJMJyk7XG52YXIgYnVpbGRGdWxsUGF0aCA9IHJlcXVpcmUoJy4uL2NvcmUvYnVpbGRGdWxsUGF0aCcpO1xudmFyIHBhcnNlSGVhZGVycyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9wYXJzZUhlYWRlcnMnKTtcbnZhciBpc1VSTFNhbWVPcmlnaW4gPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvaXNVUkxTYW1lT3JpZ2luJyk7XG52YXIgdHJhbnNpdGlvbmFsRGVmYXVsdHMgPSByZXF1aXJlKCcuLi9kZWZhdWx0cy90cmFuc2l0aW9uYWwnKTtcbnZhciBBeGlvc0Vycm9yID0gcmVxdWlyZSgnLi4vY29yZS9BeGlvc0Vycm9yJyk7XG52YXIgQ2FuY2VsZWRFcnJvciA9IHJlcXVpcmUoJy4uL2NhbmNlbC9DYW5jZWxlZEVycm9yJyk7XG52YXIgcGFyc2VQcm90b2NvbCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcGFyc2VQcm90b2NvbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHhockFkYXB0ZXIoY29uZmlnKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiBkaXNwYXRjaFhoclJlcXVlc3QocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIHJlcXVlc3REYXRhID0gY29uZmlnLmRhdGE7XG4gICAgdmFyIHJlcXVlc3RIZWFkZXJzID0gY29uZmlnLmhlYWRlcnM7XG4gICAgdmFyIHJlc3BvbnNlVHlwZSA9IGNvbmZpZy5yZXNwb25zZVR5cGU7XG4gICAgdmFyIG9uQ2FuY2VsZWQ7XG4gICAgZnVuY3Rpb24gZG9uZSgpIHtcbiAgICAgIGlmIChjb25maWcuY2FuY2VsVG9rZW4pIHtcbiAgICAgICAgY29uZmlnLmNhbmNlbFRva2VuLnVuc3Vic2NyaWJlKG9uQ2FuY2VsZWQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29uZmlnLnNpZ25hbCkge1xuICAgICAgICBjb25maWcuc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0Jywgb25DYW5jZWxlZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHV0aWxzLmlzRm9ybURhdGEocmVxdWVzdERhdGEpICYmIHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkpIHtcbiAgICAgIGRlbGV0ZSByZXF1ZXN0SGVhZGVyc1snQ29udGVudC1UeXBlJ107IC8vIExldCB0aGUgYnJvd3NlciBzZXQgaXRcbiAgICB9XG5cbiAgICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgLy8gSFRUUCBiYXNpYyBhdXRoZW50aWNhdGlvblxuICAgIGlmIChjb25maWcuYXV0aCkge1xuICAgICAgdmFyIHVzZXJuYW1lID0gY29uZmlnLmF1dGgudXNlcm5hbWUgfHwgJyc7XG4gICAgICB2YXIgcGFzc3dvcmQgPSBjb25maWcuYXV0aC5wYXNzd29yZCA/IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChjb25maWcuYXV0aC5wYXNzd29yZCkpIDogJyc7XG4gICAgICByZXF1ZXN0SGVhZGVycy5BdXRob3JpemF0aW9uID0gJ0Jhc2ljICcgKyBidG9hKHVzZXJuYW1lICsgJzonICsgcGFzc3dvcmQpO1xuICAgIH1cblxuICAgIHZhciBmdWxsUGF0aCA9IGJ1aWxkRnVsbFBhdGgoY29uZmlnLmJhc2VVUkwsIGNvbmZpZy51cmwpO1xuXG4gICAgcmVxdWVzdC5vcGVuKGNvbmZpZy5tZXRob2QudG9VcHBlckNhc2UoKSwgYnVpbGRVUkwoZnVsbFBhdGgsIGNvbmZpZy5wYXJhbXMsIGNvbmZpZy5wYXJhbXNTZXJpYWxpemVyKSwgdHJ1ZSk7XG5cbiAgICAvLyBTZXQgdGhlIHJlcXVlc3QgdGltZW91dCBpbiBNU1xuICAgIHJlcXVlc3QudGltZW91dCA9IGNvbmZpZy50aW1lb3V0O1xuXG4gICAgZnVuY3Rpb24gb25sb2FkZW5kKCkge1xuICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIFByZXBhcmUgdGhlIHJlc3BvbnNlXG4gICAgICB2YXIgcmVzcG9uc2VIZWFkZXJzID0gJ2dldEFsbFJlc3BvbnNlSGVhZGVycycgaW4gcmVxdWVzdCA/IHBhcnNlSGVhZGVycyhyZXF1ZXN0LmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSA6IG51bGw7XG4gICAgICB2YXIgcmVzcG9uc2VEYXRhID0gIXJlc3BvbnNlVHlwZSB8fCByZXNwb25zZVR5cGUgPT09ICd0ZXh0JyB8fCAgcmVzcG9uc2VUeXBlID09PSAnanNvbicgP1xuICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVGV4dCA6IHJlcXVlc3QucmVzcG9uc2U7XG4gICAgICB2YXIgcmVzcG9uc2UgPSB7XG4gICAgICAgIGRhdGE6IHJlc3BvbnNlRGF0YSxcbiAgICAgICAgc3RhdHVzOiByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogcmVxdWVzdC5zdGF0dXNUZXh0LFxuICAgICAgICBoZWFkZXJzOiByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgIGNvbmZpZzogY29uZmlnLFxuICAgICAgICByZXF1ZXN0OiByZXF1ZXN0XG4gICAgICB9O1xuXG4gICAgICBzZXR0bGUoZnVuY3Rpb24gX3Jlc29sdmUodmFsdWUpIHtcbiAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0sIGZ1bmN0aW9uIF9yZWplY3QoZXJyKSB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9LCByZXNwb25zZSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICgnb25sb2FkZW5kJyBpbiByZXF1ZXN0KSB7XG4gICAgICAvLyBVc2Ugb25sb2FkZW5kIGlmIGF2YWlsYWJsZVxuICAgICAgcmVxdWVzdC5vbmxvYWRlbmQgPSBvbmxvYWRlbmQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIExpc3RlbiBmb3IgcmVhZHkgc3RhdGUgdG8gZW11bGF0ZSBvbmxvYWRlbmRcbiAgICAgIHJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlTG9hZCgpIHtcbiAgICAgICAgaWYgKCFyZXF1ZXN0IHx8IHJlcXVlc3QucmVhZHlTdGF0ZSAhPT0gNCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSByZXF1ZXN0IGVycm9yZWQgb3V0IGFuZCB3ZSBkaWRuJ3QgZ2V0IGEgcmVzcG9uc2UsIHRoaXMgd2lsbCBiZVxuICAgICAgICAvLyBoYW5kbGVkIGJ5IG9uZXJyb3IgaW5zdGVhZFxuICAgICAgICAvLyBXaXRoIG9uZSBleGNlcHRpb246IHJlcXVlc3QgdGhhdCB1c2luZyBmaWxlOiBwcm90b2NvbCwgbW9zdCBicm93c2Vyc1xuICAgICAgICAvLyB3aWxsIHJldHVybiBzdGF0dXMgYXMgMCBldmVuIHRob3VnaCBpdCdzIGEgc3VjY2Vzc2Z1bCByZXF1ZXN0XG4gICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gMCAmJiAhKHJlcXVlc3QucmVzcG9uc2VVUkwgJiYgcmVxdWVzdC5yZXNwb25zZVVSTC5pbmRleE9mKCdmaWxlOicpID09PSAwKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWFkeXN0YXRlIGhhbmRsZXIgaXMgY2FsbGluZyBiZWZvcmUgb25lcnJvciBvciBvbnRpbWVvdXQgaGFuZGxlcnMsXG4gICAgICAgIC8vIHNvIHdlIHNob3VsZCBjYWxsIG9ubG9hZGVuZCBvbiB0aGUgbmV4dCAndGljaydcbiAgICAgICAgc2V0VGltZW91dChvbmxvYWRlbmQpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgYnJvd3NlciByZXF1ZXN0IGNhbmNlbGxhdGlvbiAoYXMgb3Bwb3NlZCB0byBhIG1hbnVhbCBjYW5jZWxsYXRpb24pXG4gICAgcmVxdWVzdC5vbmFib3J0ID0gZnVuY3Rpb24gaGFuZGxlQWJvcnQoKSB7XG4gICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZWplY3QobmV3IEF4aW9zRXJyb3IoJ1JlcXVlc3QgYWJvcnRlZCcsIEF4aW9zRXJyb3IuRUNPTk5BQk9SVEVELCBjb25maWcsIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEhhbmRsZSBsb3cgbGV2ZWwgbmV0d29yayBlcnJvcnNcbiAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiBoYW5kbGVFcnJvcigpIHtcbiAgICAgIC8vIFJlYWwgZXJyb3JzIGFyZSBoaWRkZW4gZnJvbSB1cyBieSB0aGUgYnJvd3NlclxuICAgICAgLy8gb25lcnJvciBzaG91bGQgb25seSBmaXJlIGlmIGl0J3MgYSBuZXR3b3JrIGVycm9yXG4gICAgICByZWplY3QobmV3IEF4aW9zRXJyb3IoJ05ldHdvcmsgRXJyb3InLCBBeGlvc0Vycm9yLkVSUl9ORVRXT1JLLCBjb25maWcsIHJlcXVlc3QsIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEhhbmRsZSB0aW1lb3V0XG4gICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBmdW5jdGlvbiBoYW5kbGVUaW1lb3V0KCkge1xuICAgICAgdmFyIHRpbWVvdXRFcnJvck1lc3NhZ2UgPSBjb25maWcudGltZW91dCA/ICd0aW1lb3V0IG9mICcgKyBjb25maWcudGltZW91dCArICdtcyBleGNlZWRlZCcgOiAndGltZW91dCBleGNlZWRlZCc7XG4gICAgICB2YXIgdHJhbnNpdGlvbmFsID0gY29uZmlnLnRyYW5zaXRpb25hbCB8fCB0cmFuc2l0aW9uYWxEZWZhdWx0cztcbiAgICAgIGlmIChjb25maWcudGltZW91dEVycm9yTWVzc2FnZSkge1xuICAgICAgICB0aW1lb3V0RXJyb3JNZXNzYWdlID0gY29uZmlnLnRpbWVvdXRFcnJvck1lc3NhZ2U7XG4gICAgICB9XG4gICAgICByZWplY3QobmV3IEF4aW9zRXJyb3IoXG4gICAgICAgIHRpbWVvdXRFcnJvck1lc3NhZ2UsXG4gICAgICAgIHRyYW5zaXRpb25hbC5jbGFyaWZ5VGltZW91dEVycm9yID8gQXhpb3NFcnJvci5FVElNRURPVVQgOiBBeGlvc0Vycm9yLkVDT05OQUJPUlRFRCxcbiAgICAgICAgY29uZmlnLFxuICAgICAgICByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBBZGQgeHNyZiBoZWFkZXJcbiAgICAvLyBUaGlzIGlzIG9ubHkgZG9uZSBpZiBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciBlbnZpcm9ubWVudC5cbiAgICAvLyBTcGVjaWZpY2FsbHkgbm90IGlmIHdlJ3JlIGluIGEgd2ViIHdvcmtlciwgb3IgcmVhY3QtbmF0aXZlLlxuICAgIGlmICh1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpKSB7XG4gICAgICAvLyBBZGQgeHNyZiBoZWFkZXJcbiAgICAgIHZhciB4c3JmVmFsdWUgPSAoY29uZmlnLndpdGhDcmVkZW50aWFscyB8fCBpc1VSTFNhbWVPcmlnaW4oZnVsbFBhdGgpKSAmJiBjb25maWcueHNyZkNvb2tpZU5hbWUgP1xuICAgICAgICBjb29raWVzLnJlYWQoY29uZmlnLnhzcmZDb29raWVOYW1lKSA6XG4gICAgICAgIHVuZGVmaW5lZDtcblxuICAgICAgaWYgKHhzcmZWYWx1ZSkge1xuICAgICAgICByZXF1ZXN0SGVhZGVyc1tjb25maWcueHNyZkhlYWRlck5hbWVdID0geHNyZlZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZCBoZWFkZXJzIHRvIHRoZSByZXF1ZXN0XG4gICAgaWYgKCdzZXRSZXF1ZXN0SGVhZGVyJyBpbiByZXF1ZXN0KSB7XG4gICAgICB1dGlscy5mb3JFYWNoKHJlcXVlc3RIZWFkZXJzLCBmdW5jdGlvbiBzZXRSZXF1ZXN0SGVhZGVyKHZhbCwga2V5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWVzdERhdGEgPT09ICd1bmRlZmluZWQnICYmIGtleS50b0xvd2VyQ2FzZSgpID09PSAnY29udGVudC10eXBlJykge1xuICAgICAgICAgIC8vIFJlbW92ZSBDb250ZW50LVR5cGUgaWYgZGF0YSBpcyB1bmRlZmluZWRcbiAgICAgICAgICBkZWxldGUgcmVxdWVzdEhlYWRlcnNba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBPdGhlcndpc2UgYWRkIGhlYWRlciB0byB0aGUgcmVxdWVzdFxuICAgICAgICAgIHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcihrZXksIHZhbCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEFkZCB3aXRoQ3JlZGVudGlhbHMgdG8gcmVxdWVzdCBpZiBuZWVkZWRcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMpKSB7XG4gICAgICByZXF1ZXN0LndpdGhDcmVkZW50aWFscyA9ICEhY29uZmlnLndpdGhDcmVkZW50aWFscztcbiAgICB9XG5cbiAgICAvLyBBZGQgcmVzcG9uc2VUeXBlIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKHJlc3BvbnNlVHlwZSAmJiByZXNwb25zZVR5cGUgIT09ICdqc29uJykge1xuICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSBjb25maWcucmVzcG9uc2VUeXBlO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBwcm9ncmVzcyBpZiBuZWVkZWRcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5vbkRvd25sb2FkUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBjb25maWcub25Eb3dubG9hZFByb2dyZXNzKTtcbiAgICB9XG5cbiAgICAvLyBOb3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgdXBsb2FkIGV2ZW50c1xuICAgIGlmICh0eXBlb2YgY29uZmlnLm9uVXBsb2FkUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicgJiYgcmVxdWVzdC51cGxvYWQpIHtcbiAgICAgIHJlcXVlc3QudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgY29uZmlnLm9uVXBsb2FkUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIGlmIChjb25maWcuY2FuY2VsVG9rZW4gfHwgY29uZmlnLnNpZ25hbCkge1xuICAgICAgLy8gSGFuZGxlIGNhbmNlbGxhdGlvblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgICAgIG9uQ2FuY2VsZWQgPSBmdW5jdGlvbihjYW5jZWwpIHtcbiAgICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlamVjdCghY2FuY2VsIHx8IChjYW5jZWwgJiYgY2FuY2VsLnR5cGUpID8gbmV3IENhbmNlbGVkRXJyb3IoKSA6IGNhbmNlbCk7XG4gICAgICAgIHJlcXVlc3QuYWJvcnQoKTtcbiAgICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgICB9O1xuXG4gICAgICBjb25maWcuY2FuY2VsVG9rZW4gJiYgY29uZmlnLmNhbmNlbFRva2VuLnN1YnNjcmliZShvbkNhbmNlbGVkKTtcbiAgICAgIGlmIChjb25maWcuc2lnbmFsKSB7XG4gICAgICAgIGNvbmZpZy5zaWduYWwuYWJvcnRlZCA/IG9uQ2FuY2VsZWQoKSA6IGNvbmZpZy5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBvbkNhbmNlbGVkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXJlcXVlc3REYXRhKSB7XG4gICAgICByZXF1ZXN0RGF0YSA9IG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHByb3RvY29sID0gcGFyc2VQcm90b2NvbChmdWxsUGF0aCk7XG5cbiAgICBpZiAocHJvdG9jb2wgJiYgWyAnaHR0cCcsICdodHRwcycsICdmaWxlJyBdLmluZGV4T2YocHJvdG9jb2wpID09PSAtMSkge1xuICAgICAgcmVqZWN0KG5ldyBBeGlvc0Vycm9yKCdVbnN1cHBvcnRlZCBwcm90b2NvbCAnICsgcHJvdG9jb2wgKyAnOicsIEF4aW9zRXJyb3IuRVJSX0JBRF9SRVFVRVNULCBjb25maWcpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cblxuICAgIC8vIFNlbmQgdGhlIHJlcXVlc3RcbiAgICByZXF1ZXN0LnNlbmQocmVxdWVzdERhdGEpO1xuICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnLi9oZWxwZXJzL2JpbmQnKTtcbnZhciBBeGlvcyA9IHJlcXVpcmUoJy4vY29yZS9BeGlvcycpO1xudmFyIG1lcmdlQ29uZmlnID0gcmVxdWlyZSgnLi9jb3JlL21lcmdlQ29uZmlnJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuL2RlZmF1bHRzJyk7XG5cbi8qKlxuICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIEF4aW9zXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRlZmF1bHRDb25maWcgVGhlIGRlZmF1bHQgY29uZmlnIGZvciB0aGUgaW5zdGFuY2VcbiAqIEByZXR1cm4ge0F4aW9zfSBBIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICovXG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZShkZWZhdWx0Q29uZmlnKSB7XG4gIHZhciBjb250ZXh0ID0gbmV3IEF4aW9zKGRlZmF1bHRDb25maWcpO1xuICB2YXIgaW5zdGFuY2UgPSBiaW5kKEF4aW9zLnByb3RvdHlwZS5yZXF1ZXN0LCBjb250ZXh0KTtcblxuICAvLyBDb3B5IGF4aW9zLnByb3RvdHlwZSB0byBpbnN0YW5jZVxuICB1dGlscy5leHRlbmQoaW5zdGFuY2UsIEF4aW9zLnByb3RvdHlwZSwgY29udGV4dCk7XG5cbiAgLy8gQ29weSBjb250ZXh0IHRvIGluc3RhbmNlXG4gIHV0aWxzLmV4dGVuZChpbnN0YW5jZSwgY29udGV4dCk7XG5cbiAgLy8gRmFjdG9yeSBmb3IgY3JlYXRpbmcgbmV3IGluc3RhbmNlc1xuICBpbnN0YW5jZS5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaW5zdGFuY2VDb25maWcpIHtcbiAgICByZXR1cm4gY3JlYXRlSW5zdGFuY2UobWVyZ2VDb25maWcoZGVmYXVsdENvbmZpZywgaW5zdGFuY2VDb25maWcpKTtcbiAgfTtcblxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbi8vIENyZWF0ZSB0aGUgZGVmYXVsdCBpbnN0YW5jZSB0byBiZSBleHBvcnRlZFxudmFyIGF4aW9zID0gY3JlYXRlSW5zdGFuY2UoZGVmYXVsdHMpO1xuXG4vLyBFeHBvc2UgQXhpb3MgY2xhc3MgdG8gYWxsb3cgY2xhc3MgaW5oZXJpdGFuY2VcbmF4aW9zLkF4aW9zID0gQXhpb3M7XG5cbi8vIEV4cG9zZSBDYW5jZWwgJiBDYW5jZWxUb2tlblxuYXhpb3MuQ2FuY2VsZWRFcnJvciA9IHJlcXVpcmUoJy4vY2FuY2VsL0NhbmNlbGVkRXJyb3InKTtcbmF4aW9zLkNhbmNlbFRva2VuID0gcmVxdWlyZSgnLi9jYW5jZWwvQ2FuY2VsVG9rZW4nKTtcbmF4aW9zLmlzQ2FuY2VsID0gcmVxdWlyZSgnLi9jYW5jZWwvaXNDYW5jZWwnKTtcbmF4aW9zLlZFUlNJT04gPSByZXF1aXJlKCcuL2Vudi9kYXRhJykudmVyc2lvbjtcbmF4aW9zLnRvRm9ybURhdGEgPSByZXF1aXJlKCcuL2hlbHBlcnMvdG9Gb3JtRGF0YScpO1xuXG4vLyBFeHBvc2UgQXhpb3NFcnJvciBjbGFzc1xuYXhpb3MuQXhpb3NFcnJvciA9IHJlcXVpcmUoJy4uL2xpYi9jb3JlL0F4aW9zRXJyb3InKTtcblxuLy8gYWxpYXMgZm9yIENhbmNlbGVkRXJyb3IgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbmF4aW9zLkNhbmNlbCA9IGF4aW9zLkNhbmNlbGVkRXJyb3I7XG5cbi8vIEV4cG9zZSBhbGwvc3ByZWFkXG5heGlvcy5hbGwgPSBmdW5jdGlvbiBhbGwocHJvbWlzZXMpIHtcbiAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbn07XG5heGlvcy5zcHJlYWQgPSByZXF1aXJlKCcuL2hlbHBlcnMvc3ByZWFkJyk7XG5cbi8vIEV4cG9zZSBpc0F4aW9zRXJyb3JcbmF4aW9zLmlzQXhpb3NFcnJvciA9IHJlcXVpcmUoJy4vaGVscGVycy9pc0F4aW9zRXJyb3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBheGlvcztcblxuLy8gQWxsb3cgdXNlIG9mIGRlZmF1bHQgaW1wb3J0IHN5bnRheCBpbiBUeXBlU2NyaXB0XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gYXhpb3M7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDYW5jZWxlZEVycm9yID0gcmVxdWlyZSgnLi9DYW5jZWxlZEVycm9yJyk7XG5cbi8qKlxuICogQSBgQ2FuY2VsVG9rZW5gIGlzIGFuIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlcXVlc3QgY2FuY2VsbGF0aW9uIG9mIGFuIG9wZXJhdGlvbi5cbiAqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGV4ZWN1dG9yIFRoZSBleGVjdXRvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gQ2FuY2VsVG9rZW4oZXhlY3V0b3IpIHtcbiAgaWYgKHR5cGVvZiBleGVjdXRvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4ZWN1dG9yIG11c3QgYmUgYSBmdW5jdGlvbi4nKTtcbiAgfVxuXG4gIHZhciByZXNvbHZlUHJvbWlzZTtcblxuICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiBwcm9taXNlRXhlY3V0b3IocmVzb2x2ZSkge1xuICAgIHJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcbiAgfSk7XG5cbiAgdmFyIHRva2VuID0gdGhpcztcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICB0aGlzLnByb21pc2UudGhlbihmdW5jdGlvbihjYW5jZWwpIHtcbiAgICBpZiAoIXRva2VuLl9saXN0ZW5lcnMpIHJldHVybjtcblxuICAgIHZhciBpO1xuICAgIHZhciBsID0gdG9rZW4uX2xpc3RlbmVycy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICB0b2tlbi5fbGlzdGVuZXJzW2ldKGNhbmNlbCk7XG4gICAgfVxuICAgIHRva2VuLl9saXN0ZW5lcnMgPSBudWxsO1xuICB9KTtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICB0aGlzLnByb21pc2UudGhlbiA9IGZ1bmN0aW9uKG9uZnVsZmlsbGVkKSB7XG4gICAgdmFyIF9yZXNvbHZlO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICB0b2tlbi5zdWJzY3JpYmUocmVzb2x2ZSk7XG4gICAgICBfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgfSkudGhlbihvbmZ1bGZpbGxlZCk7XG5cbiAgICBwcm9taXNlLmNhbmNlbCA9IGZ1bmN0aW9uIHJlamVjdCgpIHtcbiAgICAgIHRva2VuLnVuc3Vic2NyaWJlKF9yZXNvbHZlKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH07XG5cbiAgZXhlY3V0b3IoZnVuY3Rpb24gY2FuY2VsKG1lc3NhZ2UpIHtcbiAgICBpZiAodG9rZW4ucmVhc29uKSB7XG4gICAgICAvLyBDYW5jZWxsYXRpb24gaGFzIGFscmVhZHkgYmVlbiByZXF1ZXN0ZWRcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0b2tlbi5yZWFzb24gPSBuZXcgQ2FuY2VsZWRFcnJvcihtZXNzYWdlKTtcbiAgICByZXNvbHZlUHJvbWlzZSh0b2tlbi5yZWFzb24pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBUaHJvd3MgYSBgQ2FuY2VsZWRFcnJvcmAgaWYgY2FuY2VsbGF0aW9uIGhhcyBiZWVuIHJlcXVlc3RlZC5cbiAqL1xuQ2FuY2VsVG9rZW4ucHJvdG90eXBlLnRocm93SWZSZXF1ZXN0ZWQgPSBmdW5jdGlvbiB0aHJvd0lmUmVxdWVzdGVkKCkge1xuICBpZiAodGhpcy5yZWFzb24pIHtcbiAgICB0aHJvdyB0aGlzLnJlYXNvbjtcbiAgfVxufTtcblxuLyoqXG4gKiBTdWJzY3JpYmUgdG8gdGhlIGNhbmNlbCBzaWduYWxcbiAqL1xuXG5DYW5jZWxUb2tlbi5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gc3Vic2NyaWJlKGxpc3RlbmVyKSB7XG4gIGlmICh0aGlzLnJlYXNvbikge1xuICAgIGxpc3RlbmVyKHRoaXMucmVhc29uKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodGhpcy5fbGlzdGVuZXJzKSB7XG4gICAgdGhpcy5fbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2xpc3RlbmVycyA9IFtsaXN0ZW5lcl07XG4gIH1cbn07XG5cbi8qKlxuICogVW5zdWJzY3JpYmUgZnJvbSB0aGUgY2FuY2VsIHNpZ25hbFxuICovXG5cbkNhbmNlbFRva2VuLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uIHVuc3Vic2NyaWJlKGxpc3RlbmVyKSB7XG4gIGlmICghdGhpcy5fbGlzdGVuZXJzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBpbmRleCA9IHRoaXMuX2xpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcbiAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgIHRoaXMuX2xpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgYSBuZXcgYENhbmNlbFRva2VuYCBhbmQgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCxcbiAqIGNhbmNlbHMgdGhlIGBDYW5jZWxUb2tlbmAuXG4gKi9cbkNhbmNlbFRva2VuLnNvdXJjZSA9IGZ1bmN0aW9uIHNvdXJjZSgpIHtcbiAgdmFyIGNhbmNlbDtcbiAgdmFyIHRva2VuID0gbmV3IENhbmNlbFRva2VuKGZ1bmN0aW9uIGV4ZWN1dG9yKGMpIHtcbiAgICBjYW5jZWwgPSBjO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICB0b2tlbjogdG9rZW4sXG4gICAgY2FuY2VsOiBjYW5jZWxcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FuY2VsVG9rZW47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBBeGlvc0Vycm9yID0gcmVxdWlyZSgnLi4vY29yZS9BeGlvc0Vycm9yJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG4vKipcbiAqIEEgYENhbmNlbGVkRXJyb3JgIGlzIGFuIG9iamVjdCB0aGF0IGlzIHRocm93biB3aGVuIGFuIG9wZXJhdGlvbiBpcyBjYW5jZWxlZC5cbiAqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7c3RyaW5nPX0gbWVzc2FnZSBUaGUgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gQ2FuY2VsZWRFcnJvcihtZXNzYWdlKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lcS1udWxsLGVxZXFlcVxuICBBeGlvc0Vycm9yLmNhbGwodGhpcywgbWVzc2FnZSA9PSBudWxsID8gJ2NhbmNlbGVkJyA6IG1lc3NhZ2UsIEF4aW9zRXJyb3IuRVJSX0NBTkNFTEVEKTtcbiAgdGhpcy5uYW1lID0gJ0NhbmNlbGVkRXJyb3InO1xufVxuXG51dGlscy5pbmhlcml0cyhDYW5jZWxlZEVycm9yLCBBeGlvc0Vycm9yLCB7XG4gIF9fQ0FOQ0VMX186IHRydWVcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbmNlbGVkRXJyb3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNDYW5jZWwodmFsdWUpIHtcbiAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9fQ0FOQ0VMX18pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIGJ1aWxkVVJMID0gcmVxdWlyZSgnLi4vaGVscGVycy9idWlsZFVSTCcpO1xudmFyIEludGVyY2VwdG9yTWFuYWdlciA9IHJlcXVpcmUoJy4vSW50ZXJjZXB0b3JNYW5hZ2VyJyk7XG52YXIgZGlzcGF0Y2hSZXF1ZXN0ID0gcmVxdWlyZSgnLi9kaXNwYXRjaFJlcXVlc3QnKTtcbnZhciBtZXJnZUNvbmZpZyA9IHJlcXVpcmUoJy4vbWVyZ2VDb25maWcnKTtcbnZhciBidWlsZEZ1bGxQYXRoID0gcmVxdWlyZSgnLi9idWlsZEZ1bGxQYXRoJyk7XG52YXIgdmFsaWRhdG9yID0gcmVxdWlyZSgnLi4vaGVscGVycy92YWxpZGF0b3InKTtcblxudmFyIHZhbGlkYXRvcnMgPSB2YWxpZGF0b3IudmFsaWRhdG9ycztcbi8qKlxuICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGluc3RhbmNlQ29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIEF4aW9zKGluc3RhbmNlQ29uZmlnKSB7XG4gIHRoaXMuZGVmYXVsdHMgPSBpbnN0YW5jZUNvbmZpZztcbiAgdGhpcy5pbnRlcmNlcHRvcnMgPSB7XG4gICAgcmVxdWVzdDogbmV3IEludGVyY2VwdG9yTWFuYWdlcigpLFxuICAgIHJlc3BvbnNlOiBuZXcgSW50ZXJjZXB0b3JNYW5hZ2VyKClcbiAgfTtcbn1cblxuLyoqXG4gKiBEaXNwYXRjaCBhIHJlcXVlc3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcgc3BlY2lmaWMgZm9yIHRoaXMgcmVxdWVzdCAobWVyZ2VkIHdpdGggdGhpcy5kZWZhdWx0cylcbiAqL1xuQXhpb3MucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiByZXF1ZXN0KGNvbmZpZ09yVXJsLCBjb25maWcpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIC8vIEFsbG93IGZvciBheGlvcygnZXhhbXBsZS91cmwnWywgY29uZmlnXSkgYSBsYSBmZXRjaCBBUElcbiAgaWYgKHR5cGVvZiBjb25maWdPclVybCA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25maWcgPSBjb25maWcgfHwge307XG4gICAgY29uZmlnLnVybCA9IGNvbmZpZ09yVXJsO1xuICB9IGVsc2Uge1xuICAgIGNvbmZpZyA9IGNvbmZpZ09yVXJsIHx8IHt9O1xuICB9XG5cbiAgY29uZmlnID0gbWVyZ2VDb25maWcodGhpcy5kZWZhdWx0cywgY29uZmlnKTtcblxuICAvLyBTZXQgY29uZmlnLm1ldGhvZFxuICBpZiAoY29uZmlnLm1ldGhvZCkge1xuICAgIGNvbmZpZy5tZXRob2QgPSBjb25maWcubWV0aG9kLnRvTG93ZXJDYXNlKCk7XG4gIH0gZWxzZSBpZiAodGhpcy5kZWZhdWx0cy5tZXRob2QpIHtcbiAgICBjb25maWcubWV0aG9kID0gdGhpcy5kZWZhdWx0cy5tZXRob2QudG9Mb3dlckNhc2UoKTtcbiAgfSBlbHNlIHtcbiAgICBjb25maWcubWV0aG9kID0gJ2dldCc7XG4gIH1cblxuICB2YXIgdHJhbnNpdGlvbmFsID0gY29uZmlnLnRyYW5zaXRpb25hbDtcblxuICBpZiAodHJhbnNpdGlvbmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YWxpZGF0b3IuYXNzZXJ0T3B0aW9ucyh0cmFuc2l0aW9uYWwsIHtcbiAgICAgIHNpbGVudEpTT05QYXJzaW5nOiB2YWxpZGF0b3JzLnRyYW5zaXRpb25hbCh2YWxpZGF0b3JzLmJvb2xlYW4pLFxuICAgICAgZm9yY2VkSlNPTlBhcnNpbmc6IHZhbGlkYXRvcnMudHJhbnNpdGlvbmFsKHZhbGlkYXRvcnMuYm9vbGVhbiksXG4gICAgICBjbGFyaWZ5VGltZW91dEVycm9yOiB2YWxpZGF0b3JzLnRyYW5zaXRpb25hbCh2YWxpZGF0b3JzLmJvb2xlYW4pXG4gICAgfSwgZmFsc2UpO1xuICB9XG5cbiAgLy8gZmlsdGVyIG91dCBza2lwcGVkIGludGVyY2VwdG9yc1xuICB2YXIgcmVxdWVzdEludGVyY2VwdG9yQ2hhaW4gPSBbXTtcbiAgdmFyIHN5bmNocm9ub3VzUmVxdWVzdEludGVyY2VwdG9ycyA9IHRydWU7XG4gIHRoaXMuaW50ZXJjZXB0b3JzLnJlcXVlc3QuZm9yRWFjaChmdW5jdGlvbiB1bnNoaWZ0UmVxdWVzdEludGVyY2VwdG9ycyhpbnRlcmNlcHRvcikge1xuICAgIGlmICh0eXBlb2YgaW50ZXJjZXB0b3IucnVuV2hlbiA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnRlcmNlcHRvci5ydW5XaGVuKGNvbmZpZykgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3luY2hyb25vdXNSZXF1ZXN0SW50ZXJjZXB0b3JzID0gc3luY2hyb25vdXNSZXF1ZXN0SW50ZXJjZXB0b3JzICYmIGludGVyY2VwdG9yLnN5bmNocm9ub3VzO1xuXG4gICAgcmVxdWVzdEludGVyY2VwdG9yQ2hhaW4udW5zaGlmdChpbnRlcmNlcHRvci5mdWxmaWxsZWQsIGludGVyY2VwdG9yLnJlamVjdGVkKTtcbiAgfSk7XG5cbiAgdmFyIHJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbiA9IFtdO1xuICB0aGlzLmludGVyY2VwdG9ycy5yZXNwb25zZS5mb3JFYWNoKGZ1bmN0aW9uIHB1c2hSZXNwb25zZUludGVyY2VwdG9ycyhpbnRlcmNlcHRvcikge1xuICAgIHJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbi5wdXNoKGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xuICB9KTtcblxuICB2YXIgcHJvbWlzZTtcblxuICBpZiAoIXN5bmNocm9ub3VzUmVxdWVzdEludGVyY2VwdG9ycykge1xuICAgIHZhciBjaGFpbiA9IFtkaXNwYXRjaFJlcXVlc3QsIHVuZGVmaW5lZF07XG5cbiAgICBBcnJheS5wcm90b3R5cGUudW5zaGlmdC5hcHBseShjaGFpbiwgcmVxdWVzdEludGVyY2VwdG9yQ2hhaW4pO1xuICAgIGNoYWluID0gY2hhaW4uY29uY2F0KHJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbik7XG5cbiAgICBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGNvbmZpZyk7XG4gICAgd2hpbGUgKGNoYWluLmxlbmd0aCkge1xuICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihjaGFpbi5zaGlmdCgpLCBjaGFpbi5zaGlmdCgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG5cbiAgdmFyIG5ld0NvbmZpZyA9IGNvbmZpZztcbiAgd2hpbGUgKHJlcXVlc3RJbnRlcmNlcHRvckNoYWluLmxlbmd0aCkge1xuICAgIHZhciBvbkZ1bGZpbGxlZCA9IHJlcXVlc3RJbnRlcmNlcHRvckNoYWluLnNoaWZ0KCk7XG4gICAgdmFyIG9uUmVqZWN0ZWQgPSByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbi5zaGlmdCgpO1xuICAgIHRyeSB7XG4gICAgICBuZXdDb25maWcgPSBvbkZ1bGZpbGxlZChuZXdDb25maWcpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBvblJlamVjdGVkKGVycm9yKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHRyeSB7XG4gICAgcHJvbWlzZSA9IGRpc3BhdGNoUmVxdWVzdChuZXdDb25maWcpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gIH1cblxuICB3aGlsZSAocmVzcG9uc2VJbnRlcmNlcHRvckNoYWluLmxlbmd0aCkge1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4ocmVzcG9uc2VJbnRlcmNlcHRvckNoYWluLnNoaWZ0KCksIHJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbi5zaGlmdCgpKTtcbiAgfVxuXG4gIHJldHVybiBwcm9taXNlO1xufTtcblxuQXhpb3MucHJvdG90eXBlLmdldFVyaSA9IGZ1bmN0aW9uIGdldFVyaShjb25maWcpIHtcbiAgY29uZmlnID0gbWVyZ2VDb25maWcodGhpcy5kZWZhdWx0cywgY29uZmlnKTtcbiAgdmFyIGZ1bGxQYXRoID0gYnVpbGRGdWxsUGF0aChjb25maWcuYmFzZVVSTCwgY29uZmlnLnVybCk7XG4gIHJldHVybiBidWlsZFVSTChmdWxsUGF0aCwgY29uZmlnLnBhcmFtcywgY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIpO1xufTtcblxuLy8gUHJvdmlkZSBhbGlhc2VzIGZvciBzdXBwb3J0ZWQgcmVxdWVzdCBtZXRob2RzXG51dGlscy5mb3JFYWNoKFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJywgJ29wdGlvbnMnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZE5vRGF0YShtZXRob2QpIHtcbiAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbih1cmwsIGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QobWVyZ2VDb25maWcoY29uZmlnIHx8IHt9LCB7XG4gICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgIHVybDogdXJsLFxuICAgICAgZGF0YTogKGNvbmZpZyB8fCB7fSkuZGF0YVxuICAgIH0pKTtcbiAgfTtcbn0pO1xuXG51dGlscy5mb3JFYWNoKFsncG9zdCcsICdwdXQnLCAncGF0Y2gnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZFdpdGhEYXRhKG1ldGhvZCkge1xuICAvKmVzbGludCBmdW5jLW5hbWVzOjAqL1xuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlSFRUUE1ldGhvZChpc0Zvcm0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gaHR0cE1ldGhvZCh1cmwsIGRhdGEsIGNvbmZpZykge1xuICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChtZXJnZUNvbmZpZyhjb25maWcgfHwge30sIHtcbiAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgIGhlYWRlcnM6IGlzRm9ybSA/IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ211bHRpcGFydC9mb3JtLWRhdGEnXG4gICAgICAgIH0gOiB7fSxcbiAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgIGRhdGE6IGRhdGFcbiAgICAgIH0pKTtcbiAgICB9O1xuICB9XG5cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBnZW5lcmF0ZUhUVFBNZXRob2QoKTtcblxuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kICsgJ0Zvcm0nXSA9IGdlbmVyYXRlSFRUUE1ldGhvZCh0cnVlKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF4aW9zO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBFcnJvciB3aXRoIHRoZSBzcGVjaWZpZWQgbWVzc2FnZSwgY29uZmlnLCBlcnJvciBjb2RlLCByZXF1ZXN0IGFuZCByZXNwb25zZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSBUaGUgZXJyb3IgbWVzc2FnZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29kZV0gVGhlIGVycm9yIGNvZGUgKGZvciBleGFtcGxlLCAnRUNPTk5BQk9SVEVEJykuXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ10gVGhlIGNvbmZpZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVxdWVzdF0gVGhlIHJlcXVlc3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW3Jlc3BvbnNlXSBUaGUgcmVzcG9uc2UuXG4gKiBAcmV0dXJucyB7RXJyb3J9IFRoZSBjcmVhdGVkIGVycm9yLlxuICovXG5mdW5jdGlvbiBBeGlvc0Vycm9yKG1lc3NhZ2UsIGNvZGUsIGNvbmZpZywgcmVxdWVzdCwgcmVzcG9uc2UpIHtcbiAgRXJyb3IuY2FsbCh0aGlzKTtcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgdGhpcy5uYW1lID0gJ0F4aW9zRXJyb3InO1xuICBjb2RlICYmICh0aGlzLmNvZGUgPSBjb2RlKTtcbiAgY29uZmlnICYmICh0aGlzLmNvbmZpZyA9IGNvbmZpZyk7XG4gIHJlcXVlc3QgJiYgKHRoaXMucmVxdWVzdCA9IHJlcXVlc3QpO1xuICByZXNwb25zZSAmJiAodGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlKTtcbn1cblxudXRpbHMuaW5oZXJpdHMoQXhpb3NFcnJvciwgRXJyb3IsIHtcbiAgdG9KU09OOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIFN0YW5kYXJkXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAvLyBNaWNyb3NvZnRcbiAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLmRlc2NyaXB0aW9uLFxuICAgICAgbnVtYmVyOiB0aGlzLm51bWJlcixcbiAgICAgIC8vIE1vemlsbGFcbiAgICAgIGZpbGVOYW1lOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxuICAgICAgY29sdW1uTnVtYmVyOiB0aGlzLmNvbHVtbk51bWJlcixcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrLFxuICAgICAgLy8gQXhpb3NcbiAgICAgIGNvbmZpZzogdGhpcy5jb25maWcsXG4gICAgICBjb2RlOiB0aGlzLmNvZGUsXG4gICAgICBzdGF0dXM6IHRoaXMucmVzcG9uc2UgJiYgdGhpcy5yZXNwb25zZS5zdGF0dXMgPyB0aGlzLnJlc3BvbnNlLnN0YXR1cyA6IG51bGxcbiAgICB9O1xuICB9XG59KTtcblxudmFyIHByb3RvdHlwZSA9IEF4aW9zRXJyb3IucHJvdG90eXBlO1xudmFyIGRlc2NyaXB0b3JzID0ge307XG5cbltcbiAgJ0VSUl9CQURfT1BUSU9OX1ZBTFVFJyxcbiAgJ0VSUl9CQURfT1BUSU9OJyxcbiAgJ0VDT05OQUJPUlRFRCcsXG4gICdFVElNRURPVVQnLFxuICAnRVJSX05FVFdPUksnLFxuICAnRVJSX0ZSX1RPT19NQU5ZX1JFRElSRUNUUycsXG4gICdFUlJfREVQUkVDQVRFRCcsXG4gICdFUlJfQkFEX1JFU1BPTlNFJyxcbiAgJ0VSUl9CQURfUkVRVUVTVCcsXG4gICdFUlJfQ0FOQ0VMRUQnXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuXS5mb3JFYWNoKGZ1bmN0aW9uKGNvZGUpIHtcbiAgZGVzY3JpcHRvcnNbY29kZV0gPSB7dmFsdWU6IGNvZGV9O1xufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEF4aW9zRXJyb3IsIGRlc2NyaXB0b3JzKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90b3R5cGUsICdpc0F4aW9zRXJyb3InLCB7dmFsdWU6IHRydWV9KTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbkF4aW9zRXJyb3IuZnJvbSA9IGZ1bmN0aW9uKGVycm9yLCBjb2RlLCBjb25maWcsIHJlcXVlc3QsIHJlc3BvbnNlLCBjdXN0b21Qcm9wcykge1xuICB2YXIgYXhpb3NFcnJvciA9IE9iamVjdC5jcmVhdGUocHJvdG90eXBlKTtcblxuICB1dGlscy50b0ZsYXRPYmplY3QoZXJyb3IsIGF4aW9zRXJyb3IsIGZ1bmN0aW9uIGZpbHRlcihvYmopIHtcbiAgICByZXR1cm4gb2JqICE9PSBFcnJvci5wcm90b3R5cGU7XG4gIH0pO1xuXG4gIEF4aW9zRXJyb3IuY2FsbChheGlvc0Vycm9yLCBlcnJvci5tZXNzYWdlLCBjb2RlLCBjb25maWcsIHJlcXVlc3QsIHJlc3BvbnNlKTtcblxuICBheGlvc0Vycm9yLm5hbWUgPSBlcnJvci5uYW1lO1xuXG4gIGN1c3RvbVByb3BzICYmIE9iamVjdC5hc3NpZ24oYXhpb3NFcnJvciwgY3VzdG9tUHJvcHMpO1xuXG4gIHJldHVybiBheGlvc0Vycm9yO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBeGlvc0Vycm9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIEludGVyY2VwdG9yTWFuYWdlcigpIHtcbiAgdGhpcy5oYW5kbGVycyA9IFtdO1xufVxuXG4vKipcbiAqIEFkZCBhIG5ldyBpbnRlcmNlcHRvciB0byB0aGUgc3RhY2tcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdWxmaWxsZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgdGhlbmAgZm9yIGEgYFByb21pc2VgXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3RlZCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIGByZWplY3RgIGZvciBhIGBQcm9taXNlYFxuICpcbiAqIEByZXR1cm4ge051bWJlcn0gQW4gSUQgdXNlZCB0byByZW1vdmUgaW50ZXJjZXB0b3IgbGF0ZXJcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS51c2UgPSBmdW5jdGlvbiB1c2UoZnVsZmlsbGVkLCByZWplY3RlZCwgb3B0aW9ucykge1xuICB0aGlzLmhhbmRsZXJzLnB1c2goe1xuICAgIGZ1bGZpbGxlZDogZnVsZmlsbGVkLFxuICAgIHJlamVjdGVkOiByZWplY3RlZCxcbiAgICBzeW5jaHJvbm91czogb3B0aW9ucyA/IG9wdGlvbnMuc3luY2hyb25vdXMgOiBmYWxzZSxcbiAgICBydW5XaGVuOiBvcHRpb25zID8gb3B0aW9ucy5ydW5XaGVuIDogbnVsbFxuICB9KTtcbiAgcmV0dXJuIHRoaXMuaGFuZGxlcnMubGVuZ3RoIC0gMTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFuIGludGVyY2VwdG9yIGZyb20gdGhlIHN0YWNrXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGlkIFRoZSBJRCB0aGF0IHdhcyByZXR1cm5lZCBieSBgdXNlYFxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLmVqZWN0ID0gZnVuY3Rpb24gZWplY3QoaWQpIHtcbiAgaWYgKHRoaXMuaGFuZGxlcnNbaWRdKSB7XG4gICAgdGhpcy5oYW5kbGVyc1tpZF0gPSBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbGwgdGhlIHJlZ2lzdGVyZWQgaW50ZXJjZXB0b3JzXG4gKlxuICogVGhpcyBtZXRob2QgaXMgcGFydGljdWxhcmx5IHVzZWZ1bCBmb3Igc2tpcHBpbmcgb3ZlciBhbnlcbiAqIGludGVyY2VwdG9ycyB0aGF0IG1heSBoYXZlIGJlY29tZSBgbnVsbGAgY2FsbGluZyBgZWplY3RgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIGludGVyY2VwdG9yXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2goZm4pIHtcbiAgdXRpbHMuZm9yRWFjaCh0aGlzLmhhbmRsZXJzLCBmdW5jdGlvbiBmb3JFYWNoSGFuZGxlcihoKSB7XG4gICAgaWYgKGggIT09IG51bGwpIHtcbiAgICAgIGZuKGgpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEludGVyY2VwdG9yTWFuYWdlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzQWJzb2x1dGVVUkwgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2lzQWJzb2x1dGVVUkwnKTtcbnZhciBjb21iaW5lVVJMcyA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvY29tYmluZVVSTHMnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFVSTCBieSBjb21iaW5pbmcgdGhlIGJhc2VVUkwgd2l0aCB0aGUgcmVxdWVzdGVkVVJMLFxuICogb25seSB3aGVuIHRoZSByZXF1ZXN0ZWRVUkwgaXMgbm90IGFscmVhZHkgYW4gYWJzb2x1dGUgVVJMLlxuICogSWYgdGhlIHJlcXVlc3RVUkwgaXMgYWJzb2x1dGUsIHRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgcmVxdWVzdGVkVVJMIHVudG91Y2hlZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVSTCBUaGUgYmFzZSBVUkxcbiAqIEBwYXJhbSB7c3RyaW5nfSByZXF1ZXN0ZWRVUkwgQWJzb2x1dGUgb3IgcmVsYXRpdmUgVVJMIHRvIGNvbWJpbmVcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb21iaW5lZCBmdWxsIHBhdGhcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBidWlsZEZ1bGxQYXRoKGJhc2VVUkwsIHJlcXVlc3RlZFVSTCkge1xuICBpZiAoYmFzZVVSTCAmJiAhaXNBYnNvbHV0ZVVSTChyZXF1ZXN0ZWRVUkwpKSB7XG4gICAgcmV0dXJuIGNvbWJpbmVVUkxzKGJhc2VVUkwsIHJlcXVlc3RlZFVSTCk7XG4gIH1cbiAgcmV0dXJuIHJlcXVlc3RlZFVSTDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciB0cmFuc2Zvcm1EYXRhID0gcmVxdWlyZSgnLi90cmFuc2Zvcm1EYXRhJyk7XG52YXIgaXNDYW5jZWwgPSByZXF1aXJlKCcuLi9jYW5jZWwvaXNDYW5jZWwnKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4uL2RlZmF1bHRzJyk7XG52YXIgQ2FuY2VsZWRFcnJvciA9IHJlcXVpcmUoJy4uL2NhbmNlbC9DYW5jZWxlZEVycm9yJyk7XG5cbi8qKlxuICogVGhyb3dzIGEgYENhbmNlbGVkRXJyb3JgIGlmIGNhbmNlbGxhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQuXG4gKi9cbmZ1bmN0aW9uIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKSB7XG4gIGlmIChjb25maWcuY2FuY2VsVG9rZW4pIHtcbiAgICBjb25maWcuY2FuY2VsVG9rZW4udGhyb3dJZlJlcXVlc3RlZCgpO1xuICB9XG5cbiAgaWYgKGNvbmZpZy5zaWduYWwgJiYgY29uZmlnLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgdGhyb3cgbmV3IENhbmNlbGVkRXJyb3IoKTtcbiAgfVxufVxuXG4vKipcbiAqIERpc3BhdGNoIGEgcmVxdWVzdCB0byB0aGUgc2VydmVyIHVzaW5nIHRoZSBjb25maWd1cmVkIGFkYXB0ZXIuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHRoYXQgaXMgdG8gYmUgdXNlZCBmb3IgdGhlIHJlcXVlc3RcbiAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgUHJvbWlzZSB0byBiZSBmdWxmaWxsZWRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkaXNwYXRjaFJlcXVlc3QoY29uZmlnKSB7XG4gIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAvLyBFbnN1cmUgaGVhZGVycyBleGlzdFxuICBjb25maWcuaGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzIHx8IHt9O1xuXG4gIC8vIFRyYW5zZm9ybSByZXF1ZXN0IGRhdGFcbiAgY29uZmlnLmRhdGEgPSB0cmFuc2Zvcm1EYXRhLmNhbGwoXG4gICAgY29uZmlnLFxuICAgIGNvbmZpZy5kYXRhLFxuICAgIGNvbmZpZy5oZWFkZXJzLFxuICAgIGNvbmZpZy50cmFuc2Zvcm1SZXF1ZXN0XG4gICk7XG5cbiAgLy8gRmxhdHRlbiBoZWFkZXJzXG4gIGNvbmZpZy5oZWFkZXJzID0gdXRpbHMubWVyZ2UoXG4gICAgY29uZmlnLmhlYWRlcnMuY29tbW9uIHx8IHt9LFxuICAgIGNvbmZpZy5oZWFkZXJzW2NvbmZpZy5tZXRob2RdIHx8IHt9LFxuICAgIGNvbmZpZy5oZWFkZXJzXG4gICk7XG5cbiAgdXRpbHMuZm9yRWFjaChcbiAgICBbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdwb3N0JywgJ3B1dCcsICdwYXRjaCcsICdjb21tb24nXSxcbiAgICBmdW5jdGlvbiBjbGVhbkhlYWRlckNvbmZpZyhtZXRob2QpIHtcbiAgICAgIGRlbGV0ZSBjb25maWcuaGVhZGVyc1ttZXRob2RdO1xuICAgIH1cbiAgKTtcblxuICB2YXIgYWRhcHRlciA9IGNvbmZpZy5hZGFwdGVyIHx8IGRlZmF1bHRzLmFkYXB0ZXI7XG5cbiAgcmV0dXJuIGFkYXB0ZXIoY29uZmlnKS50aGVuKGZ1bmN0aW9uIG9uQWRhcHRlclJlc29sdXRpb24ocmVzcG9uc2UpIHtcbiAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuICAgIHJlc3BvbnNlLmRhdGEgPSB0cmFuc2Zvcm1EYXRhLmNhbGwoXG4gICAgICBjb25maWcsXG4gICAgICByZXNwb25zZS5kYXRhLFxuICAgICAgcmVzcG9uc2UuaGVhZGVycyxcbiAgICAgIGNvbmZpZy50cmFuc2Zvcm1SZXNwb25zZVxuICAgICk7XG5cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH0sIGZ1bmN0aW9uIG9uQWRhcHRlclJlamVjdGlvbihyZWFzb24pIHtcbiAgICBpZiAoIWlzQ2FuY2VsKHJlYXNvbikpIHtcbiAgICAgIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAgICAgLy8gVHJhbnNmb3JtIHJlc3BvbnNlIGRhdGFcbiAgICAgIGlmIChyZWFzb24gJiYgcmVhc29uLnJlc3BvbnNlKSB7XG4gICAgICAgIHJlYXNvbi5yZXNwb25zZS5kYXRhID0gdHJhbnNmb3JtRGF0YS5jYWxsKFxuICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICByZWFzb24ucmVzcG9uc2UuZGF0YSxcbiAgICAgICAgICByZWFzb24ucmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2VcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QocmVhc29uKTtcbiAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG4vKipcbiAqIENvbmZpZy1zcGVjaWZpYyBtZXJnZS1mdW5jdGlvbiB3aGljaCBjcmVhdGVzIGEgbmV3IGNvbmZpZy1vYmplY3RcbiAqIGJ5IG1lcmdpbmcgdHdvIGNvbmZpZ3VyYXRpb24gb2JqZWN0cyB0b2dldGhlci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnMVxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZzJcbiAqIEByZXR1cm5zIHtPYmplY3R9IE5ldyBvYmplY3QgcmVzdWx0aW5nIGZyb20gbWVyZ2luZyBjb25maWcyIHRvIGNvbmZpZzFcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtZXJnZUNvbmZpZyhjb25maWcxLCBjb25maWcyKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICBjb25maWcyID0gY29uZmlnMiB8fCB7fTtcbiAgdmFyIGNvbmZpZyA9IHt9O1xuXG4gIGZ1bmN0aW9uIGdldE1lcmdlZFZhbHVlKHRhcmdldCwgc291cmNlKSB7XG4gICAgaWYgKHV0aWxzLmlzUGxhaW5PYmplY3QodGFyZ2V0KSAmJiB1dGlscy5pc1BsYWluT2JqZWN0KHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiB1dGlscy5tZXJnZSh0YXJnZXQsIHNvdXJjZSk7XG4gICAgfSBlbHNlIGlmICh1dGlscy5pc1BsYWluT2JqZWN0KHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiB1dGlscy5tZXJnZSh7fSwgc291cmNlKTtcbiAgICB9IGVsc2UgaWYgKHV0aWxzLmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgcmV0dXJuIHNvdXJjZS5zbGljZSgpO1xuICAgIH1cbiAgICByZXR1cm4gc291cmNlO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gIGZ1bmN0aW9uIG1lcmdlRGVlcFByb3BlcnRpZXMocHJvcCkge1xuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMltwcm9wXSkpIHtcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZShjb25maWcxW3Byb3BdLCBjb25maWcyW3Byb3BdKTtcbiAgICB9IGVsc2UgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcxW3Byb3BdKSkge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMVtwcm9wXSk7XG4gICAgfVxuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gIGZ1bmN0aW9uIHZhbHVlRnJvbUNvbmZpZzIocHJvcCkge1xuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMltwcm9wXSkpIHtcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzJbcHJvcF0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICBmdW5jdGlvbiBkZWZhdWx0VG9Db25maWcyKHByb3ApIHtcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzJbcHJvcF0pKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcyW3Byb3BdKTtcbiAgICB9IGVsc2UgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcxW3Byb3BdKSkge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMVtwcm9wXSk7XG4gICAgfVxuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gIGZ1bmN0aW9uIG1lcmdlRGlyZWN0S2V5cyhwcm9wKSB7XG4gICAgaWYgKHByb3AgaW4gY29uZmlnMikge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKGNvbmZpZzFbcHJvcF0sIGNvbmZpZzJbcHJvcF0pO1xuICAgIH0gZWxzZSBpZiAocHJvcCBpbiBjb25maWcxKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcxW3Byb3BdKTtcbiAgICB9XG4gIH1cblxuICB2YXIgbWVyZ2VNYXAgPSB7XG4gICAgJ3VybCc6IHZhbHVlRnJvbUNvbmZpZzIsXG4gICAgJ21ldGhvZCc6IHZhbHVlRnJvbUNvbmZpZzIsXG4gICAgJ2RhdGEnOiB2YWx1ZUZyb21Db25maWcyLFxuICAgICdiYXNlVVJMJzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAndHJhbnNmb3JtUmVxdWVzdCc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ3RyYW5zZm9ybVJlc3BvbnNlJzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAncGFyYW1zU2VyaWFsaXplcic6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ3RpbWVvdXQnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICd0aW1lb3V0TWVzc2FnZSc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ3dpdGhDcmVkZW50aWFscyc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ2FkYXB0ZXInOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICdyZXNwb25zZVR5cGUnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICd4c3JmQ29va2llTmFtZSc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ3hzcmZIZWFkZXJOYW1lJzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAnb25VcGxvYWRQcm9ncmVzcyc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ29uRG93bmxvYWRQcm9ncmVzcyc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ2RlY29tcHJlc3MnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICdtYXhDb250ZW50TGVuZ3RoJzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAnbWF4Qm9keUxlbmd0aCc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ2JlZm9yZVJlZGlyZWN0JzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAndHJhbnNwb3J0JzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAnaHR0cEFnZW50JzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAnaHR0cHNBZ2VudCc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ2NhbmNlbFRva2VuJzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAnc29ja2V0UGF0aCc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ3Jlc3BvbnNlRW5jb2RpbmcnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICd2YWxpZGF0ZVN0YXR1cyc6IG1lcmdlRGlyZWN0S2V5c1xuICB9O1xuXG4gIHV0aWxzLmZvckVhY2goT2JqZWN0LmtleXMoY29uZmlnMSkuY29uY2F0KE9iamVjdC5rZXlzKGNvbmZpZzIpKSwgZnVuY3Rpb24gY29tcHV0ZUNvbmZpZ1ZhbHVlKHByb3ApIHtcbiAgICB2YXIgbWVyZ2UgPSBtZXJnZU1hcFtwcm9wXSB8fCBtZXJnZURlZXBQcm9wZXJ0aWVzO1xuICAgIHZhciBjb25maWdWYWx1ZSA9IG1lcmdlKHByb3ApO1xuICAgICh1dGlscy5pc1VuZGVmaW5lZChjb25maWdWYWx1ZSkgJiYgbWVyZ2UgIT09IG1lcmdlRGlyZWN0S2V5cykgfHwgKGNvbmZpZ1twcm9wXSA9IGNvbmZpZ1ZhbHVlKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGNvbmZpZztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBBeGlvc0Vycm9yID0gcmVxdWlyZSgnLi9BeGlvc0Vycm9yJyk7XG5cbi8qKlxuICogUmVzb2x2ZSBvciByZWplY3QgYSBQcm9taXNlIGJhc2VkIG9uIHJlc3BvbnNlIHN0YXR1cy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXNvbHZlIEEgZnVuY3Rpb24gdGhhdCByZXNvbHZlcyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdCBBIGZ1bmN0aW9uIHRoYXQgcmVqZWN0cyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSByZXNwb25zZSBUaGUgcmVzcG9uc2UuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpIHtcbiAgdmFyIHZhbGlkYXRlU3RhdHVzID0gcmVzcG9uc2UuY29uZmlnLnZhbGlkYXRlU3RhdHVzO1xuICBpZiAoIXJlc3BvbnNlLnN0YXR1cyB8fCAhdmFsaWRhdGVTdGF0dXMgfHwgdmFsaWRhdGVTdGF0dXMocmVzcG9uc2Uuc3RhdHVzKSkge1xuICAgIHJlc29sdmUocmVzcG9uc2UpO1xuICB9IGVsc2Uge1xuICAgIHJlamVjdChuZXcgQXhpb3NFcnJvcihcbiAgICAgICdSZXF1ZXN0IGZhaWxlZCB3aXRoIHN0YXR1cyBjb2RlICcgKyByZXNwb25zZS5zdGF0dXMsXG4gICAgICBbQXhpb3NFcnJvci5FUlJfQkFEX1JFUVVFU1QsIEF4aW9zRXJyb3IuRVJSX0JBRF9SRVNQT05TRV1bTWF0aC5mbG9vcihyZXNwb25zZS5zdGF0dXMgLyAxMDApIC0gNF0sXG4gICAgICByZXNwb25zZS5jb25maWcsXG4gICAgICByZXNwb25zZS5yZXF1ZXN0LFxuICAgICAgcmVzcG9uc2VcbiAgICApKTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi4vZGVmYXVsdHMnKTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gdGhlIGRhdGEgZm9yIGEgcmVxdWVzdCBvciBhIHJlc3BvbnNlXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBkYXRhIFRoZSBkYXRhIHRvIGJlIHRyYW5zZm9ybWVkXG4gKiBAcGFyYW0ge0FycmF5fSBoZWFkZXJzIFRoZSBoZWFkZXJzIGZvciB0aGUgcmVxdWVzdCBvciByZXNwb25zZVxuICogQHBhcmFtIHtBcnJheXxGdW5jdGlvbn0gZm5zIEEgc2luZ2xlIGZ1bmN0aW9uIG9yIEFycmF5IG9mIGZ1bmN0aW9uc1xuICogQHJldHVybnMgeyp9IFRoZSByZXN1bHRpbmcgdHJhbnNmb3JtZWQgZGF0YVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRyYW5zZm9ybURhdGEoZGF0YSwgaGVhZGVycywgZm5zKSB7XG4gIHZhciBjb250ZXh0ID0gdGhpcyB8fCBkZWZhdWx0cztcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIHV0aWxzLmZvckVhY2goZm5zLCBmdW5jdGlvbiB0cmFuc2Zvcm0oZm4pIHtcbiAgICBkYXRhID0gZm4uY2FsbChjb250ZXh0LCBkYXRhLCBoZWFkZXJzKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGRhdGE7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIG5vcm1hbGl6ZUhlYWRlck5hbWUgPSByZXF1aXJlKCcuLi9oZWxwZXJzL25vcm1hbGl6ZUhlYWRlck5hbWUnKTtcbnZhciBBeGlvc0Vycm9yID0gcmVxdWlyZSgnLi4vY29yZS9BeGlvc0Vycm9yJyk7XG52YXIgdHJhbnNpdGlvbmFsRGVmYXVsdHMgPSByZXF1aXJlKCcuL3RyYW5zaXRpb25hbCcpO1xudmFyIHRvRm9ybURhdGEgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3RvRm9ybURhdGEnKTtcblxudmFyIERFRkFVTFRfQ09OVEVOVF9UWVBFID0ge1xuICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCdcbn07XG5cbmZ1bmN0aW9uIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCB2YWx1ZSkge1xuICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGhlYWRlcnMpICYmIHV0aWxzLmlzVW5kZWZpbmVkKGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKSkge1xuICAgIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gdmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdEFkYXB0ZXIoKSB7XG4gIHZhciBhZGFwdGVyO1xuICBpZiAodHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIEZvciBicm93c2VycyB1c2UgWEhSIGFkYXB0ZXJcbiAgICBhZGFwdGVyID0gcmVxdWlyZSgnLi4vYWRhcHRlcnMveGhyJyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChwcm9jZXNzKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nKSB7XG4gICAgLy8gRm9yIG5vZGUgdXNlIEhUVFAgYWRhcHRlclxuICAgIGFkYXB0ZXIgPSByZXF1aXJlKCcuLi9hZGFwdGVycy9odHRwJyk7XG4gIH1cbiAgcmV0dXJuIGFkYXB0ZXI7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeVNhZmVseShyYXdWYWx1ZSwgcGFyc2VyLCBlbmNvZGVyKSB7XG4gIGlmICh1dGlscy5pc1N0cmluZyhyYXdWYWx1ZSkpIHtcbiAgICB0cnkge1xuICAgICAgKHBhcnNlciB8fCBKU09OLnBhcnNlKShyYXdWYWx1ZSk7XG4gICAgICByZXR1cm4gdXRpbHMudHJpbShyYXdWYWx1ZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUubmFtZSAhPT0gJ1N5bnRheEVycm9yJykge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAoZW5jb2RlciB8fCBKU09OLnN0cmluZ2lmeSkocmF3VmFsdWUpO1xufVxuXG52YXIgZGVmYXVsdHMgPSB7XG5cbiAgdHJhbnNpdGlvbmFsOiB0cmFuc2l0aW9uYWxEZWZhdWx0cyxcblxuICBhZGFwdGVyOiBnZXREZWZhdWx0QWRhcHRlcigpLFxuXG4gIHRyYW5zZm9ybVJlcXVlc3Q6IFtmdW5jdGlvbiB0cmFuc2Zvcm1SZXF1ZXN0KGRhdGEsIGhlYWRlcnMpIHtcbiAgICBub3JtYWxpemVIZWFkZXJOYW1lKGhlYWRlcnMsICdBY2NlcHQnKTtcbiAgICBub3JtYWxpemVIZWFkZXJOYW1lKGhlYWRlcnMsICdDb250ZW50LVR5cGUnKTtcblxuICAgIGlmICh1dGlscy5pc0Zvcm1EYXRhKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0FycmF5QnVmZmVyKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0J1ZmZlcihkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNTdHJlYW0oZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzRmlsZShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNCbG9iKGRhdGEpXG4gICAgKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzQXJyYXlCdWZmZXJWaWV3KGRhdGEpKSB7XG4gICAgICByZXR1cm4gZGF0YS5idWZmZXI7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc1VSTFNlYXJjaFBhcmFtcyhkYXRhKSkge1xuICAgICAgc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD11dGYtOCcpO1xuICAgICAgcmV0dXJuIGRhdGEudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICB2YXIgaXNPYmplY3RQYXlsb2FkID0gdXRpbHMuaXNPYmplY3QoZGF0YSk7XG4gICAgdmFyIGNvbnRlbnRUeXBlID0gaGVhZGVycyAmJiBoZWFkZXJzWydDb250ZW50LVR5cGUnXTtcblxuICAgIHZhciBpc0ZpbGVMaXN0O1xuXG4gICAgaWYgKChpc0ZpbGVMaXN0ID0gdXRpbHMuaXNGaWxlTGlzdChkYXRhKSkgfHwgKGlzT2JqZWN0UGF5bG9hZCAmJiBjb250ZW50VHlwZSA9PT0gJ211bHRpcGFydC9mb3JtLWRhdGEnKSkge1xuICAgICAgdmFyIF9Gb3JtRGF0YSA9IHRoaXMuZW52ICYmIHRoaXMuZW52LkZvcm1EYXRhO1xuICAgICAgcmV0dXJuIHRvRm9ybURhdGEoaXNGaWxlTGlzdCA/IHsnZmlsZXNbXSc6IGRhdGF9IDogZGF0YSwgX0Zvcm1EYXRhICYmIG5ldyBfRm9ybURhdGEoKSk7XG4gICAgfSBlbHNlIGlmIChpc09iamVjdFBheWxvYWQgfHwgY29udGVudFR5cGUgPT09ICdhcHBsaWNhdGlvbi9qc29uJykge1xuICAgICAgc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICByZXR1cm4gc3RyaW5naWZ5U2FmZWx5KGRhdGEpO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhO1xuICB9XSxcblxuICB0cmFuc2Zvcm1SZXNwb25zZTogW2Z1bmN0aW9uIHRyYW5zZm9ybVJlc3BvbnNlKGRhdGEpIHtcbiAgICB2YXIgdHJhbnNpdGlvbmFsID0gdGhpcy50cmFuc2l0aW9uYWwgfHwgZGVmYXVsdHMudHJhbnNpdGlvbmFsO1xuICAgIHZhciBzaWxlbnRKU09OUGFyc2luZyA9IHRyYW5zaXRpb25hbCAmJiB0cmFuc2l0aW9uYWwuc2lsZW50SlNPTlBhcnNpbmc7XG4gICAgdmFyIGZvcmNlZEpTT05QYXJzaW5nID0gdHJhbnNpdGlvbmFsICYmIHRyYW5zaXRpb25hbC5mb3JjZWRKU09OUGFyc2luZztcbiAgICB2YXIgc3RyaWN0SlNPTlBhcnNpbmcgPSAhc2lsZW50SlNPTlBhcnNpbmcgJiYgdGhpcy5yZXNwb25zZVR5cGUgPT09ICdqc29uJztcblxuICAgIGlmIChzdHJpY3RKU09OUGFyc2luZyB8fCAoZm9yY2VkSlNPTlBhcnNpbmcgJiYgdXRpbHMuaXNTdHJpbmcoZGF0YSkgJiYgZGF0YS5sZW5ndGgpKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHN0cmljdEpTT05QYXJzaW5nKSB7XG4gICAgICAgICAgaWYgKGUubmFtZSA9PT0gJ1N5bnRheEVycm9yJykge1xuICAgICAgICAgICAgdGhyb3cgQXhpb3NFcnJvci5mcm9tKGUsIEF4aW9zRXJyb3IuRVJSX0JBRF9SRVNQT05TRSwgdGhpcywgbnVsbCwgdGhpcy5yZXNwb25zZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfV0sXG5cbiAgLyoqXG4gICAqIEEgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgdG8gYWJvcnQgYSByZXF1ZXN0LiBJZiBzZXQgdG8gMCAoZGVmYXVsdCkgYVxuICAgKiB0aW1lb3V0IGlzIG5vdCBjcmVhdGVkLlxuICAgKi9cbiAgdGltZW91dDogMCxcblxuICB4c3JmQ29va2llTmFtZTogJ1hTUkYtVE9LRU4nLFxuICB4c3JmSGVhZGVyTmFtZTogJ1gtWFNSRi1UT0tFTicsXG5cbiAgbWF4Q29udGVudExlbmd0aDogLTEsXG4gIG1heEJvZHlMZW5ndGg6IC0xLFxuXG4gIGVudjoge1xuICAgIEZvcm1EYXRhOiByZXF1aXJlKCcuL2Vudi9Gb3JtRGF0YScpXG4gIH0sXG5cbiAgdmFsaWRhdGVTdGF0dXM6IGZ1bmN0aW9uIHZhbGlkYXRlU3RhdHVzKHN0YXR1cykge1xuICAgIHJldHVybiBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMDtcbiAgfSxcblxuICBoZWFkZXJzOiB7XG4gICAgY29tbW9uOiB7XG4gICAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24sIHRleHQvcGxhaW4sICovKidcbiAgICB9XG4gIH1cbn07XG5cbnV0aWxzLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZE5vRGF0YShtZXRob2QpIHtcbiAgZGVmYXVsdHMuaGVhZGVyc1ttZXRob2RdID0ge307XG59KTtcblxudXRpbHMuZm9yRWFjaChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2RXaXRoRGF0YShtZXRob2QpIHtcbiAgZGVmYXVsdHMuaGVhZGVyc1ttZXRob2RdID0gdXRpbHMubWVyZ2UoREVGQVVMVF9DT05URU5UX1RZUEUpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmYXVsdHM7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzaWxlbnRKU09OUGFyc2luZzogdHJ1ZSxcbiAgZm9yY2VkSlNPTlBhcnNpbmc6IHRydWUsXG4gIGNsYXJpZnlUaW1lb3V0RXJyb3I6IGZhbHNlXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIFwidmVyc2lvblwiOiBcIjAuMjcuMlwiXG59OyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiaW5kKGZuLCB0aGlzQXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbiB3cmFwKCkge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5mdW5jdGlvbiBlbmNvZGUodmFsKSB7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQodmFsKS5cbiAgICByZXBsYWNlKC8lM0EvZ2ksICc6JykuXG4gICAgcmVwbGFjZSgvJTI0L2csICckJykuXG4gICAgcmVwbGFjZSgvJTJDL2dpLCAnLCcpLlxuICAgIHJlcGxhY2UoLyUyMC9nLCAnKycpLlxuICAgIHJlcGxhY2UoLyU1Qi9naSwgJ1snKS5cbiAgICByZXBsYWNlKC8lNUQvZ2ksICddJyk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBVUkwgYnkgYXBwZW5kaW5nIHBhcmFtcyB0byB0aGUgZW5kXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgYmFzZSBvZiB0aGUgdXJsIChlLmcuLCBodHRwOi8vd3d3Lmdvb2dsZS5jb20pXG4gKiBAcGFyYW0ge29iamVjdH0gW3BhcmFtc10gVGhlIHBhcmFtcyB0byBiZSBhcHBlbmRlZFxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGZvcm1hdHRlZCB1cmxcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBidWlsZFVSTCh1cmwsIHBhcmFtcywgcGFyYW1zU2VyaWFsaXplcikge1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgaWYgKCFwYXJhbXMpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG5cbiAgdmFyIHNlcmlhbGl6ZWRQYXJhbXM7XG4gIGlmIChwYXJhbXNTZXJpYWxpemVyKSB7XG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcmFtc1NlcmlhbGl6ZXIocGFyYW1zKTtcbiAgfSBlbHNlIGlmICh1dGlscy5pc1VSTFNlYXJjaFBhcmFtcyhwYXJhbXMpKSB7XG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcmFtcy50b1N0cmluZygpO1xuICB9IGVsc2Uge1xuICAgIHZhciBwYXJ0cyA9IFtdO1xuXG4gICAgdXRpbHMuZm9yRWFjaChwYXJhbXMsIGZ1bmN0aW9uIHNlcmlhbGl6ZSh2YWwsIGtleSkge1xuICAgICAgaWYgKHZhbCA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh1dGlscy5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAga2V5ID0ga2V5ICsgJ1tdJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IFt2YWxdO1xuICAgICAgfVxuXG4gICAgICB1dGlscy5mb3JFYWNoKHZhbCwgZnVuY3Rpb24gcGFyc2VWYWx1ZSh2KSB7XG4gICAgICAgIGlmICh1dGlscy5pc0RhdGUodikpIHtcbiAgICAgICAgICB2ID0gdi50b0lTT1N0cmluZygpO1xuICAgICAgICB9IGVsc2UgaWYgKHV0aWxzLmlzT2JqZWN0KHYpKSB7XG4gICAgICAgICAgdiA9IEpTT04uc3RyaW5naWZ5KHYpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnRzLnB1c2goZW5jb2RlKGtleSkgKyAnPScgKyBlbmNvZGUodikpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFydHMuam9pbignJicpO1xuICB9XG5cbiAgaWYgKHNlcmlhbGl6ZWRQYXJhbXMpIHtcbiAgICB2YXIgaGFzaG1hcmtJbmRleCA9IHVybC5pbmRleE9mKCcjJyk7XG4gICAgaWYgKGhhc2htYXJrSW5kZXggIT09IC0xKSB7XG4gICAgICB1cmwgPSB1cmwuc2xpY2UoMCwgaGFzaG1hcmtJbmRleCk7XG4gICAgfVxuXG4gICAgdXJsICs9ICh1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgKyBzZXJpYWxpemVkUGFyYW1zO1xuICB9XG5cbiAgcmV0dXJuIHVybDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBVUkwgYnkgY29tYmluaW5nIHRoZSBzcGVjaWZpZWQgVVJMc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJMIFRoZSBiYXNlIFVSTFxuICogQHBhcmFtIHtzdHJpbmd9IHJlbGF0aXZlVVJMIFRoZSByZWxhdGl2ZSBVUkxcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb21iaW5lZCBVUkxcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjb21iaW5lVVJMcyhiYXNlVVJMLCByZWxhdGl2ZVVSTCkge1xuICByZXR1cm4gcmVsYXRpdmVVUkxcbiAgICA/IGJhc2VVUkwucmVwbGFjZSgvXFwvKyQvLCAnJykgKyAnLycgKyByZWxhdGl2ZVVSTC5yZXBsYWNlKC9eXFwvKy8sICcnKVxuICAgIDogYmFzZVVSTDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoXG4gIHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkgP1xuXG4gIC8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBzdXBwb3J0IGRvY3VtZW50LmNvb2tpZVxuICAgIChmdW5jdGlvbiBzdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUobmFtZSwgdmFsdWUsIGV4cGlyZXMsIHBhdGgsIGRvbWFpbiwgc2VjdXJlKSB7XG4gICAgICAgICAgdmFyIGNvb2tpZSA9IFtdO1xuICAgICAgICAgIGNvb2tpZS5wdXNoKG5hbWUgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpKTtcblxuICAgICAgICAgIGlmICh1dGlscy5pc051bWJlcihleHBpcmVzKSkge1xuICAgICAgICAgICAgY29va2llLnB1c2goJ2V4cGlyZXM9JyArIG5ldyBEYXRlKGV4cGlyZXMpLnRvR01UU3RyaW5nKCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh1dGlscy5pc1N0cmluZyhwYXRoKSkge1xuICAgICAgICAgICAgY29va2llLnB1c2goJ3BhdGg9JyArIHBhdGgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh1dGlscy5pc1N0cmluZyhkb21haW4pKSB7XG4gICAgICAgICAgICBjb29raWUucHVzaCgnZG9tYWluPScgKyBkb21haW4pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzZWN1cmUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGNvb2tpZS5wdXNoKCdzZWN1cmUnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkb2N1bWVudC5jb29raWUgPSBjb29raWUuam9pbignOyAnKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG5hbWUpIHtcbiAgICAgICAgICB2YXIgbWF0Y2ggPSBkb2N1bWVudC5jb29raWUubWF0Y2gobmV3IFJlZ0V4cCgnKF58O1xcXFxzKikoJyArIG5hbWUgKyAnKT0oW147XSopJykpO1xuICAgICAgICAgIHJldHVybiAobWF0Y2ggPyBkZWNvZGVVUklDb21wb25lbnQobWF0Y2hbM10pIDogbnVsbCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUobmFtZSkge1xuICAgICAgICAgIHRoaXMud3JpdGUobmFtZSwgJycsIERhdGUubm93KCkgLSA4NjQwMDAwMCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSkoKSA6XG5cbiAgLy8gTm9uIHN0YW5kYXJkIGJyb3dzZXIgZW52ICh3ZWIgd29ya2VycywgcmVhY3QtbmF0aXZlKSBsYWNrIG5lZWRlZCBzdXBwb3J0LlxuICAgIChmdW5jdGlvbiBub25TdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoKSB7fSxcbiAgICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZCgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge31cbiAgICAgIH07XG4gICAgfSkoKVxuKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBVUkwgaXMgYWJzb2x1dGVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBVUkwgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHNwZWNpZmllZCBVUkwgaXMgYWJzb2x1dGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQWJzb2x1dGVVUkwodXJsKSB7XG4gIC8vIEEgVVJMIGlzIGNvbnNpZGVyZWQgYWJzb2x1dGUgaWYgaXQgYmVnaW5zIHdpdGggXCI8c2NoZW1lPjovL1wiIG9yIFwiLy9cIiAocHJvdG9jb2wtcmVsYXRpdmUgVVJMKS5cbiAgLy8gUkZDIDM5ODYgZGVmaW5lcyBzY2hlbWUgbmFtZSBhcyBhIHNlcXVlbmNlIG9mIGNoYXJhY3RlcnMgYmVnaW5uaW5nIHdpdGggYSBsZXR0ZXIgYW5kIGZvbGxvd2VkXG4gIC8vIGJ5IGFueSBjb21iaW5hdGlvbiBvZiBsZXR0ZXJzLCBkaWdpdHMsIHBsdXMsIHBlcmlvZCwgb3IgaHlwaGVuLlxuICByZXR1cm4gL14oW2Etel1bYS16XFxkK1xcLS5dKjopP1xcL1xcLy9pLnRlc3QodXJsKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHBheWxvYWQgaXMgYW4gZXJyb3IgdGhyb3duIGJ5IEF4aW9zXG4gKlxuICogQHBhcmFtIHsqfSBwYXlsb2FkIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcGF5bG9hZCBpcyBhbiBlcnJvciB0aHJvd24gYnkgQXhpb3MsIG90aGVyd2lzZSBmYWxzZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQXhpb3NFcnJvcihwYXlsb2FkKSB7XG4gIHJldHVybiB1dGlscy5pc09iamVjdChwYXlsb2FkKSAmJiAocGF5bG9hZC5pc0F4aW9zRXJyb3IgPT09IHRydWUpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgdXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSA/XG5cbiAgLy8gU3RhbmRhcmQgYnJvd3NlciBlbnZzIGhhdmUgZnVsbCBzdXBwb3J0IG9mIHRoZSBBUElzIG5lZWRlZCB0byB0ZXN0XG4gIC8vIHdoZXRoZXIgdGhlIHJlcXVlc3QgVVJMIGlzIG9mIHRoZSBzYW1lIG9yaWdpbiBhcyBjdXJyZW50IGxvY2F0aW9uLlxuICAgIChmdW5jdGlvbiBzdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgICB2YXIgbXNpZSA9IC8obXNpZXx0cmlkZW50KS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgICB2YXIgdXJsUGFyc2luZ05vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICB2YXIgb3JpZ2luVVJMO1xuXG4gICAgICAvKipcbiAgICAqIFBhcnNlIGEgVVJMIHRvIGRpc2NvdmVyIGl0J3MgY29tcG9uZW50c1xuICAgICpcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVGhlIFVSTCB0byBiZSBwYXJzZWRcbiAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgKi9cbiAgICAgIGZ1bmN0aW9uIHJlc29sdmVVUkwodXJsKSB7XG4gICAgICAgIHZhciBocmVmID0gdXJsO1xuXG4gICAgICAgIGlmIChtc2llKSB7XG4gICAgICAgIC8vIElFIG5lZWRzIGF0dHJpYnV0ZSBzZXQgdHdpY2UgdG8gbm9ybWFsaXplIHByb3BlcnRpZXNcbiAgICAgICAgICB1cmxQYXJzaW5nTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcbiAgICAgICAgICBocmVmID0gdXJsUGFyc2luZ05vZGUuaHJlZjtcbiAgICAgICAgfVxuXG4gICAgICAgIHVybFBhcnNpbmdOb2RlLnNldEF0dHJpYnV0ZSgnaHJlZicsIGhyZWYpO1xuXG4gICAgICAgIC8vIHVybFBhcnNpbmdOb2RlIHByb3ZpZGVzIHRoZSBVcmxVdGlscyBpbnRlcmZhY2UgLSBodHRwOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jdXJsdXRpbHNcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBocmVmOiB1cmxQYXJzaW5nTm9kZS5ocmVmLFxuICAgICAgICAgIHByb3RvY29sOiB1cmxQYXJzaW5nTm9kZS5wcm90b2NvbCA/IHVybFBhcnNpbmdOb2RlLnByb3RvY29sLnJlcGxhY2UoLzokLywgJycpIDogJycsXG4gICAgICAgICAgaG9zdDogdXJsUGFyc2luZ05vZGUuaG9zdCxcbiAgICAgICAgICBzZWFyY2g6IHVybFBhcnNpbmdOb2RlLnNlYXJjaCA/IHVybFBhcnNpbmdOb2RlLnNlYXJjaC5yZXBsYWNlKC9eXFw/LywgJycpIDogJycsXG4gICAgICAgICAgaGFzaDogdXJsUGFyc2luZ05vZGUuaGFzaCA/IHVybFBhcnNpbmdOb2RlLmhhc2gucmVwbGFjZSgvXiMvLCAnJykgOiAnJyxcbiAgICAgICAgICBob3N0bmFtZTogdXJsUGFyc2luZ05vZGUuaG9zdG5hbWUsXG4gICAgICAgICAgcG9ydDogdXJsUGFyc2luZ05vZGUucG9ydCxcbiAgICAgICAgICBwYXRobmFtZTogKHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSA/XG4gICAgICAgICAgICB1cmxQYXJzaW5nTm9kZS5wYXRobmFtZSA6XG4gICAgICAgICAgICAnLycgKyB1cmxQYXJzaW5nTm9kZS5wYXRobmFtZVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBvcmlnaW5VUkwgPSByZXNvbHZlVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcblxuICAgICAgLyoqXG4gICAgKiBEZXRlcm1pbmUgaWYgYSBVUkwgc2hhcmVzIHRoZSBzYW1lIG9yaWdpbiBhcyB0aGUgY3VycmVudCBsb2NhdGlvblxuICAgICpcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0VVJMIFRoZSBVUkwgdG8gdGVzdFxuICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgVVJMIHNoYXJlcyB0aGUgc2FtZSBvcmlnaW4sIG90aGVyd2lzZSBmYWxzZVxuICAgICovXG4gICAgICByZXR1cm4gZnVuY3Rpb24gaXNVUkxTYW1lT3JpZ2luKHJlcXVlc3RVUkwpIHtcbiAgICAgICAgdmFyIHBhcnNlZCA9ICh1dGlscy5pc1N0cmluZyhyZXF1ZXN0VVJMKSkgPyByZXNvbHZlVVJMKHJlcXVlc3RVUkwpIDogcmVxdWVzdFVSTDtcbiAgICAgICAgcmV0dXJuIChwYXJzZWQucHJvdG9jb2wgPT09IG9yaWdpblVSTC5wcm90b2NvbCAmJlxuICAgICAgICAgICAgcGFyc2VkLmhvc3QgPT09IG9yaWdpblVSTC5ob3N0KTtcbiAgICAgIH07XG4gICAgfSkoKSA6XG5cbiAgLy8gTm9uIHN0YW5kYXJkIGJyb3dzZXIgZW52cyAod2ViIHdvcmtlcnMsIHJlYWN0LW5hdGl2ZSkgbGFjayBuZWVkZWQgc3VwcG9ydC5cbiAgICAoZnVuY3Rpb24gbm9uU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbigpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuICAgIH0pKClcbik7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbm9ybWFsaXplSGVhZGVyTmFtZShoZWFkZXJzLCBub3JtYWxpemVkTmFtZSkge1xuICB1dGlscy5mb3JFYWNoKGhlYWRlcnMsIGZ1bmN0aW9uIHByb2Nlc3NIZWFkZXIodmFsdWUsIG5hbWUpIHtcbiAgICBpZiAobmFtZSAhPT0gbm9ybWFsaXplZE5hbWUgJiYgbmFtZS50b1VwcGVyQ2FzZSgpID09PSBub3JtYWxpemVkTmFtZS50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICBoZWFkZXJzW25vcm1hbGl6ZWROYW1lXSA9IHZhbHVlO1xuICAgICAgZGVsZXRlIGhlYWRlcnNbbmFtZV07XG4gICAgfVxuICB9KTtcbn07XG4iLCIvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgc3RyaWN0XG5tb2R1bGUuZXhwb3J0cyA9IG51bGw7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuLy8gSGVhZGVycyB3aG9zZSBkdXBsaWNhdGVzIGFyZSBpZ25vcmVkIGJ5IG5vZGVcbi8vIGMuZi4gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9odHRwLmh0bWwjaHR0cF9tZXNzYWdlX2hlYWRlcnNcbnZhciBpZ25vcmVEdXBsaWNhdGVPZiA9IFtcbiAgJ2FnZScsICdhdXRob3JpemF0aW9uJywgJ2NvbnRlbnQtbGVuZ3RoJywgJ2NvbnRlbnQtdHlwZScsICdldGFnJyxcbiAgJ2V4cGlyZXMnLCAnZnJvbScsICdob3N0JywgJ2lmLW1vZGlmaWVkLXNpbmNlJywgJ2lmLXVubW9kaWZpZWQtc2luY2UnLFxuICAnbGFzdC1tb2RpZmllZCcsICdsb2NhdGlvbicsICdtYXgtZm9yd2FyZHMnLCAncHJveHktYXV0aG9yaXphdGlvbicsXG4gICdyZWZlcmVyJywgJ3JldHJ5LWFmdGVyJywgJ3VzZXItYWdlbnQnXG5dO1xuXG4vKipcbiAqIFBhcnNlIGhlYWRlcnMgaW50byBhbiBvYmplY3RcbiAqXG4gKiBgYGBcbiAqIERhdGU6IFdlZCwgMjcgQXVnIDIwMTQgMDg6NTg6NDkgR01UXG4gKiBDb250ZW50LVR5cGU6IGFwcGxpY2F0aW9uL2pzb25cbiAqIENvbm5lY3Rpb246IGtlZXAtYWxpdmVcbiAqIFRyYW5zZmVyLUVuY29kaW5nOiBjaHVua2VkXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaGVhZGVycyBIZWFkZXJzIG5lZWRpbmcgdG8gYmUgcGFyc2VkXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBIZWFkZXJzIHBhcnNlZCBpbnRvIGFuIG9iamVjdFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlSGVhZGVycyhoZWFkZXJzKSB7XG4gIHZhciBwYXJzZWQgPSB7fTtcbiAgdmFyIGtleTtcbiAgdmFyIHZhbDtcbiAgdmFyIGk7XG5cbiAgaWYgKCFoZWFkZXJzKSB7IHJldHVybiBwYXJzZWQ7IH1cblxuICB1dGlscy5mb3JFYWNoKGhlYWRlcnMuc3BsaXQoJ1xcbicpLCBmdW5jdGlvbiBwYXJzZXIobGluZSkge1xuICAgIGkgPSBsaW5lLmluZGV4T2YoJzonKTtcbiAgICBrZXkgPSB1dGlscy50cmltKGxpbmUuc3Vic3RyKDAsIGkpKS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhbCA9IHV0aWxzLnRyaW0obGluZS5zdWJzdHIoaSArIDEpKTtcblxuICAgIGlmIChrZXkpIHtcbiAgICAgIGlmIChwYXJzZWRba2V5XSAmJiBpZ25vcmVEdXBsaWNhdGVPZi5pbmRleE9mKGtleSkgPj0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoa2V5ID09PSAnc2V0LWNvb2tpZScpIHtcbiAgICAgICAgcGFyc2VkW2tleV0gPSAocGFyc2VkW2tleV0gPyBwYXJzZWRba2V5XSA6IFtdKS5jb25jYXQoW3ZhbF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VkW2tleV0gPSBwYXJzZWRba2V5XSA/IHBhcnNlZFtrZXldICsgJywgJyArIHZhbCA6IHZhbDtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBwYXJzZWQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlUHJvdG9jb2wodXJsKSB7XG4gIHZhciBtYXRjaCA9IC9eKFstK1xcd117MSwyNX0pKDo/XFwvXFwvfDopLy5leGVjKHVybCk7XG4gIHJldHVybiBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU3ludGFjdGljIHN1Z2FyIGZvciBpbnZva2luZyBhIGZ1bmN0aW9uIGFuZCBleHBhbmRpbmcgYW4gYXJyYXkgZm9yIGFyZ3VtZW50cy5cbiAqXG4gKiBDb21tb24gdXNlIGNhc2Ugd291bGQgYmUgdG8gdXNlIGBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHlgLlxuICpcbiAqICBgYGBqc1xuICogIGZ1bmN0aW9uIGYoeCwgeSwgeikge31cbiAqICB2YXIgYXJncyA9IFsxLCAyLCAzXTtcbiAqICBmLmFwcGx5KG51bGwsIGFyZ3MpO1xuICogIGBgYFxuICpcbiAqIFdpdGggYHNwcmVhZGAgdGhpcyBleGFtcGxlIGNhbiBiZSByZS13cml0dGVuLlxuICpcbiAqICBgYGBqc1xuICogIHNwcmVhZChmdW5jdGlvbih4LCB5LCB6KSB7fSkoWzEsIDIsIDNdKTtcbiAqICBgYGBcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNwcmVhZChjYWxsYmFjaykge1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcChhcnIpIHtcbiAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkobnVsbCwgYXJyKTtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbi8qKlxuICogQ29udmVydCBhIGRhdGEgb2JqZWN0IHRvIEZvcm1EYXRhXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0gez9PYmplY3R9IFtmb3JtRGF0YV1cbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKiovXG5cbmZ1bmN0aW9uIHRvRm9ybURhdGEob2JqLCBmb3JtRGF0YSkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgZm9ybURhdGEgPSBmb3JtRGF0YSB8fCBuZXcgRm9ybURhdGEoKTtcblxuICB2YXIgc3RhY2sgPSBbXTtcblxuICBmdW5jdGlvbiBjb252ZXJ0VmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHJldHVybiAnJztcblxuICAgIGlmICh1dGlscy5pc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWUudG9JU09TdHJpbmcoKTtcbiAgICB9XG5cbiAgICBpZiAodXRpbHMuaXNBcnJheUJ1ZmZlcih2YWx1ZSkgfHwgdXRpbHMuaXNUeXBlZEFycmF5KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBCbG9iID09PSAnZnVuY3Rpb24nID8gbmV3IEJsb2IoW3ZhbHVlXSkgOiBCdWZmZXIuZnJvbSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gYnVpbGQoZGF0YSwgcGFyZW50S2V5KSB7XG4gICAgaWYgKHV0aWxzLmlzUGxhaW5PYmplY3QoZGF0YSkgfHwgdXRpbHMuaXNBcnJheShkYXRhKSkge1xuICAgICAgaWYgKHN0YWNrLmluZGV4T2YoZGF0YSkgIT09IC0xKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdDaXJjdWxhciByZWZlcmVuY2UgZGV0ZWN0ZWQgaW4gJyArIHBhcmVudEtleSk7XG4gICAgICB9XG5cbiAgICAgIHN0YWNrLnB1c2goZGF0YSk7XG5cbiAgICAgIHV0aWxzLmZvckVhY2goZGF0YSwgZnVuY3Rpb24gZWFjaCh2YWx1ZSwga2V5KSB7XG4gICAgICAgIGlmICh1dGlscy5pc1VuZGVmaW5lZCh2YWx1ZSkpIHJldHVybjtcbiAgICAgICAgdmFyIGZ1bGxLZXkgPSBwYXJlbnRLZXkgPyBwYXJlbnRLZXkgKyAnLicgKyBrZXkgOiBrZXk7XG4gICAgICAgIHZhciBhcnI7XG5cbiAgICAgICAgaWYgKHZhbHVlICYmICFwYXJlbnRLZXkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGlmICh1dGlscy5lbmRzV2l0aChrZXksICd7fScpKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIHZhbHVlID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodXRpbHMuZW5kc1dpdGgoa2V5LCAnW10nKSAmJiAoYXJyID0gdXRpbHMudG9BcnJheSh2YWx1ZSkpKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICAgICAgICAgICAgYXJyLmZvckVhY2goZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgICAgIXV0aWxzLmlzVW5kZWZpbmVkKGVsKSAmJiBmb3JtRGF0YS5hcHBlbmQoZnVsbEtleSwgY29udmVydFZhbHVlKGVsKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBidWlsZCh2YWx1ZSwgZnVsbEtleSk7XG4gICAgICB9KTtcblxuICAgICAgc3RhY2sucG9wKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvcm1EYXRhLmFwcGVuZChwYXJlbnRLZXksIGNvbnZlcnRWYWx1ZShkYXRhKSk7XG4gICAgfVxuICB9XG5cbiAgYnVpbGQob2JqKTtcblxuICByZXR1cm4gZm9ybURhdGE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9Gb3JtRGF0YTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFZFUlNJT04gPSByZXF1aXJlKCcuLi9lbnYvZGF0YScpLnZlcnNpb247XG52YXIgQXhpb3NFcnJvciA9IHJlcXVpcmUoJy4uL2NvcmUvQXhpb3NFcnJvcicpO1xuXG52YXIgdmFsaWRhdG9ycyA9IHt9O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuWydvYmplY3QnLCAnYm9vbGVhbicsICdudW1iZXInLCAnZnVuY3Rpb24nLCAnc3RyaW5nJywgJ3N5bWJvbCddLmZvckVhY2goZnVuY3Rpb24odHlwZSwgaSkge1xuICB2YWxpZGF0b3JzW3R5cGVdID0gZnVuY3Rpb24gdmFsaWRhdG9yKHRoaW5nKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGluZyA9PT0gdHlwZSB8fCAnYScgKyAoaSA8IDEgPyAnbiAnIDogJyAnKSArIHR5cGU7XG4gIH07XG59KTtcblxudmFyIGRlcHJlY2F0ZWRXYXJuaW5ncyA9IHt9O1xuXG4vKipcbiAqIFRyYW5zaXRpb25hbCBvcHRpb24gdmFsaWRhdG9yXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufGJvb2xlYW4/fSB2YWxpZGF0b3IgLSBzZXQgdG8gZmFsc2UgaWYgdGhlIHRyYW5zaXRpb25hbCBvcHRpb24gaGFzIGJlZW4gcmVtb3ZlZFxuICogQHBhcmFtIHtzdHJpbmc/fSB2ZXJzaW9uIC0gZGVwcmVjYXRlZCB2ZXJzaW9uIC8gcmVtb3ZlZCBzaW5jZSB2ZXJzaW9uXG4gKiBAcGFyYW0ge3N0cmluZz99IG1lc3NhZ2UgLSBzb21lIG1lc3NhZ2Ugd2l0aCBhZGRpdGlvbmFsIGluZm9cbiAqIEByZXR1cm5zIHtmdW5jdGlvbn1cbiAqL1xudmFsaWRhdG9ycy50cmFuc2l0aW9uYWwgPSBmdW5jdGlvbiB0cmFuc2l0aW9uYWwodmFsaWRhdG9yLCB2ZXJzaW9uLCBtZXNzYWdlKSB7XG4gIGZ1bmN0aW9uIGZvcm1hdE1lc3NhZ2Uob3B0LCBkZXNjKSB7XG4gICAgcmV0dXJuICdbQXhpb3MgdicgKyBWRVJTSU9OICsgJ10gVHJhbnNpdGlvbmFsIG9wdGlvbiBcXCcnICsgb3B0ICsgJ1xcJycgKyBkZXNjICsgKG1lc3NhZ2UgPyAnLiAnICsgbWVzc2FnZSA6ICcnKTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSwgb3B0LCBvcHRzKSB7XG4gICAgaWYgKHZhbGlkYXRvciA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93IG5ldyBBeGlvc0Vycm9yKFxuICAgICAgICBmb3JtYXRNZXNzYWdlKG9wdCwgJyBoYXMgYmVlbiByZW1vdmVkJyArICh2ZXJzaW9uID8gJyBpbiAnICsgdmVyc2lvbiA6ICcnKSksXG4gICAgICAgIEF4aW9zRXJyb3IuRVJSX0RFUFJFQ0FURURcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKHZlcnNpb24gJiYgIWRlcHJlY2F0ZWRXYXJuaW5nc1tvcHRdKSB7XG4gICAgICBkZXByZWNhdGVkV2FybmluZ3Nbb3B0XSA9IHRydWU7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBmb3JtYXRNZXNzYWdlKFxuICAgICAgICAgIG9wdCxcbiAgICAgICAgICAnIGhhcyBiZWVuIGRlcHJlY2F0ZWQgc2luY2UgdicgKyB2ZXJzaW9uICsgJyBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZWFyIGZ1dHVyZSdcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsaWRhdG9yID8gdmFsaWRhdG9yKHZhbHVlLCBvcHQsIG9wdHMpIDogdHJ1ZTtcbiAgfTtcbn07XG5cbi8qKlxuICogQXNzZXJ0IG9iamVjdCdzIHByb3BlcnRpZXMgdHlwZVxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7b2JqZWN0fSBzY2hlbWFcbiAqIEBwYXJhbSB7Ym9vbGVhbj99IGFsbG93VW5rbm93blxuICovXG5cbmZ1bmN0aW9uIGFzc2VydE9wdGlvbnMob3B0aW9ucywgc2NoZW1hLCBhbGxvd1Vua25vd24pIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBBeGlvc0Vycm9yKCdvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0JywgQXhpb3NFcnJvci5FUlJfQkFEX09QVElPTl9WQUxVRSk7XG4gIH1cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSA+IDApIHtcbiAgICB2YXIgb3B0ID0ga2V5c1tpXTtcbiAgICB2YXIgdmFsaWRhdG9yID0gc2NoZW1hW29wdF07XG4gICAgaWYgKHZhbGlkYXRvcikge1xuICAgICAgdmFyIHZhbHVlID0gb3B0aW9uc1tvcHRdO1xuICAgICAgdmFyIHJlc3VsdCA9IHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsaWRhdG9yKHZhbHVlLCBvcHQsIG9wdGlvbnMpO1xuICAgICAgaWYgKHJlc3VsdCAhPT0gdHJ1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcignb3B0aW9uICcgKyBvcHQgKyAnIG11c3QgYmUgJyArIHJlc3VsdCwgQXhpb3NFcnJvci5FUlJfQkFEX09QVElPTl9WQUxVRSk7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGFsbG93VW5rbm93biAhPT0gdHJ1ZSkge1xuICAgICAgdGhyb3cgbmV3IEF4aW9zRXJyb3IoJ1Vua25vd24gb3B0aW9uICcgKyBvcHQsIEF4aW9zRXJyb3IuRVJSX0JBRF9PUFRJT04pO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYXNzZXJ0T3B0aW9uczogYXNzZXJ0T3B0aW9ucyxcbiAgdmFsaWRhdG9yczogdmFsaWRhdG9yc1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJpbmQgPSByZXF1aXJlKCcuL2hlbHBlcnMvYmluZCcpO1xuXG4vLyB1dGlscyBpcyBhIGxpYnJhcnkgb2YgZ2VuZXJpYyBoZWxwZXIgZnVuY3Rpb25zIG5vbi1zcGVjaWZpYyB0byBheGlvc1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xudmFyIGtpbmRPZiA9IChmdW5jdGlvbihjYWNoZSkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICByZXR1cm4gZnVuY3Rpb24odGhpbmcpIHtcbiAgICB2YXIgc3RyID0gdG9TdHJpbmcuY2FsbCh0aGluZyk7XG4gICAgcmV0dXJuIGNhY2hlW3N0cl0gfHwgKGNhY2hlW3N0cl0gPSBzdHIuc2xpY2UoOCwgLTEpLnRvTG93ZXJDYXNlKCkpO1xuICB9O1xufSkoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG5cbmZ1bmN0aW9uIGtpbmRPZlRlc3QodHlwZSkge1xuICB0eXBlID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gZnVuY3Rpb24gaXNLaW5kT2YodGhpbmcpIHtcbiAgICByZXR1cm4ga2luZE9mKHRoaW5nKSA9PT0gdHlwZTtcbiAgfTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEFycmF5LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheSh2YWwpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyB1bmRlZmluZWRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgdW5kZWZpbmVkLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgQnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNCdWZmZXIodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IG51bGwgJiYgIWlzVW5kZWZpbmVkKHZhbCkgJiYgdmFsLmNvbnN0cnVjdG9yICE9PSBudWxsICYmICFpc1VuZGVmaW5lZCh2YWwuY29uc3RydWN0b3IpXG4gICAgJiYgdHlwZW9mIHZhbC5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiB2YWwuY29uc3RydWN0b3IuaXNCdWZmZXIodmFsKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG52YXIgaXNBcnJheUJ1ZmZlciA9IGtpbmRPZlRlc3QoJ0FycmF5QnVmZmVyJyk7XG5cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIHZpZXcgb24gYW4gQXJyYXlCdWZmZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIHZpZXcgb24gYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyVmlldyh2YWwpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnKSAmJiAoQXJyYXlCdWZmZXIuaXNWaWV3KSkge1xuICAgIHJlc3VsdCA9IEFycmF5QnVmZmVyLmlzVmlldyh2YWwpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9ICh2YWwpICYmICh2YWwuYnVmZmVyKSAmJiAoaXNBcnJheUJ1ZmZlcih2YWwuYnVmZmVyKSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmluZ1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyaW5nLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIE51bWJlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgTnVtYmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNOdW1iZXIodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBPYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBPYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIHBsYWluIE9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBwbGFpbiBPYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbCkge1xuICBpZiAoa2luZE9mKHZhbCkgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWwpO1xuICByZXR1cm4gcHJvdG90eXBlID09PSBudWxsIHx8IHByb3RvdHlwZSA9PT0gT2JqZWN0LnByb3RvdHlwZTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIERhdGVcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRGF0ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbnZhciBpc0RhdGUgPSBraW5kT2ZUZXN0KCdEYXRlJyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGaWxlXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZpbGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG52YXIgaXNGaWxlID0ga2luZE9mVGVzdCgnRmlsZScpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQmxvYlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBCbG9iLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xudmFyIGlzQmxvYiA9IGtpbmRPZlRlc3QoJ0Jsb2InKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZpbGVMaXN0XG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZpbGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG52YXIgaXNGaWxlTGlzdCA9IGtpbmRPZlRlc3QoJ0ZpbGVMaXN0Jyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRnVuY3Rpb24sIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgU3RyZWFtXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBTdHJlYW0sIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N0cmVhbSh2YWwpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbCkgJiYgaXNGdW5jdGlvbih2YWwucGlwZSk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGb3JtRGF0YVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0aGluZyBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gRm9ybURhdGEsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Zvcm1EYXRhKHRoaW5nKSB7XG4gIHZhciBwYXR0ZXJuID0gJ1tvYmplY3QgRm9ybURhdGFdJztcbiAgcmV0dXJuIHRoaW5nICYmIChcbiAgICAodHlwZW9mIEZvcm1EYXRhID09PSAnZnVuY3Rpb24nICYmIHRoaW5nIGluc3RhbmNlb2YgRm9ybURhdGEpIHx8XG4gICAgdG9TdHJpbmcuY2FsbCh0aGluZykgPT09IHBhdHRlcm4gfHxcbiAgICAoaXNGdW5jdGlvbih0aGluZy50b1N0cmluZykgJiYgdGhpbmcudG9TdHJpbmcoKSA9PT0gcGF0dGVybilcbiAgKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3RcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xudmFyIGlzVVJMU2VhcmNoUGFyYW1zID0ga2luZE9mVGVzdCgnVVJMU2VhcmNoUGFyYW1zJyk7XG5cbi8qKlxuICogVHJpbSBleGNlc3Mgd2hpdGVzcGFjZSBvZmYgdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIGEgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgU3RyaW5nIHRvIHRyaW1cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBTdHJpbmcgZnJlZWQgb2YgZXhjZXNzIHdoaXRlc3BhY2VcbiAqL1xuZnVuY3Rpb24gdHJpbShzdHIpIHtcbiAgcmV0dXJuIHN0ci50cmltID8gc3RyLnRyaW0oKSA6IHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHdlJ3JlIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIGVudmlyb25tZW50XG4gKlxuICogVGhpcyBhbGxvd3MgYXhpb3MgdG8gcnVuIGluIGEgd2ViIHdvcmtlciwgYW5kIHJlYWN0LW5hdGl2ZS5cbiAqIEJvdGggZW52aXJvbm1lbnRzIHN1cHBvcnQgWE1MSHR0cFJlcXVlc3QsIGJ1dCBub3QgZnVsbHkgc3RhbmRhcmQgZ2xvYmFscy5cbiAqXG4gKiB3ZWIgd29ya2VyczpcbiAqICB0eXBlb2Ygd2luZG93IC0+IHVuZGVmaW5lZFxuICogIHR5cGVvZiBkb2N1bWVudCAtPiB1bmRlZmluZWRcbiAqXG4gKiByZWFjdC1uYXRpdmU6XG4gKiAgbmF2aWdhdG9yLnByb2R1Y3QgLT4gJ1JlYWN0TmF0aXZlJ1xuICogbmF0aXZlc2NyaXB0XG4gKiAgbmF2aWdhdG9yLnByb2R1Y3QgLT4gJ05hdGl2ZVNjcmlwdCcgb3IgJ05TJ1xuICovXG5mdW5jdGlvbiBpc1N0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIChuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ1JlYWN0TmF0aXZlJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnTmF0aXZlU2NyaXB0JyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnTlMnKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gKFxuICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJ1xuICApO1xufVxuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbiBBcnJheSBvciBhbiBPYmplY3QgaW52b2tpbmcgYSBmdW5jdGlvbiBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmIGBvYmpgIGlzIGFuIEFycmF5IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3NpbmdcbiAqIHRoZSB2YWx1ZSwgaW5kZXgsIGFuZCBjb21wbGV0ZSBhcnJheSBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmICdvYmonIGlzIGFuIE9iamVjdCBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXG4gKiB0aGUgdmFsdWUsIGtleSwgYW5kIGNvbXBsZXRlIG9iamVjdCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gb2JqIFRoZSBvYmplY3QgdG8gaXRlcmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGNhbGxiYWNrIHRvIGludm9rZSBmb3IgZWFjaCBpdGVtXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2gob2JqLCBmbikge1xuICAvLyBEb24ndCBib3RoZXIgaWYgbm8gdmFsdWUgcHJvdmlkZWRcbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEZvcmNlIGFuIGFycmF5IGlmIG5vdCBhbHJlYWR5IHNvbWV0aGluZyBpdGVyYWJsZVxuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgICBvYmogPSBbb2JqXTtcbiAgfVxuXG4gIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgYXJyYXkgdmFsdWVzXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIG9ialtpXSwgaSwgb2JqKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIG9iamVjdCBrZXlzXG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgZm4uY2FsbChudWxsLCBvYmpba2V5XSwga2V5LCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFjY2VwdHMgdmFyYXJncyBleHBlY3RpbmcgZWFjaCBhcmd1bWVudCB0byBiZSBhbiBvYmplY3QsIHRoZW5cbiAqIGltbXV0YWJseSBtZXJnZXMgdGhlIHByb3BlcnRpZXMgb2YgZWFjaCBvYmplY3QgYW5kIHJldHVybnMgcmVzdWx0LlxuICpcbiAqIFdoZW4gbXVsdGlwbGUgb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIGtleSB0aGUgbGF0ZXIgb2JqZWN0IGluXG4gKiB0aGUgYXJndW1lbnRzIGxpc3Qgd2lsbCB0YWtlIHByZWNlZGVuY2UuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICogdmFyIHJlc3VsdCA9IG1lcmdlKHtmb286IDEyM30sIHtmb286IDQ1Nn0pO1xuICogY29uc29sZS5sb2cocmVzdWx0LmZvbyk7IC8vIG91dHB1dHMgNDU2XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqMSBPYmplY3QgdG8gbWVyZ2VcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJlc3VsdCBvZiBhbGwgbWVyZ2UgcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBtZXJnZSgvKiBvYmoxLCBvYmoyLCBvYmozLCAuLi4gKi8pIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBmdW5jdGlvbiBhc3NpZ25WYWx1ZSh2YWwsIGtleSkge1xuICAgIGlmIChpc1BsYWluT2JqZWN0KHJlc3VsdFtrZXldKSAmJiBpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gbWVyZ2UocmVzdWx0W2tleV0sIHZhbCk7XG4gICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gbWVyZ2Uoe30sIHZhbCk7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KHZhbCkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsLnNsaWNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGZvckVhY2goYXJndW1lbnRzW2ldLCBhc3NpZ25WYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBFeHRlbmRzIG9iamVjdCBhIGJ5IG11dGFibHkgYWRkaW5nIHRvIGl0IHRoZSBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhIFRoZSBvYmplY3QgdG8gYmUgZXh0ZW5kZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBiIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb21cbiAqIEBwYXJhbSB7T2JqZWN0fSB0aGlzQXJnIFRoZSBvYmplY3QgdG8gYmluZCBmdW5jdGlvbiB0b1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgcmVzdWx0aW5nIHZhbHVlIG9mIG9iamVjdCBhXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZChhLCBiLCB0aGlzQXJnKSB7XG4gIGZvckVhY2goYiwgZnVuY3Rpb24gYXNzaWduVmFsdWUodmFsLCBrZXkpIHtcbiAgICBpZiAodGhpc0FyZyAmJiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhW2tleV0gPSBiaW5kKHZhbCwgdGhpc0FyZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFba2V5XSA9IHZhbDtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gYTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgYnl0ZSBvcmRlciBtYXJrZXIuIFRoaXMgY2F0Y2hlcyBFRiBCQiBCRiAodGhlIFVURi04IEJPTSlcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGVudCB3aXRoIEJPTVxuICogQHJldHVybiB7c3RyaW5nfSBjb250ZW50IHZhbHVlIHdpdGhvdXQgQk9NXG4gKi9cbmZ1bmN0aW9uIHN0cmlwQk9NKGNvbnRlbnQpIHtcbiAgaWYgKGNvbnRlbnQuY2hhckNvZGVBdCgwKSA9PT0gMHhGRUZGKSB7XG4gICAgY29udGVudCA9IGNvbnRlbnQuc2xpY2UoMSk7XG4gIH1cbiAgcmV0dXJuIGNvbnRlbnQ7XG59XG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IFtwcm9wc11cbiAqIEBwYXJhbSB7b2JqZWN0fSBbZGVzY3JpcHRvcnNdXG4gKi9cblxuZnVuY3Rpb24gaW5oZXJpdHMoY29uc3RydWN0b3IsIHN1cGVyQ29uc3RydWN0b3IsIHByb3BzLCBkZXNjcmlwdG9ycykge1xuICBjb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ29uc3RydWN0b3IucHJvdG90eXBlLCBkZXNjcmlwdG9ycyk7XG4gIGNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGNvbnN0cnVjdG9yO1xuICBwcm9wcyAmJiBPYmplY3QuYXNzaWduKGNvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvcHMpO1xufVxuXG4vKipcbiAqIFJlc29sdmUgb2JqZWN0IHdpdGggZGVlcCBwcm90b3R5cGUgY2hhaW4gdG8gYSBmbGF0IG9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZU9iaiBzb3VyY2Ugb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gW2Rlc3RPYmpdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZmlsdGVyXVxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuXG5mdW5jdGlvbiB0b0ZsYXRPYmplY3Qoc291cmNlT2JqLCBkZXN0T2JqLCBmaWx0ZXIpIHtcbiAgdmFyIHByb3BzO1xuICB2YXIgaTtcbiAgdmFyIHByb3A7XG4gIHZhciBtZXJnZWQgPSB7fTtcblxuICBkZXN0T2JqID0gZGVzdE9iaiB8fCB7fTtcblxuICBkbyB7XG4gICAgcHJvcHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzb3VyY2VPYmopO1xuICAgIGkgPSBwcm9wcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSA+IDApIHtcbiAgICAgIHByb3AgPSBwcm9wc1tpXTtcbiAgICAgIGlmICghbWVyZ2VkW3Byb3BdKSB7XG4gICAgICAgIGRlc3RPYmpbcHJvcF0gPSBzb3VyY2VPYmpbcHJvcF07XG4gICAgICAgIG1lcmdlZFtwcm9wXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHNvdXJjZU9iaiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihzb3VyY2VPYmopO1xuICB9IHdoaWxlIChzb3VyY2VPYmogJiYgKCFmaWx0ZXIgfHwgZmlsdGVyKHNvdXJjZU9iaiwgZGVzdE9iaikpICYmIHNvdXJjZU9iaiAhPT0gT2JqZWN0LnByb3RvdHlwZSk7XG5cbiAgcmV0dXJuIGRlc3RPYmo7XG59XG5cbi8qXG4gKiBkZXRlcm1pbmVzIHdoZXRoZXIgYSBzdHJpbmcgZW5kcyB3aXRoIHRoZSBjaGFyYWN0ZXJzIG9mIGEgc3BlY2lmaWVkIHN0cmluZ1xuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHBhcmFtIHtTdHJpbmd9IHNlYXJjaFN0cmluZ1xuICogQHBhcmFtIHtOdW1iZXJ9IFtwb3NpdGlvbj0gMF1cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBlbmRzV2l0aChzdHIsIHNlYXJjaFN0cmluZywgcG9zaXRpb24pIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChwb3NpdGlvbiA9PT0gdW5kZWZpbmVkIHx8IHBvc2l0aW9uID4gc3RyLmxlbmd0aCkge1xuICAgIHBvc2l0aW9uID0gc3RyLmxlbmd0aDtcbiAgfVxuICBwb3NpdGlvbiAtPSBzZWFyY2hTdHJpbmcubGVuZ3RoO1xuICB2YXIgbGFzdEluZGV4ID0gc3RyLmluZGV4T2Yoc2VhcmNoU3RyaW5nLCBwb3NpdGlvbik7XG4gIHJldHVybiBsYXN0SW5kZXggIT09IC0xICYmIGxhc3RJbmRleCA9PT0gcG9zaXRpb247XG59XG5cblxuLyoqXG4gKiBSZXR1cm5zIG5ldyBhcnJheSBmcm9tIGFycmF5IGxpa2Ugb2JqZWN0XG4gKiBAcGFyYW0geyp9IFt0aGluZ11cbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gdG9BcnJheSh0aGluZykge1xuICBpZiAoIXRoaW5nKSByZXR1cm4gbnVsbDtcbiAgdmFyIGkgPSB0aGluZy5sZW5ndGg7XG4gIGlmIChpc1VuZGVmaW5lZChpKSkgcmV0dXJuIG51bGw7XG4gIHZhciBhcnIgPSBuZXcgQXJyYXkoaSk7XG4gIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgYXJyW2ldID0gdGhpbmdbaV07XG4gIH1cbiAgcmV0dXJuIGFycjtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbnZhciBpc1R5cGVkQXJyYXkgPSAoZnVuY3Rpb24oVHlwZWRBcnJheSkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICByZXR1cm4gZnVuY3Rpb24odGhpbmcpIHtcbiAgICByZXR1cm4gVHlwZWRBcnJheSAmJiB0aGluZyBpbnN0YW5jZW9mIFR5cGVkQXJyYXk7XG4gIH07XG59KSh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKFVpbnQ4QXJyYXkpKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzQXJyYXk6IGlzQXJyYXksXG4gIGlzQXJyYXlCdWZmZXI6IGlzQXJyYXlCdWZmZXIsXG4gIGlzQnVmZmVyOiBpc0J1ZmZlcixcbiAgaXNGb3JtRGF0YTogaXNGb3JtRGF0YSxcbiAgaXNBcnJheUJ1ZmZlclZpZXc6IGlzQXJyYXlCdWZmZXJWaWV3LFxuICBpc1N0cmluZzogaXNTdHJpbmcsXG4gIGlzTnVtYmVyOiBpc051bWJlcixcbiAgaXNPYmplY3Q6IGlzT2JqZWN0LFxuICBpc1BsYWluT2JqZWN0OiBpc1BsYWluT2JqZWN0LFxuICBpc1VuZGVmaW5lZDogaXNVbmRlZmluZWQsXG4gIGlzRGF0ZTogaXNEYXRlLFxuICBpc0ZpbGU6IGlzRmlsZSxcbiAgaXNCbG9iOiBpc0Jsb2IsXG4gIGlzRnVuY3Rpb246IGlzRnVuY3Rpb24sXG4gIGlzU3RyZWFtOiBpc1N0cmVhbSxcbiAgaXNVUkxTZWFyY2hQYXJhbXM6IGlzVVJMU2VhcmNoUGFyYW1zLFxuICBpc1N0YW5kYXJkQnJvd3NlckVudjogaXNTdGFuZGFyZEJyb3dzZXJFbnYsXG4gIGZvckVhY2g6IGZvckVhY2gsXG4gIG1lcmdlOiBtZXJnZSxcbiAgZXh0ZW5kOiBleHRlbmQsXG4gIHRyaW06IHRyaW0sXG4gIHN0cmlwQk9NOiBzdHJpcEJPTSxcbiAgaW5oZXJpdHM6IGluaGVyaXRzLFxuICB0b0ZsYXRPYmplY3Q6IHRvRmxhdE9iamVjdCxcbiAga2luZE9mOiBraW5kT2YsXG4gIGtpbmRPZlRlc3Q6IGtpbmRPZlRlc3QsXG4gIGVuZHNXaXRoOiBlbmRzV2l0aCxcbiAgdG9BcnJheTogdG9BcnJheSxcbiAgaXNUeXBlZEFycmF5OiBpc1R5cGVkQXJyYXksXG4gIGlzRmlsZUxpc3Q6IGlzRmlsZUxpc3Rcbn07XG4iLCI8dGVtcGxhdGU+XG4gICAgPFNlYXJjaCAvPlxuICAgIDxNYXAgLz5cblxuICAgIDxkaXYgY2xhc3M9XCJ1aSBjYXJkc1wiIGlkPVwibGlzdFwiIHYtaWY9XCJzdG9yZS5zdGF0ZS5zZWFyY2hSZXN1bHRzTGVuZ3RoID4gMFwiPlxuICAgICAgICA8dGVtcGxhdGVcbiAgICAgICAgICAgICAgICAgIHYtZm9yPVwicmV0YWlsZXIgaW4gc3RvcmUuc3RhdGUucmV0YWlsZXJzXCJcbiAgICAgICAgICAgICAgICAgIDprZXk9XCJyZXRhaWxlci5pZFwiPlxuICAgICAgICAgICAgPFJldGFpbGVyIDpyZXRhaWxlcj1cInJldGFpbGVyXCIgOmltYWdlPVwiaW1hZ2VVUkwgKyByZXRhaWxlci5wYXRoXCIgLz5cbiAgICAgICAgPC90ZW1wbGF0ZT5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJ1aSBpZ25vcmVkIGluZm8gbWVzc2FnZVwiIHYtZWxzZT5cbiAgICAgICAge3sgSlNPTi5wYXJzZSh0aGlzLiRwcm9wcy5jb25maWcpLmVtcHR5UmVzdWx0c01lc3NhZ2UgfX1cbiAgICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgU2VhcmNoIGZyb20gJy4vY29tcG9uZW50cy9UaGVTZWFyY2gudnVlJztcbmltcG9ydCBNYXAgZnJvbSAnLi9jb21wb25lbnRzL1RoZU1hcC52dWUnO1xuaW1wb3J0IFJldGFpbGVyIGZyb20gJy4vY29tcG9uZW50cy9UaGVSZXRhaWxlcic7XG5pbXBvcnQgeyBwcm92aWRlLCBpbmplY3QgfSBmcm9tICd2dWUnO1xuaW1wb3J0IHsgdXNlU3RvcmUgfSBmcm9tIFwidnVleFwiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgbmFtZTogXCJBcHBcIixcbiAgICBjb21wb25lbnRzOiB7XG4gICAgICAgIFNlYXJjaCxcbiAgICAgICAgTWFwLFxuICAgICAgICBSZXRhaWxlclxuICAgIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgY29uZmlnOiBTdHJpbmcsXG4gICAgfSxcbiAgICBwcm92aWRlKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWpheFJvdXRlOiBKU09OLnBhcnNlKHRoaXMuY29uZmlnKS5hamF4Um91dGUsXG4gICAgICAgICAgICBpbWFnZVJvdXRlOiBKU09OLnBhcnNlKHRoaXMuY29uZmlnKS5pbWFnZVJvdXRlLFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlczogSlNPTi5wYXJzZSh0aGlzLmNvbmZpZykuZGVmYXVsdCxcbiAgICAgICAgICAgIGZvcm1hdFBob25lTnVtYmVyOiB0aGlzLmZvcm1hdFBob25lTnVtYmVyLFxuICAgICAgICAgICAgc2VhcmNoRmllbGQ6ICBKU09OLnBhcnNlKHRoaXMuY29uZmlnKS5zZWFyY2hGaWVsZCxcbiAgICAgICAgICAgIGZpbmRCdXR0b246ICBKU09OLnBhcnNlKHRoaXMuY29uZmlnKS5maW5kQnV0dG9uLFxuICAgICAgICAgICAgZW1wdHlSZXN1bHRzTWVzc2FnZTogIEpTT04ucGFyc2UodGhpcy5jb25maWcpLmVtcHR5UmVzdWx0c01lc3NhZ2UsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBzZXR1cChwcm9wcykge1xuICAgICAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlKCk7XG4gICAgICAgIGNvbnN0IGltZ1JvdXRlID0gSlNPTi5wYXJzZShwcm9wcy5jb25maWcpLmltYWdlUm91dGU7XG4gICAgICAgIGNvbnN0IGltYWdlVVJMID0gIGRvY3VtZW50LmxvY2F0aW9uLm9yaWdpbiArICcvJyArIGltZ1JvdXRlO1xuXG4gICAgICAgIGZ1bmN0aW9uIGZvcm1hdFBob25lTnVtYmVyKG51bWJlcikge1xuICAgICAgICAgICAgLy8gSHVnbyBEdXZhbCAtLSBDb2RlIDpcbiAgICAgICAgICAgIGNvbnN0IE1BU0tTID0ge1xuICAgICAgICAgICAgICAgICcwMDAgMCAwMCAwMCAwMCAwMCc6IHYgPT4gdi5zdGFydHNXaXRoKCcrMzMnKSAmJiB2Lmxlbmd0aCA9PT0gMTIsXG4gICAgICAgICAgICAgICAgJzAwIDAwIDAwIDAwIDAwJzogdiA9PiB2LnN0YXJ0c1dpdGgoJzAnKSAmJiB2Lmxlbmd0aCA9PT0gMTAsXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjb25zdCBbbWFza10gPSBPYmplY3QuZW50cmllcyhNQVNLUykuZmluZCgoW18sIGNvbmRpdGlvbl0pID0+IGNvbmRpdGlvbihudW1iZXIpKSA/PyBbXTtcblxuICAgICAgICAgICAgaWYgKCFtYXNrKSByZXR1cm4gbnVtYmVyO1xuXG4gICAgICAgICAgICBjb25zdCBudW1iZXJBcnIgPSBbLi4ubnVtYmVyXTtcbiAgICAgICAgICAgIGxldCBudW1iZXJJbmRleCA9IDA7XG4gICAgICAgICAgICByZXR1cm4gWy4uLm1hc2tdLnJlZHVjZSgoYWNjLCB2KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHYgPT09ICcgJykgcmV0dXJuIGFjYyArICcgJztcblxuICAgICAgICAgICAgICAgIGFjYyArPSBudW1iZXJBcnJbbnVtYmVySW5kZXhdO1xuICAgICAgICAgICAgICAgIG51bWJlckluZGV4Kys7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSwgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnByb3BzLFxuICAgICAgICAgICAgc3RvcmUsXG4gICAgICAgICAgICBpbWdSb3V0ZSxcbiAgICAgICAgICAgIGltYWdlVVJMLFxuICAgICAgICAgICAgZm9ybWF0UGhvbmVOdW1iZXIsXG4gICAgICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgfVxuICAgIH1cbn1cbjwvc2NyaXB0PlxuXG48c3R5bGUgc2NvcGVkPlxuKiB7XG4gICAgbWFyZ2luOiAxZW0gMDtcbn1cblxuI2xpc3Qge1xuICAgIG1hcmdpbjogMWVtIDA7XG59XG5cbiNsaXN0ICoge1xuICAgIG1hcmdpbjogMWVtO1xufVxuPC9zdHlsZT5cbiIsIjx0ZW1wbGF0ZT5cbiAgICA8bC1tYXJrZXJcbiAgICAgICAgOmtleT1cIm1hcmtlci5pZFwiXG4gICAgICAgIDpsYXQtbG5nPVwibWFya2VyLmNvb3JkaW5hdGVzXCJcbiAgICA+XG4gICAgICAgIDxsLWljb24gcmVmPVwiaWNvblwiIHYtaWY9XCJtYXJrZXIuaW1hZ2UgIT09IHVuZGVmaW5lZFwiPlxuICAgICAgICAgICAgPGltZyBjbGFzcz1cInJldGFpbGVyLWljb25cIiA6c3JjPVwibWFya2VyLmltYWdlXCIgLz5cbiAgICAgICAgPC9sLWljb24+XG5cbiAgICAgICAgPGwtcG9wdXAgOmNvbnRlbnQ9XCJjb250ZW50XCIgLz5cbiAgICA8L2wtbWFya2VyPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCB7IExJY29uLCBMTWFya2VyLCBMUG9wdXAgfSBmcm9tICdAdnVlLWxlYWZsZXQvdnVlLWxlYWZsZXQnO1xuaW1wb3J0IHsgb25CZWZvcmVNb3VudCwgaW5qZWN0IH0gZnJvbSAndnVlJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIGNvbXBvbmVudHM6IHsgTEljb24sIExNYXJrZXIsIExQb3B1cCB9LFxuICAgIHByb3BzOiB7XG4gICAgICAgIG1hcmtlcjoge1xuICAgICAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICAgICAgfVxuICAgIH0sXG4gICAgc2V0dXAocHJvcHMpIHtcblxuICAgICAgICBjb25zdCBmb3JtYXRQaG9uZU51bWJlciA9IGluamVjdCgnZm9ybWF0UGhvbmVOdW1iZXInKTtcblxuICAgICAgICBjb25zdCBjb250ZW50ID1cbiAgICAgICAgICAgICc8Yj4nICtcbiAgICAgICAgICAgIHByb3BzLm1hcmtlci5uYW1lXG4gICAgICAgICAgICArICc8L2I+PGJyIC8+J1xuICAgICAgICAgICAgKyBwcm9wcy5tYXJrZXIuc3RyZWV0XG4gICAgICAgICAgICArICc8YnIgLz4nXG4gICAgICAgICAgICArIHByb3BzLm1hcmtlci5jaXR5LnRvVXBwZXJDYXNlKClcbiAgICAgICAgICAgICsgJyAnXG4gICAgICAgICAgICArIHByb3BzLm1hcmtlci5wb3N0Y29kZVxuICAgICAgICAgICAgKyBgPGJyIC8+PGEgaHJlZj1cInRlbDoke3Byb3BzLm1hcmtlci5waG9uZU51bWJlcn1cIj4ke2Zvcm1hdFBob25lTnVtYmVyKHByb3BzLm1hcmtlci5waG9uZU51bWJlcil9PC9hPmBcbiAgICAgICAgO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgIH1cbiAgICB9XG59XG5cbjwvc2NyaXB0PlxuXG48c3R5bGUgc2NvcGVkPlxuLnJldGFpbGVyLWljb24ge1xuICAgIGhlaWdodDogNTBweDtcbiAgICB3aWR0aDogYXV0bztcbn1cbjwvc3R5bGU+XG4iLCI8dGVtcGxhdGU+XG4gICAgPGRpdj5cbiAgICAgICAgPGwtbWFwXG4gICAgICAgICAgICA6Y2VudGVyPVwiY2VudGVyXCJcbiAgICAgICAgICAgIDp6b29tPVwiem9vbVwiXG4gICAgICAgICAgICBjbGFzcz1cIm1hcFwiXG4gICAgICAgICAgICByZWY9XCJtYXBcIlxuICAgICAgICA+XG4gICAgICAgICAgICA8bC10aWxlLWxheWVyXG4gICAgICAgICAgICAgICAgOnVybD1cInVybFwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICA8L2wtdGlsZS1sYXllcj5cblxuICAgICAgICAgICAgPE1hcmtlciB2LWZvcj1cIm1hcmtlciBpbiBtYXJrZXJzXCIgOmtleT1cIm1hcmtlci5pZFwiIDptYXJrZXI9XCJtYXJrZXJcIj48L01hcmtlcj5cbiAgICAgICAgPC9sLW1hcD5cbiAgICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5cbmltcG9ydCB7IExNYXAsIExUaWxlTGF5ZXIgfSBmcm9tICdAdnVlLWxlYWZsZXQvdnVlLWxlYWZsZXQnO1xuaW1wb3J0IE1hcmtlciBmcm9tICcuL1JldGFpbGVyTWFwSWNvbi52dWUnO1xuaW1wb3J0ICdsZWFmbGV0L2Rpc3QvbGVhZmxldC5jc3MnO1xuXG5pbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xuXG5pbXBvcnQgeyBvbkJlZm9yZU1vdW50LCBjb21wdXRlZCwgcmVmLCB3YXRjaCwgaW5qZWN0IH0gZnJvbSAndnVlJztcbmltcG9ydCB7IHVzZVN0b3JlIH0gZnJvbSAndnVleCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBuYW1lOiBcIlRoZU1hcFwiLFxuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgICAgTE1hcCxcbiAgICAgICAgTFRpbGVMYXllcixcbiAgICAgICAgTWFya2VyLFxuICAgIH0sXG4gICAgc2V0dXAocHJvcHMsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZSgpO1xuXG4gICAgICAgIGNvbnN0IHJvdXRlQWpheCA9IGluamVjdCgnYWpheFJvdXRlJyk7XG4gICAgICAgIGNvbnN0IGltYWdlUm91dGUgPSBpbmplY3QoJ2ltYWdlUm91dGUnKTtcbiAgICAgICAgY29uc3QgZGVmYXVsdFZhbHVlcyA9IGluamVjdCAoJ2RlZmF1bHRWYWx1ZXMnKTtcblxuICAgICAgICBjb25zdCB1cmwgPSAnaHR0cHM6Ly90aWxlcy5zdGFkaWFtYXBzLmNvbS90aWxlcy9hbGlkYWRlX3Ntb290aC97en0ve3h9L3t5fXtyfS5wbmcnO1xuICAgICAgICBjb25zdCBjZW50ZXIgPSByZWYoWyBkZWZhdWx0VmFsdWVzLmxhdGl0dWRlLCBkZWZhdWx0VmFsdWVzLmxvbmdpdHVkZSBdKTtcbiAgICAgICAgY29uc3QgbWFya2VycyA9IHJlZihbXSlcblxuICAgICAgICBjb25zdCB6b29tID0gMTQ7XG5cbiAgICAgICAgY29uc3QgcmV0YWlsZXJzID0gY29tcHV0ZWQoICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBzdG9yZS5zdGF0ZS5yZXRhaWxlcnM7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IGNlbnRlckJ5Q2xpY2sgPSBjb21wdXRlZCggKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHN0b3JlLnN0YXRlLmNlbnRlckJ5Q2xpY2tcbiAgICAgICAgfSk7XG5cbiAgICAgICAgd2F0Y2gocmV0YWlsZXJzLCBmdW5jdGlvbiAobmV3VmFsdWUsIG9sZFZhbHVlKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IFtvYmplY3RdID0gbmV3VmFsdWU7XG5cbiAgICAgICAgICAgIGNlbnRlci52YWx1ZSA9IFsgcGFyc2VGbG9hdChvYmplY3QubGF0aXR1ZGUpLCBwYXJzZUZsb2F0KG9iamVjdC5sb25naXR1ZGUpIF07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHdhdGNoKGNlbnRlckJ5Q2xpY2ssIGZ1bmN0aW9uIChuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcblxuICAgICAgICAgICAgY2VudGVyLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG9uQmVmb3JlTW91bnQoIGFzeW5jICgpID0+IHtcblxuICAgICAgICAgICAgY29uc3QgY2VudGVyID0gWyBkZWZhdWx0VmFsdWVzLmxhdGl0dWRlLCBkZWZhdWx0VmFsdWVzLmxvbmdpdHVkZSBdO1xuICAgICAgICAgICAgY29uc3Qgcm91dGVBamF4ID0gaW5qZWN0KCdhamF4Um91dGUnKS5yZXBsYWNlKCcwJywgJycpO1xuICAgICAgICAgICAgY29uc3QgaW1hZ2VSb3V0ZSA9IGluamVjdCgnaW1hZ2VSb3V0ZScpO1xuXG4gICAgICAgICAgICBjb25zdCBvYmplY3RzID0gYXdhaXQgYXhpb3MuZ2V0KHJvdXRlQWpheCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBjb25zdCByZXRhaWxlcnMgPSBvYmplY3RzLmRhdGEuX2VtYmVkZGVkLml0ZW1zO1xuXG4gICAgICAgICAgICBpZiAoIXJldGFpbGVycykgcmV0dXJuO1xuXG4gICAgICAgICAgICBjb25zdCBpbWFnZVVybCA9IGRvY3VtZW50LmxvY2F0aW9uLm9yaWdpbiArICcvJyArIGltYWdlUm91dGU7XG5cbiAgICAgICAgICAgIHJldGFpbGVycy5mb3JFYWNoKChpdGVtKSA9PiB7XG5cbiAgICAgICAgICAgICAgICBsZXQgaW1hZ2VQYXRoID0gaW1hZ2VVcmwgKyBpdGVtLnBhdGg7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5wYXRoID09PSBudWxsIHx8IGl0ZW0ucGF0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGltYWdlUGF0aCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtYXJrZXJzLnZhbHVlLnB1c2goXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpdGVtLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogaXRlbS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWV0OiBpdGVtLnN0cmVldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNpdHk6IGl0ZW0uY2l0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc3Rjb2RlOiBpdGVtLnBvc3Rjb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGhvbmVOdW1iZXI6IGl0ZW0ucGhvbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZTogaW1hZ2VQYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29vcmRpbmF0ZXM6IFsgcGFyc2VGbG9hdChpdGVtLmxhdGl0dWRlKSwgcGFyc2VGbG9hdChpdGVtLmxvbmdpdHVkZSkgXVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25zdCB7Y2lyY2xlTWFya2VyfSA9IGF3YWl0IGltcG9ydChcImxlYWZsZXQvc3JjL0xlYWZsZXRcIik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdG9yZSxcbiAgICAgICAgICAgIHJvdXRlQWpheCxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZXMsXG4gICAgICAgICAgICBpbWFnZVJvdXRlLFxuICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgY2VudGVyLFxuICAgICAgICAgICAgem9vbSxcbiAgICAgICAgICAgIG1hcmtlcnMsXG4gICAgICAgIH1cbiAgICB9XG59XG48L3NjcmlwdD5cblxuPHN0eWxlIHNjb3BlZD5cbmRpdiB7XG4gICAgaGVpZ2h0OiA2MDBweDtcbiAgICB3aWR0aDogMTEyN3B4O1xuICAgIG1hcmdpbjogYXV0bztcblxufVxuXG4ubWFwIHtcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xufVxuPC9zdHlsZT5cbiIsIjx0ZW1wbGF0ZT5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNvbHVtblwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInVpIGJsdWUgZmx1aWQgY2FyZFwiIEBjbGljaz1cInVwZGF0ZUNlbnRlcihyZXRhaWxlci5sYXRpdHVkZSwgcmV0YWlsZXIubG9uZ2l0dWRlKVwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb250ZW50XCI+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJsZWZ0IGZsb2F0ZWQgYXV0aG9yXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8aW1nIGNsYXNzPVwidWkgYXZhdGFyIGltYWdlXCIgOnNyYz1cImltYWdlXCIgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIHt7IHJldGFpbGVyLm5hbWUgfX1cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImV4dHJhIGNvbnRlbnRcIj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1ldGFcIj48aSBjbGFzcz1cIm1hcCBtYXJrZXIgYWx0ZXJuYXRlIGljb25cIj48L2k+e3sgcmV0YWlsZXIuc3RyZWV0IH19LCB7eyByZXRhaWxlci5jaXR5LnRvVXBwZXJDYXNlKCkgfX0ge3sgcmV0YWlsZXIucG9zdGNvZGUgfX08L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1ldGFcIj48aSBjbGFzcz1cInBob25lIGljb25cIj48L2k+e3sgZm9ybWF0UGhvbmVOdW1iZXIocmV0YWlsZXIucGhvbmVOdW1iZXIpIH19PC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IHsgdXNlU3RvcmUgfSBmcm9tICd2dWV4JztcbmltcG9ydCB7IG9uQmVmb3JlTW91bnQsIHJlZiwgaW5qZWN0IH0gZnJvbSBcInZ1ZVwiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgbmFtZTogXCJUaGVSZXRhaWxlclwiLFxuICAgIHByb3BzOiB7XG4gICAgICByZXRhaWxlcjogSlNPTixcbiAgICAgIGltYWdlOiBTdHJpbmcsXG4gICAgfSxcbiAgICBzZXR1cChwcm9wcykge1xuICAgICAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlKCk7XG4gICAgICAgIGNvbnN0IGZvcm1hdFBob25lTnVtYmVyID0gaW5qZWN0KCdmb3JtYXRQaG9uZU51bWJlcicpO1xuXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZUNlbnRlcihsYXRpdHVkZSwgbG9uZ2l0dWRlKSB7XG5cbiAgICAgICAgICAgIHN0b3JlLnN0YXRlLmNlbnRlckJ5Q2xpY2sgPSBbIGxhdGl0dWRlLCBsb25naXR1ZGUgXTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZvcm1hdFBob25lTnVtYmVyLFxuICAgICAgICAgICAgdXBkYXRlQ2VudGVyLFxuICAgICAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgIH1cbiAgICB9XG59XG48L3NjcmlwdD5cblxuPHN0eWxlIHNjb3BlZD5cbjwvc3R5bGU+XG4iLCI8dGVtcGxhdGU+XG4gICAgPGRpdiBjbGFzcz1cInVpIGFjdGlvbiBpbnB1dFwiPlxuICAgICAgICA8aW5wdXQgaWQ9XCJyZXRhaWxlckFkZHJlc3NcIiB0eXBlPVwidGV4dFwiIDpwbGFjZWhvbGRlcj1cInNlYXJjaEZpZWxkVGV4dFwiIHYtbW9kZWw9XCJ1c2VySW5wdXRcIj5cbiAgICAgICAgPGJ1dHRvbiBjbGFzcz1cInVpIGJ1dHRvbiBibHVlXCIgQGNsaWNrPVwic2VhcmNoXCI+e3sgZmluZEJ1dHRvblRleHQgfX08L2J1dHRvbj5cbiAgICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQge3VzZVN0b3JlfSBmcm9tICd2dWV4JztcbmltcG9ydCBheGlvcyBmcm9tICdheGlvcyc7XG5pbXBvcnQge3JlZiwgd2F0Y2gsIHByb3ZpZGUsIGluamVjdH0gZnJvbSAndnVlJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIG5hbWU6IFwiVGhlU2VhcmNoXCIsXG4gICAgc2V0dXAoKSB7XG4gICAgICAgIGNvbnN0IHJvdXRlQWpheCA9IGluamVjdCgnYWpheFJvdXRlJyk7XG4gICAgICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmUoKTtcblxuICAgICAgICBjb25zdCBzZWFyY2hGaWVsZFRleHQgPSBpbmplY3QoJ3NlYXJjaEZpZWxkJyk7XG4gICAgICAgIGNvbnN0IGZpbmRCdXR0b25UZXh0ID0gaW5qZWN0KCdmaW5kQnV0dG9uJyk7XG5cbiAgICAgICAgbGV0IHVzZXJJbnB1dCA9IHJlZihudWxsKTtcbiAgICAgICAgbGV0IHVybFJlcXVlc3QgPSByb3V0ZUFqYXgucmVwbGFjZSgnMCcsIHVzZXJJbnB1dC52YWx1ZSk7XG5cbiAgICAgICAgd2F0Y2godXNlcklucHV0LCBmdW5jdGlvbiAobmV3VmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgICAgICB1cmxSZXF1ZXN0ID0gdXJsUmVxdWVzdC5yZXBsYWNlKG9sZFZhbHVlLCBuZXdWYWx1ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIHNlYXJjaChpbnB1dCkge1xuXG4gICAgICAgICAgICBzdG9yZS5zdGF0ZS5zZWFyY2hSZXN1bHRzTGVuZ3RoID0gMDtcblxuICAgICAgICAgICAgaW5wdXQgPSB1c2VySW5wdXQudmFsdWU7XG5cbiAgICAgICAgICAgIGlmICghaW5wdXQpIHJldHVybjtcblxuICAgICAgICAgICAgY29uc3Qgb2JqZWN0ID0gYXdhaXQgYXhpb3MuZ2V0KHVybFJlcXVlc3QsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYgKCFvYmplY3QuZGF0YS5fZW1iZWRkZWQuaXRlbXMpIHJldHVybjtcblxuICAgICAgICAgICAgc3RvcmUuc3RhdGUuc2VhcmNoUmVzdWx0c0xlbmd0aCA9IG9iamVjdC5kYXRhLl9lbWJlZGRlZC5pdGVtcy5sZW5ndGg7XG5cbiAgICAgICAgICAgIHN0b3JlLnN0YXRlLnJldGFpbGVycyA9IG9iamVjdC5kYXRhLl9lbWJlZGRlZC5pdGVtcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByb3V0ZUFqYXgsXG4gICAgICAgICAgICBzdG9yZSxcbiAgICAgICAgICAgIHNlYXJjaEZpZWxkVGV4dCxcbiAgICAgICAgICAgIGZpbmRCdXR0b25UZXh0LFxuICAgICAgICAgICAgdXNlcklucHV0LFxuICAgICAgICAgICAgdXJsUmVxdWVzdCxcbiAgICAgICAgICAgIHNlYXJjaCxcbiAgICAgICAgfVxuICAgIH1cbn1cbjwvc2NyaXB0PlxuXG48c3R5bGUgc2NvcGVkPlxuXG48L3N0eWxlPlxuIiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQge307IiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQge307IiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQge307IiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQge307IiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQge307IiwibW9kdWxlLmV4cG9ydHM9ZnVuY3Rpb24oZSl7dmFyIHQ9e307ZnVuY3Rpb24gaShuKXtpZih0W25dKXJldHVybiB0W25dLmV4cG9ydHM7dmFyIHI9dFtuXT17aTpuLGw6ITEsZXhwb3J0czp7fX07cmV0dXJuIGVbbl0uY2FsbChyLmV4cG9ydHMscixyLmV4cG9ydHMsaSksci5sPSEwLHIuZXhwb3J0c31yZXR1cm4gaS5tPWUsaS5jPXQsaS5kPWZ1bmN0aW9uKGUsdCxuKXtpLm8oZSx0KXx8T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCx7ZW51bWVyYWJsZTohMCxnZXQ6bn0pfSxpLnI9ZnVuY3Rpb24oZSl7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLnRvU3RyaW5nVGFnJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxTeW1ib2wudG9TdHJpbmdUYWcse3ZhbHVlOlwiTW9kdWxlXCJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KX0saS50PWZ1bmN0aW9uKGUsdCl7aWYoMSZ0JiYoZT1pKGUpKSw4JnQpcmV0dXJuIGU7aWYoNCZ0JiZcIm9iamVjdFwiPT10eXBlb2YgZSYmZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO3ZhciBuPU9iamVjdC5jcmVhdGUobnVsbCk7aWYoaS5yKG4pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOiEwLHZhbHVlOmV9KSwyJnQmJlwic3RyaW5nXCIhPXR5cGVvZiBlKWZvcih2YXIgciBpbiBlKWkuZChuLHIsZnVuY3Rpb24odCl7cmV0dXJuIGVbdF19LmJpbmQobnVsbCxyKSk7cmV0dXJuIG59LGkubj1mdW5jdGlvbihlKXt2YXIgdD1lJiZlLl9fZXNNb2R1bGU/ZnVuY3Rpb24oKXtyZXR1cm4gZS5kZWZhdWx0fTpmdW5jdGlvbigpe3JldHVybiBlfTtyZXR1cm4gaS5kKHQsXCJhXCIsdCksdH0saS5vPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpfSxpLnA9XCIvXCIsaShpLnM9MSl9KFtmdW5jdGlvbihlLHQsaSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbigpe3JldHVybihuPU9iamVjdC5hc3NpZ258fGZ1bmN0aW9uKGUpe2Zvcih2YXIgdCxpPTE7aTxhcmd1bWVudHMubGVuZ3RoO2krKylmb3IodmFyIG4gaW4gdD1hcmd1bWVudHNbaV0pT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbikmJihlW25dPXRbbl0pO3JldHVybiBlfSkuYXBwbHkodGhpcyxhcmd1bWVudHMpfXZhciByPVtcImF0dHJzXCIsXCJwcm9wc1wiLFwiZG9tUHJvcHNcIl0scz1bXCJjbGFzc1wiLFwic3R5bGVcIixcImRpcmVjdGl2ZXNcIl0sbz1bXCJvblwiLFwibmF0aXZlT25cIl0sYT1mdW5jdGlvbihlLHQpe3JldHVybiBmdW5jdGlvbigpe2UmJmUuYXBwbHkodGhpcyxhcmd1bWVudHMpLHQmJnQuYXBwbHkodGhpcyxhcmd1bWVudHMpfX07ZS5leHBvcnRzPWZ1bmN0aW9uKGUpe3JldHVybiBlLnJlZHVjZSgoZnVuY3Rpb24oZSx0KXtmb3IodmFyIGkgaW4gdClpZihlW2ldKWlmKC0xIT09ci5pbmRleE9mKGkpKWVbaV09bih7fSxlW2ldLHRbaV0pO2Vsc2UgaWYoLTEhPT1zLmluZGV4T2YoaSkpe3ZhciBjPWVbaV1pbnN0YW5jZW9mIEFycmF5P2VbaV06W2VbaV1dLGw9dFtpXWluc3RhbmNlb2YgQXJyYXk/dFtpXTpbdFtpXV07ZVtpXT1jLmNvbmNhdChsKX1lbHNlIGlmKC0xIT09by5pbmRleE9mKGkpKWZvcih2YXIgZCBpbiB0W2ldKWlmKGVbaV1bZF0pe3ZhciB1PWVbaV1bZF1pbnN0YW5jZW9mIEFycmF5P2VbaV1bZF06W2VbaV1bZF1dLGg9dFtpXVtkXWluc3RhbmNlb2YgQXJyYXk/dFtpXVtkXTpbdFtpXVtkXV07ZVtpXVtkXT11LmNvbmNhdChoKX1lbHNlIGVbaV1bZF09dFtpXVtkXTtlbHNlIGlmKFwiaG9va1wiPT1pKWZvcih2YXIgcCBpbiB0W2ldKWVbaV1bcF09ZVtpXVtwXT9hKGVbaV1bcF0sdFtpXVtwXSk6dFtpXVtwXTtlbHNlIGVbaV09dFtpXTtlbHNlIGVbaV09dFtpXTtyZXR1cm4gZX0pLHt9KX19LGZ1bmN0aW9uKGUsdCxpKXtcInVzZSBzdHJpY3RcIjtpLnIodCk7dmFyIG49e307aS5yKG4pLGkuZChuLFwiQnJlYWRjcnVtYlwiLChmdW5jdGlvbigpe3JldHVybiBVfSkpLGkuZChuLFwiQnJlYWRjcnVtYkRpdmlkZXJcIiwoZnVuY3Rpb24oKXtyZXR1cm4gTn0pKSxpLmQobixcIkJyZWFkY3J1bWJTZWN0aW9uXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIFJ9KSksaS5kKG4sXCJGb3JtXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIFd9KSksaS5kKG4sXCJGb3JtRmllbGRcIiwoZnVuY3Rpb24oKXtyZXR1cm4gWX0pKSxpLmQobixcIkZvcm1GaWVsZHNcIiwoZnVuY3Rpb24oKXtyZXR1cm4gS30pKSxpLmQobixcIkdyaWRcIiwoZnVuY3Rpb24oKXtyZXR1cm4gWH0pKSxpLmQobixcIkdyaWRDb2x1bW5cIiwoZnVuY3Rpb24oKXtyZXR1cm4gSn0pKSxpLmQobixcIkdyaWRSb3dcIiwoZnVuY3Rpb24oKXtyZXR1cm4gWn0pKSxpLmQobixcIk1lbnVcIiwoZnVuY3Rpb24oKXtyZXR1cm4gcmV9KSksaS5kKG4sXCJNZW51SGVhZGVyXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIHNlfSkpLGkuZChuLFwiTWVudUl0ZW1cIiwoZnVuY3Rpb24oKXtyZXR1cm4gZWV9KSksaS5kKG4sXCJNZW51TWVudVwiLChmdW5jdGlvbigpe3JldHVybiBvZX0pKSxpLmQobixcIk1lc3NhZ2VcIiwoZnVuY3Rpb24oKXtyZXR1cm4gdWV9KSksaS5kKG4sXCJNZXNzYWdlQ29udGVudFwiLChmdW5jdGlvbigpe3JldHVybiBhZX0pKSxpLmQobixcIk1lc3NhZ2VIZWFkZXJcIiwoZnVuY3Rpb24oKXtyZXR1cm4gY2V9KSksaS5kKG4sXCJNZXNzYWdlSXRlbVwiLChmdW5jdGlvbigpe3JldHVybiBsZX0pKSxpLmQobixcIk1lc3NhZ2VMaXN0XCIsKGZ1bmN0aW9uKCl7cmV0dXJuIGRlfSkpLGkuZChuLFwiVGFibGVcIiwoZnVuY3Rpb24oKXtyZXR1cm4gaGV9KSksaS5kKG4sXCJUYWJsZUJvZHlcIiwoZnVuY3Rpb24oKXtyZXR1cm4gcGV9KSksaS5kKG4sXCJUYWJsZUNlbGxcIiwoZnVuY3Rpb24oKXtyZXR1cm4gZmV9KSksaS5kKG4sXCJUYWJsZUZvb3RlclwiLChmdW5jdGlvbigpe3JldHVybiBtZX0pKSxpLmQobixcIlRhYmxlSGVhZGVyXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIGdlfSkpLGkuZChuLFwiVGFibGVIZWFkZXJDZWxsXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIGJlfSkpLGkuZChuLFwiVGFibGVSb3dcIiwoZnVuY3Rpb24oKXtyZXR1cm4geWV9KSk7dmFyIHI9e307aS5yKHIpLGkuZChyLFwiZmxvYXRlZFwiLChmdW5jdGlvbigpe3JldHVybiB2ZX0pKTt2YXIgcz17fTtpLnIocyksaS5kKHMsXCJCdXR0b25cIiwoZnVuY3Rpb24oKXtyZXR1cm4gU2V9KSksaS5kKHMsXCJCdXR0b25Db250ZW50XCIsKGZ1bmN0aW9uKCl7cmV0dXJuIHdlfSkpLGkuZChzLFwiQnV0dG9uR3JvdXBcIiwoZnVuY3Rpb24oKXtyZXR1cm4gQWV9KSksaS5kKHMsXCJCdXR0b25PclwiLChmdW5jdGlvbigpe3JldHVybiBCZX0pKSxpLmQocyxcIkNvbnRhaW5lclwiLChmdW5jdGlvbigpe3JldHVybiBDZX0pKSxpLmQocyxcIkRpdmlkZXJcIiwoZnVuY3Rpb24oKXtyZXR1cm4gamV9KSksaS5kKHMsXCJGbGFnXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIEVlfSkpLGkuZChzLFwiSGVhZGVyXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIFRlfSkpLGkuZChzLFwiSGVhZGVyQ29udGVudFwiLChmdW5jdGlvbigpe3JldHVybiAkZX0pKSxpLmQocyxcIkhlYWRlclN1YmhlYWRlclwiLChmdW5jdGlvbigpe3JldHVybiBMZX0pKSxpLmQocyxcIkljb25cIiwoZnVuY3Rpb24oKXtyZXR1cm4gUX0pKSxpLmQocyxcIkljb25Hcm91cFwiLChmdW5jdGlvbigpe3JldHVybiBrZX0pKSxpLmQocyxcIkltYWdlXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIERlfSkpLGkuZChzLFwiSW1hZ2VHcm91cFwiLChmdW5jdGlvbigpe3JldHVybiBJZX0pKSxpLmQocyxcIklucHV0XCIsKGZ1bmN0aW9uKCl7cmV0dXJuIFJlfSkpLGkuZChzLFwiTGFiZWxcIiwoZnVuY3Rpb24oKXtyZXR1cm4gTmV9KSksaS5kKHMsXCJMYWJlbERldGFpbFwiLChmdW5jdGlvbigpe3JldHVybiBIZX0pKSxpLmQocyxcIkxpc3RcIiwoZnVuY3Rpb24oKXtyZXR1cm4gV2V9KSksaS5kKHMsXCJMaXN0Q29udGVudFwiLChmdW5jdGlvbigpe3JldHVybiBfZX0pKSxpLmQocyxcIkxpc3REZXNjcmlwdGlvblwiLChmdW5jdGlvbigpe3JldHVybiBZZX0pKSxpLmQocyxcIkxpc3RIZWFkZXJcIiwoZnVuY3Rpb24oKXtyZXR1cm4gS2V9KSksaS5kKHMsXCJMaXN0SWNvblwiLChmdW5jdGlvbigpe3JldHVybiBHZX0pKSxpLmQocyxcIkxpc3RJdGVtXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIFVlfSkpLGkuZChzLFwiTGlzdExpc3RcIiwoZnVuY3Rpb24oKXtyZXR1cm4gWGV9KSksaS5kKHMsXCJMb2FkZXJcIiwoZnVuY3Rpb24oKXtyZXR1cm4gSmV9KSksaS5kKHMsXCJSYWlsXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIFplfSkpLGkuZChzLFwiUmV2ZWFsXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIFFlfSkpLGkuZChzLFwiUmV2ZWFsQ29udGVudFwiLChmdW5jdGlvbigpe3JldHVybiBldH0pKSxpLmQocyxcIlNlZ21lbnRcIiwoZnVuY3Rpb24oKXtyZXR1cm4gdHR9KSksaS5kKHMsXCJTZWdtZW50c1wiLChmdW5jdGlvbigpe3JldHVybiBpdH0pKSxpLmQocyxcIlN0ZXBcIiwoZnVuY3Rpb24oKXtyZXR1cm4gb3R9KSksaS5kKHMsXCJTdGVwQ29udGVudFwiLChmdW5jdGlvbigpe3JldHVybiBzdH0pKSxpLmQocyxcIlN0ZXBEZXNjcmlwdGlvblwiLChmdW5jdGlvbigpe3JldHVybiBudH0pKSxpLmQocyxcIlN0ZXBHcm91cFwiLChmdW5jdGlvbigpe3JldHVybiBkdH0pKSxpLmQocyxcIlN0ZXBUaXRsZVwiLChmdW5jdGlvbigpe3JldHVybiBydH0pKTt2YXIgbz17fTtpLnIobyksaS5kKG8sXCJBY2NvcmRpb25cIiwoZnVuY3Rpb24oKXtyZXR1cm4gcHR9KSksaS5kKG8sXCJBY2NvcmRpb25Db250ZW50XCIsKGZ1bmN0aW9uKCl7cmV0dXJuIGJ0fSkpLGkuZChvLFwiQWNjb3JkaW9uVGl0bGVcIiwoZnVuY3Rpb24oKXtyZXR1cm4gU3R9KSksaS5kKG8sXCJDaGVja2JveFwiLChmdW5jdGlvbigpe3JldHVybiB3dH0pKSxpLmQobyxcIkRpbW1lclwiLChmdW5jdGlvbigpe3JldHVybiBBdH0pKSxpLmQobyxcIkRpbW1lckRpbW1hYmxlXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIE90fSkpLGkuZChvLFwiRHJvcGRvd25cIiwoZnVuY3Rpb24oKXtyZXR1cm4gVnR9KSksaS5kKG8sXCJEcm9wZG93bkRpdmlkZXJcIiwoZnVuY3Rpb24oKXtyZXR1cm4gcXR9KSksaS5kKG8sXCJEcm9wZG93bkhlYWRlclwiLChmdW5jdGlvbigpe3JldHVybiBHdH0pKSxpLmQobyxcIkRyb3Bkb3duSXRlbVwiLChmdW5jdGlvbigpe3JldHVybiBDdH0pKSxpLmQobyxcIkRyb3Bkb3duTWVudVwiLChmdW5jdGlvbigpe3JldHVybiBMdH0pKSxpLmQobyxcIkVtYmVkXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIF90fSkpLGkuZChvLFwiTW9kYWxcIiwoZnVuY3Rpb24oKXtyZXR1cm4gUXR9KSksaS5kKG8sXCJNb2RhbEFjdGlvbnNcIiwoZnVuY3Rpb24oKXtyZXR1cm4gZWl9KSksaS5kKG8sXCJNb2RhbENvbnRlbnRcIiwoZnVuY3Rpb24oKXtyZXR1cm4gdGl9KSksaS5kKG8sXCJNb2RhbERlc2NyaXB0aW9uXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIGlpfSkpLGkuZChvLFwiTW9kYWxIZWFkZXJcIiwoZnVuY3Rpb24oKXtyZXR1cm4gbml9KSksaS5kKG8sXCJSYXRpbmdcIiwoZnVuY3Rpb24oKXtyZXR1cm4gYWl9KSksaS5kKG8sXCJTZWFyY2hcIiwoZnVuY3Rpb24oKXtyZXR1cm4gYml9KSksaS5kKG8sXCJTaWRlYmFyXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIHlpfSkpLGkuZChvLFwiU2lkZWJhclB1c2hhYmxlXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIHZpfSkpLGkuZChvLFwiU2lkZWJhclB1c2hlclwiLChmdW5jdGlvbigpe3JldHVybiBTaX0pKSxpLmQobyxcIlBvcHVwXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIEVpfSkpLGkuZChvLFwiUG9wdXBDb250ZW50XCIsKGZ1bmN0aW9uKCl7cmV0dXJuIGppfSkpLGkuZChvLFwiUG9wdXBIZWFkZXJcIiwoZnVuY3Rpb24oKXtyZXR1cm4gQ2l9KSksaS5kKG8sXCJQcm9ncmVzc1wiLChmdW5jdGlvbigpe3JldHVybiBUaX0pKSxpLmQobyxcIlRhYlBhbmVcIiwoZnVuY3Rpb24oKXtyZXR1cm4gTWl9KSksaS5kKG8sXCJUYWJcIiwoZnVuY3Rpb24oKXtyZXR1cm4gSWl9KSk7dmFyIGE9e307aS5yKGEpLGkuZChhLFwiQ2FyZFwiLChmdW5jdGlvbigpe3JldHVybiBGaX0pKSxpLmQoYSxcIkNhcmRDb250ZW50XCIsKGZ1bmN0aW9uKCl7cmV0dXJuIHppfSkpLGkuZChhLFwiQ2FyZERlc2NyaXB0aW9uXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIFJpfSkpLGkuZChhLFwiQ2FyZEdyb3VwXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIE5pfSkpLGkuZChhLFwiQ2FyZEhlYWRlclwiLChmdW5jdGlvbigpe3JldHVybiBIaX0pKSxpLmQoYSxcIkNhcmRNZXRhXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIFZpfSkpLGkuZChhLFwiQ29tbWVudFwiLChmdW5jdGlvbigpe3JldHVybiBxaX0pKSxpLmQoYSxcIkNvbW1lbnRBY3Rpb25cIiwoZnVuY3Rpb24oKXtyZXR1cm4gR2l9KSksaS5kKGEsXCJDb21tZW50QWN0aW9uc1wiLChmdW5jdGlvbigpe3JldHVybiBfaX0pKSxpLmQoYSxcIkNvbW1lbnRBdXRob3JcIiwoZnVuY3Rpb24oKXtyZXR1cm4gVWl9KSksaS5kKGEsXCJDb21tZW50QXZhdGFyXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIFdpfSkpLGkuZChhLFwiQ29tbWVudENvbnRlbnRcIiwoZnVuY3Rpb24oKXtyZXR1cm4gWWl9KSksaS5kKGEsXCJDb21tZW50R3JvdXBcIiwoZnVuY3Rpb24oKXtyZXR1cm4gS2l9KSksaS5kKGEsXCJDb21tZW50TWV0YWRhdGFcIiwoZnVuY3Rpb24oKXtyZXR1cm4gWGl9KSksaS5kKGEsXCJDb21tZW50VGV4dFwiLChmdW5jdGlvbigpe3JldHVybiBKaX0pKSxpLmQoYSxcIkZlZWRcIiwoZnVuY3Rpb24oKXtyZXR1cm4gbm59KSksaS5kKGEsXCJGZWVkQ29udGVudFwiLChmdW5jdGlvbigpe3JldHVybiBybn0pKSxpLmQoYSxcIkZlZWREYXRlXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIHNufSkpLGkuZChhLFwiRmVlZEV2ZW50XCIsKGZ1bmN0aW9uKCl7cmV0dXJuIFppfSkpLGkuZChhLFwiRmVlZEV4dHJhXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIG9ufSkpLGkuZChhLFwiRmVlZExhYmVsXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIGFufSkpLGkuZChhLFwiRmVlZExpa2VcIiwoZnVuY3Rpb24oKXtyZXR1cm4gY259KSksaS5kKGEsXCJGZWVkTWV0YVwiLChmdW5jdGlvbigpe3JldHVybiBsbn0pKSxpLmQoYSxcIkZlZWRTdW1tYXJ5XCIsKGZ1bmN0aW9uKCl7cmV0dXJuIGRufSkpLGkuZChhLFwiRmVlZFVzZXJcIiwoZnVuY3Rpb24oKXtyZXR1cm4gdW59KSksaS5kKGEsXCJJdGVtXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIGhufSkpLGkuZChhLFwiSXRlbUdyb3VwXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIHBufSkpLGkuZChhLFwiSXRlbUNvbnRlbnRcIiwoZnVuY3Rpb24oKXtyZXR1cm4gZm59KSksaS5kKGEsXCJJdGVtSW1hZ2VcIiwoZnVuY3Rpb24oKXtyZXR1cm4gbW59KSksaS5kKGEsXCJJdGVtSGVhZGVyXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIGdufSkpLGkuZChhLFwiSXRlbU1ldGFcIiwoZnVuY3Rpb24oKXtyZXR1cm4gYm59KSksaS5kKGEsXCJJdGVtRGVzY3JpcHRpb25cIiwoZnVuY3Rpb24oKXtyZXR1cm4geW59KSksaS5kKGEsXCJJdGVtRXh0cmFcIiwoZnVuY3Rpb24oKXtyZXR1cm4gdm59KSksaS5kKGEsXCJTdGF0aXN0aWNcIiwoZnVuY3Rpb24oKXtyZXR1cm4gU259KSksaS5kKGEsXCJTdGF0aXN0aWNWYWx1ZVwiLChmdW5jdGlvbigpe3JldHVybiB3bn0pKSxpLmQoYSxcIlN0YXRpc3RpY0xhYmVsXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIEFufSkpLGkuZChhLFwiU3RhdGlzdGljR3JvdXBcIiwoZnVuY3Rpb24oKXtyZXR1cm4gT259KSksaS5kKGEsXCJBZHZlcnRpc2VtZW50XCIsKGZ1bmN0aW9uKCl7cmV0dXJuIHhufSkpO3ZhciBjPWkoMCksbD1pLm4oYyk7ZnVuY3Rpb24gZChlKXtyZXR1cm4oZD1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24oZSl7cmV0dXJuIHR5cGVvZiBlfTpmdW5jdGlvbihlKXtyZXR1cm4gZSYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZlLmNvbnN0cnVjdG9yPT09U3ltYm9sJiZlIT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiBlfSkoZSl9dmFyIHU9XCJvYmplY3RcIj09PShcInVuZGVmaW5lZFwiPT10eXBlb2YgZG9jdW1lbnQ/XCJ1bmRlZmluZWRcIjpkKGRvY3VtZW50KSkmJm51bGwhPT1kb2N1bWVudCxoPVwib2JqZWN0XCI9PT0oXCJ1bmRlZmluZWRcIj09dHlwZW9mIHdpbmRvdz9cInVuZGVmaW5lZFwiOmQod2luZG93KSkmJm51bGwhPT13aW5kb3cmJndpbmRvdy5zZWxmPT09d2luZG93LHA9dSYmaDtmdW5jdGlvbiBmKGUpe3JldHVybihmPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbihlKXtyZXR1cm4gdHlwZW9mIGV9OmZ1bmN0aW9uKGUpe3JldHVybiBlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJmUuY29uc3RydWN0b3I9PT1TeW1ib2wmJmUhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIGV9KShlKX1mdW5jdGlvbiBtKGUpe3JldHVybiBlLm1hdGNoKC9bQS1aXFx4QzAtXFx4RDZcXHhEOC1cXHhERV0/W2EtelxceERGLVxceEY2XFx4RjgtXFx4RkZdK3xbQS1aXFx4QzAtXFx4RDZcXHhEOC1cXHhERV0rKD8hW2EtelxceERGLVxceEY2XFx4RjgtXFx4RkZdKXxcXGQrL2cpfWZ1bmN0aW9uIGcoZSl7cmV0dXJuIGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrZS5zbGljZSgxKX1mdW5jdGlvbiBiKGUpe3JldHVybiBtKGUpLnJlZHVjZSgoZnVuY3Rpb24oZSx0KXt2YXIgaT10LnRvTG93ZXJDYXNlKCk7cmV0dXJuIGUrKGU/ZyhpKTppKX0pLFwiXCIpfWZ1bmN0aW9uIHkoZSl7cmV0dXJuIG0oZSkubWFwKChmdW5jdGlvbihlKXtyZXR1cm4gZS50b0xvd2VyQ2FzZSgpfSkpLmpvaW4oXCItXCIpfWZ1bmN0aW9uIHYoZSl7cmV0dXJuIGUuZmlsdGVyKChmdW5jdGlvbih0LGkpe3JldHVybiBlLmluZGV4T2YodCk9PT1pfSkpfWZ1bmN0aW9uIFMoZSx0KXt2YXIgaT1PYmplY3QuYXNzaWduKHt9LGUpO3JldHVybiBPYmplY3Qua2V5cyh0KS5mb3JFYWNoKChmdW5jdGlvbihlKXt2YXIgbj10W2VdO09iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChpLGUpP1wib2JqZWN0XCI9PT1mKG4pJiZcIm9iamVjdFwiPT09ZihpW2VdKSYmKGlbZV09UyhpW2VdLG4pKTppW2VdPW59KSksaX1mdW5jdGlvbiB3KGUsdCl7dmFyIGk9YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOm51bGw7cmV0dXJuIHQuc3BsaXQoXCIuXCIpLnJlZHVjZSgoZnVuY3Rpb24oZSx0KXtyZXR1cm4gZSYmT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCk/ZVt0XTppfSksZSl9ZnVuY3Rpb24gQShlLHQpe3ZhciBpPU9iamVjdC5rZXlzKGUpO2lmKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpe3ZhciBuPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7dCYmKG49bi5maWx0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsdCkuZW51bWVyYWJsZX0pKSksaS5wdXNoLmFwcGx5KGksbil9cmV0dXJuIGl9ZnVuY3Rpb24gTyhlLHQsaSl7cmV0dXJuIHQgaW4gZT9PYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHt2YWx1ZTppLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6ZVt0XT1pLGV9ZnVuY3Rpb24geChlLHQpe3JldHVybiBmdW5jdGlvbihlKXtpZihBcnJheS5pc0FycmF5KGUpKXJldHVybiBlfShlKXx8ZnVuY3Rpb24oZSx0KXtpZighKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoZSl8fFwiW29iamVjdCBBcmd1bWVudHNdXCI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSkpKXJldHVybjt2YXIgaT1bXSxuPSEwLHI9ITEscz12b2lkIDA7dHJ5e2Zvcih2YXIgbyxhPWVbU3ltYm9sLml0ZXJhdG9yXSgpOyEobj0obz1hLm5leHQoKSkuZG9uZSkmJihpLnB1c2goby52YWx1ZSksIXR8fGkubGVuZ3RoIT09dCk7bj0hMCk7fWNhdGNoKGUpe3I9ITAscz1lfWZpbmFsbHl7dHJ5e258fG51bGw9PWEucmV0dXJufHxhLnJldHVybigpfWZpbmFsbHl7aWYocil0aHJvdyBzfX1yZXR1cm4gaX0oZSx0KXx8ZnVuY3Rpb24oKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKX0oKX1mdW5jdGlvbiBQKGUpe3JldHVybihQPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbihlKXtyZXR1cm4gdHlwZW9mIGV9OmZ1bmN0aW9uKGUpe3JldHVybiBlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJmUuY29uc3RydWN0b3I9PT1TeW1ib2wmJmUhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIGV9KShlKX1mdW5jdGlvbiBCKGUsdCl7cmV0dXJuIGZ1bmN0aW9uKGUpe2lmKEFycmF5LmlzQXJyYXkoZSkpcmV0dXJuIGV9KGUpfHxmdW5jdGlvbihlLHQpe2lmKCEoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChlKXx8XCJbb2JqZWN0IEFyZ3VtZW50c11cIj09PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlKSkpcmV0dXJuO3ZhciBpPVtdLG49ITAscj0hMSxzPXZvaWQgMDt0cnl7Zm9yKHZhciBvLGE9ZVtTeW1ib2wuaXRlcmF0b3JdKCk7IShuPShvPWEubmV4dCgpKS5kb25lKSYmKGkucHVzaChvLnZhbHVlKSwhdHx8aS5sZW5ndGghPT10KTtuPSEwKTt9Y2F0Y2goZSl7cj0hMCxzPWV9ZmluYWxseXt0cnl7bnx8bnVsbD09YS5yZXR1cm58fGEucmV0dXJuKCl9ZmluYWxseXtpZihyKXRocm93IHN9fXJldHVybiBpfShlLHQpfHxmdW5jdGlvbigpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpfSgpfWZ1bmN0aW9uIEMoZSx0KXt2YXIgaT1PYmplY3Qua2V5cyhlKTtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgbj1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO3QmJihuPW4uZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLHQpLmVudW1lcmFibGV9KSkpLGkucHVzaC5hcHBseShpLG4pfXJldHVybiBpfWZ1bmN0aW9uIGooZSx0LGkpe3JldHVybiB0IGluIGU/T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCx7dmFsdWU6aSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOmVbdF09aSxlfWZ1bmN0aW9uIEUoZSx0KXtyZXR1cm4gZnVuY3Rpb24oZSl7aWYoQXJyYXkuaXNBcnJheShlKSlyZXR1cm4gZX0oZSl8fGZ1bmN0aW9uKGUsdCl7aWYoIShTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGUpfHxcIltvYmplY3QgQXJndW1lbnRzXVwiPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpKSlyZXR1cm47dmFyIGk9W10sbj0hMCxyPSExLHM9dm9pZCAwO3RyeXtmb3IodmFyIG8sYT1lW1N5bWJvbC5pdGVyYXRvcl0oKTshKG49KG89YS5uZXh0KCkpLmRvbmUpJiYoaS5wdXNoKG8udmFsdWUpLCF0fHxpLmxlbmd0aCE9PXQpO249ITApO31jYXRjaChlKXtyPSEwLHM9ZX1maW5hbGx5e3RyeXtufHxudWxsPT1hLnJldHVybnx8YS5yZXR1cm4oKX1maW5hbGx5e2lmKHIpdGhyb3cgc319cmV0dXJuIGl9KGUsdCl8fGZ1bmN0aW9uKCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIil9KCl9dmFyIFQ9W1wib25lXCIsXCJ0d29cIixcInRocmVlXCIsXCJmb3VyXCIsXCJmaXZlXCIsXCJzaXhcIixcInNldmVuXCIsXCJlaWdodFwiLFwibmluZVwiLFwidGVuXCIsXCJlbGV2ZW5cIixcInR3ZWx2ZVwiLFwidGhpcnRlZW5cIixcImZvdXJ0ZWVuXCIsXCJmaWZ0ZWVuXCIsXCJzaXh0ZWVuXCJdO3ZhciAkPXtuYW1lOlwiQVBJXCIsbmFtZXNwYWNlOlwiYXBpXCIsZGVidWc6ITEsdmVyYm9zZTohMSxwZXJmb3JtYW5jZTohMCxhcGk6e30sY2FjaGU6ITAsaW50ZXJydXB0UmVxdWVzdHM6ITAsb246XCJhdXRvXCIsc3RhdGVDb250ZXh0OiExLGxvYWRpbmdEdXJhdGlvbjowLGhpZGVFcnJvcjpcImF1dG9cIixlcnJvckR1cmF0aW9uOjJlMyxlbmNvZGVQYXJhbWV0ZXJzOiEwLGFjdGlvbjohMSx1cmw6ITEsYmFzZTpcIlwiLHVybERhdGE6e30sZGVmYXVsdERhdGE6ITAsc2VyaWFsaXplRm9ybTohMSx0aHJvdHRsZTowLHRocm90dGxlRmlyc3RSZXF1ZXN0OiEwLG1ldGhvZDpcImdldFwiLGRhdGE6e30sZGF0YVR5cGU6XCJqc29uXCIsbW9ja1Jlc3BvbnNlOiExLG1vY2tSZXNwb25zZUFzeW5jOiExLHJlc3BvbnNlOiExLHJlc3BvbnNlQXN5bmM6ITEsYmVmb3JlU2VuZDpmdW5jdGlvbihlKXtyZXR1cm4gZX0sYmVmb3JlWEhSOmZ1bmN0aW9uKGUpe30sb25SZXF1ZXN0OmZ1bmN0aW9uKGUsdCl7fSxvblJlc3BvbnNlOiExLG9uU3VjY2VzczpmdW5jdGlvbihlLHQpe30sb25Db21wbGV0ZTpmdW5jdGlvbihlLHQpe30sb25GYWlsdXJlOmZ1bmN0aW9uKGUsdCl7fSxvbkVycm9yOmZ1bmN0aW9uKGUsdCl7fSxvbkFib3J0OmZ1bmN0aW9uKGUsdCl7fSxzdWNjZXNzVGVzdDohMSxlcnJvcjp7YmVmb3JlU2VuZDpcIlRoZSBiZWZvcmUgc2VuZCBmdW5jdGlvbiBoYXMgYWJvcnRlZCB0aGUgcmVxdWVzdFwiLGVycm9yOlwiVGhlcmUgd2FzIGFuIGVycm9yIHdpdGggeW91ciByZXF1ZXN0XCIsZXhpdENvbmRpdGlvbnM6XCJBUEkgUmVxdWVzdCBBYm9ydGVkLiBFeGl0IGNvbmRpdGlvbnMgbWV0XCIsSlNPTlBhcnNlOlwiSlNPTiBjb3VsZCBub3QgYmUgcGFyc2VkIGR1cmluZyBlcnJvciBoYW5kbGluZ1wiLGxlZ2FjeVBhcmFtZXRlcnM6XCJZb3UgYXJlIHVzaW5nIGxlZ2FjeSBBUEkgc3VjY2VzcyBjYWxsYmFjayBuYW1lc1wiLG1ldGhvZDpcIlRoZSBtZXRob2QgeW91IGNhbGxlZCBpcyBub3QgZGVmaW5lZFwiLG1pc3NpbmdBY3Rpb246XCJBUEkgYWN0aW9uIHVzZWQgYnV0IG5vIHVybCB3YXMgZGVmaW5lZFwiLG1pc3NpbmdTZXJpYWxpemU6XCJqcXVlcnktc2VyaWFsaXplLW9iamVjdCBpcyByZXF1aXJlZCB0byBhZGQgZm9ybSBkYXRhIHRvIGFuIGV4aXN0aW5nIGRhdGEgb2JqZWN0XCIsbWlzc2luZ1VSTDpcIk5vIFVSTCBzcGVjaWZpZWQgZm9yIGFwaSBldmVudFwiLG5vUmV0dXJuZWRWYWx1ZTpcIlRoZSBiZWZvcmVTZW5kIGNhbGxiYWNrIG11c3QgcmV0dXJuIGEgc2V0dGluZ3Mgb2JqZWN0LCBiZWZvcmVTZW5kIGlnbm9yZWQuXCIsbm9TdG9yYWdlOlwiQ2FjaGluZyByZXNwb25zZXMgbG9jYWxseSByZXF1aXJlcyBzZXNzaW9uIHN0b3JhZ2VcIixwYXJzZUVycm9yOlwiVGhlcmUgd2FzIGFuIGVycm9yIHBhcnNpbmcgeW91ciByZXF1ZXN0XCIscmVxdWlyZWRQYXJhbWV0ZXI6XCJNaXNzaW5nIGEgcmVxdWlyZWQgVVJMIHBhcmFtZXRlcjogXCIsc3RhdHVzTWVzc2FnZTpcIlNlcnZlciBnYXZlIGFuIGVycm9yOiBcIix0aW1lb3V0OlwiWW91ciByZXF1ZXN0IHRpbWVkIG91dFwifSxyZWdFeHA6e3JlcXVpcmVkOi9cXHtcXCQqW0EtejAtOV0rXFx9L2csb3B0aW9uYWw6L1xce1xcL1xcJCpbQS16MC05XStcXH0vZ30sY2xhc3NOYW1lOntsb2FkaW5nOlwibG9hZGluZ1wiLGVycm9yOlwiZXJyb3JcIn0sc2VsZWN0b3I6e2Rpc2FibGVkOlwiLmRpc2FibGVkXCIsZm9ybTpcImZvcm1cIn0sbWV0YWRhdGE6e2FjdGlvbjpcImFjdGlvblwiLHVybDpcInVybFwifX0sTD17aW5qZWN0Ontfc3VpOntmcm9tOlwic3VpXCIsZGVmYXVsdDpmdW5jdGlvbigpe3JldHVybnthcGk6e319fX19LHByb3BzOntzdWk6e3R5cGU6T2JqZWN0LGRlZmF1bHQ6ZnVuY3Rpb24oKXtyZXR1cm57YXBpOlModGhpcy5fc3VpP3RoaXMuX3N1aS5hcGk6e30sJCl9fX19LG1ldGhvZHM6e251bTpmdW5jdGlvbihlKXtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgZT9UW2UtMV06ZX0sY2xhc3NlczpmdW5jdGlvbigpe2Zvcih2YXIgZT1hcmd1bWVudHMubGVuZ3RoLHQ9bmV3IEFycmF5KGUpLGk9MDtpPGU7aSsrKXRbaV09YXJndW1lbnRzW2ldO3JldHVybiB0LmZpbHRlcigoZnVuY3Rpb24oZSl7cmV0dXJuIGUmJiEwIT09ZX0pKS5qb2luKFwiIFwiKX0sZ2V0RW5kcG9pbnQ6ZnVuY3Rpb24oZSx0KXt2YXIgaT13KHRoaXMuc3VpLFwiYXBpLmFwaS5cIi5jb25jYXQoZSkpO2lmKCFpKXRocm93IG5ldyBFcnJvcihcIkFjdGlvbiAnXCIuY29uY2F0KGUsXCInIG5vdCBwcm92aWRlZFwiKSk7dmFyIG49dyh0aGlzLnN1aSxcImFwaS5iYXNlXCIsXCJcIikscj1cIlwiLmNvbmNhdChuKS5jb25jYXQoaSk7cmV0dXJuIE9iamVjdC5rZXlzKHQpLnJlZHVjZSgoZnVuY3Rpb24oZSxpKXtyZXR1cm4gZS5yZXBsYWNlKFwie1wiLmNvbmNhdChpLFwifVwiKSx0W2ldKX0pLHIpfSxleGVjdXRlQWN0aW9uOmZ1bmN0aW9uKGUsdCl7dmFyIGksbixyPShpPXRoaXMuc3VpLmFwaS5tZXRob2Qsbj1lLG5ldyBQcm9taXNlKChmdW5jdGlvbihlLHQpe3ZhciByPW5ldyBYTUxIdHRwUmVxdWVzdDtyLm9wZW4oaSxuLCEwKSxyLm9ucmVhZHlzdGF0ZWNoYW5nZT1mdW5jdGlvbigpezQ9PT10aGlzLnJlYWR5U3RhdGUmJih0aGlzLnN0YXR1cz49MjAwJiZ0aGlzLnN0YXR1czw0MDA/ZShKU09OLnBhcnNlKHRoaXMucmVzcG9uc2VUZXh0KSk6dCh0aGlzLnJlc3BvbnNlKSl9LHIuc2VuZCgpfSkpKTtyZXR1cm4gdGhpcy5zdWkuYXBpLm9uUmVzcG9uc2UmJihyPXIudGhlbih0aGlzLnN1aS5hcGkub25SZXNwb25zZSkpLHJ9LGdldEVsZW1lbnRUeXBlOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOlwiZGl2XCIsdD10aGlzLiR2bm9kZSYmdGhpcy4kdm5vZGUuZGF0YS50YWc7aWYoIXR8fFwiY29tcG9uZW50XCI9PT10KXJldHVybiBlO3ZhciBpPXRoaXMuJHZub2RlLmNvbnRleHQsbj1PYmplY3QuZW50cmllcyhpLiRvcHRpb25zLmNvbXBvbmVudHN8fHt9KS5maW5kKChmdW5jdGlvbihlKXtyZXR1cm4geShFKGUsMSlbMF0pPT09dH0pKTtyZXR1cm4gbj9uWzFdOnR9LGdldENoaWxkUHJvcHM6ZnVuY3Rpb24oKXtpZighdGhpcy4kdm5vZGV8fCF0aGlzLiR2bm9kZS5kYXRhLmF0dHJzKXJldHVybnt9O3ZhciBlLHQ9dGhpcy5nZXRFbGVtZW50VHlwZSgpO2lmKFwic3RyaW5nXCI9PXR5cGVvZiB0KXt2YXIgaSxuPXRoaXMuJG9wdGlvbnMuY29tcG9uZW50cyxyPW5bdF18fG5baT1iKHQpXXx8bltnKGkpXTtpZighcilyZXR1cm57fTtlPXIub3B0aW9ucy5wcm9wc31lbHNle2lmKFwib2JqZWN0XCIhPT1QKHQpKXJldHVybnt9O2U9dC5wcm9wc31yZXR1cm4gT2JqZWN0LmVudHJpZXModGhpcy4kdm5vZGUuZGF0YS5hdHRycykuZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4gYih4KHQsMSlbMF0paW4gZX0pKS5tYXAoKGZ1bmN0aW9uKHQpe3ZhciBpPXgodCwyKSxuPWlbMF0scj1pWzFdLHM9YihuKTtyZXR1cm4gZVtzXS50eXBlPT09Qm9vbGVhbj8hMT09PXI/W3MsITFdOltzLCEwXTpbcyxyXX0pKS5yZWR1Y2UoKGZ1bmN0aW9uKGUsdCl7dmFyIGk9eCh0LDIpO3JldHVybiBmdW5jdGlvbihlKXtmb3IodmFyIHQ9MTt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKXt2YXIgaT1udWxsIT1hcmd1bWVudHNbdF0/YXJndW1lbnRzW3RdOnt9O3QlMj9BKE9iamVjdChpKSwhMCkuZm9yRWFjaCgoZnVuY3Rpb24odCl7TyhlLHQsaVt0XSl9KSk6T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM/T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhpKSk6QShPYmplY3QoaSkpLmZvckVhY2goKGZ1bmN0aW9uKHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihpLHQpKX0pKX1yZXR1cm4gZX0oe30sZSxPKHt9LGlbMF0saVsxXSkpfSkse30pfSxnZXRDaGlsZExpc3RlbmVyczpmdW5jdGlvbigpe3ZhciBlPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD0xO3Q8YXJndW1lbnRzLmxlbmd0aDt0Kyspe3ZhciBpPW51bGwhPWFyZ3VtZW50c1t0XT9hcmd1bWVudHNbdF06e307dCUyP0MoT2JqZWN0KGkpLCEwKS5mb3JFYWNoKChmdW5jdGlvbih0KXtqKGUsdCxpW3RdKX0pKTpPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycz9PYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKGkpKTpDKE9iamVjdChpKSkuZm9yRWFjaCgoZnVuY3Rpb24odCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGksdCkpfSkpfXJldHVybiBlfSh7fSx0aGlzLiRsaXN0ZW5lcnMpO3JldHVybiBPYmplY3QuZW50cmllcyh0aGlzLiRvcHRpb25zLmV2ZW50c3x8e30pLmZvckVhY2goKGZ1bmN0aW9uKHQpe3ZhciBpPUIodCwyKSxuPWlbMF07aVsxXS5jdXN0b20mJmRlbGV0ZSBlW25dfSkpLGV9LGdldENoaWxkUHJvcHNBbmRMaXN0ZW5lcnM6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLmdldENoaWxkUHJvcHMoKTtyZXR1cm57cHJvcHM6ZSxhdHRyczplLG9uOnRoaXMuZ2V0Q2hpbGRMaXN0ZW5lcnMoKX19fX0saz17bWV0aG9kczp7Z2V0VUlDbGFzczpmdW5jdGlvbigpe3ZhciBlPXRoaXMuY29uc3RydWN0b3Iub3B0aW9ucyYmdGhpcy5jb25zdHJ1Y3Rvci5vcHRpb25zLm5hbWUsdD10aGlzLiRwYXJlbnQmJnRoaXMuJHBhcmVudC5jb25zdHJ1Y3Rvci5vcHRpb25zJiZ0aGlzLiRwYXJlbnQuY29uc3RydWN0b3Iub3B0aW9ucy5uYW1lO3JldHVybiBlJiZ0JiZ0Lm1hdGNoKG5ldyBSZWdFeHAoXCJeXCIuY29uY2F0KGUsXCIuKkdyb3VwJFwiKSkpP1wiXCI6XCJ1aVwifSxnZXRQYXJlbnROYW1lOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuJHBhcmVudCYmdGhpcy4kcGFyZW50LmNvbnN0cnVjdG9yLm9wdGlvbnMmJnRoaXMuJHBhcmVudC5jb25zdHJ1Y3Rvci5vcHRpb25zLm5hbWV8fFwiXCJ9fX0sRD1mdW5jdGlvbigpe3JldHVybiB3aW5kb3cmJndpbmRvdy53ZWJraXRBbmltYXRpb25FbmQ/XCJ3ZWJraXRBbmltYXRpb25FbmRcIjpcImFuaW1hdGlvbmVuZFwifTtmdW5jdGlvbiBJKGUpe3JldHVybiBlJiYoXCJqdXN0aWZ5XCI9PT1lP1wianVzdGlmaWVkXCI6XCJcIi5jb25jYXQoZSxcIiBhbGlnbmVkXCIpKX1mdW5jdGlvbiBNKGUpe3JldHVybiBlJiZcIlwiLmNvbmNhdChlLFwiIGZsaXBwZWRcIil9ZnVuY3Rpb24gRihlKXtyZXR1cm4gZSYmXCJcIi5jb25jYXQoZSxcIiByb3RhdGVkXCIpfWZ1bmN0aW9uIHooZSl7cmV0dXJuIGUmJlwiXCIuY29uY2F0KGUsXCIgY29ybmVyXCIpfXZhciBSPXtuYW1lOlwiU3VpQnJlYWRjcnVtYlNlY3Rpb25cIixtaXhpbnM6W0xdLHByb3BzOnthY3RpdmU6Qm9vbGVhbixsaW5rOkJvb2xlYW59LHJlbmRlcjpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50c1swXSx0PXRoaXMuZ2V0RWxlbWVudFR5cGUodGhpcy5saW5rP1wiYVwiOlwiZGl2XCIpO3JldHVybiBlKHQsbCgpKFt7fSx0aGlzLmdldENoaWxkUHJvcHNBbmRMaXN0ZW5lcnMoKSx7Y2xhc3M6dGhpcy5jbGFzc2VzKHRoaXMuYWN0aXZlJiZcImFjdGl2ZVwiLHRoaXMubGluayYmXCJsaW5rXCIsXCJzZWN0aW9uXCIpfV0pLFt0aGlzLiRzbG90cy5kZWZhdWx0XSl9LG1ldGE6e3BhcmVudDpcIlN1aUJyZWFkY3J1bWJcIn19LE49e25hbWU6XCJTdWlCcmVhZGNydW1iRGl2aWRlclwiLG1peGluczpbTF0scHJvcHM6e2ljb246U3RyaW5nfSxyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHNbMF0sdD10aGlzLmdldEVsZW1lbnRUeXBlKHRoaXMuaWNvbj9cImlcIjpcImRpdlwiKTtyZXR1cm4gZSh0LGwoKShbe30sdGhpcy5nZXRDaGlsZFByb3BzQW5kTGlzdGVuZXJzKCkse2NsYXNzOnRoaXMuY2xhc3Nlcyh0aGlzLmljb24sdGhpcy5pY29uJiZcImljb25cIixcImRpdmlkZXJcIil9XSksWyF0aGlzLmljb24mJih0aGlzLiRzbG90cy5kZWZhdWx0fHxcIi9cIildKX0sbWV0YTp7cGFyZW50OlwiU3VpQnJlYWRjcnVtYlwifX07ZnVuY3Rpb24gSChlLHQpe3ZhciBpPU9iamVjdC5rZXlzKGUpO2lmKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpe3ZhciBuPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7dCYmKG49bi5maWx0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsdCkuZW51bWVyYWJsZX0pKSksaS5wdXNoLmFwcGx5KGksbil9cmV0dXJuIGl9ZnVuY3Rpb24gVihlKXtmb3IodmFyIHQ9MTt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKXt2YXIgaT1udWxsIT1hcmd1bWVudHNbdF0/YXJndW1lbnRzW3RdOnt9O3QlMj9IKE9iamVjdChpKSwhMCkuZm9yRWFjaCgoZnVuY3Rpb24odCl7cShlLHQsaVt0XSl9KSk6T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM/T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhpKSk6SChPYmplY3QoaSkpLmZvckVhY2goKGZ1bmN0aW9uKHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihpLHQpKX0pKX1yZXR1cm4gZX1mdW5jdGlvbiBxKGUsdCxpKXtyZXR1cm4gdCBpbiBlP09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQse3ZhbHVlOmksZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTplW3RdPWksZX1mdW5jdGlvbiBHKGUpe3JldHVybiBmdW5jdGlvbihlKXtpZihBcnJheS5pc0FycmF5KGUpKXtmb3IodmFyIHQ9MCxpPW5ldyBBcnJheShlLmxlbmd0aCk7dDxlLmxlbmd0aDt0KyspaVt0XT1lW3RdO3JldHVybiBpfX0oZSl8fGZ1bmN0aW9uKGUpe2lmKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoZSl8fFwiW29iamVjdCBBcmd1bWVudHNdXCI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSkpcmV0dXJuIEFycmF5LmZyb20oZSl9KGUpfHxmdW5jdGlvbigpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKX0oKX1mdW5jdGlvbiBfKCl7dmFyIGUsdD1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06W10saT1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06e30sbj1HKHQpO0FycmF5LmlzQXJyYXkoaS5jaG9pY2VzKSYmbi5wdXNoLmFwcGx5KG4sRyhpLmNob2ljZXMpKTt2YXIgcj12KHQubWFwKChmdW5jdGlvbihlKXtyZXR1cm4gZS5jb25zdHJ1Y3Rvcn0pKSk7cmV0dXJuIGkudHlwZT9BcnJheS5pc0FycmF5KGkudHlwZSk/KGkudHlwZS5pbmNsdWRlcyhCb29sZWFuKSYmbi51bnNoaWZ0KCEwKSxlPXYoW10uY29uY2F0KEcoaS50eXBlKSxHKHIpKSkpOihpLnR5cGU9PT1Cb29sZWFuJiZuLnVuc2hpZnQoITApLGU9dihbaS50eXBlXS5jb25jYXQoRyhyKSkpKTplPTE9PT1yLmxlbmd0aD9yWzBdOnIsVih7fSxpLHtjaG9pY2VzOm4sdHlwZTplLHZhbGlkYXRvcjpmdW5jdGlvbihlKXtyZXR1cm4hci5pbmNsdWRlcyhlLmNvbnN0cnVjdG9yKXx8bi5pbmNsdWRlcyhlKX19KX1PYmplY3QuZGVmaW5lUHJvcGVydHkoXyxcIkV4dGVuZFwiLHt2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e307cmV0dXJuIF8oZSx0KX19fSksXy5TdGF0ZT1fLkV4dGVuZChbXCJhY3RpdmVcIixcImRpc2FibGVkXCIsXCJlcnJvclwiLFwid2FybmluZ1wiLFwic3VjY2Vzc1wiXSksXy5TaXplPV8uRXh0ZW5kKFtcIm1pbmlcIixcInRpbnlcIixcInNtYWxsXCIsXCJzdGFuZGFyZFwiLFwibWVkaXVtXCIsXCJsYXJnZVwiLFwiYmlnXCIsXCJodWdlXCIsXCJtYXNzaXZlXCJdKSxfLkNvbG9yPV8uRXh0ZW5kKFtcInJlZFwiLFwib3JhbmdlXCIsXCJ5ZWxsb3dcIixcIm9saXZlXCIsXCJncmVlblwiLFwidGVhbFwiLFwiYmx1ZVwiLFwidmlvbGV0XCIsXCJwdXJwbGVcIixcInBpbmtcIixcImJyb3duXCIsXCJncmV5XCIsXCJibGFja1wiXSksXy5BdHRhY2hlZD1fLkV4dGVuZChbXCJ0b3BcIixcImJvdHRvbVwiXSksXy5UZXh0QWxpZ249Xy5FeHRlbmQoW1wibGVmdFwiLFwicmlnaHRcIixcImNlbnRlclwiLFwianVzdGlmaWVkXCJdKSxfLlZlcnRpY2FsQWxpZ249Xy5FeHRlbmQoW1widG9wXCIsXCJtaWRkbGVcIixcImJvdHRvbVwiXSksXy5Tb2NpYWw9Xy5FeHRlbmQoW1wiZmFjZWJvb2tcIixcInR3aXR0ZXJcIixcImdvb2dsZVwiLFwiZ29vZ2xlIHBsdXNcIixcInZrXCIsXCJpbnN0YWdyYW1cIixcImxpbmtlZGluXCIsXCJ5b3V0dWJlXCJdKSxfLk51bWJlcj1fLkV4dGVuZChbMSwyLDMsNCw1LDYsNyw4LDksMTAsMTEsMTIsMTMsMTQsMTUsMTYsXCJvbmVcIixcInR3b1wiLFwidGhyZWVcIixcImZvdXJcIixcImZpdmVcIixcInNpeFwiLFwic2V2ZW5cIixcImVpZ2h0XCIsXCJuaW5lXCIsXCJ0ZW5cIixcImVsZXZlblwiLFwidHdlbHZlXCIsXCJ0aGlydGVlblwiLFwiZm91cnRlZW5cIixcImZpZnRlZW5cIixcInNpeHRlZW5cIl0pLF8uUGFkZGVkPV8uRXh0ZW5kKFtcInZlcnlcIl0pLF8uRW1waGFzaXM9Xy5FeHRlbmQoW1wic2Vjb25kYXJ5XCIsXCJ0ZXJ0aWFyeVwiXSksXy5GbG9hdGVkPV8uRXh0ZW5kKFtcInJpZ2h0XCIsXCJsZWZ0XCJdKSxfLkRpcmVjdGlvbj1fLkV4dGVuZChbXCJob3Jpem9udGFsbHlcIixcInZlcnRpY2FsbHlcIl0pLF8uUm90YXRlRGlyZWN0aW9uPV8uRXh0ZW5kKFtcImNsb2Nrd2lzZVwiLFwiY291bnRlcmNsb2Nrd2lzZVwiXSksXy5Db3JuZXI9Xy5FeHRlbmQoW1widG9wIGxlZnRcIixcInRvcCByaWdodFwiLFwiYm90dG9tIGxlZnRcIixcImJvdHRvbSByaWdodFwiXSk7dmFyIFU9e25hbWU6XCJTdWlCcmVhZGNydW1iXCIsY29tcG9uZW50czp7U3VpQnJlYWRjcnVtYkRpdmlkZXI6TixTdWlCcmVhZGNydW1iU2VjdGlvbjpSfSxtaXhpbnM6W0xdLHByb3BzOntpY29uOlN0cmluZyxzZWN0aW9uczpBcnJheSxzaXplOl8uU2l6ZSgpfSxyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLHQ9YXJndW1lbnRzWzBdLGk9dGhpcy5nZXRFbGVtZW50VHlwZSgpO3JldHVybiB0KGksbCgpKFt7fSx0aGlzLmdldENoaWxkUHJvcHNBbmRMaXN0ZW5lcnMoKSx7Y2xhc3M6dGhpcy5jbGFzc2VzKFwidWlcIix0aGlzLnNpemUsXCJicmVhZGNydW1iXCIpfV0pLFt0aGlzLiRzbG90cy5kZWZhdWx0fHx0aGlzLnNlY3Rpb25zLm1hcCgoZnVuY3Rpb24oaSxuKXt2YXIgcj1pLmFjdGl2ZSxzPWkuY29udGVudCxvPWkua2V5LGE9aS5saW5rLGM9dChSLHtrZXk6byxhdHRyczp7YWN0aXZlOnIsbGluazphfX0sW3NdKTtyZXR1cm4gMD09PW4/YzpbXCIgXCIsdChOLHthdHRyczp7aWNvbjplLmljb259fSksXCIgXCIsY119KSldKX19LFc9e25hbWU6XCJTdWlGb3JtXCIsbWl4aW5zOltMXSxwcm9wczp7c2l6ZTpfLlNpemUoe2Rlc2NyaXB0aW9uOlwiQSBmb3JtIGNhbiB2YXJ5IGluIHNpemUuXCJ9KSxsb2FkaW5nOnt0eXBlOkJvb2xlYW4sZGVzY3JpcHRpb246XCJJZiBhIGZvcm0gaXMgaW4gbG9hZGluZyBzdGF0ZSwgaXQgd2lsbCBhdXRvbWF0aWNhbGx5IHNob3cgYSBsb2FkaW5nIGluZGljYXRvci5cIn0sc3VjY2Vzczp7dHlwZTpCb29sZWFuLGRlc2NyaXB0aW9uOlwiQXV0b21hdGljYWxseSBzaG93IGFueSBzdWNjZXNzIE1lc3NhZ2UgY2hpbGRyZW4uXCJ9LHdhcm5pbmc6e3R5cGU6Qm9vbGVhbixkZXNjcmlwdGlvbjpcIkF1dG9tYXRpY2FsbHkgc2hvdyBhbnkgd2FybmluZyBNZXNzYWdlIGNoaWxkcmVuLlwifSxlcnJvcjp7dHlwZTpCb29sZWFuLGRlc2NyaXB0aW9uOlwiQXV0b21hdGljYWxseSBzaG93IGFueSBlcnJvciBNZXNzYWdlIGNoaWxkcmVuLlwifSxzdGF0ZTpfKFtcInN1Y2Nlc3NcIixcIndhcm5pbmdcIixcImVycm9yXCIsXCJsb2FkaW5nXCJdLHtkZXNjcmlwdGlvbjpcIllvdSBjYW4gc2V0IHRoZSBzdGF0ZSBvZiBmb3JtIHVzaW5nIG9uZSB2YXJpYWJsZVwifSksaW52ZXJ0ZWQ6e3R5cGU6Qm9vbGVhbixkZXNjcmlwdGlvbjpcIkEgZm9ybSBjYW4gaGF2ZSBpdHMgY29sb3IgaW52ZXJ0ZWQgZm9yIGNvbnRyYXN0LlwifSxlcXVhbFdpZHRoOnt0eXBlOkJvb2xlYW4sZGVzY3JpcHRpb246XCJGb3JtcyBjYW4gYXV0b21hdGljYWxseSBkaXZpZGUgZmllbGRzIHRvIGJlIGVxdWFsIHdpZHRoLlwifSx1bnN0YWNrYWJsZTp7dHlwZTpCb29sZWFuLGRlc2NyaXB0aW9uOlwiQSBmb3JtIGNhbiBwcmV2ZW50IGl0c2VsZiBmcm9tIHN0YWNraW5nIG9uIG1vYmlsZS5cIn19LHJlbmRlcjpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50c1swXSx0PXRoaXMuZ2V0RWxlbWVudFR5cGUoXCJmb3JtXCIpO3JldHVybiBlKHQsbCgpKFt7fSx0aGlzLmdldENoaWxkUHJvcHNBbmRMaXN0ZW5lcnMoKSx7Y2xhc3M6dGhpcy5jbGFzc2VzKFwidWlcIix0aGlzLnVuc3RhY2thYmxlJiZcInVuc3RhY2thYmxlXCIsdGhpcy5lcXVhbFdpZHRoJiZcImVxdWFsIHdpZHRoXCIsdGhpcy5pbnZlcnRlZCYmXCJpbnZlcnRlZFwiLHRoaXMuc2l6ZSx0aGlzLmxvYWRpbmcmJlwibG9hZGluZ1wiLFwiZm9ybVwiLHRoaXMuc3VjY2VzcyYmXCJzdWNjZXNzXCIsdGhpcy53YXJuaW5nJiZcIndhcm5pbmdcIix0aGlzLmVycm9yJiZcImVycm9yXCIsdGhpcy5zdGF0ZSl9XSksW3RoaXMuJHNsb3RzLmRlZmF1bHRdKX19LFk9e25hbWU6XCJTdWlGb3JtRmllbGRcIixtaXhpbnM6W0xdLHByb3BzOnt3aWR0aDpfLk51bWJlcih7ZGVzY3JpcHRpb246XCJBIGZpZWxkIGNhbiBzcGVjaWZ5IGl0cyB3aWR0aCBpbiBncmlkIGNvbHVtbnNcIn0pLGlubGluZTp7dHlwZTpCb29sZWFuLGRlc2NyaXB0aW9uOlwiQSBmaWVsZCBjYW4gaGF2ZSBpdHMgbGFiZWwgbmV4dCB0byBpbnN0ZWFkIG9mIGFib3ZlIGl0LlwifSxyZXF1aXJlZDp7dHlwZTpCb29sZWFuLGRlc2NyaXB0aW9uOlwiQSBmaWVsZCBjYW4gc2hvdyB0aGF0IGlucHV0IGlzIG1hbmRhdG9yeS5cIn0sZGlzYWJsZWQ6e3R5cGU6Qm9vbGVhbixkZXNjcmlwdGlvbjpcIkluZGl2aWR1YWwgZmllbGRzIG1heSBiZSBkaXNhYmxlZC5cIn0sZXJyb3I6e3R5cGU6Qm9vbGVhbixkZXNjcmlwdGlvbjpcIkluZGl2aWR1YWwgZmllbGRzIG1heSBkaXNwbGF5IGFuIGVycm9yIHN0YXRlLlwifX0scmVuZGVyOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzWzBdLHQ9dGhpcy5nZXRFbGVtZW50VHlwZSgpO3JldHVybiBlKHQsbCgpKFt7fSx0aGlzLmdldENoaWxkUHJvcHNBbmRMaXN0ZW5lcnMoKSx7Y2xhc3M6dGhpcy5jbGFzc2VzKHRoaXMud2lkdGgmJlwiXCIuY29uY2F0KHRoaXMubnVtKHRoaXMud2lkdGgpLFwiIHdpZGVcIiksdGhpcy5pbmxpbmUmJlwiaW5saW5lXCIsdGhpcy5yZXF1aXJlZCYmXCJyZXF1aXJlZFwiLHRoaXMuZGlzYWJsZWQmJlwiZGlzYWJsZWRcIixcImZpZWxkXCIsdGhpcy5lcnJvciYmXCJlcnJvclwiKX1dKSxbdGhpcy4kc2xvdHMuZGVmYXVsdF0pfSxtZXRhOntwYXJlbnQ6XCJTdWlGb3JtXCJ9fSxLPXtuYW1lOlwiU3VpRm9ybUZpZWxkc1wiLG1peGluczpbTF0scHJvcHM6e2lubGluZTp7dHlwZTpCb29sZWFuLGRlc2NyaXB0aW9uOlwiTXVsdGlwbGUgZmllbGRzIG1heSBiZSBpbmxpbmUgaW4gYSByb3cuXCJ9LGVxdWFsV2lkdGg6e3R5cGU6Qm9vbGVhbixkZXNjcmlwdGlvbjpcIkZpZWxkIGdyb3VwIGNhbiBhdXRvbWF0aWNhbGx5IGRpdmlkZSBmaWVsZHMgdG8gYmUgZXF1YWwgd2lkdGguXCJ9LGdyb3VwZWQ6e3R5cGU6Qm9vbGVhbixkZXNjcmlwdGlvbjpcIkZpZWxkcyBjYW4gc2hvdyByZWxhdGVkIGNob2ljZXMuXCJ9LGZpZWxkczpfLk51bWJlcih7Y2hvaWNlczpbXCJlcXVhbFwiXSxkZXNjcmlwdGlvbjpcIlJlcHJlc2VudHMgbnVtYmVyIG9mIGZpZWxkcyBpbiBncm91cFwifSksdW5zdGFja2FibGU6e3R5cGU6Qm9vbGVhbixkZXNjcmlwdGlvbjpcIkEgZm9ybSBncm91cCBjYW4gcHJldmVudCBpdHNlbGYgZnJvbSBzdGFja2luZyBvbiBtb2JpbGUuXCJ9fSxyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHNbMF0sdD10aGlzLmdldEVsZW1lbnRUeXBlKCk7cmV0dXJuIGUodCxsKCkoW3t9LHRoaXMuZ2V0Q2hpbGRQcm9wc0FuZExpc3RlbmVycygpLHtjbGFzczp0aGlzLmNsYXNzZXModGhpcy51bnN0YWNrYWJsZSYmXCJ1bnN0YWNrYWJsZVwiLHRoaXMuaW5saW5lJiZcImlubGluZVwiLHRoaXMuZXF1YWxXaWR0aCYmXCJlcXVhbCB3aWR0aFwiLHRoaXMuZ3JvdXBlZCYmXCJncm91cGVkXCIsdGhpcy5udW0odGhpcy5maWVsZHMpLFwiZmllbGRzXCIpfV0pLFt0aGlzLiRzbG90cy5kZWZhdWx0XSl9LG1ldGE6e3BhcmVudDpcIlN1aUZvcm1cIn19LFg9e25hbWU6XCJTdWlHcmlkXCIsbWl4aW5zOltMXSxkZXNjcmlwdGlvbjpcIkEgZ3JpZCBpcyB1c2VkIHRvIGhhcm1vbml6ZSBuZWdhdGl2ZSBzcGFjZSBpbiBhIGxheW91dC5cIixwcm9wczp7Y2VsbGVkOl8oW1wiaW50ZXJuYWxseVwiXSx7dHlwZTpCb29sZWFuLGRlc2NyaXB0aW9uOlwiQSBncmlkIGNhbiBoYXZlIHJvd3MgZGl2aWRlZCBpbnRvIGNlbGxzLlwifSksY2VudGVyZWQ6e3R5cGU6Qm9vbGVhbixkZXNjcmlwdGlvbjpcIkEgZ3JpZCBjYW4gaGF2ZSBpdHMgY29sdW1ucyBjZW50ZXJlZC5cIn0sY29sdW1uczpfLk51bWJlcih7Y2hvaWNlczpbXCJlcXVhbFwiXSxkZXNjcmlwdGlvbjpcIlJlcHJlc2VudHMgY29sdW1uIGNvdW50IHBlciByb3cgaW4gR3JpZC5cIn0pLGNvbnRhaW5lcjp7dHlwZTpCb29sZWFuLGRlc2NyaXB0aW9uOlwiQSBncmlkIGNhbiBiZSBjb21iaW5lZCB3aXRoIGEgY29udGFpbmVyIHRvIHVzZSB0aGUgYXZhaWxhYmxlIGxheW91dCBhbmQgYWxpZ25tZW50LlwifSxkaXZpZGVkOl8oW1widmVydGljYWxseVwiXSx7dHlwZTpCb29sZWFuLGRlc2NyaXB0aW9uOlwiQSBncmlkIGNhbiBoYXZlIGRpdmlkZXJzIGJldHdlZW4gaXRzIGNvbHVtbnMuXCJ9KSxkb3VibGluZzp7dHlwZTpCb29sZWFuLGRlc2NyaXB0aW9uOlwiQSBncmlkIGNhbiBkb3VibGUgaXRzIGNvbHVtbiB3aWR0aCBvbiB0YWJsZXQgYW5kIG1vYmlsZSBzaXplcy5cIn0scGFkZGVkOl8oW1wiaG9yaXpvbnRhbGx5XCIsXCJ2ZXJ0aWNhbGx5XCJdLHt0eXBlOkJvb2xlYW4sZGVzY3JpcHRpb246XCJBIGdyaWQgY2FuIHByZXNlcnZlIGl0cyB2ZXJ0aWNhbCBhbmQgaG9yaXpvbnRhbCBndXR0ZXJzIG9uIGZpcnN0IGFuZCBsYXN0IGNvbHVtbnMuXCJ9KSxyZWxheGVkOl8oW1widmVyeVwiXSx7dHlwZTpCb29sZWFuLGRlc2NyaXB0aW9uOlwiQSBncmlkIGNhbiBpbmNyZWFzZSBpdHMgZ3V0dGVycyB0byBhbGxvdyBmb3IgbW9yZSBuZWdhdGl2ZSBzcGFjZS5cIn0pLHJldmVyc2VkOl8oW1wibW9iaWxlXCIsXCJ0YWJsZXRcIixcImNvbXB1dGVyXCJdLHtkZXNjcmlwdGlvbjpcIkEgZ3JpZCBjYW4gc3BlY2lmeSB0aGF0IGl0cyBjb2x1bW5zIHNob3VsZCByZXZlcnNlIG9yZGVyIGF0IGRpZmZlcmVudCBkZXZpY2UgdHlwZXMuXCJ9KSxzdGFja2FibGU6e3R5cGU6Qm9vbGVhbixkZXNjcmlwdGlvbjpcIkEgZ3JpZCBjYW4gaGF2ZSBpdHMgY29sdW1ucyBzdGFjayBvbi10b3Agb2YgZWFjaCBvdGhlciBhZnRlciByZWFjaGluZyBtb2JpbGUgYnJlYWtwb2ludHMuXCJ9LHN0cmV0Y2hlZDp7dHlwZTpCb29sZWFuLGRlc2NyaXB0aW9uOlwiQSBncmlkIGNhbiBzdHJldGNoIGl0cyBjb250ZW50cyB0byB0YWtlIHVwIHRoZSBlbnRpcmUgZ3JpZCBoZWlnaHQuXCJ9LHRleHRBbGlnbjpfLlRleHRBbGlnbih7ZGVzY3JpcHRpb246XCJBIGdyaWQgY2FuIHNwZWNpZnkgaXRzIHRleHQgYWxpZ25tZW50LlwifSksdmVydGljYWxBbGlnbjpfLlZlcnRpY2FsQWxpZ24oe2Rlc2NyaXB0aW9uOlwiQSBncmlkIGNhbiBzcGVjaWZ5IGl0cyB2ZXJ0aWNhbCBhbGlnbm1lbnQgdG8gaGF2ZSBhbGwgaXRzIGNvbHVtbnMgdmVydGljYWxseSBjZW50ZXJlZC5cIn0pLHZlcnRpY2FsbHlSZXZlcnNlZDpfKFtcIm1vYmlsZVwiLFwidGFibGV0XCIsXCJjb21wdXRlclwiXSx7ZGVzY3JpcHRpb246XCJBIGdyaWQgY2FuIHNwZWNpZnkgdGhhdCBpdHMgcm93cyBzaG91bGQgcmV2ZXJzZSBvcmRlciBhdCBkaWZmZXJlbnQgZGV2aWNlIHR5cGVzLlwifSl9LHJlbmRlcjpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50c1swXSx0PXRoaXMuZ2V0RWxlbWVudFR5cGUoKTtyZXR1cm4gZSh0LGwoKShbe30sdGhpcy5nZXRDaGlsZFByb3BzQW5kTGlzdGVuZXJzKCkse2NsYXNzOnRoaXMuY2xhc3NlcyhcInVpXCIsdGhpcy5yZXZlcnNlZCYmXCJcIi5jb25jYXQodGhpcy5yZXZlcnNlZCxcIiByZXZlcnNlZFwiKSx0aGlzLnZlcnRpY2FsbHlSZXZlcnNlZCYmXCJcIi5jb25jYXQodGhpcy52ZXJ0aWNhbGx5UmV2ZXJzZWQsXCIgdmVydGljYWxseSByZXZlcnNlZFwiKSx0aGlzLmNvbHVtbnMmJlwiXCIuY29uY2F0KHRoaXMubnVtKHRoaXMuY29sdW1ucyksXCIgY29sdW1uXCIpLHRoaXMuc3RhY2thYmxlJiZcInN0YWNrYWJsZVwiLHRoaXMuc3RyZXRjaGVkJiZcInN0cmV0Y2hlZFwiLHRoaXMuZG91YmxpbmcmJlwiZG91YmxpbmdcIix0aGlzLnBhZGRlZCx0aGlzLnBhZGRlZCYmXCJwYWRkZWRcIix0aGlzLnZlcnRpY2FsQWxpZ24sdGhpcy52ZXJ0aWNhbEFsaWduJiZcImFsaWduZWRcIixJKHRoaXMudGV4dEFsaWduKSx0aGlzLmNlbnRlcmVkJiZcImNlbnRlcmVkXCIsdGhpcy5kaXZpZGVkLHRoaXMuZGl2aWRlZCYmXCJkaXZpZGVkXCIsdGhpcy5jZWxsZWQsdGhpcy5jZWxsZWQmJlwiY2VsbGVkXCIsdGhpcy5yZWxheGVkLHRoaXMucmVsYXhlZCYmXCJyZWxheGVkXCIsXCJncmlkXCIsdGhpcy5jb250YWluZXImJlwiY29udGFpbmVyXCIpfV0pLFt0aGlzLiRzbG90cy5kZWZhdWx0XSl9fSxKPXtuYW1lOlwiU3VpR3JpZENvbHVtblwiLG1peGluczpbTF0sZGVzY3JpcHRpb246XCJBIGNvbHVtbiBzdWItY29tcG9uZW50IGZvciBHcmlkLlwiLHByb3BzOntjb2xvcjpfLkNvbG9yKHtkZXNjcmlwdGlvbjpcIkEgZ3JpZCBjb2x1bW4gY2FuIGJlIGNvbG9yZWQuXCJ9KSxjZW50ZXJlZDpCb29sZWFuLHdpZHRoOl8uTnVtYmVyKHtkZXNjcmlwdGlvbjpcIlJlcHJlc2VudHMgd2lkdGggb2YgY29sdW1uLlwifSksbW9iaWxlOl8uTnVtYmVyKHtkZXNjcmlwdGlvbjpcIkEgY29sdW1uIGNhbiBzcGVjaWZ5IGEgd2lkdGggZm9yIGEgbW9iaWxlIGRldmljZS5cIn0pLHRhYmxldDpfLk51bWJlcih7ZGVzY3JpcHRpb246XCJBIGNvbHVtbiBjYW4gc3BlY2lmeSBhIHdpZHRoIGZvciBhIHRhYmxldCBkZXZpY2UuXCJ9KSxjb21wdXRlcjpfLk51bWJlcih7ZGVzY3JpcHRpb246XCJBIGNvbHVtbiBjYW4gc3BlY2lmeSBhIHdpZHRoIGZvciBhIGNvbXB1dGVyLlwifSksbGFyZ2VTY3JlZW46Xy5OdW1iZXIoe2Rlc2NyaXB0aW9uOlwiQSBjb2x1bW4gY2FuIHNwZWNpZnkgYSB3aWR0aCBmb3IgYSBsYXJnZSBzY3JlZW4gZGV2aWNlLlwifSksd2lkZXNjcmVlbjpfLk51bWJlcih7ZGVzY3JpcHRpb246XCJBIGNvbHVtbiBjYW4gc3BlY2lmeSBhIHdpZHRoIGZvciBhIHdpZGVzY3JlZW4gZGV2aWNlLlwifSksZmxvYXRlZDpfKFtcImxlZnRcIixcInJpZ2h0XCJdLHtkZXNjcmlwdGlvbjpcIkEgY29sdW1uIGNhbiBzaXQgZmx1c2ggYWdhaW5zdCB0aGUgbGVmdCBvciByaWdodCBlZGdlIG9mIGEgcm93LlwifSksdGV4dEFsaWduOl8uVGV4dEFsaWduKHtkZXNjcmlwdGlvbjpcIkEgY29sdW1uIGNhbiBzcGVjaWZ5IGl0cyB0ZXh0IGFsaWdubWVudC5cIn0pLHZlcnRpY2FsQWxpZ246Xy5WZXJ0aWNhbEFsaWduKHtkZXNjcmlwdGlvbjpcIkEgY29sdW1uIGNhbiBzcGVjaWZ5IGl0cyB2ZXJ0aWNhbCBhbGlnbm1lbnQgdG8gaGF2ZSBhbGwgaXRzIGNvbHVtbnMgdmVydGljYWxseSBjZW50ZXJlZC5cIn0pLG9ubHk6XyhbXCJtb2JpbGVcIixcInRhYmxldFwiLFwiY29tcHV0ZXJcIixcIndpZGVzY3JlZW5cIixcImxhcmdlIHNjcmVlblwiXSx7ZGVzY3JpcHRpb246XCJBIGNvbHVtbiBjYW4gYXBwZWFyIG9ubHkgZm9yIGEgc3BlY2lmaWMgZGV2aWNlLCBvciBzY3JlZW4gc2l6ZXMuXCJ9KSxzdHJldGNoZWQ6e3R5cGU6Qm9vbGVhbixkZXNjcmlwdGlvbjpcIkEgY29sdW1uIGNhbiBzdHJldGNoIGl0cyBjb250ZW50cyB0byB0YWtlIHVwIHRoZSBlbnRpcmUgZ3JpZCBvciByb3cgaGVpZ2h0LlwifX0scmVuZGVyOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzWzBdLHQ9dGhpcy5nZXRFbGVtZW50VHlwZSgpO3JldHVybiBlKHQsbCgpKFt7fSx0aGlzLmdldENoaWxkUHJvcHNBbmRMaXN0ZW5lcnMoKSx7Y2xhc3M6dGhpcy5jbGFzc2VzKHRoaXMuZmxvYXRlZCYmXCJcIi5jb25jYXQodGhpcy5mbG9hdGVkLFwiIGZsb2F0ZWRcIiksSSh0aGlzLnRleHRBbGlnbiksdGhpcy52ZXJ0aWNhbEFsaWduJiZcIlwiLmNvbmNhdCh0aGlzLnZlcnRpY2FsQWxpZ24sXCIgYWxpZ25lZFwiKSx0aGlzLndpZHRoJiZcIlwiLmNvbmNhdCh0aGlzLm51bSh0aGlzLndpZHRoKSxcIiB3aWRlXCIpLHRoaXMubW9iaWxlJiZcIlwiLmNvbmNhdCh0aGlzLm51bSh0aGlzLm1vYmlsZSksXCIgd2lkZSBtb2JpbGVcIiksdGhpcy50YWJsZXQmJlwiXCIuY29uY2F0KHRoaXMubnVtKHRoaXMudGFibGV0KSxcIiB3aWRlIHRhYmxldFwiKSx0aGlzLmNvbXB1dGVyJiZcIlwiLmNvbmNhdCh0aGlzLm51bSh0aGlzLmNvbXB1dGVyKSxcIiB3aWRlIGNvbXB1dGVyXCIpLHRoaXMud2lkZXNjcmVlbiYmXCJcIi5jb25jYXQodGhpcy5udW0odGhpcy53aWRlc2NyZWVuKSxcIiB3aWRlIHdpZGVzY3JlZW5cIiksdGhpcy5sYXJnZVNjcmVlbiYmXCJcIi5jb25jYXQodGhpcy5udW0odGhpcy5sYXJnZVNjcmVlbiksXCIgd2lkZSBsYXJnZSBzY3JlZW5cIiksdGhpcy5vbmx5JiZcIlwiLmNvbmNhdCh0aGlzLm9ubHksXCIgb25seVwiKSx0aGlzLmNlbnRlcmVkJiZcImNlbnRlcmVkXCIsdGhpcy5zdHJldGNoZWQmJlwic3RyZXRjaGVkXCIsdGhpcy5jb2xvcixcImNvbHVtblwiKX1dKSxbdGhpcy4kc2xvdHMuZGVmYXVsdF0pfSxtZXRhOntwYXJlbnQ6XCJTdWlHcmlkXCJ9fSxaPXtuYW1lOlwiU3VpR3JpZFJvd1wiLG1peGluczpbTF0sZGVzY3JpcHRpb246XCJBIHJvdyBzdWItY29tcG9uZW50IGZvciBHcmlkXCIscHJvcHM6e2NvbHVtbnM6Xy5OdW1iZXIoe2Rlc2NyaXB0aW9uOlwiUmVwcmVzZW50cyBjb2x1bW4gY291bnQgcGVyIGxpbmUgaW4gUm93LlwifSksY2VudGVyZWQ6e3R5cGU6Qm9vbGVhbixkZXNjcmlwdGlvbjpcIkEgcm93IGNhbiBoYXZlIGl0cyBjb2x1bW5zIGNlbnRlcmVkLlwifSxvbmx5Ol8oW1wibW9iaWxlXCIsXCJ0YWJsZXRcIixcImNvbXB1dGVyXCIsXCJ3aWRlc2NyZWVuXCIsXCJsYXJnZSBzY3JlZW5cIl0se2Rlc2NyaXB0aW9uOlwiQSByb3cgY2FuIGFwcGVhciBvbmx5IGZvciBhIHNwZWNpZmljIGRldmljZSwgb3Igc2NyZWVuIHNpemVzLlwifSksZGl2aWRlZDp7dHlwZTpCb29sZWFuLGRlc2NyaXB0aW9uOlwiQSByb3cgY2FuIGhhdmUgZGl2aWRlcnMgYmV0d2VlbiBpdHMgY29sdW1ucy5cIn0sY29sb3I6Xy5Db2xvcih7ZGVzY3JpcHRpb246XCJBIGdyaWQgcm93IGNhbiBiZSBjb2xvcmVkLlwifSkscmV2ZXJzZWQ6XyhbXCJtb2JpbGVcIixcInRhYmxldFwiLFwiY29tcHV0ZXJcIl0se2Rlc2NyaXB0aW9uOlwiQSByb3cgY2FuIHNwZWNpZnkgdGhhdCBpdHMgY29sdW1ucyBzaG91bGQgcmV2ZXJzZSBvcmRlciBhdCBkaWZmZXJlbnQgZGV2aWNlIHR5cGVzLlwifSksc3RyZXRjaGVkOnt0eXBlOkJvb2xlYW4sZGVzY3JpcHRpb246XCJBIHJvdyBjYW4gc3RyZXRjaCBpdHMgY29udGVudHMgdG8gdGFrZSB1cCB0aGUgZW50aXJlIGNvbHVtbiBoZWlnaHQuXCJ9LHRleHRBbGlnbjpfLlRleHRBbGlnbih7ZGVzY3JpcHRpb246XCJBIHJvdyBjYW4gc3BlY2lmeSBpdHMgdGV4dCBhbGlnbm1lbnQuXCJ9KSx2ZXJ0aWNhbEFsaWduOl8uVmVydGljYWxBbGlnbih7ZGVzY3JpcHRpb246XCJBIHJvdyBjYW4gc3BlY2lmeSBpdHMgdmVydGljYWwgYWxpZ25tZW50IHRvIGhhdmUgYWxsIGl0cyBjb2x1bW5zIHZlcnRpY2FsbHkgY2VudGVyZWQuXCJ9KX0scmVuZGVyOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzWzBdLHQ9dGhpcy5nZXRFbGVtZW50VHlwZSgpO3JldHVybiBlKHQsbCgpKFt7fSx0aGlzLmdldENoaWxkUHJvcHNBbmRMaXN0ZW5lcnMoKSx7Y2xhc3M6dGhpcy5jbGFzc2VzKHRoaXMucmV2ZXJzZWQmJlwiXCIuY29uY2F0KHRoaXMucmV2ZXJzZWQsXCIgcmV2ZXJzZWRcIiksdGhpcy5vbmx5JiZcIlwiLmNvbmNhdCh0aGlzLm9ubHksXCIgb25seVwiKSx0aGlzLmRpdmlkZWQmJlwiZGl2aWRlZFwiLEkodGhpcy50ZXh0QWxpZ24pLHRoaXMudmVydGljYWxBbGlnbiYmXCJcIi5jb25jYXQodGhpcy52ZXJ0aWNhbEFsaWduLFwiIGFsaWduZWRcIiksdGhpcy5jZW50ZXJlZCYmXCJjZW50ZXJlZFwiLHRoaXMuc3RyZXRjaGVkJiZcInN0cmV0Y2hlZFwiLHRoaXMuY29sb3IsdGhpcy5jb2x1bW5zJiZcIlwiLmNvbmNhdCh0aGlzLm51bSh0aGlzLmNvbHVtbnMpLFwiIGNvbHVtblwiKSxcInJvd1wiKX1dKSxbdGhpcy4kc2xvdHMuZGVmYXVsdF0pfSxtZXRhOntwYXJlbnQ6XCJTdWlHcmlkXCJ9fSxRPXtuYW1lOlwiU3VpSWNvblwiLG1peGluczpbTF0scHJvcHM6e2JvcmRlcmVkOnt0eXBlOkJvb2xlYW4sZGVzY3JpcHRpb246XCJBZGQgc3F1YXJlZCBib3JkZXIgdG8gaWNvbi5cIn0sY2lyY3VsYXI6e3R5cGU6Qm9vbGVhbixkZXNjcmlwdGlvbjpcIkFkZCBjaXJjdWxhciBib3JkZXIgdG8gaWNvbi5cIn0sY29sb3I6Xy5Db2xvcih7ZGVzY3JpcHRpb246XCJJY29uIGNvbG9yLlwifSksY29ybmVyOl8uQ29ybmVyKHt0eXBlOltCb29sZWFuLFN0cmluZ10sZGVzY3JpcHRpb246XCJBbGlnbiBpY29uIHRvIGNvcm5lclwifSksZGlzYWJsZWQ6e3R5cGU6Qm9vbGVhbixkZXNjcmlwdGlvbjonUmVkdWNpbmcgaWNvbiBvcGFjaXR5IHRvIGNyZWF0ZSBcImRpc2FibGVkIGljb25cIiBlZmZlY3QuJ30sZml0dGVkOnt0eXBlOkJvb2xlYW4sZGVzY3JpcHRpb246XCJSZW1vdmUgbWFyZ2luIGZyb20gaWNvblwifSxmbGlwcGVkOl8uRGlyZWN0aW9uKHtkZXNjcmlwdGlvbjpcIkljb24gZmxpcCBkaXJlY3Rpb24uXCJ9KSxpbnZlcnRlZDp7dHlwZTpCb29sZWFuLGRlc2NyaXB0aW9uOlwiQWRkIGJsYWNrIGJhY2tncm91bmQgdG8gaWNvbiwgYWxzbyBjaGFuZ2UgaWNvbiBjb2xvciB0byBjb250cmFzdGVkIHZhcmlhbnQuXCJ9LGxpbms6e3R5cGU6Qm9vbGVhbixkZXNjcmlwdGlvbjpcIkFkZCBob3ZlciBhbmltYXRpb24gdG8gaWNvbi5cIn0sbG9hZGluZzp7dHlwZTpCb29sZWFuLGRlc2NyaXB0aW9uOlwiQWRkIHJvdGF0ZSBhbmltYXRpb24gdG8gaWNvbi5cIn0sbmFtZTp7dHlwZTpTdHJpbmcscmVxdWlyZWQ6ITAsZGVzY3JpcHRpb246XCJJY29uIG5hbWUuXCJ9LG91dGxpbmU6e3R5cGU6Qm9vbGVhbixkZXNjcmlwdGlvbjpcIlNldCBmb250LWZhbWlseSBpY29uIHRvIG91dGxpbmVkXCJ9LHJvdGF0ZWQ6Xy5Sb3RhdGVEaXJlY3Rpb24oe2Rlc2NyaXB0aW9uOlwiSWNvbiByb3RhdGUgZGlyZWN0aW9uLlwifSksc2l6ZTpfLlNpemUoe2Rlc2NyaXB0aW9uOlwiSWNvbiBzaXplLlwifSl9LHJlbmRlcjpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50c1swXSx0PXRoaXMuZ2V0RWxlbWVudFR5cGUoXCJpXCIpO3JldHVybiBlKHQsbCgpKFt7fSx0aGlzLmdldENoaWxkUHJvcHNBbmRMaXN0ZW5lcnMoKSx7Y2xhc3M6dGhpcy5jbGFzc2VzKE0odGhpcy5mbGlwcGVkKSxGKHRoaXMucm90YXRlZCksdGhpcy5ib3JkZXJlZCYmXCJib3JkZXJlZFwiLHRoaXMuY2lyY3VsYXImJlwiY2lyY3VsYXJcIix0aGlzLmludmVydGVkJiZcImludmVydGVkXCIseih0aGlzLmNvcm5lciksdGhpcy5jb2xvcix0aGlzLm5hbWUsdGhpcy5zaXplLHRoaXMuZGlzYWJsZWQmJlwiZGlzYWJsZWRcIix0aGlzLmZpdHRlZCYmXCJmaXR0ZWRcIix0aGlzLmxpbmsmJlwibGlua1wiLHRoaXMubG9hZGluZyYmXCJsb2FkaW5nXCIsdGhpcy5vdXRsaW5lJiZcIm91dGxpbmVcIixcImljb25cIil9XSkpfX0sZWU9e25hbWU6XCJTdWlNZW51SXRlbVwiLG1peGluczpbTF0scHJvcHM6e2FjdGl2ZTp7dHlwZTpCb29sZWFuLGRlc2NyaXB0aW9uOlwiQSBtZW51IGl0ZW0gY2FuIGJlIGFjdGl2ZS5cIn0sY29sb3I6Xy5Db2xvcih7ZGVzY3JpcHRpb246XCJBZGRpdGlvbmFsIGNvbG9ycyBjYW4gYmUgc3BlY2lmaWVkLlwifSksY29udGVudDp7dHlwZTpTdHJpbmcsZGVzY3JpcHRpb246XCJTaG9ydGhhbmQgZm9yIHByaW1hcnkgY29udGVudC5cIn0saGVhZGVyOnt0eXBlOkJvb2xlYW4sZGVzY3JpcHRpb246XCJBIG1lbnUgaXRlbSBtYXkgaW5jbHVkZSBhIGhlYWRlciBvciBtYXkgaXRzZWxmIGJlIGEgaGVhZGVyLlwifSxpY29uOnt0eXBlOltCb29sZWFuLFN0cmluZ10sZGVzY3JpcHRpb246XCJNZW51SXRlbSBjYW4gYmUgb25seSBpY29uLlwifSxsaW5rOnt0eXBlOkJvb2xlYW4sZGVzY3JpcHRpb246XCJBIG1lbnUgaXRlbSBjYW4gYmUgbGluay5cIn0scG9zaXRpb246XyhbXCJsZWZ0XCIsXCJyaWdodFwiXSx7ZGVzY3JpcHRpb246XCJBIG1lbnUgaXRlbSBjYW4gdGFrZSBsZWZ0IG9yIHJpZ2h0IHBvc2l0aW9uLlwifSksZGlzYWJsZWQ6e3R5cGU6Qm9vbGVhbixkZXNjcmlwdGlvbjpcIkEgbWVudSBpdGVtIGNhbiBiZSBkaXNhYmxlZC5cIn0sZml0dGVkOl8oW1wiaG9yaXpvbnRhbGx5XCIsXCJ2ZXJ0aWNhbGx5XCJdLHt0eXBlOkJvb2xlYW4sZGVzY3JpcHRpb246XCJBIG1lbnUgaXRlbSBvciBtZW51IGNhbiByZW1vdmUgZWxlbWVudCBwYWRkaW5nLCB2ZXJ0aWNhbGx5IG9yIGhvcml6b250YWxseS4uXCJ9KX0scmVuZGVyOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzWzBdLHQ9dGhpcy5nZXRFbGVtZW50VHlwZSh0aGlzLmxpbms/XCJhXCI6XCJkaXZcIik7cmV0dXJuIGUodCxsKCkoW3t9LHRoaXMuZ2V0Q2hpbGRQcm9wc0FuZExpc3RlbmVycygpLHtjbGFzczp0aGlzLmNsYXNzZXModGhpcy5kaXNhYmxlZCYmXCJkaXNhYmxlZFwiLHRoaXMuYWN0aXZlJiZcImFjdGl2ZVwiLHRoaXMuZml0dGVkLHRoaXMuZml0dGVkJiZcImZpdHRlZFwiLHRoaXMuaGVhZGVyJiZcImhlYWRlclwiLHRoaXMubGluayYmXCJsaW5rXCIsdGhpcy5pY29uJiZcImljb25cIix0aGlzLnBvc2l0aW9uLFwiaXRlbVwiKX1dKSxbXCJzdHJpbmdcIj09dHlwZW9mIHRoaXMuaWNvbiYmZShRLHthdHRyczp7bmFtZTp0aGlzLmljb259fSksdGhpcy4kc2xvdHMuZGVmYXVsdHx8dGhpcy5jb250ZW50XSl9LG1ldGE6e3BhcmVudDpcIlN1aU1lbnVcIn19O2Z1bmN0aW9uIHRlKGUsdCl7dmFyIGk9T2JqZWN0LmtleXMoZSk7aWYoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyl7dmFyIG49T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTt0JiYobj1uLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSx0KS5lbnVtZXJhYmxlfSkpKSxpLnB1c2guYXBwbHkoaSxuKX1yZXR1cm4gaX1mdW5jdGlvbiBpZShlKXtmb3IodmFyIHQ9MTt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKXt2YXIgaT1udWxsIT1hcmd1bWVudHNbdF0/YXJndW1lbnRzW3RdOnt9O3QlMj90ZShPYmplY3QoaSksITApLmZvckVhY2goKGZ1bmN0aW9uKHQpe25lKGUsdCxpW3RdKX0pKTpPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycz9PYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKGkpKTp0ZShPYmplY3QoaSkpLmZvckVhY2goKGZ1bmN0aW9uKHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihpLHQpKX0pKX1yZXR1cm4gZX1mdW5jdGlvbiBuZShlLHQsaSl7cmV0dXJuIHQgaW4gZT9PYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHt2YWx1ZTppLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6ZVt0XT1pLGV9dmFyIHJlPXtuYW1lOlwiU3VpTWVudVwiLGNvbXBvbmVudHM6e1N1aU1lbnVJdGVtOmVlfSxtaXhpbnM6W0xdLHByb3BzOnthY3RpdmVJbmRleDp7dHlwZTpOdW1iZXIsZGVzY3JpcHRpb246XCJJbmRleCBvZiB0aGUgY3VycmVudGx5IGFjdGl2ZSBpdGVtLlwifSxhdHRhY2hlZDpfLkF0dGFjaGVkKHt0eXBlOkJvb2xlYW4sZGVzY3JpcHRpb246XCJBIG1lbnUgbWF5IGJlIGF0dGFjaGVkIHRvIG90aGVyIGNvbnRlbnQgc2VnbWVudHMuXCJ9KSxjb2xvcjpfLkNvbG9yKHtkZXNjcmlwdGlvbjpcIkFkZGl0aW9uYWwgY29sb3JzIGNhbiBiZSBzcGVjaWZpZWQuXCJ9KSxjb21wYWN0Ont0eXBlOkJvb2xlYW4sZGVzY3JpcHRpb246XCJBIG1lbnUgY2FuIHRha2UgdXAgb25seSB0aGUgc3BhY2UgbmVjZXNzYXJ5IHRvIGZpdCBpdHMgY29udGVudC5cIn0sZml4ZWQ6XyhbXCJyaWdodFwiLFwibGVmdFwiLFwiYm90dG9tXCIsXCJ0b3BcIl0se2Rlc2NyaXB0aW9uOlwiQSBtZW51IGNhbiBiZSBmaXhlZCB0byBhIHNpZGUgb2YgaXRzIGNvbnRleHQuXCIsdHlwZTpCb29sZWFufSksaWNvbjpfKFtcImxhYmVsZWRcIl0se3R5cGU6Qm9vbGVhbixkZXNjcmlwdGlvbjpcIkEgbWVudSBtYXkgaGF2ZSBqdXN0IGljb25zIChib29sKSBvciBsYWJlbGVkIGljb25zXCJ9KSxpbnZlcnRlZDp7dHlwZTpCb29sZWFuLGRlc2NyaXB0aW9uOlwiQSBtZW51IG1heSBoYXZlIGl0cyBjb2xvcnMgaW52ZXJ0ZWQgdG8gc2hvdyBncmVhdGVyIGNvbnRyYXN0LlwifSxpdGVtczp7dHlwZTpBcnJheSxkZXNjcmlwdGlvbjpcIlNob3J0aGFuZCBhcnJheSBvZiBwcm9wcyBmb3IgTWVudSBpdGVtcy5cIn0sZmxvYXRlZDpfKFtcInJpZ2h0XCJdLHt0eXBlOkJvb2xlYW4sZGVzY3JpcHRpb246XCJBIG1lbnUgY2FuIGJlIGZsb2F0ZWQuXCJ9KSxmbHVpZDp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITEsZGVzY3JpcHRpb246XCJBIHZlcnRpY2FsIG1lbnUgbWF5IHRha2UgdGhlIHNpemUgb2YgaXRzIGNvbnRhaW5lci5cIn0sc2Vjb25kYXJ5Ont0eXBlOkJvb2xlYW4sZGVzY3JpcHRpb246XCJBIG1lbnUgY2FuIGFkanVzdCBpdHMgYXBwZWFyYW5jZSB0byBkZS1lbXBoYXNpemUgaXRzIGNvbnRlbnRzLlwifSxwb2ludGluZzp7dHlwZTpCb29sZWFuLGRlc2NyaXB0aW9uOlwiQSBtZW51IGNhbiBwb2ludCB0byBzaG93IGl0cyByZWxhdGlvbnNoaXAgdG8gbmVhcmJ5IGNvbnRlbnQuXCJ9LHRhYnVsYXI6XyhbXCJyaWdodFwiXSx7dHlwZTpCb29sZWFuLGRlc2NyaXB0aW9uOlwiQSBtZW51IGNhbiBiZSBmb3JtYXR0ZWQgdG8gc2hvdyB0YWJzIG9mIGluZm9ybWF0aW9uXCJ9KSx0ZXh0Ont0eXBlOkJvb2xlYW4sZGVzY3JpcHRpb246XCJBIG1lbnUgY2FuIGJlIGZvcm1hdHRlZCBmb3IgdGV4dCBjb250ZW50LlwifSx2ZXJ0aWNhbDp7dHlwZTpCb29sZWFuLGRlc2NyaXB0aW9uOlwiQSB2ZXJ0aWNhbCBtZW51IGRpc3BsYXlzIGVsZW1lbnRzIHZlcnRpY2FsbHkuXCJ9LHdpZHRoczpfLk51bWJlcih7ZGVzY3JpcHRpb246XCJBIG1lbnUgY2FuIGhhdmUgaXRzIGl0ZW1zIGRpdmlkZWQgZXZlbmx5LlwifSksYm9yZGVybGVzczp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITEsZGVzY3JpcHRpb246XCJBIG1lbnUgaXRlbSBvciBtZW51IGNhbiBoYXZlIG5vIGJvcmRlcnMuXCJ9LHBhZ2luYXRpb246e3R5cGU6Qm9vbGVhbixkZXNjcmlwdGlvbjpcIkEgcGFnaW5hdGlvbiBtZW51IGlzIHNwZWNpYWxseSBmb3JtYXR0ZWQgdG8gcHJlc2VudCBsaW5rcyB0byBwYWdlcyBvZiBjb250ZW50LlwifX0scmVuZGVyOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcyx0PWFyZ3VtZW50c1swXSxpPXRoaXMuZ2V0RWxlbWVudFR5cGUoKTtyZXR1cm4gdChpLGwoKShbe30sdGhpcy5nZXRDaGlsZFByb3BzQW5kTGlzdGVuZXJzKCkse2NsYXNzOnRoaXMuY2xhc3NlcyhcInVpXCIsdGhpcy5hdHRhY2hlZCYmXCJcIi5jb25jYXQodGhpcy5hdHRhY2hlZCxcIiBhdHRhY2hlZFwiKSx0aGlzLnZlcnRpY2FsJiZcInZlcnRpY2FsXCIsdGhpcy5mbHVpZCYmXCJmbHVpZFwiLHRoaXMuY29tcGFjdCYmXCJjb21wYWN0XCIsdGhpcy5maXhlZCYmXCJcIi5jb25jYXQodGhpcy5maXhlZCxcIiBmaXhlZFwiKSx0aGlzLnRleHQmJlwidGV4dFwiLHRoaXMuaWNvbix0aGlzLmljb24mJlwiaWNvblwiLHRoaXMuaW52ZXJ0ZWQmJlwiaW52ZXJ0ZWRcIix0aGlzLnBhZ2luYXRpb24mJlwicGFnaW5hdGlvblwiLHRoaXMuYm9yZGVybGVzcyYmXCJib3JkZXJsZXNzXCIsdGhpcy5mbG9hdGVkLHRoaXMuZmxvYXRlZCYmXCJmbG9hdGVkXCIsdGhpcy53aWR0aHMmJlwiXCIuY29uY2F0KHRoaXMubnVtKHRoaXMud2lkdGhzKSxcIiBpdGVtXCIpLHRoaXMuc2Vjb25kYXJ5JiZcInNlY29uZGFyeVwiLHRoaXMucG9pbnRpbmcmJlwicG9pbnRpbmdcIix0aGlzLnRhYnVsYXIsdGhpcy50YWJ1bGFyJiZcInRhYnVsYXJcIix0aGlzLmNvbG9yLFwibWVudVwiKX1dKSxbdGhpcy4kc2xvdHMuZGVmYXVsdHx8dGhpcy5pdGVtcyYmdGhpcy5pdGVtcy5tYXAoKGZ1bmN0aW9uKGksbil7cmV0dXJuIHQoZWUse3Byb3BzOmllKHt9LGkpLGF0dHJzOnthY3RpdmU6aS5hY3RpdmV8fGUuYWN0aXZlSW5kZXg9PT1ufX0pfSkpXSl9fSxzZT17bmFtZTpcIlN1aU1lbnVIZWFkZXJcIixtaXhpbnM6W0xdLHByb3BzOntjb250ZW50Ont0eXBlOlN0cmluZyxkZXNjcmlwdGlvbjpcIlNob3J0aGFuZCBmb3IgcHJpbWFyeSBjb250ZW50LlwifX0scmVuZGVyOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzWzBdLHQ9dGhpcy5nZXRFbGVtZW50VHlwZSgpO3JldHVybiBlKHQsbCgpKFt7fSx0aGlzLmdldENoaWxkUHJvcHNBbmRMaXN0ZW5lcnMoKSx7Y2xhc3M6XCJoZWFkZXJcIn1dKSxbdGhpcy4kc2xvdHMuZGVmYXVsdHx8dGhpcy5jb250ZW50XSl9LG1ldGE6e3BhcmVudDpcIlN1aU1lbnVcIn19LG9lPXtuYW1lOlwiU3VpTWVudU1lbnVcIixtaXhpbnM6W0xdLHByb3BzOntwb3NpdGlvbjpfKFtcImxlZnRcIixcInJpZ2h0XCJdLHtkZXNjcmlwdGlvbjpcIkEgc3ViIG1lbnUgY2FuIHRha2UgbGVmdCBvciByaWdodCBwb3NpdGlvblwifSl9LHJlbmRlcjpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50c1swXSx0PXRoaXMuZ2V0RWxlbWVudFR5cGUoKTtyZXR1cm4gZSh0LGwoKShbe30sdGhpcy5nZXRDaGlsZFByb3BzQW5kTGlzdGVuZXJzKCkse2NsYXNzOnRoaXMuY2xhc3Nlcyh0aGlzLnBvc2l0aW9uLFwibWVudVwiKX1dKSxbdGhpcy4kc2xvdHMuZGVmYXVsdF0pfSxtZXRhOntwYXJlbnQ6XCJTdWlNZW51XCJ9fSxhZT17bmFtZTpcIlN1aU1lc3NhZ2VDb250ZW50XCIsbWl4aW5zOltMXSxyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHNbMF0sdD10aGlzLmdldEVsZW1lbnRUeXBlKCk7cmV0dXJuIGUodCxsKCkoW3t9LHRoaXMuZ2V0Q2hpbGRQcm9wc0FuZExpc3RlbmVycygpLHtjbGFzczp0aGlzLmNsYXNzZXMoXCJjb250ZW50XCIpfV0pLFt0aGlzLiRzbG90cy5kZWZhdWx0XSl9LG1ldGE6e3BhcmVudDpcIlN1aU1lc3NhZ2VcIn19LGNlPXtuYW1lOlwiU3VpTWVzc2FnZUhlYWRlclwiLG1peGluczpbTF0scmVuZGVyOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzWzBdLHQ9dGhpcy5nZXRFbGVtZW50VHlwZSgpO3JldHVybiBlKHQsbCgpKFt7fSx0aGlzLmdldENoaWxkUHJvcHNBbmRMaXN0ZW5lcnMoKSx7Y2xhc3M6dGhpcy5jbGFzc2VzKFwiaGVhZGVyXCIpfV0pLFt0aGlzLiRzbG90cy5kZWZhdWx0XSl9LG1ldGE6e3BhcmVudDpcIlN1aU1lc3NhZ2VcIn19LGxlPXtuYW1lOlwiU3VpTWVzc2FnZUl0ZW1cIixtaXhpbnM6W0xdLHJlbmRlcjpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50c1swXSx0PXRoaXMuZ2V0RWxlbWVudFR5cGUoXCJsaVwiKTtyZXR1cm4gZSh0LGwoKShbe30sdGhpcy5nZXRDaGlsZFByb3BzQW5kTGlzdGVuZXJzKCldKSxbdGhpcy4kc2xvdHMuZGVmYXVsdF0pfSxtZXRhOntwYXJlbnQ6XCJTdWlNZXNzYWdlXCJ9fSxkZT17bmFtZTpcIlN1aU1lc3NhZ2VMaXN0XCIsbWl4aW5zOltMXSxyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHNbMF0sdD10aGlzLmdldEVsZW1lbnRUeXBlKFwidWxcIik7cmV0dXJuIGUodCxsKCkoW3t9LHRoaXMuZ2V0Q2hpbGRQcm9wc0FuZExpc3RlbmVycygpLHtjbGFzczp0aGlzLmNsYXNzZXMoXCJsaXN0XCIpfV0pLFt0aGlzLiRzbG90cy5kZWZhdWx0XSl9LG1ldGE6e3BhcmVudDpcIlN1aU1lc3NhZ2VcIn19LHVlPXtuYW1lOlwiU3VpTWVzc2FnZVwiLGNvbXBvbmVudHM6e1N1aUljb246USxTdWlNZXNzYWdlQ29udGVudDphZSxTdWlNZXNzYWdlSGVhZGVyOmNlLFN1aU1lc3NhZ2VJdGVtOmxlLFN1aU1lc3NhZ2VMaXN0OmRlfSxtaXhpbnM6W0xdLHByb3BzOntjb250ZW50Ont0eXBlOlN0cmluZyxkZXNjcmlwdGlvbjpcIlNob3J0aGFuZCBmb3IgcHJpbWFyeSBjb250ZW50LlwifSxkaXNtaXNzYWJsZTp7dHlwZTpCb29sZWFuLGRlc2NyaXB0aW9uOlwiQSBtZXNzYWdlIGNhbiBiZSBkaXNtaXNzYWJsZVwifSxoZWFkZXI6e3R5cGU6U3RyaW5nLGRlc2NyaXB0aW9uOlwiU2hvcnRoYW5kIGZvciBTdWlNZXNzYWdlSGVhZGVyLlwifSxpY29uOnt0eXBlOltCb29sZWFuLFN0cmluZ10sZGVzY3JpcHRpb246XCJBIG1lc3NhZ2UgY2FuIGNvbnRhaW4gYW4gaWNvbi5cIn0sbGlzdDp7dHlwZTpBcnJheSxkZXNjcmlwdGlvbjpcIkFycmF5IHNob3J0aGFuZCBpdGVtcyBmb3IgdGhlIFN1aU1lc3NhZ2VMaXN0XCJ9LHNpemU6XyhbXCJtaW5pXCIsXCJ0aW55XCIsXCJzbWFsbFwiLFwibGFyZ2VcIixcImJpZ1wiLFwiaHVnZVwiLFwibWFzc2l2ZVwiXSx7ZGVzY3JpcHRpb246XCJBIG1lc3NhZ2UgY2FuIGhhdmUgZGlmZmVyZW50IHNpemVzLlwifSksYXR0YWNoZWQ6XyhbXCJib3R0b21cIixcInRvcFwiXSx7dHlwZTpCb29sZWFuLGRlc2NyaXB0aW9uOlwiQSBtZXNzYWdlIGNhbiBiZSBmb3JtYXR0ZWQgdG8gYXR0YWNoIGl0c2VsZiB0byBvdGhlciBjb250ZW50LlwifSksY29sb3I6Xy5Db2xvcih7ZGVzY3JpcHRpb246XCJBIG1lc3NhZ2UgY2FuIGJlIGZvcm1hdHRlZCB0byBiZSBkaWZmZXJlbnQgY29sb3JzLlwifSksY29tcGFjdDp7dHlwZTpCb29sZWFuLGRlc2NyaXB0aW9uOlwiQSBtZXNzYWdlIGNhbiBvbmx5IHRha2UgdXAgdGhlIHdpZHRoIG9mIGl0cyBjb250ZW50LlwifSxmbG9hdGluZzp7dHlwZTpCb29sZWFuLGRlc2NyaXB0aW9uOlwiQSBtZXNzYWdlIGNhbiBmbG9hdCBhYm92ZSBjb250ZW50IHRoYXQgaXQgaXMgcmVsYXRlZCB0by5cIn0saW5mbzp7dHlwZTpCb29sZWFuLGRlc2NyaXB0aW9uOlwiQSBtZXNzYWdlIG1heSBiZSBmb3JtYXR0ZWQgdG8gZGlzcGxheSBpbmZvcm1hdGlvbi5cIn0sd2FybmluZzp7dHlwZTpCb29sZWFuLGRlc2NyaXB0aW9uOlwiQSBtZXNzYWdlIG1heSBiZSBmb3JtYXR0ZWQgdG8gZGlzcGxheSB3YXJuaW5nIG1lc3NhZ2VzLlwifSxlcnJvcjp7dHlwZTpCb29sZWFuLGRlc2NyaXB0aW9uOlwiQSBtZXNzYWdlIG1heSBiZSBmb3JtYXR0ZWQgdG8gZGlzcGxheSBhIG5lZ2F0aXZlIG1lc3NhZ2UuIFNhbWUgYXMgYG5lZ2F0aXZlYC5cIn0sbmVnYXRpdmU6e3R5cGU6Qm9vbGVhbixkZXNjcmlwdGlvbjpcIkEgbWVzc2FnZSBtYXkgYmUgZm9ybWF0dGVkIHRvIGRpc3BsYXkgYSBuZWdhdGl2ZSBtZXNzYWdlLiBTYW1lIGFzIGBlcnJvcmAuXCJ9LHN1Y2Nlc3M6e3R5cGU6Qm9vbGVhbixkZXNjcmlwdGlvbjpcIkEgbWVzc2FnZSBtYXkgYmUgZm9ybWF0dGVkIHRvIGRpc3BsYXkgYSBwb3NpdGl2ZSBtZXNzYWdlLiBTYW1lIGFzIGBwb3NpdGl2ZWAuXCJ9LHBvc2l0aXZlOnt0eXBlOkJvb2xlYW4sZGVzY3JpcHRpb246XCJBIG1lc3NhZ2UgbWF5IGJlIGZvcm1hdHRlZCB0byBkaXNwbGF5IGEgcG9zaXRpdmUgbWVzc2FnZS4gU2FtZSBhcyBgc3VjY2Vzc2AuXCJ9LGhpZGRlbjp7dHlwZTpCb29sZWFuLGRlc2NyaXB0aW9uOlwiQSBtZXNzYWdlIGNhbiBiZSBoaWRkZW4uXCJ9LHZpc2libGU6e3R5cGU6Qm9vbGVhbixkZXNjcmlwdGlvbjpcIkEgbWVzc2FnZSBjYW4gYmUgc2V0IHRvIHZpc2libGUgdG8gZm9yY2UgaXRzZWxmIHRvIGJlIHNob3duLlwifX0sZXZlbnRzOntkaXNtaXNzOntjdXN0b206ITB9fSxtZXRob2RzOntoYW5kbGVEaXNtaXNzOmZ1bmN0aW9uKCl7dGhpcy4kZW1pdChcImRpc21pc3NcIil9fSxyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHNbMF0sdD1bdGhpcy5oZWFkZXImJmUoY2UsW3RoaXMuaGVhZGVyXSksdGhpcy5jb250ZW50LHRoaXMuJHNsb3RzLmRlZmF1bHQsdGhpcy5saXN0JiZlKGRlLFt0aGlzLmxpc3QubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gZShsZSxbdF0pfSkpXSldLGk9dGhpcy5nZXRFbGVtZW50VHlwZSgpO3JldHVybiBlKGksbCgpKFt7fSx0aGlzLmdldENoaWxkUHJvcHNBbmRMaXN0ZW5lcnMoKSx7Y2xhc3M6dGhpcy5jbGFzc2VzKFwidWlcIix0aGlzLmNvbG9yLHRoaXMuc2l6ZSx0aGlzLmZsb2F0aW5nJiZcImZsb2F0aW5nXCIsdGhpcy5pbmZvJiZcImluZm9cIix0aGlzLndhcm5pbmcmJlwid2FybmluZ1wiLHRoaXMuc3VjY2VzcyYmXCJzdWNjZXNzXCIsdGhpcy5wb3NpdGl2ZSYmXCJwb3NpdGl2ZVwiLHRoaXMuZXJyb3ImJlwiZXJyb3JcIix0aGlzLm5lZ2F0aXZlJiZcIm5lZ2F0aXZlXCIsdGhpcy5hdHRhY2hlZCx0aGlzLmF0dGFjaGVkJiZcImF0dGFjaGVkXCIsdGhpcy5pY29uJiZcImljb25cIix0aGlzLmNvbXBhY3QmJlwiY29tcGFjdFwiLHRoaXMuaGlkZGVuJiZcImhpZGRlblwiLHRoaXMudmlzaWJsZSYmXCJ2aXNpYmxlXCIsXCJtZXNzYWdlXCIpfV0pLFt0aGlzLmRpc21pc3NhYmxlJiZlKFEse2F0dHJzOntuYW1lOlwiY2xvc2VcIn0sbmF0aXZlT246e2NsaWNrOnRoaXMuaGFuZGxlRGlzbWlzc319KSxcInN0cmluZ1wiPT10eXBlb2YgdGhpcy5pY29uJiZlKFEse2F0dHJzOntuYW1lOnRoaXMuaWNvbn19KSwhdGhpcy5pY29uJiZ0XSl9fSxoZT17bmFtZTpcIlN1aVRhYmxlXCIsbWl4aW5zOltMXSxkZXNjcmlwdGlvbjpcIkEgdGFibGUgZGlzcGxheXMgYSBjb2xsZWN0aW9ucyBvZiBkYXRhIGdyb3VwZWQgaW50byByb3dzLlwiLHByb3BzOntiYXNpYzpfKFtcInZlcnlcIl0se3R5cGU6Qm9vbGVhbixkZXNjcmlwdGlvbjpcIkEgdGFibGUgY2FuIHJlZHVjZSBpdHMgY29tcGxleGl0eSB0byBpbmNyZWFzZSByZWFkYWJpbGl0eS5cIn0pLGNlbGxlZDpCb29sZWFuLHBhZGRlZDpfKFtcInZlcnlcIl0se3R5cGU6Qm9vbGVhbn0pLGNvbGxhcHNpbmc6Qm9vbGVhbixjb21wYWN0Ol8oW1widmVyeVwiXSx7dHlwZTpCb29sZWFuLGRlc2NyaXB0aW9uOlwiQSB0YWJsZSBtYXkgc29tZXRpbWVzIG5lZWQgdG8gYmUgbW9yZSBjb21wYWN0IHRvIG1ha2UgbW9yZSByb3dzIHZpc2libGUgYXQgYSB0aW1lLlwifSksZGVmaW5pdGlvbjpCb29sZWFuLHN0cmlwZWQ6Qm9vbGVhbix0ZXh0QWxpZ246XyhbXCJsZWZ0XCIsXCJyaWdodFwiLFwiY2VudGVyXCJdKSxmaXhlZDpCb29sZWFuLHVuc3RhY2thYmxlOkJvb2xlYW4sc3RhY2thYmxlOkJvb2xlYW4sc2VsZWN0YWJsZTpCb29sZWFuLGludmVydGVkOkJvb2xlYW4sY29sb3I6Xy5Db2xvcigpLHNpemU6XyhbXCJzbWFsbFwiLFwibGFyZ2VcIl0pLHNpbmdsZUxpbmU6Qm9vbGVhbixjb2x1bW5zOl8uTnVtYmVyKCl9LHJlbmRlcjpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50c1swXSx0PXRoaXMuZ2V0RWxlbWVudFR5cGUoXCJ0YWJsZVwiKTtyZXR1cm4gZSh0LGwoKShbe30sdGhpcy5nZXRDaGlsZFByb3BzQW5kTGlzdGVuZXJzKCkse2NsYXNzOnRoaXMuY2xhc3NlcyhcInVpXCIsdGhpcy50ZXh0QWxpZ24sdGhpcy50ZXh0QWxpZ24mJlwiYWxpZ25lZFwiLHRoaXMuYmFzaWMsdGhpcy5iYXNpYyYmXCJiYXNpY1wiLHRoaXMuY2VsbGVkJiZcImNlbGxlZFwiLHRoaXMucGFkZGVkLHRoaXMucGFkZGVkJiZcInBhZGRlZFwiLHRoaXMuY29sbGFwc2luZyYmXCJjb2xsYXBzaW5nXCIsdGhpcy5jb21wYWN0LHRoaXMuY29tcGFjdCYmXCJjb21wYWN0XCIsdGhpcy5kZWZpbml0aW9uJiZcImRlZmluaXRpb25cIix0aGlzLnN0cmlwZWQmJlwic3RyaXBlZFwiLHRoaXMuZml4ZWQmJlwiZml4ZWRcIix0aGlzLnVuc3RhY2thYmxlJiZcInVuc3RhY2thYmxlXCIsdGhpcy5zdGFja2FibGUmJlwidGFibGV0IHN0YWNrYWJsZVwiLHRoaXMuc2VsZWN0YWJsZSYmXCJzZWxlY3RhYmxlXCIsdGhpcy5pbnZlcnRlZCYmXCJpbnZlcnRlZFwiLHRoaXMuY29sb3IsdGhpcy5zaXplLHRoaXMuc2luZ2xlTGluZSYmXCJzaW5nbGUgbGluZVwiLHRoaXMuY29sdW1ucyYmXCJcIi5jb25jYXQodGhpcy5udW0odGhpcy5jb2x1bW5zKSxcIiBjb2x1bW5cIiksXCJ0YWJsZVwiKX1dKSxbdGhpcy4kc2xvdHMuZGVmYXVsdF0pfX0scGU9e25hbWU6XCJTdWlUYWJsZUJvZHlcIixtaXhpbnM6W0xdLHJlbmRlcjpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50c1swXSx0PXRoaXMuZ2V0RWxlbWVudFR5cGUoXCJ0Ym9keVwiKTtyZXR1cm4gZSh0LGwoKShbe30sdGhpcy5nZXRDaGlsZFByb3BzQW5kTGlzdGVuZXJzKCldKSxbdGhpcy4kc2xvdHMuZGVmYXVsdF0pfSxtZXRhOntwYXJlbnQ6XCJTdWlUYWJsZVwifX0sZmU9e25hbWU6XCJTdWlUYWJsZUNlbGxcIixtaXhpbnM6W0xdLHByb3BzOntuZWdhdGl2ZTpCb29sZWFuLHBvc2l0aXZlOkJvb2xlYW4sc2VsZWN0ZWQ6Qm9vbGVhbix0ZXh0QWxpZ246XyhbXCJsZWZ0XCIsXCJyaWdodFwiLFwiY2VudGVyXCJdKSx3YXJuaW5nOkJvb2xlYW4sc2luZ2xlTGluZTpCb29sZWFuLGNvbGxhcHNpbmc6Qm9vbGVhbixkaXNhYmxlZDpCb29sZWFuLHNlbGVjdGFibGU6Qm9vbGVhbix3aWR0aDpfLk51bWJlcigpLHN0YXRlOl8uU3RhdGUoKSx2ZXJ0aWNhbEFsaWduOl8uVmVydGljYWxBbGlnbigpfSxyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHNbMF0sdD10aGlzLmdldEVsZW1lbnRUeXBlKFwidGRcIik7cmV0dXJuIGUodCxsKCkoW3t9LHRoaXMuZ2V0Q2hpbGRQcm9wc0FuZExpc3RlbmVycygpLHtjbGFzczp0aGlzLmNsYXNzZXModGhpcy50ZXh0QWxpZ24mJlwiXCIuY29uY2F0KHRoaXMudGV4dEFsaWduLFwiIGFsaWduZWRcIiksdGhpcy52ZXJ0aWNhbEFsaWduJiZcIlwiLmNvbmNhdCh0aGlzLnZlcnRpY2FsQWxpZ24sXCIgYWxpZ25lZFwiKSx0aGlzLm5lZ2F0aXZlJiZcIm5lZ2F0aXZlXCIsdGhpcy5wb3NpdGl2ZSYmXCJwb3NpdGl2ZVwiLHRoaXMud2FybmluZyYmXCJ3YXJuaW5nXCIsdGhpcy5zaW5nbGVMaW5lJiZcInNpbmdsZSBsaW5lXCIsdGhpcy5jb2xsYXBzaW5nJiZcImNvbGxhcHNpbmdcIix0aGlzLmRpc2FibGVkJiZcImRpc2FibGVkXCIsdGhpcy5zZWxlY3RhYmxlJiZcInNlbGVjdGFibGVcIix0aGlzLndpZHRoJiZcIlwiLmNvbmNhdCh0aGlzLm51bSh0aGlzLndpZHRoKSxcIiB3aWRlXCIpLHRoaXMuc3RhdGUpfV0pLFt0aGlzLiRzbG90cy5kZWZhdWx0XSl9LG1ldGE6e3BhcmVudDpcIlN1aVRhYmxlXCJ9fSxtZT17bmFtZTpcIlN1aVRhYmxlRm9vdGVyXCIsbWl4aW5zOltMXSxwcm9wczp7ZnVsbFdpZHRoOkJvb2xlYW59LHJlbmRlcjpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50c1swXSx0PXRoaXMuZ2V0RWxlbWVudFR5cGUoXCJ0Zm9vdFwiKTtyZXR1cm4gZSh0LGwoKShbe30sdGhpcy5nZXRDaGlsZFByb3BzQW5kTGlzdGVuZXJzKCkse2NsYXNzOnRoaXMuY2xhc3Nlcyh0aGlzLmZ1bGxXaWR0aCYmXCJmdWxsLXdpZHRoXCIpfV0pLFt0aGlzLiRzbG90cy5kZWZhdWx0XSl9LG1ldGE6e3BhcmVudDpcIlN1aVRhYmxlXCJ9fSxnZT17bmFtZTpcIlN1aVRhYmxlSGVhZGVyXCIsbWl4aW5zOltMXSxwcm9wczp7ZnVsbFdpZHRoOkJvb2xlYW59LHJlbmRlcjpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50c1swXSx0PXRoaXMuZ2V0RWxlbWVudFR5cGUoXCJ0aGVhZFwiKTtyZXR1cm4gZSh0LGwoKShbe30sdGhpcy5nZXRDaGlsZFByb3BzQW5kTGlzdGVuZXJzKCkse2NsYXNzOnRoaXMuY2xhc3Nlcyh0aGlzLmZ1bGxXaWR0aCYmXCJmdWxsLXdpZHRoXCIpfV0pLFt0aGlzLiRzbG90cy5kZWZhdWx0XSl9LG1ldGE6e3BhcmVudDpcIlN1aVRhYmxlXCJ9fSxiZT17bmFtZTpcIlN1aVRhYmxlSGVhZGVyQ2VsbFwiLG1peGluczpbTF0scHJvcHM6e25lZ2F0aXZlOkJvb2xlYW4scG9zaXRpdmU6Qm9vbGVhbixzZWxlY3RlZDpCb29sZWFuLHRleHRBbGlnbjpfKFtcImxlZnRcIixcInJpZ2h0XCIsXCJjZW50ZXJcIl0pLHdhcm5pbmc6Qm9vbGVhbixzaW5nbGVMaW5lOkJvb2xlYW4sY29sbGFwc2luZzpCb29sZWFuLGRpc2FibGVkOkJvb2xlYW4sc2VsZWN0YWJsZTpCb29sZWFuLHdpZHRoOl8uTnVtYmVyKCksdmVydGljYWxBbGlnbjpfLlZlcnRpY2FsQWxpZ24oKX0scmVuZGVyOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzWzBdLHQ9dGhpcy5nZXRFbGVtZW50VHlwZShcInRoXCIpO3JldHVybiBlKHQsbCgpKFt7fSx0aGlzLmdldENoaWxkUHJvcHNBbmRMaXN0ZW5lcnMoKSx7Y2xhc3M6dGhpcy5jbGFzc2VzKHRoaXMudGV4dEFsaWduJiZcIlwiLmNvbmNhdCh0aGlzLnRleHRBbGlnbixcIiBhbGlnbmVkXCIpLHRoaXMudmVydGljYWxBbGlnbiYmXCJcIi5jb25jYXQodGhpcy52ZXJ0aWNhbEFsaWduLFwiIGFsaWduZWRcIiksdGhpcy5uZWdhdGl2ZSYmXCJuZWdhdGl2ZVwiLHRoaXMucG9zaXRpdmUmJlwicG9zaXRpdmVcIix0aGlzLndhcm5pbmcmJlwid2FybmluZ1wiLHRoaXMuc2luZ2xlTGluZSYmXCJzaW5nbGUgbGluZVwiLHRoaXMuY29sbGFwc2luZyYmXCJjb2xsYXBzaW5nXCIsdGhpcy5kaXNhYmxlZCYmXCJkaXNhYmxlZFwiLHRoaXMuc2VsZWN0YWJsZSYmXCJzZWxlY3RhYmxlXCIsdGhpcy53aWR0aCYmXCJcIi5jb25jYXQodGhpcy5udW0odGhpcy53aWR0aCksXCIgd2lkZVwiKSl9XSksW3RoaXMuJHNsb3RzLmRlZmF1bHRdKX0sbWV0YTp7cGFyZW50OlwiU3VpVGFibGVcIn19LHllPXtuYW1lOlwiU3VpVGFibGVSb3dcIixtaXhpbnM6W0xdLHByb3BzOnthY3RpdmU6e2Rlc2NyaXB0aW9uOlwiQSByb3cgY2FuIGJlIGFjdGl2ZSBvciBzZWxlY3RlZCBieSBhIHVzZXIuXCIsdHlwZTpCb29sZWFufSxkaXNhYmxlZDp7ZGVzY3JpcHRpb246XCJBIHJvdyBjYW4gYmUgZGlzYWJsZWQuXCIsdHlwZTpCb29sZWFufSxlcnJvcjp7ZGVzY3JpcHRpb246XCJBIHJvdyBtYXkgY2FsbCBhdHRlbnRpb24gdG8gYW4gZXJyb3Igb3IgYSBuZWdhdGl2ZSB2YWx1ZS5cIix0eXBlOkJvb2xlYW59LG5lZ2F0aXZlOntkZXNjcmlwdGlvbjpcIkEgcm93IG1heSBsZXQgYSB1c2VyIGtub3cgd2hldGhlciBhIHZhbHVlIGlzIGJhZC5cIix0eXBlOkJvb2xlYW59LHBvc2l0aXZlOntkZXNjcmlwdGlvbjpcIkEgcm93IG1heSBsZXQgYSB1c2VyIGtub3cgd2hldGhlciBhIHZhbHVlIGlzIGdvb2QuXCIsdHlwZTpCb29sZWFufSxzZWxlY3RlZDp7ZGVzY3JpcHRpb246XCJERVBSRUNBVEVEIEEgcm93IGNhbiBiZSBhY3RpdmUgb3Igc2VsZWN0ZWQgYnkgYSB1c2VyLlwiLHR5cGU6Qm9vbGVhbn0sc3RhdGU6Xy5TdGF0ZSh7ZGVzY3JpcHRpb246XCJERVBSRUNBVEVEXCJ9KSx0ZXh0QWxpZ246XyhbXCJsZWZ0XCIsXCJyaWdodFwiLFwiY2VudGVyXCJdLHtkZXNjcmlwdGlvbjpcIkEgdGFibGUgcm93IGNhbiBhZGp1c3QgaXRzIHRleHQgYWxpZ25tZW50LlwifSksdmVydGljYWxBbGlnbjpfLlZlcnRpY2FsQWxpZ24oe2Rlc2NyaXB0aW9uOlwiQSByb3cgbWF5IHdhcm4gYSB1c2VyLlwifSksd2FybmluZzp7ZGVzY3JpcHRpb246XCJBIHJvdyBtYXkgd2FybiBhIHVzZXIuXCIsdHlwZTpCb29sZWFufX0scmVuZGVyOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzWzBdLHQ9dGhpcy5nZXRFbGVtZW50VHlwZShcInRyXCIpO3JldHVybiBlKHQsbCgpKFt7fSx0aGlzLmdldENoaWxkUHJvcHNBbmRMaXN0ZW5lcnMoKSx7Y2xhc3M6dGhpcy5jbGFzc2VzKHRoaXMudGV4dEFsaWduJiZcIlwiLmNvbmNhdCh0aGlzLnRleHRBbGlnbixcIiBhbGlnbmVkXCIpLHRoaXMudmVydGljYWxBbGlnbiYmXCJcIi5jb25jYXQodGhpcy52ZXJ0aWNhbEFsaWduLFwiIGFsaWduZWRcIiksdGhpcy5kaXNhYmxlZCYmXCJkaXNhYmxlZFwiLHRoaXMuZXJyb3ImJlwiZXJyb3JcIix0aGlzLm5lZ2F0aXZlJiZcIm5lZ2F0aXZlXCIsdGhpcy5wb3NpdGl2ZSYmXCJwb3NpdGl2ZVwiLCh0aGlzLnNlbGVjdGVkfHx0aGlzLmFjdGl2ZSkmJlwiYWN0aXZlXCIsdGhpcy53YXJuaW5nJiZcIndhcm5pbmdcIix0aGlzLnN0YXRlKX1dKSxbdGhpcy4kc2xvdHMuZGVmYXVsdF0pfSxtZXRhOntwYXJlbnQ6XCJTdWlUYWJsZVwifX07ZnVuY3Rpb24gdmUoZSx0KXt2YXIgaT10LmFyZztlLmNsYXNzTGlzdC5yZW1vdmUoXCJsZWZ0XCIpLGUuY2xhc3NMaXN0LnJlbW92ZShcInJpZ2h0XCIpLGUuY2xhc3NMaXN0LnJlbW92ZShcImZsb2F0ZWRcIiksZS5jbGFzc0xpc3QuYWRkKGkpLGUuY2xhc3NMaXN0LmFkZChcImZsb2F0ZWRcIil9dmFyIFNlPXtuYW1lOlwiU3VpQnV0dG9uXCIsZGVzY3JpcHRpb246XCJBIGJ1dHRvbiBpbmRpY2F0ZXMgYSBwb3NzaWJsZSB1c2VyIGFjdGlvblwiLG1peGluczpbTF0scHJvcHM6e2FjdGl2ZTp7dHlwZTpCb29sZWFuLGRlc2NyaXB0aW9uOlwiQSBidXR0b24gY2FuIHNob3cgaXQgaXMgY3VycmVudGx5IHRoZSBhY3RpdmUgdXNlciBzZWxlY3Rpb24uXCJ9LGFuaW1hdGVkOl8oW1wiZmFkZVwiLFwidmVydGljYWxcIl0se3R5cGU6Qm9vbGVhbixkZXNjcmlwdGlvbjpcIkEgYnV0dG9uIGNhbiBhbmltYXRlIHRvIHNob3cgaGlkZGVuIGNvbnRlbnQuXCJ9KSxhdHRhY2hlZDpfKFtcImxlZnRcIixcInJpZ2h0XCIsXCJ0b3BcIixcImJvdHRvbVwiXSx7ZGVzY3JpcHRpb246XCJBIGJ1dHRvbiBjYW4gYmUgYXR0YWNoZWQgdG8gdGhlIHRvcCBvciBib3R0b20gb2Ygb3RoZXIgY29udGVudC5cIn0pLGJhc2ljOnt0eXBlOkJvb2xlYW4sZGVzY3JpcHRpb246XCJBIGJhc2ljIGJ1dHRvbiBpcyBsZXNzIHByb25vdW5jZWQuXCJ9LGNpcmN1bGFyOnt0eXBlOkJvb2xlYW4sZGVzY3JpcHRpb246XCJBIGJ1dHRvbiBjYW4gYmUgY2lyY3VsYXIuXCJ9LGNsYXNzTmFtZTp7dHlwZTpTdHJpbmcsZGVzY3JpcHRpb246XCJBZGRpdGlvbmFsIGNsYXNzZXMuXCJ9LGNvbG9yOl8uQ29sb3IoKSxjb21wYWN0Ont0eXBlOkJvb2xlYW4sZGVzY3JpcHRpb246XCJBIGJ1dHRvbiBjYW4gcmVkdWNlIGl0cyBwYWRkaW5nIHRvIGZpdCBpbnRvIHRpZ2h0ZXIgc3BhY2VzLlwifSxjb250ZW50Ont0eXBlOlN0cmluZyxkZXNjcmlwdGlvbjpcIlNob3J0aGFuZCBmb3IgcHJpbWFyeSBjb250ZW50LlwifSxkaXNhYmxlZDp7dHlwZTpCb29sZWFuLGRlc2NyaXB0aW9uOlwiQSBidXR0b24gY2FuIHNob3cgaXQgaXMgY3VycmVudGx5IHVuYWJsZSB0byBiZSBpbnRlcmFjdGVkIHdpdGguXCJ9LGZsb2F0ZWQ6XyhbXCJsZWZ0XCIsXCJyaWdodFwiXSx7ZGVzY3JpcHRpb246XCJBIGJ1dHRvbiBjYW4gYmUgYWxpZ25lZCB0byB0aGUgbGVmdCBvciByaWdodCBvZiBpdHMgY29udGFpbmVyLlwifSksZmx1aWQ6e3R5cGU6Qm9vbGVhbixkZXNjcmlwdGlvbjpcIkEgYnV0dG9uIGNhbiB0YWtlIHRoZSB3aWR0aCBvZiBpdHMgY29udGFpbmVyLlwifSxpY29uOltCb29sZWFuLFN0cmluZ10saW52ZXJ0ZWQ6e3R5cGU6Qm9vbGVhbixkZXNjcmlwdGlvbjpcIkEgYnV0dG9uIGNhbiBiZSBmb3JtYXR0ZWQgdG8gYXBwZWFyIG9uIGRhcmsgYmFja2dyb3VuZHMuXCJ9LGxhYmVsUG9zaXRpb246XyhbXCJsZWZ0XCIsXCJyaWdodFwiXSx7ZGVzY3JpcHRpb246XCJBIGxhYmVsZWQgYnV0dG9uIGNhbiBmb3JtYXQgYSBMYWJlbCBvciBJY29uIHRvIGFwcGVhciBvbiB0aGUgbGVmdCBvciByaWdodC5cIn0pLGxvYWRpbmc6e3R5cGU6Qm9vbGVhbixkZXNjcmlwdGlvbjpcIkEgYnV0dG9uIGNhbiBzaG93IGEgbG9hZGluZyBpbmRpY2F0b3IuXCJ9LG5lZ2F0aXZlOnt0eXBlOkJvb2xlYW4sZGVzY3JpcHRpb246XCJBIGJ1dHRvbiBjYW4gaGludCB0b3dhcmRzIGEgbmVnYXRpdmUgY29uc2VxdWVuY2UuXCJ9LHBvc2l0aXZlOnt0eXBlOkJvb2xlYW4sZGVzY3JpcHRpb246XCJBIGJ1dHRvbiBjYW4gaGludCB0b3dhcmRzIGEgcG9zaXRpdmUgY29uc2VxdWVuY2UuXCJ9LHByaW1hcnk6e3R5cGU6Qm9vbGVhbixkZXNjcmlwdGlvbjpcIkEgYnV0dG9uIGNhbiBiZSBmb3JtYXR0ZWQgdG8gc2hvdyBkaWZmZXJlbnQgbGV2ZWxzIG9mIGVtcGhhc2lzLlwifSxzZWNvbmRhcnk6e3R5cGU6Qm9vbGVhbixkZXNjcmlwdGlvbjpcIkEgYnV0dG9uIGNhbiBiZSBmb3JtYXR0ZWQgdG8gc2hvdyBkaWZmZXJlbnQgbGV2ZWxzIG9mIGVtcGhhc2lzLlwifSxzaXplOl8uU2l6ZSgpLHRhYkluZGV4Ont0eXBlOltOdW1iZXIsU3RyaW5nXSxkZXNjcmlwdGlvbjpcIkEgYnV0dG9uIGNhbiByZWNlaXZlIGZvY3VzLlwifSx0b2dnbGU6e3R5cGU6Qm9vbGVhbixkZXNjcmlwdGlvbjpcIkEgYnV0dG9uIGNhbiBiZSBmb3JtYXR0ZWQgdG8gdG9nZ2xlIG9uIGFuZCBvZmYuXCJ9LHNvY2lhbDpfLlNvY2lhbCgpfSxtZXRhOntldmVudHM6e2NsaWNrOntkZXNjcmlwdGlvbjpcIkNsaWNrIGV2ZW50IHBhc3NlZCB0byB0aGUgYnV0dG9uLlwiLHZhbHVlOlwiRXZlbnRcIn19LHNsb3RzOntkZWZhdWx0OntkZXNjcmlwdGlvbjpcIlByaW1hcnkgY29udGVudC5cIn19fSxjb21wdXRlZDp7aGFzSWNvbkNsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuISF0aGlzLmljb24mJihcInN0cmluZ1wiIT10eXBlb2YgdGhpcy5pY29ufHwhKHRoaXMuY29udGVudHx8dGhpcy4kc2xvdHMuZGVmYXVsdCkpfX0scmVuZGVyOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzWzBdLHQ9dGhpcy5nZXRFbGVtZW50VHlwZShcImJ1dHRvblwiKSxpPXRoaXMuJHNsb3RzLmxhYmVsLG49dGhpcy5jbGFzc2VzKFwidWlcIix0aGlzLmFjdGl2ZSYmXCJhY3RpdmVcIix0aGlzLmF0dGFjaGVkJiZcIlwiLmNvbmNhdCh0aGlzLmF0dGFjaGVkLFwiIGF0dGFjaGVkXCIpLHRoaXMuYW5pbWF0ZWQsdGhpcy5hbmltYXRlZCYmXCJhbmltYXRlZFwiLHRoaXMuYmFzaWMmJlwiYmFzaWNcIix0aGlzLmNpcmN1bGFyJiZcImNpcmN1bGFyXCIsdGhpcy5jbGFzc05hbWUsdGhpcy5jb2xvcix0aGlzLmNvbXBhY3QmJlwiY29tcGFjdFwiLHRoaXMuZGlzYWJsZWQmJlwiZGlzYWJsZWRcIix0aGlzLmZsb2F0ZWQmJlwiXCIuY29uY2F0KHRoaXMuZmxvYXRlZCxcIiBmbG9hdGVkXCIpLHRoaXMuZmx1aWQmJlwiZmx1aWRcIix0aGlzLmhhc0ljb25DbGFzcyYmXCJpY29uXCIsIWkmJnRoaXMuaWNvbiYmdGhpcy5sYWJlbFBvc2l0aW9uJiZcImljb25cIix0aGlzLmludmVydGVkJiZcImludmVydGVkXCIsIWkmJnRoaXMubGFiZWxQb3NpdGlvbiYmdGhpcy5sYWJlbFBvc2l0aW9uLCFpJiZ0aGlzLmxhYmVsUG9zaXRpb24mJlwibGFiZWxlZFwiLHRoaXMubG9hZGluZyYmXCJsb2FkaW5nXCIsdGhpcy50b2dnbGUmJlwidG9nZ2xlXCIsdGhpcy5uZWdhdGl2ZSYmXCJuZWdhdGl2ZVwiLHRoaXMucG9zaXRpdmUmJlwicG9zaXRpdmVcIix0aGlzLnByaW1hcnkmJlwicHJpbWFyeVwiLHRoaXMuc2Vjb25kYXJ5JiZcInNlY29uZGFyeVwiLHRoaXMuc29jaWFsLHRoaXMuc2l6ZSxcImJ1dHRvblwiKSxyPWUodCxsKCkoW3t9LHRoaXMuZ2V0Q2hpbGRQcm9wc0FuZExpc3RlbmVycygpLHtjbGFzczpuLGF0dHJzOntyb2xlOlwiYnV0dG9uXCJ9fV0pLFtcInN0cmluZ1wiPT10eXBlb2YgdGhpcy5pY29uJiZlKFEse2F0dHJzOntuYW1lOnRoaXMuaWNvbn19KSx0aGlzLmNvbnRlbnR8fHRoaXMuJHNsb3RzLmRlZmF1bHRdKTtyZXR1cm4gaT9lKFwiZGl2XCIse2NsYXNzOnRoaXMuY2xhc3NlcyhcInVpXCIsdGhpcy5sYWJlbFBvc2l0aW9uLFwibGFiZWxlZFwiLFwiYnV0dG9uXCIpfSxbXCJsZWZ0XCI9PT10aGlzLmxhYmVsUG9zaXRpb24mJmkscixcImxlZnRcIiE9PXRoaXMubGFiZWxQb3NpdGlvbiYmaV0pOnJ9fSx3ZT17bmFtZTpcIlN1aUJ1dHRvbkNvbnRlbnRcIixtaXhpbnM6W0xdLHByb3BzOnt2aXNpYmxlOnt0eXBlOkJvb2xlYW59LGhpZGRlbjp7dHlwZTpCb29sZWFufX0scmVuZGVyOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzWzBdLHQ9dGhpcy5nZXRFbGVtZW50VHlwZShcImRpdlwiKSxpPXRoaXMuY2xhc3Nlcyh0aGlzLnZpc2libGUmJlwidmlzaWJsZVwiLHRoaXMuaGlkZGVuJiZcImhpZGRlblwiLFwiY29udGVudFwiKTtyZXR1cm4gZSh0LGwoKShbe30sdGhpcy5nZXRDaGlsZFByb3BzQW5kTGlzdGVuZXJzKCkse2NsYXNzOml9XSksW3RoaXMuY29udGVudHx8dGhpcy4kc2xvdHMuZGVmYXVsdF0pfSxtZXRhOntwYXJlbnQ6XCJTdWlCdXR0b25cIn19LEFlPXtuYW1lOlwiU3VpQnV0dG9uR3JvdXBcIixtaXhpbnM6W0xdLHByb3BzOnthdHRhY2hlZDpfKFtcInRvcFwiLFwiYm90dG9tXCJdKSx3aWR0aHM6Xy5OdW1iZXIoKSx2ZXJ0aWNhbDpCb29sZWFuLGxhYmVsZWQ6Qm9vbGVhbixpY29uczpCb29sZWFuLGNvbG9yOl8uQ29sb3IoKSxiYXNpYzpCb29sZWFuLHNpemU6Xy5TaXplKCl9LHJlbmRlcjpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50c1swXSx0PXRoaXMuZ2V0RWxlbWVudFR5cGUoKTtyZXR1cm4gZSh0LGwoKShbe30sdGhpcy5nZXRDaGlsZFByb3BzQW5kTGlzdGVuZXJzKCkse2NsYXNzOnRoaXMuY2xhc3NlcyhcInVpXCIsdGhpcy5zaXplLHRoaXMuY29sb3IsdGhpcy5hdHRhY2hlZCx0aGlzLmF0dGFjaGVkJiZcImF0dGFjaGVkXCIsdGhpcy5udW0odGhpcy53aWR0aHMpLHRoaXMudmVydGljYWwmJlwidmVydGljYWxcIix0aGlzLmxhYmVsZWQmJlwibGFiZWxlZFwiLHRoaXMuaWNvbnMmJlwiaWNvblwiLHRoaXMuYmFzaWMmJlwiYmFzaWNcIixcImJ1dHRvbnNcIil9XSksW3RoaXMuJHNsb3RzLmRlZmF1bHRdKX0sbWV0YTp7cGFyZW50OlwiU3VpQnV0dG9uXCJ9fTtmdW5jdGlvbiBPZShlLHQpe3ZhciBpPU9iamVjdC5rZXlzKGUpO2lmKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpe3ZhciBuPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7dCYmKG49bi5maWx0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsdCkuZW51bWVyYWJsZX0pKSksaS5wdXNoLmFwcGx5KGksbil9cmV0dXJuIGl9ZnVuY3Rpb24geGUoZSl7Zm9yKHZhciB0PTE7dDxhcmd1bWVudHMubGVuZ3RoO3QrKyl7dmFyIGk9bnVsbCE9YXJndW1lbnRzW3RdP2FyZ3VtZW50c1t0XTp7fTt0JTI/T2UoT2JqZWN0KGkpLCEwKS5mb3JFYWNoKChmdW5jdGlvbih0KXtQZShlLHQsaVt0XSl9KSk6T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM/T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhpKSk6T2UoT2JqZWN0KGkpKS5mb3JFYWNoKChmdW5jdGlvbih0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaSx0KSl9KSl9cmV0dXJuIGV9ZnVuY3Rpb24gUGUoZSx0LGkpe3JldHVybiB0IGluIGU/T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCx7dmFsdWU6aSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOmVbdF09aSxlfXZhciBCZT17bmFtZTpcIlN1aUJ1dHRvbk9yXCIsbWl4aW5zOltMXSxwcm9wczp7dGV4dDpTdHJpbmd9LHJlbmRlcjpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50c1swXSx0PXRoaXMuZ2V0RWxlbWVudFR5cGUoKSxpPXt9O3JldHVybiB0aGlzLnRleHQmJihpW1wiZGF0YS10ZXh0XCJdPXRoaXMudGV4dCksZSh0LGwoKShbe30sdGhpcy5nZXRDaGlsZFByb3BzQW5kTGlzdGVuZXJzKCkse2NsYXNzOlwib3JcIixhdHRyczp4ZSh7fSxpKX1dKSl9LG1ldGE6e3BhcmVudDpcIlN1aUJ1dHRvblwifX0sQ2U9e25hbWU6XCJTdWlDb250YWluZXJcIixtaXhpbnM6W0xdLHByb3BzOntmbHVpZDp7dHlwZTpCb29sZWFuLGRlc2NyaXB0aW9uOlwiQ29udGFpbmVyIGhhcyBubyBtYXhpbXVtIHdpZHRoLlwifSx0ZXh0Ont0eXBlOkJvb2xlYW4sZGVzY3JpcHRpb246XCJSZWR1Y2UgbWF4aW11bSB3aWR0aCB0byBtb3JlIG5hdHVyYWxseSBhY2NvbW1vZGF0ZSB0ZXh0LlwifSx0ZXh0QWxpZ246Xy5UZXh0QWxpZ24oe2Rlc2NyaXB0aW9uOlwiQWxpZ24gY29udGFpbmVyIHRleHQuXCJ9KX0scmVuZGVyOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzWzBdLHQ9dGhpcy5nZXRFbGVtZW50VHlwZSgpO3JldHVybiBlKHQsbCgpKFt7fSx0aGlzLmdldENoaWxkUHJvcHNBbmRMaXN0ZW5lcnMoKSx7Y2xhc3M6dGhpcy5jbGFzc2VzKFwidWlcIixJKHRoaXMudGV4dEFsaWduKSx0aGlzLnRleHQmJlwidGV4dFwiLHRoaXMuZmx1aWQmJlwiZmx1aWRcIixcImNvbnRhaW5lclwiKX1dKSxbdGhpcy4kc2xvdHMuZGVmYXVsdF0pfX0samU9e25hbWU6XCJTdWlEaXZpZGVyXCIsbWl4aW5zOltMXSxwcm9wczp7Y2xlYXJpbmc6Qm9vbGVhbixmaXR0ZWQ6Qm9vbGVhbixoaWRkZW46Qm9vbGVhbixob3Jpem9udGFsOkJvb2xlYW4saW52ZXJ0ZWQ6Qm9vbGVhbix2ZXJ0aWNhbDpCb29sZWFufSxyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHNbMF0sdD10aGlzLmdldEVsZW1lbnRUeXBlKCk7cmV0dXJuIGUodCxsKCkoW3t9LHRoaXMuZ2V0Q2hpbGRQcm9wc0FuZExpc3RlbmVycygpLHtjbGFzczp0aGlzLmNsYXNzZXMoXCJ1aVwiLHRoaXMuY2xlYXJpbmcmJlwiY2xlYXJpbmdcIix0aGlzLmZpdHRlZCYmXCJmaXR0ZWRcIix0aGlzLmhpZGRlbiYmXCJoaWRkZW5cIix0aGlzLmhvcml6b250YWwmJlwiaG9yaXpvbnRhbFwiLHRoaXMudmVydGljYWwmJlwidmVydGljYWxcIix0aGlzLmludmVydGVkJiZcImludmVydGVkXCIsXCJkaXZpZGVyXCIpfV0pLFt0aGlzLiRzbG90cy5kZWZhdWx0XSl9fSxFZT17bmFtZTpcIlN1aUZsYWdcIixtaXhpbnM6W0xdLHByb3BzOntuYW1lOlN0cmluZ30scmVuZGVyOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzWzBdLHQ9dGhpcy5nZXRFbGVtZW50VHlwZShcImlcIik7cmV0dXJuIGUodCxsKCkoW3t9LHRoaXMuZ2V0Q2hpbGRQcm9wc0FuZExpc3RlbmVycygpLHtjbGFzczp0aGlzLmNsYXNzZXMoXCJmbGFnXCIsdGhpcy5uYW1lKX1dKSl9fSxUZT17bmFtZTpcIlN1aUhlYWRlclwiLG1peGluczpbTF0scHJvcHM6e2NvbG9yOl8uQ29sb3IoKSxjb250ZW50OlN0cmluZyxkaXZpZGluZzpCb29sZWFuLGRpc2FibGVkOkJvb2xlYW4sZmxvYXRlZDpfKFtcImxlZnRcIixcInJpZ2h0XCJdKSxpY29uOnt0eXBlOltCb29sZWFuLFN0cmluZ10sZGVmYXVsdDohMX0saW1hZ2U6e3R5cGU6U3RyaW5nLGRlc2NyaXB0aW9uOlwiQWRkIGFuIGltYWdlIGJ5IGltZyBzcmMgb3IgcGFzcyBhbiBJbWFnZS5cIn0sc2l6ZTpfLlNpemUoKSxzdWI6Qm9vbGVhbix0ZXh0QWxpZ246XyhbXCJsZWZ0XCIsXCJyaWdodFwiLFwiY2VudGVyXCIsXCJqdXN0aWZ5XCJdKSxibG9jazpCb29sZWFuLGF0dGFjaGVkOl8oW1widG9wXCIsXCJib3R0b21cIl0se3R5cGU6Qm9vbGVhbn0pLGludmVydGVkOkJvb2xlYW59LHJlbmRlcjpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50c1swXSx0PXRoaXMuZ2V0RWxlbWVudFR5cGUoKTtyZXR1cm4gZSh0LGwoKShbe30sdGhpcy5nZXRDaGlsZFByb3BzQW5kTGlzdGVuZXJzKCkse2NsYXNzOnRoaXMuY2xhc3NlcyhcInVpXCIsdGhpcy5mbG9hdGVkJiZcIlwiLmNvbmNhdCh0aGlzLmZsb2F0ZWQsXCIgZmxvYXRlZFwiKSxJKHRoaXMudGV4dEFsaWduKSx0aGlzLmF0dGFjaGVkLHRoaXMuYXR0YWNoZWQmJlwiYXR0YWNoZWRcIix0aGlzLmNvbG9yLHRoaXMuc2l6ZSx0aGlzLmljb24mJlwiaWNvblwiLHRoaXMuYmxvY2smJlwiYmxvY2tcIix0aGlzLmRpdmlkaW5nJiZcImRpdmlkaW5nXCIsdGhpcy5pbWFnZSYmXCJpbWFnZVwiLHRoaXMuc3ViJiZcInN1YlwiLHRoaXMuZGlzYWJsZWQmJlwiZGlzYWJsZWRcIix0aGlzLmludmVydGVkJiZcImludmVydGVkXCIsXCJoZWFkZXJcIil9XSksW3RoaXMuaWNvbiE9PSEhdGhpcy5pY29uJiZlKFEse2F0dHJzOntuYW1lOnRoaXMuaWNvbn19KSx0aGlzLmltYWdlJiZlKFwiaW1nXCIse2F0dHJzOntzcmM6dGhpcy5pbWFnZX0sY2xhc3M6XCJ1aSBpbWFnZVwifSksdGhpcy4kc2xvdHMuZGVmYXVsdHx8dGhpcy5jb250ZW50XSl9fSwkZT17bmFtZTpcIlN1aUhlYWRlckNvbnRlbnRcIixtaXhpbnM6W0xdLHJlbmRlcjpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50c1swXSx0PXRoaXMuZ2V0RWxlbWVudFR5cGUoKTtyZXR1cm4gZSh0LGwoKShbe30sdGhpcy5nZXRDaGlsZFByb3BzQW5kTGlzdGVuZXJzKCkse2NsYXNzOlwiY29udGVudFwifV0pLFt0aGlzLiRzbG90cy5kZWZhdWx0XSl9LG1ldGE6e3BhcmVudDpcIlN1aUhlYWRlclwifX0sTGU9e25hbWU6XCJTdWlIZWFkZXJTdWJoZWFkZXJcIixtaXhpbnM6W0xdLHJlbmRlcjpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50c1swXSx0PXRoaXMuZ2V0RWxlbWVudFR5cGUoKTtyZXR1cm4gZSh0LGwoKShbe30sdGhpcy5nZXRDaGlsZFByb3BzQW5kTGlzdGVuZXJzKCkse2NsYXNzOlwic3ViIGhlYWRlclwifV0pLFt0aGlzLiRzbG90cy5kZWZhdWx0XSl9LG1ldGE6e3BhcmVudDpcIlN1aUhlYWRlclwifX0sa2U9e25hbWU6XCJTdWlJY29uR3JvdXBcIixtaXhpbnM6W0xdLHByb3BzOntzaXplOl8uU2l6ZSh7ZGVzY3JpcHRpb246XCJJY29uIGdyb3VwIHNpemUuXCJ9KX0scmVuZGVyOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzWzBdLHQ9dGhpcy5nZXRFbGVtZW50VHlwZShcImlcIik7cmV0dXJuIGUodCxsKCkoW3t9LHRoaXMuZ2V0Q2hpbGRQcm9wc0FuZExpc3RlbmVycygpLHtjbGFzczp0aGlzLmNsYXNzZXModGhpcy5zaXplLFwiaWNvbnNcIil9XSksW3RoaXMuJHNsb3RzLmRlZmF1bHRdKX0sbWV0YTp7cGFyZW50OlwiU3VpSWNvblwifX0sRGU9e25hbWU6XCJTdWlJbWFnZVwiLG1peGluczpbTF0scHJvcHM6e2F2YXRhcjp7dHlwZTpCb29sZWFuLGRlc2NyaXB0aW9uOlwiQW4gaW1hZ2UgbWF5IGJlIGZvcm1hdHRlZCB0byBhcHBlYXIgaW5saW5lIHdpdGggdGV4dCBhcyBhbiBhdmF0YXIuXCJ9LGJvcmRlcmVkOnt0eXBlOkJvb2xlYW4sZGVzY3JpcHRpb246XCJBbiBpbWFnZSBtYXkgaW5jbHVkZSBhIGJvcmRlciB0byBlbXBoYXNpemUgdGhlIGVkZ2VzIG9mIHdoaXRlIG9yIHRyYW5zcGFyZW50IGNvbnRlbnQuXCJ9LGNpcmN1bGFyOnt0eXBlOkJvb2xlYW4sZGVzY3JpcHRpb246XCJBbiBpbWFnZSBtYXkgYXBwZWFyIGNpcmN1bGFyLlwifSxyb3VuZGVkOnt0eXBlOkJvb2xlYW4sZGVzY3JpcHRpb246XCJBbiBpbWFnZSBtYXkgYXBwZWFyIHJvdW5kZWQuXCJ9LGRpc2FibGVkOkJvb2xlYW4saGlkZGVuOkJvb2xlYW4sc2l6ZTpfLlNpemUoKSxzcGFjZWQ6XyhbXCJsZWZ0XCIsXCJyaWdodFwiXSx7dHlwZTpCb29sZWFufSksc2hhcGU6XyhbXCJyb3VuZGVkXCIsXCJjaXJjdWxhclwiXSksc3JjOnt0eXBlOlN0cmluZyxyZXF1aXJlZDohMH0sZmxvYXRlZDpfKFtcImxlZnRcIixcInJpZ2h0XCJdKSxjZW50ZXJlZDpCb29sZWFuLHZlcnRpY2FsQWxpZ246Xy5WZXJ0aWNhbEFsaWduKHtkZXNjcmlwdGlvbjpcIkFuIGltYWdlIGNhbiBzcGVjaWZ5IGl0cyB2ZXJ0aWNhbCBhbGlnbm1lbnQuXCJ9KSx3cmFwcGVkOkJvb2xlYW59LHJlbmRlcjpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50c1swXSx0PXRoaXMuZ2V0RWxlbWVudFR5cGUoXCJkaXZcIiksaT10aGlzLmNsYXNzZXMoXCJ1aVwiLHRoaXMuYXZhdGFyJiZcImF2YXRhclwiLHRoaXMuc2l6ZSx0aGlzLnNoYXBlLHRoaXMudmVydGljYWxBbGlnbiYmXCJcIi5jb25jYXQodGhpcy52ZXJ0aWNhbEFsaWduLFwiIGFsaWduZWRcIiksdGhpcy5mbG9hdGVkJiZcIlwiLmNvbmNhdCh0aGlzLmZsb2F0ZWQsXCIgZmxvYXRlZFwiKSx0aGlzLmNlbnRlcmVkJiZcImNlbnRlcmVkXCIsdGhpcy5ib3JkZXJlZCYmXCJib3JkZXJlZFwiLHRoaXMucm91bmRlZCYmXCJyb3VuZGVkXCIsdGhpcy5jaXJjdWxhciYmXCJjaXJjdWxhclwiLHRoaXMuc3BhY2VkLHRoaXMuc3BhY2VkJiZcInNwYWNlZFwiLHRoaXMuaGlkZGVuJiZcImhpZGRlblwiLHRoaXMuZGlzYWJsZWQmJlwiZGlzYWJsZWRcIixcImltYWdlXCIpO3JldHVybiB0aGlzLndyYXBwZWR8fHRoaXMuJHNsb3RzLmNvcm5lcnx8dGhpcy4kc2xvdHMubGFiZWw/ZSh0LHtjbGFzczppfSxbdGhpcy4kc2xvdHMuY29ybmVyLGUoXCJpbWdcIix7YXR0cnM6e3NyYzp0aGlzLnNyY319KSx0aGlzLiRzbG90cy5sYWJlbF0pOmUoXCJpbWdcIix7Y2xhc3M6aSxhdHRyczp7c3JjOnRoaXMuc3JjfX0pfX0sSWU9e25hbWU6XCJTdWlJbWFnZUdyb3VwXCIsbWl4aW5zOltMXSxwcm9wczp7c2l6ZTpfLlNpemUoKX0scmVuZGVyOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzWzBdLHQ9dGhpcy5nZXRFbGVtZW50VHlwZShcImRpdlwiKTtyZXR1cm4gZSh0LHtjbGFzczp0aGlzLmNsYXNzZXMoXCJ1aVwiLHRoaXMuc2l6ZSxcImltYWdlc1wiKX0sW3RoaXMuJHNsb3RzLmRlZmF1bHRdKX0sbWV0YTp7cGFyZW50OlwiU3VpSW1hZ2VcIn19O2Z1bmN0aW9uIE1lKGUsdCl7dmFyIGk9T2JqZWN0LmtleXMoZSk7aWYoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyl7dmFyIG49T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTt0JiYobj1uLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSx0KS5lbnVtZXJhYmxlfSkpKSxpLnB1c2guYXBwbHkoaSxuKX1yZXR1cm4gaX1mdW5jdGlvbiBGZShlKXtmb3IodmFyIHQ9MTt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKXt2YXIgaT1udWxsIT1hcmd1bWVudHNbdF0/YXJndW1lbnRzW3RdOnt9O3QlMj9NZShPYmplY3QoaSksITApLmZvckVhY2goKGZ1bmN0aW9uKHQpe3plKGUsdCxpW3RdKX0pKTpPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycz9PYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKGkpKTpNZShPYmplY3QoaSkpLmZvckVhY2goKGZ1bmN0aW9uKHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihpLHQpKX0pKX1yZXR1cm4gZX1mdW5jdGlvbiB6ZShlLHQsaSl7cmV0dXJuIHQgaW4gZT9PYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHt2YWx1ZTppLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6ZVt0XT1pLGV9dmFyIFJlPXtuYW1lOlwiU3VpSW5wdXRcIixjb21wb25lbnRzOntTdWlCdXR0b246U2UsU3VpSWNvbjpRfSxtaXhpbnM6W0xdLHByb3BzOnthY3Rpb246U3RyaW5nLGRpc2FibGVkOkJvb2xlYW4sZXJyb3I6Qm9vbGVhbixmb2N1czpCb29sZWFuLGZsdWlkOkJvb2xlYW4saWNvbjpTdHJpbmcsaWNvblBvc2l0aW9uOl8oW1wibGVmdFwiLFwicmlnaHRcIl0pLGludmVydGVkOkJvb2xlYW4saW5wdXRDbGFzczpTdHJpbmcsbG9hZGluZzpCb29sZWFuLHNpemU6XyhbXCJtaW5pXCIsXCJzbWFsbFwiLFwibGFyZ2VcIixcImJpZ1wiLFwiaHVnZVwiLFwibWFzc2l2ZVwiXSksdHJhbnNwYXJlbnQ6Qm9vbGVhbix0eXBlOntkZXNjcmlwdGlvbjpcIlRoZSBIVE1MIGlucHV0IHR5cGUuXCIsZGVmYXVsdDpcInRleHRcIix0eXBlOlN0cmluZ30sdmFsdWU6W1N0cmluZyxOdW1iZXJdfSxldmVudHM6e2lucHV0OntjdXN0b206ITB9LGJsdXI6e2N1c3RvbTohMH19LG1ldGhvZHM6e2hhbmRsZUNoYW5nZTpmdW5jdGlvbihlKXt2YXIgdD1lLnRhcmdldC52YWx1ZSxpPVwibnVtYmVyXCI9PT10aGlzLnR5cGU/TnVtYmVyKHQpOnQ7dGhpcy4kZW1pdChcImlucHV0XCIsaSl9fSxyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgZSx0PXRoaXMsaT1hcmd1bWVudHNbMF0sbj10aGlzLmdldEVsZW1lbnRUeXBlKCk7cmV0dXJuKHRoaXMubG9hZGluZ3x8dGhpcy5pY29uKSYmKGU9aShRLHthdHRyczp7bmFtZTp0aGlzLmxvYWRpbmc/XCJsb2FkaW5nXCI6dGhpcy5pY29ufX0pKSxpKG4sbCgpKFt7fSx0aGlzLmdldENoaWxkUHJvcHNBbmRMaXN0ZW5lcnMoKSx7Y2xhc3M6dGhpcy5jbGFzc2VzKFwidWlcIix0aGlzLmFjdGlvbiYmXCJhY3Rpb25cIix0aGlzLmRpc2FibGVkJiZcImRpc2FibGVkXCIsdGhpcy5lcnJvciYmXCJlcnJvclwiLHRoaXMuZm9jdXMmJlwiZm9jdXNcIix0aGlzLnRyYW5zcGFyZW50JiZcInRyYW5zcGFyZW50XCIsdGhpcy5pbnZlcnRlZCYmXCJpbnZlcnRlZFwiLHRoaXMubG9hZGluZyYmXCJsb2FkaW5nXCIsdGhpcy5mbHVpZCYmXCJmbHVpZFwiLFwibGVmdFwiPT09dGhpcy5pY29uUG9zaXRpb24mJlwibGVmdFwiLCh0aGlzLmxvYWRpbmd8fHRoaXMuaWNvbikmJlwiaWNvblwiLEJvb2xlYW4odGhpcy5zaXplKSYmdGhpcy5zaXplLFwiaW5wdXRcIil9XSksW2koXCJpbnB1dFwiLHtjbGFzczp0aGlzLmlucHV0Q2xhc3MsZG9tUHJvcHM6e3ZhbHVlOnRoaXMudmFsdWV9LG9uOntpbnB1dDp0aGlzLmhhbmRsZUNoYW5nZSxmb2N1czpmdW5jdGlvbihlKXtyZXR1cm4gdC4kZW1pdChcImZvY3VzXCIsZSl9LGJsdXI6ZnVuY3Rpb24oZSl7cmV0dXJuIHQuJGVtaXQoXCJibHVyXCIsZSl9fSxyZWY6XCJpbnB1dFwiLGF0dHJzOkZlKHt0eXBlOnRoaXMudHlwZX0sdGhpcy4kYXR0cnMpfSksZSx0aGlzLmFjdGlvbiYmaShTZSx7YXR0cnM6e2NvbnRlbnQ6dGhpcy5hY3Rpb259fSldKX19LE5lPXtuYW1lOlwiU3VpTGFiZWxcIixtaXhpbnM6W0xdLGRlc2NyaXB0aW9uOlwiQSBsYWJlbCBkaXNwbGF5cyBjb250ZW50IGNsYXNzaWZpY2F0aW9uLlwiLHByb3BzOnthdHRhY2hlZDpfKFtcInRvcFwiLFwiYm90dG9tXCIsXCJ0b3AgcmlnaHRcIixcInRvcCBsZWZ0XCIsXCJib3R0b20gbGVmdFwiLFwiYm90dG9tIHJpZ2h0XCJdLHtkZXNjcmlwdGlvbjpcIkEgbGFiZWwgY2FuIGF0dGFjaCB0byBhIGNvbnRlbnQgc2VnbWVudC5cIn0pLGJhc2ljOnt0eXBlOkJvb2xlYW4sZGVzY3JpcHRpb246XCJBIGxhYmVsIGNhbiByZWR1Y2UgaXRzIGNvbXBsZXhpdHkuXCJ9LGNpcmN1bGFyOnt0eXBlOkJvb2xlYW4sZGVzY3JpcHRpb246XCJBIGxhYmVsIGNhbiBiZSBjaXJjdWxhci5cIn0sY29sb3I6Xy5Db2xvcigpLGNvcm5lcjpfKFtcImxlZnRcIixcInJpZ2h0XCJdLHtkZXNjcmlwdGlvbjpcIkEgbGFiZWwgY2FuIHBvc2l0aW9uIGl0c2VsZiBpbiB0aGUgY29ybmVyIG9mIGFuIGVsZW1lbnQuXCJ9KSxlbXB0eTp7dHlwZTpCb29sZWFuLGRlc2NyaXB0aW9uOlwiRm9ybWF0cyB0aGUgbGFiZWwgYXMgYSBkb3QuXCJ9LGZsb2F0aW5nOnt0eXBlOkJvb2xlYW4sZGVzY3JpcHRpb246XCJGbG9hdCBhYm92ZSBhbm90aGVyIGVsZW1lbnQgaW4gdGhlIHVwcGVyIHJpZ2h0IGNvcm5lci5cIn0saW1hZ2U6Qm9vbGVhbixwb2ludGluZzpfKFtcImxlZnRcIixcInJpZ2h0XCIsXCJhYm92ZVwiLFwiYmVsb3dcIl0se2Rlc2NyaXB0aW9uOlwiQSBsYWJlbCBjYW4gcG9pbnQgdG8gY29udGVudCBuZXh0IHRvIGl0LlwiLHR5cGU6Qm9vbGVhbn0pLGljb246U3RyaW5nLHJpYmJvbjpfKFtcImxlZnRcIixcInJpZ2h0XCJdLHtkZXNjcmlwdGlvbjpcIkEgbGFiZWwgY2FuIGFwcGVhciBhcyBhIHJpYmJvbiBhdHRhY2hpbmcgaXRzZWxmIHRvIGFuIGVsZW1lbnQuXCIsdHlwZTpCb29sZWFufSksc2l6ZTpfLlNpemUoe2Rlc2NyaXB0aW9uOlwiQSBsYWJlbCBjYW4gaGF2ZSBkaWZmZXJlbnQgc2l6ZXMuXCJ9KSx0YWc6Xy5Db2xvcih7ZGVzY3JpcHRpb246XCJBIGxhYmVsIGNhbiBhcHBlYXIgYXMgYSB0YWcuXCIsdHlwZTpCb29sZWFufSl9LGNvbXB1dGVkOntwb2ludGluZ0NsYXNzOmZ1bmN0aW9uKCl7aWYoIXRoaXMucG9pbnRpbmcpcmV0dXJuXCJcIjt2YXIgZT1cIlwiO3JldHVybltcImxlZnRcIixcInJpZ2h0XCJdLmluY2x1ZGVzKHRoaXMucG9pbnRpbmcpJiYoZSs9XCJcIi5jb25jYXQodGhpcy5wb2ludGluZyxcIiBcIikpLGUrPVwicG9pbnRpbmdcIixbXCJhYm92ZVwiLFwiYmVsb3dcIl0uaW5jbHVkZXModGhpcy5wb2ludGluZykmJihlKz1cIiBcIi5jb25jYXQodGhpcy5wb2ludGluZykpLGV9fSxyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHNbMF0sdD10aGlzLmdldEVsZW1lbnRUeXBlKCk7cmV0dXJuIGUodCxsKCkoW3t9LHRoaXMuZ2V0Q2hpbGRQcm9wc0FuZExpc3RlbmVycygpLHtjbGFzczp0aGlzLmNsYXNzZXMoXCJ1aVwiLHRoaXMucG9pbnRpbmdDbGFzcyx0aGlzLmNvbG9yLHRoaXMuc2l6ZSx0aGlzLmNpcmN1bGFyJiZcImNpcmN1bGFyXCIsdGhpcy5lbXB0eSYmXCJlbXB0eVwiLHRoaXMuZmxvYXRpbmcmJlwiZmxvYXRpbmdcIix0aGlzLmJhc2ljJiZcImJhc2ljXCIsdGhpcy5pbWFnZSYmXCJpbWFnZVwiLHRoaXMuYXR0YWNoZWQmJlwiXCIuY29uY2F0KHRoaXMuYXR0YWNoZWQsXCIgYXR0YWNoZWRcIiksdGhpcy5yaWJib24mJlwiXCIuY29uY2F0KHRoaXMucmliYm9uLFwiIHJpYmJvblwiKSx0aGlzLmNvcm5lciYmXCJcIi5jb25jYXQodGhpcy5jb3JuZXIsXCIgY29ybmVyXCIpLHRoaXMudGFnJiZcIlwiLmNvbmNhdCh0aGlzLnRhZyxcIiB0YWdcIiksXCJsYWJlbFwiKX1dKSxbdGhpcy5pY29uJiZlKFEse2F0dHJzOntuYW1lOnRoaXMuaWNvbn19KSx0aGlzLiRzbG90cy5kZWZhdWx0XSl9fSxIZT17bmFtZTpcIlN1aUxhYmVsRGV0YWlsXCIsbWl4aW5zOltMXSxyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHNbMF0sdD10aGlzLmdldEVsZW1lbnRUeXBlKCk7cmV0dXJuIGUodCxsKCkoW3t9LHRoaXMuZ2V0Q2hpbGRQcm9wc0FuZExpc3RlbmVycygpLHtjbGFzczpcImRldGFpbFwifV0pLFt0aGlzLiRzbG90cy5kZWZhdWx0XSl9LG1ldGE6e3BhcmVudDpcIlN1aUxhYmVsXCJ9fTtmdW5jdGlvbiBWZShlLHQpe3ZhciBpPU9iamVjdC5rZXlzKGUpO2lmKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpe3ZhciBuPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7dCYmKG49bi5maWx0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsdCkuZW51bWVyYWJsZX0pKSksaS5wdXNoLmFwcGx5KGksbil9cmV0dXJuIGl9ZnVuY3Rpb24gcWUoZSx0LGkpe3JldHVybiB0IGluIGU/T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCx7dmFsdWU6aSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOmVbdF09aSxlfXZhciBHZT1mdW5jdGlvbihlKXtmb3IodmFyIHQ9MTt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKXt2YXIgaT1udWxsIT1hcmd1bWVudHNbdF0/YXJndW1lbnRzW3RdOnt9O3QlMj9WZShPYmplY3QoaSksITApLmZvckVhY2goKGZ1bmN0aW9uKHQpe3FlKGUsdCxpW3RdKX0pKTpPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycz9PYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKGkpKTpWZShPYmplY3QoaSkpLmZvckVhY2goKGZ1bmN0aW9uKHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihpLHQpKX0pKX1yZXR1cm4gZX0oe30sUSx7bmFtZTpcIlN1aUxpc3RJY29uXCIsbWl4aW5zOltMXSxtZXRhOntwYXJlbnQ6XCJTdWlMaXN0XCJ9fSksX2U9e25hbWU6XCJTdWlMaXN0Q29udGVudFwiLG1peGluczpbTF0scmVuZGVyOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzWzBdLHQ9dGhpcy5nZXRFbGVtZW50VHlwZSgpO3JldHVybiBlKHQsbCgpKFt7fSx0aGlzLmdldENoaWxkUHJvcHNBbmRMaXN0ZW5lcnMoKSx7Y2xhc3M6XCJjb250ZW50XCJ9XSksW3RoaXMuJHNsb3RzLmRlZmF1bHRdKX0sbWV0YTp7cGFyZW50OlwiU3VpTGlzdFwifX0sVWU9e25hbWU6XCJTdWlMaXN0SXRlbVwiLGNvbXBvbmVudHM6e1N1aUxpc3RDb250ZW50Ol9lLFN1aUxpc3RJY29uOkdlfSxtaXhpbnM6W0xdLHByb3BzOnthY3RpdmU6e3R5cGU6Qm9vbGVhbixkZXNjcmlwdGlvbjpcIkEgbGlzdCBpdGVtIGNhbiBiZSBhY3RpdmUuXCJ9LGNvbnRlbnQ6U3RyaW5nLGljb246U3RyaW5nfSxyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHNbMF0sdD10aGlzLmdldEVsZW1lbnRUeXBlKCk7cmV0dXJuIGUodCxsKCkoW3t9LHRoaXMuZ2V0Q2hpbGRQcm9wc0FuZExpc3RlbmVycygpLHtjbGFzczp0aGlzLmNsYXNzZXMoXCJpdGVtXCIsdGhpcy5hY3RpdmUmJlwiYWN0aXZlXCIpLGF0dHJzOntyb2xlOlwibGlzdGl0ZW1cIn19XSksW3RoaXMuaWNvbiYmZShHZSx7YXR0cnM6e25hbWU6dGhpcy5pY29ufX0pLHRoaXMuY29udGVudD9lKF9lLFt0aGlzLmNvbnRlbnRdKTp0aGlzLiRzbG90cy5kZWZhdWx0XSl9LG1ldGE6e3BhcmVudDpcIlN1aUxpc3RcIn19LFdlPXtuYW1lOlwiU3VpTGlzdFwiLG1peGluczpbTF0scHJvcHM6e2J1bGxldGVkOnt0eXBlOkJvb2xlYW4sZGVzY3JpcHRpb246XCJBIGxpc3QgY2FuIG1hcmsgaXRlbXMgd2l0aCBhIGJ1bGxldC5cIn0sZGl2aWRlZDpCb29sZWFuLGhvcml6b250YWw6Qm9vbGVhbixpdGVtczpBcnJheSxsaW5rOkJvb2xlYW4scmVsYXhlZDpCb29sZWFuLGludmVydGVkOnt0eXBlOkJvb2xlYW4sZGVzY3JpcHRpb246XCJBIGxpc3QgY2FuIGJlIGludmVydGVkIHRvIGFwcGVhciBvbiBhIGRhcmsgYmFja2dyb3VuZC5cIn0sb3JkZXJlZDp7dHlwZTpCb29sZWFuLGRlc2NyaXB0aW9uOlwiQSBsaXN0IGNhbiBiZSBvcmRlcmVkIG51bWVyaWNhbGx5LlwifSxzaXplOl8uU2l6ZSgpfSxyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgZSx0PWFyZ3VtZW50c1swXSxpPXRoaXMuZ2V0RWxlbWVudFR5cGUoKTtyZXR1cm4gZT10aGlzLml0ZW1zP3RoaXMuaXRlbXMubWFwKChmdW5jdGlvbihlKXtyZXR1cm4gdChVZSxbZV0pfSkpOnRoaXMuJHNsb3RzLmRlZmF1bHQsdChpLGwoKShbe30sdGhpcy5nZXRDaGlsZFByb3BzQW5kTGlzdGVuZXJzKCkse2NsYXNzOnRoaXMuY2xhc3NlcyhcInVpXCIsdGhpcy5zaXplLHRoaXMuYnVsbGV0ZWQmJlwiYnVsbGV0ZWRcIix0aGlzLmRpdmlkZWQmJlwiZGl2aWRlZFwiLHRoaXMub3JkZXJlZCYmXCJvcmRlcmVkXCIsdGhpcy5ob3Jpem9udGFsJiZcImhvcml6b250YWxcIix0aGlzLmxpbmsmJlwibGlua1wiLHRoaXMucmVsYXhlZCYmXCJyZWxheGVkXCIsdGhpcy5pbnZlcnRlZCYmXCJpbnZlcnRlZFwiLFwibGlzdFwiKSxhdHRyczp7cm9sZTpcImxpc3RcIn19XSksW2VdKX19LFllPXtuYW1lOlwiU3VpTGlzdERlc2NyaXB0aW9uXCIsbWl4aW5zOltMXSxyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHNbMF0sdD10aGlzLmdldEVsZW1lbnRUeXBlKCk7cmV0dXJuIGUodCxsKCkoW3t9LHRoaXMuZ2V0Q2hpbGRQcm9wc0FuZExpc3RlbmVycygpLHtjbGFzczpcImRlc2NyaXB0aW9uXCJ9XSksW3RoaXMuJHNsb3RzLmRlZmF1bHRdKX0sbWV0YTp7cGFyZW50OlwiU3VpTGlzdFwifX0sS2U9e25hbWU6XCJTdWlMaXN0SGVhZGVyXCIsbWl4aW5zOltMXSxyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHNbMF0sdD10aGlzLmdldEVsZW1lbnRUeXBlKCk7cmV0dXJuIGUodCxsKCkoW3t9LHRoaXMuZ2V0Q2hpbGRQcm9wc0FuZExpc3RlbmVycygpLHtjbGFzczpcImhlYWRlclwifV0pLFt0aGlzLiRzbG90cy5kZWZhdWx0XSl9LG1ldGE6e3BhcmVudDpcIlN1aUxpc3RcIn19LFhlPXtuYW1lOlwiU3VpTGlzdExpc3RcIixtaXhpbnM6W0xdLHJlbmRlcjpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50c1swXSx0PXRoaXMuZ2V0RWxlbWVudFR5cGUoKTtyZXR1cm4gZSh0LGwoKShbe30sdGhpcy5nZXRDaGlsZFByb3BzQW5kTGlzdGVuZXJzKCkse2NsYXNzOlwibGlzdFwifV0pLFt0aGlzLiRzbG90cy5kZWZhdWx0XSl9LG1ldGE6e3BhcmVudDpcIlN1aUxpc3RcIn19LEplPXtuYW1lOlwiU3VpTG9hZGVyXCIsbWl4aW5zOltMXSxwcm9wczp7YWN0aXZlOkJvb2xlYW4sY29udGVudDpTdHJpbmcsaW5kZXRlcm1pbmF0ZTpCb29sZWFuLGRpc2FibGVkOkJvb2xlYW4saW5saW5lOkJvb2xlYW4sY2VudGVyZWQ6Qm9vbGVhbixzaXplOl8uU2l6ZSh7dHlwZTpTdHJpbmd9KSxpbnZlcnRlZDpCb29sZWFufSxyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHNbMF0sdD10aGlzLmdldEVsZW1lbnRUeXBlKCk7cmV0dXJuIGUodCxsKCkoW3t9LHRoaXMuZ2V0Q2hpbGRQcm9wc0FuZExpc3RlbmVycygpLHtjbGFzczp0aGlzLmNsYXNzZXMoXCJ1aVwiLHRoaXMuaW5kZXRlcm1pbmF0ZSYmXCJpbmRldGVybWluYXRlXCIsdGhpcy5hY3RpdmUmJlwiYWN0aXZlXCIsdGhpcy5kaXNhYmxlZCYmXCJkaXNhYmxlZFwiLHRoaXMuaW5saW5lJiZcImlubGluZVwiLHRoaXMuY2VudGVyZWQmJlwiY2VudGVyZWRcIix0aGlzLmludmVydGVkJiZcImludmVydGVkXCIsdGhpcy5zaXplLCh0aGlzLmNvbnRlbnR8fHRoaXMuJHNsb3RzLmRlZmF1bHQpJiZcInRleHRcIixcImxvYWRlclwiKX1dKSxbdGhpcy5jb250ZW50fHx0aGlzLiRzbG90cy5kZWZhdWx0XSl9fSxaZT17bmFtZTpcIlN1aVJhaWxcIixtaXhpbnM6W0xdLHByb3BzOnthdHRhY2hlZDpCb29sZWFuLGRpdmlkaW5nOkJvb2xlYW4saW50ZXJuYWw6Qm9vbGVhbixwb3NpdGlvbjpfKFtcImxlZnRcIixcInJpZ2h0XCJdKX0scmVuZGVyOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzWzBdLHQ9dGhpcy5nZXRFbGVtZW50VHlwZSgpO3JldHVybiBlKHQsbCgpKFt7fSx0aGlzLmdldENoaWxkUHJvcHNBbmRMaXN0ZW5lcnMoKSx7Y2xhc3M6dGhpcy5jbGFzc2VzKFwidWlcIix0aGlzLmRpdmlkaW5nJiZcImRpdmlkaW5nXCIsdGhpcy5hdHRhY2hlZCYmXCJhdHRhY2hlZFwiLHRoaXMuaW50ZXJuYWwmJlwiaW50ZXJuYWxcIix0aGlzLnBvc2l0aW9uLFwicmFpbFwiKX1dKSxbdGhpcy4kc2xvdHMuZGVmYXVsdF0pfX0sUWU9e25hbWU6XCJTdWlSZXZlYWxcIixtaXhpbnM6W0xdLHByb3BzOnthY3RpdmU6e3R5cGU6Qm9vbGVhbixkZXNjcmlwdGlvbjpcIkFuIGFjdGl2ZSByZXZlYWwgZGlzcGxheXMgaXRzIGhpZGRlbiBjb250ZW50LlwifSxhbmltYXRlZDpfKFtcImZhZGVcIixcInNtYWxsIGZhZGVcIixcIm1vdmVcIixcIm1vdmUgcmlnaHRcIixcIm1vdmUgdXBcIixcIm1vdmUgZG93blwiLFwicm90YXRlXCIsXCJyb3RhdGUgbGVmdFwiXSksZGlzYWJsZWQ6e3R5cGU6Qm9vbGVhbixkZXNjcmlwdGlvbjpcIkEgZGlzYWJsZWQgcmV2ZWFsIHdpbGwgbm90IGFuaW1hdGUgd2hlbiBob3ZlcmVkLlwifSxpbnN0YW50Ont0eXBlOkJvb2xlYW4sZGVzY3JpcHRpb246XCJBbiBlbGVtZW50IGNhbiBzaG93IGl0cyBjb250ZW50IHdpdGhvdXQgZGVsYXkuXCJ9fSxyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHNbMF0sdD10aGlzLmdldEVsZW1lbnRUeXBlKCk7cmV0dXJuIGUodCxsKCkoW3t9LHRoaXMuZ2V0Q2hpbGRQcm9wc0FuZExpc3RlbmVycygpLHtjbGFzczp0aGlzLmNsYXNzZXMoXCJ1aVwiLHRoaXMuYW5pbWF0ZWQsdGhpcy5kaXNhYmxlZCYmXCJkaXNhYmxlZFwiLHRoaXMuaW5zdGFudCYmXCJpbnN0YW50XCIsdGhpcy5hY3RpdmUmJlwiYWN0aXZlXCIsXCJyZXZlYWxcIil9XSksW3RoaXMuJHNsb3RzLmRlZmF1bHRdKX19LGV0PXtuYW1lOlwiU3VpUmV2ZWFsQ29udGVudFwiLG1peGluczpbTF0scHJvcHM6e3Zpc2libGU6Qm9vbGVhbixoaWRkZW46Qm9vbGVhbn0scmVuZGVyOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzWzBdLHQ9dGhpcy5nZXRFbGVtZW50VHlwZSgpO3JldHVybiBlKHQsbCgpKFt7fSx0aGlzLmdldENoaWxkUHJvcHNBbmRMaXN0ZW5lcnMoKSx7Y2xhc3M6dGhpcy5jbGFzc2VzKFwidWlcIix0aGlzLmhpZGRlbiYmXCJoaWRkZW5cIix0aGlzLnZpc2libGUmJlwidmlzaWJsZVwiLFwiY29udGVudFwiKX1dKSxbdGhpcy4kc2xvdHMuZGVmYXVsdF0pfSxtZXRhOntwYXJlbnQ6XCJTdWlSZXZlYWxcIn19LHR0PXtuYW1lOlwiU3VpU2VnbWVudFwiLG1peGluczpbTF0scHJvcHM6e2F0dGFjaGVkOl8uQXR0YWNoZWQoe3R5cGU6Qm9vbGVhbixkZXNjcmlwdGlvbjpcIkF0dGFjaCBzZWdtZW50IHRvIG90aGVyIGNvbnRlbnQsIGxpa2UgYSBoZWFkZXIuXCJ9KSxiYXNpYzpCb29sZWFuLGNsZWFyaW5nOnt0eXBlOkJvb2xlYW4sZGVzY3JpcHRpb246XCJBIHNlZ21lbnQgY2FuIGNsZWFyIGZsb2F0ZWQgY29udGVudC5cIn0saW52ZXJ0ZWQ6Qm9vbGVhbixwYWRkZWQ6Xy5QYWRkZWQoe3R5cGU6Qm9vbGVhbixkZXNjcmlwdGlvbjpcIkEgc2VnbWVudCBjYW4gaW5jcmVhc2UgaXRzIHBhZGRpbmdcIn0pLHBpbGVkOkJvb2xlYW4scmFpc2VkOkJvb2xlYW4sc3RhY2tlZDpfKFtcInRhbGxcIl0se3R5cGU6Qm9vbGVhbn0pLHZlcnRpY2FsOkJvb2xlYW4sZGlzYWJsZWQ6Qm9vbGVhbixsb2FkaW5nOkJvb2xlYW4sY29tcGFjdDpCb29sZWFuLGNvbG9yOl8uQ29sb3Ioe3R5cGU6U3RyaW5nfSksZW1waGFzaXM6Xy5FbXBoYXNpcyh7dHlwZTpTdHJpbmd9KSxjaXJjdWxhcjpCb29sZWFuLGZsb2F0ZWQ6Xy5GbG9hdGVkKHt0eXBlOlN0cmluZ30pLGFsaWduZWQ6Xy5UZXh0QWxpZ24oe3R5cGU6U3RyaW5nfSl9LHJlbmRlcjpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50c1swXSx0PXRoaXMuZ2V0RWxlbWVudFR5cGUoKTtyZXR1cm4gZSh0LGwoKShbe30sdGhpcy5nZXRDaGlsZFByb3BzQW5kTGlzdGVuZXJzKCkse2NsYXNzOnRoaXMuY2xhc3NlcyhcInVpXCIsdGhpcy5hdHRhY2hlZCx0aGlzLmF0dGFjaGVkJiZcImF0dGFjaGVkXCIsdGhpcy5iYXNpYyYmXCJiYXNpY1wiLHRoaXMuY2xlYXJpbmcmJlwiY2xlYXJpbmdcIix0aGlzLnBhZGRlZCx0aGlzLnBhZGRlZCYmXCJwYWRkZWRcIix0aGlzLmludmVydGVkJiZcImludmVydGVkXCIsdGhpcy5zdGFja2VkLHRoaXMuc3RhY2tlZCYmXCJzdGFja2VkXCIsdGhpcy5waWxlZCYmXCJwaWxlZFwiLHRoaXMucmFpc2VkJiZcInJhaXNlZFwiLHRoaXMudmVydGljYWwmJlwidmVydGljYWxcIix0aGlzLmRpc2FibGVkJiZcImRpc2FibGVkXCIsdGhpcy5sb2FkaW5nJiZcImxvYWRpbmdcIix0aGlzLmNvbXBhY3QmJlwiY29tcGFjdFwiLHRoaXMuY29sb3IsdGhpcy5lbXBoYXNpcyx0aGlzLmNpcmN1bGFyJiZcImNpcmN1bGFyXCIsdGhpcy5mbG9hdGVkLHRoaXMuZmxvYXRlZCYmXCJmbG9hdGVkXCIsdGhpcy5hbGlnbmVkLHRoaXMuYWxpZ25lZCYmXCJhbGlnbmVkXCIsXCJzZWdtZW50XCIpfV0pLFt0aGlzLiRzbG90cy5kZWZhdWx0XSl9fSxpdD17bmFtZTpcIlN1aVNlZ21lbnRzXCIsbWl4aW5zOltMXSxwcm9wczp7cGlsZWQ6Qm9vbGVhbixyYWlzZWQ6Qm9vbGVhbixzdGFja2VkOkJvb2xlYW4saG9yaXpvbnRhbDpCb29sZWFuLHZlcnRpY2FsOkJvb2xlYW59LG1ldGE6e3BhcmVudDpcIlN1aVNlZ21lbnRcIn0scmVuZGVyOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzWzBdLHQ9dGhpcy5nZXRFbGVtZW50VHlwZSgpO3JldHVybiBlKHQsbCgpKFt7fSx0aGlzLmdldENoaWxkUHJvcHNBbmRMaXN0ZW5lcnMoKSx7Y2xhc3M6dGhpcy5jbGFzc2VzKFwidWlcIix0aGlzLnBpbGVkJiZcInBpbGVkXCIsdGhpcy5yYWlzZWQmJlwicmFpc2VkXCIsdGhpcy5zdGFja2VkJiZcInN0YWNrZWRcIix0aGlzLmhvcml6b250YWwmJlwiaG9yaXpvbnRhbFwiLHRoaXMudmVydGljYWwmJlwidmVydGljYWxcIixcInNlZ21lbnRzXCIpfV0pLFt0aGlzLiRzbG90cy5kZWZhdWx0XSl9fSxudD17bmFtZTpcIlN1aVN0ZXBEZXNjcmlwdGlvblwiLG1peGluczpbTF0scmVuZGVyOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzWzBdLHQ9dGhpcy5nZXRFbGVtZW50VHlwZSgpO3JldHVybiBlKHQsbCgpKFt7fSx0aGlzLmdldENoaWxkUHJvcHNBbmRMaXN0ZW5lcnMoKSx7Y2xhc3M6XCJkZXNjcmlwdGlvblwifV0pLFt0aGlzLiRzbG90cy5kZWZhdWx0XSl9LG1ldGE6e3BhcmVudDpcIlN1aVN0ZXBcIn19LHJ0PXtuYW1lOlwiU3VpU3RlcFRpdGxlXCIsbWl4aW5zOltMXSxyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHNbMF0sdD10aGlzLmdldEVsZW1lbnRUeXBlKCk7cmV0dXJuIGUodCxsKCkoW3t9LHRoaXMuZ2V0Q2hpbGRQcm9wc0FuZExpc3RlbmVycygpLHtjbGFzczpcInRpdGxlXCJ9XSksW3RoaXMuJHNsb3RzLmRlZmF1bHRdKX0sbWV0YTp7cGFyZW50OlwiU3VpU3RlcFwifX0sc3Q9e25hbWU6XCJTdWlTdGVwQ29udGVudFwiLGNvbXBvbmVudHM6e1N1aVN0ZXBEZXNjcmlwdGlvbjpudCxTdWlTdGVwVGl0bGU6cnR9LG1peGluczpbTF0scHJvcHM6e2Rlc2NyaXB0aW9uOlN0cmluZyx0aXRsZTpTdHJpbmd9LHJlbmRlcjpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50c1swXSx0PXRoaXMuZ2V0RWxlbWVudFR5cGUoKTtyZXR1cm4gZSh0LGwoKShbe30sdGhpcy5nZXRDaGlsZFByb3BzQW5kTGlzdGVuZXJzKCkse2NsYXNzOlwiY29udGVudFwifV0pLFt0aGlzLnRpdGxlJiZlKHJ0LFt0aGlzLnRpdGxlXSksdGhpcy5kZXNjcmlwdGlvbiYmZShudCxbdGhpcy5kZXNjcmlwdGlvbl0pLHRoaXMuJHNsb3RzLmRlZmF1bHRdKX0sbWV0YTp7cGFyZW50OlwiU3VpU3RlcFwifX0sb3Q9e25hbWU6XCJTdWlTdGVwXCIsY29tcG9uZW50czp7U3VpSWNvbjpRLFN1aVN0ZXBDb250ZW50OnN0LFN1aVN0ZXBUaXRsZTpydCxTdWlTdGVwRGVzY3JpcHRpb246bnR9LG1peGluczpbTF0scHJvcHM6e2FjdGl2ZTpCb29sZWFuLGNvbXBsZXRlZDpCb29sZWFuLGRlc2NyaXB0aW9uOlN0cmluZyxkaXNhYmxlZDpCb29sZWFuLGljb246U3RyaW5nLHRpdGxlOlN0cmluZyxsaW5rOkJvb2xlYW59LHJlbmRlcjpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50c1swXSx0PXRoaXMuZ2V0RWxlbWVudFR5cGUoKTtyZXR1cm4gZSh0LGwoKShbe30sdGhpcy5nZXRDaGlsZFByb3BzQW5kTGlzdGVuZXJzKCkse2NsYXNzOnRoaXMuY2xhc3NlcyhcInVpXCIsdGhpcy5hY3RpdmUmJlwiYWN0aXZlXCIsdGhpcy5jb21wbGV0ZWQmJlwiY29tcGxldGVkXCIsdGhpcy5kaXNhYmxlZCYmXCJkaXNhYmxlZFwiLHRoaXMubGluayYmXCJsaW5rXCIsXCJzdGVwXCIpfV0pLFt0aGlzLmljb24mJmUoUSx7YXR0cnM6e25hbWU6dGhpcy5pY29ufX0pLHRoaXMudGl0bGV8fHRoaXMuZGVzY3JpcHRpb24/ZShzdCxbdGhpcy50aXRsZSYmZShydCxbdGhpcy50aXRsZV0pLHRoaXMuZGVzY3JpcHRpb24mJmUobnQsW3RoaXMuZGVzY3JpcHRpb25dKV0pOnRoaXMuJHNsb3RzLmRlZmF1bHRdKX19O2Z1bmN0aW9uIGF0KGUsdCl7dmFyIGk9T2JqZWN0LmtleXMoZSk7aWYoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyl7dmFyIG49T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTt0JiYobj1uLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSx0KS5lbnVtZXJhYmxlfSkpKSxpLnB1c2guYXBwbHkoaSxuKX1yZXR1cm4gaX1mdW5jdGlvbiBjdChlKXtmb3IodmFyIHQ9MTt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKXt2YXIgaT1udWxsIT1hcmd1bWVudHNbdF0/YXJndW1lbnRzW3RdOnt9O3QlMj9hdChPYmplY3QoaSksITApLmZvckVhY2goKGZ1bmN0aW9uKHQpe2x0KGUsdCxpW3RdKX0pKTpPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycz9PYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKGkpKTphdChPYmplY3QoaSkpLmZvckVhY2goKGZ1bmN0aW9uKHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihpLHQpKX0pKX1yZXR1cm4gZX1mdW5jdGlvbiBsdChlLHQsaSl7cmV0dXJuIHQgaW4gZT9PYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHt2YWx1ZTppLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6ZVt0XT1pLGV9dmFyIGR0PXtuYW1lOlwiU3VpU3RlcEdyb3VwXCIsY29tcG9uZW50czp7U3VpU3RlcDpvdH0sbWl4aW5zOltMXSxwcm9wczp7b3JkZXJlZDpCb29sZWFuLHN0ZXBzOkFycmF5LHZlcnRpY2FsOkJvb2xlYW4sc3RhY2thYmxlOkJvb2xlYW4sdW5zdGFja2FibGU6Qm9vbGVhbixmbHVpZDpCb29sZWFuLGF0dGFjaGVkOl8uQXR0YWNoZWQoe3R5cGU6Qm9vbGVhbn0pLHN0ZXBOdW1iZXI6Xy5OdW1iZXIoe3R5cGU6U3RyaW5nLGRlc2NyaXB0aW9uOlwiRGVmaW5lZCBudW1iZXIgb2Ygc3RlcHNcIn0pLHNpemU6Xy5TaXplKHt0eXBlOlN0cmluZ30pfSxyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHNbMF0sdD10aGlzLmdldEVsZW1lbnRUeXBlKCk7cmV0dXJuIGUodCxsKCkoW3t9LHRoaXMuZ2V0Q2hpbGRQcm9wc0FuZExpc3RlbmVycygpLHtjbGFzczp0aGlzLmNsYXNzZXMoXCJ1aVwiLHRoaXMuc3RlcE51bWJlciYmdGhpcy5udW0odGhpcy5zdGVwTnVtYmVyKSx0aGlzLm9yZGVyZWQmJlwib3JkZXJlZFwiLHRoaXMudmVydGljYWwmJlwidmVydGljYWxcIix0aGlzLmZsdWlkJiZcImZsdWlkXCIsdGhpcy5zdGFja2FibGUmJlwidGFibGV0IHN0YWNrYWJsZVwiLHRoaXMudW5zdGFja2FibGUmJlwidW5zdGFja2FibGVcIix0aGlzLmF0dGFjaGVkLHRoaXMuYXR0YWNoZWQmJlwiYXR0YWNoZWRcIix0aGlzLnNpemUsXCJzdGVwc1wiKX1dKSxbdGhpcy5zdGVwcz90aGlzLnN0ZXBzLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIGUob3Qse3Byb3BzOmN0KHt9LHQpfSl9KSk6dGhpcy4kc2xvdHMuZGVmYXVsdF0pfSxtZXRhOntwYXJlbnQ6XCJTdWlTdGVwXCJ9fTtmdW5jdGlvbiB1dChlLHQpe3ZhciBpPU9iamVjdC5rZXlzKGUpO2lmKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpe3ZhciBuPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7dCYmKG49bi5maWx0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsdCkuZW51bWVyYWJsZX0pKSksaS5wdXNoLmFwcGx5KGksbil9cmV0dXJuIGl9ZnVuY3Rpb24gaHQoZSx0LGkpe3JldHVybiB0IGluIGU/T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCx7dmFsdWU6aSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOmVbdF09aSxlfXZhciBwdD17bmFtZTpcIlN1aUFjY29yZGlvblwiLG1peGluczpbTF0scHJvcHM6e2FjdGl2ZUluZGV4OltOdW1iZXIsQXJyYXldLGV4Y2x1c2l2ZTpCb29sZWFuLGZsdWlkOkJvb2xlYW4saW52ZXJ0ZWQ6Qm9vbGVhbixwYW5lbHM6QXJyYXksc3R5bGVkOkJvb2xlYW59LGRhdGE6ZnVuY3Rpb24oKXtyZXR1cm57YWN0aXZlOnRoaXMuZXhjbHVzaXZlP0FycmF5LmlzQXJyYXkodGhpcy5hY3RpdmVJbmRleCk/dGhpcy5hY3RpdmVJbmRleFswXTp0aGlzLmFjdGl2ZUluZGV4OkFycmF5LmlzQXJyYXkodGhpcy5hY3RpdmVJbmRleCk/dGhpcy5hY3RpdmVJbmRleDpbdGhpcy5hY3RpdmVJbmRleF0scGFuZWxFbG1zOltdfX0sbWV0aG9kczp7cmVnaXN0ZXI6ZnVuY3Rpb24oZSl7dmFyIHQsaT10aGlzLG49LTE7IWZ1bmN0aW9uIHIocyl7cy5zb21lKChmdW5jdGlvbihzKXtyZXR1cm5cIlN1aUFjY29yZGlvblwiIT09cy4kb3B0aW9ucy5uYW1lJiYoXCJTdWlBY2NvcmRpb25UaXRsZVwiPT09cy4kb3B0aW9ucy5uYW1lJiYobis9MSkscz09PWU/KGkucGFuZWxFbG1zW25dPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD0xO3Q8YXJndW1lbnRzLmxlbmd0aDt0Kyspe3ZhciBpPW51bGwhPWFyZ3VtZW50c1t0XT9hcmd1bWVudHNbdF06e307dCUyP3V0KE9iamVjdChpKSwhMCkuZm9yRWFjaCgoZnVuY3Rpb24odCl7aHQoZSx0LGlbdF0pfSkpOk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzP09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoaSkpOnV0KE9iamVjdChpKSkuZm9yRWFjaCgoZnVuY3Rpb24odCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGksdCkpfSkpfXJldHVybiBlfSh7fSxpLnBhbmVsRWxtc1tuXXx8e30saHQoe30scy4kb3B0aW9ucy5uYW1lLHMpKSx0PSEwLCEwKToocihzLiRjaGlsZHJlbiksdCkpfSkpfSh0aGlzLiRjaGlsZHJlbil9LHRvZ2dsZUVsOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7dGhpcy5wYW5lbEVsbXMuc29tZSgoZnVuY3Rpb24oaSxuKXtyZXR1cm4oaS5TdWlBY2NvcmRpb25UaXRsZT09PWV8fGkuU3VpQWNjb3JkaW9uQ29udGVudD09PWUpJiYodC50b2dnbGUobiksITApfSkpfSx0b2dnbGU6ZnVuY3Rpb24oZSl7dGhpcy5leGNsdXNpdmU/dGhpcy5hY3RpdmU9PT1lP3RoaXMuYWN0aXZlPW51bGw6dGhpcy5hY3RpdmU9ZTp0aGlzLmFjdGl2ZS5pbmNsdWRlcyhlKT90aGlzLmFjdGl2ZT10aGlzLmFjdGl2ZS5maWx0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiB0IT09ZX0pKTp0aGlzLmFjdGl2ZT10aGlzLmFjdGl2ZS5jb25jYXQoW2VdKSx0aGlzLnBhbmVsRWxtcyYmdGhpcy50b2dnbGVDaGlsZHJlbigpfSx0b2dnbGVDaGlsZHJlbjpmdW5jdGlvbigpe3ZhciBlPXRoaXM7dGhpcy5wYW5lbEVsbXMuZm9yRWFjaCgoZnVuY3Rpb24odCxpKXt2YXIgbj1lLmlzUGFuZWxBY3RpdmUoaSk7dC5TdWlBY2NvcmRpb25UaXRsZSYmdC5TdWlBY2NvcmRpb25UaXRsZS5zZXRBY3RpdmUobiksdC5TdWlBY2NvcmRpb25Db250ZW50JiZ0LlN1aUFjY29yZGlvbkNvbnRlbnQuc2V0QWN0aXZlKG4pfSkpfSxpc1BhbmVsQWN0aXZlOmZ1bmN0aW9uKGUpe3JldHVybiBBcnJheS5pc0FycmF5KHRoaXMuYWN0aXZlKT90aGlzLmFjdGl2ZS5pbmNsdWRlcyhlKTp0aGlzLmFjdGl2ZT09PWV9fSxyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLHQ9YXJndW1lbnRzWzBdLGk9dGhpcy5nZXRFbGVtZW50VHlwZSgpO3JldHVybiB0KGksbCgpKFt7fSx0aGlzLmdldENoaWxkUHJvcHNBbmRMaXN0ZW5lcnMoKSx7Y2xhc3M6dGhpcy5jbGFzc2VzKFwidWlcIix0aGlzLmludmVydGVkJiZcImludmVydGVkXCIsdGhpcy5mbHVpZCYmXCJmbHVpZFwiLHRoaXMuc3R5bGVkJiZcInN0eWxlZFwiLFwiYWNjb3JkaW9uXCIpfV0pLFt0aGlzLnBhbmVscz90aGlzLnBhbmVscy5tYXAoKGZ1bmN0aW9uKGksbil7dmFyIHI9aS50aXRsZSxzPWkuY29udGVudDtyZXR1cm4gdChcInRlbXBsYXRlXCIsW3QoXCJkaXZcIix7Y2xhc3M6ZS5jbGFzc2VzKFwidGl0bGVcIixlLmlzUGFuZWxBY3RpdmUobikmJlwiYWN0aXZlXCIpLG9uOntjbGljazpmdW5jdGlvbigpe3JldHVybiBlLnRvZ2dsZShuKX19fSxbcl0pLHQoXCJkaXZcIix7Y2xhc3M6ZS5jbGFzc2VzKFwiY29udGVudFwiLGUuaXNQYW5lbEFjdGl2ZShuKSYmXCJhY3RpdmVcIil9LFtzXSldKX0pKTp0aGlzLiRzbG90cy5kZWZhdWx0XSl9fSxmdD17cHJvcHM6e2FjdGl2ZTpCb29sZWFufSxkYXRhOmZ1bmN0aW9uKCl7cmV0dXJue2RhdGFBY3RpdmU6dGhpcy5hY3RpdmUsY3VycmVudEluZGV4Om51bGwsYWNjb3JkaW9uOm51bGx9fSxtZXRob2RzOntzZXRBY3RpdmU6ZnVuY3Rpb24oZSl7dGhpcy5kYXRhQWN0aXZlPWV9LHRvZ2dsZTpmdW5jdGlvbigpe3RoaXMuYWNjb3JkaW9uLnRvZ2dsZUVsKHRoaXMpfX0sbW91bnRlZDpmdW5jdGlvbigpe2Zvcih2YXIgZT10aGlzLiRwYXJlbnQ7ZSYmIXRoaXMuYWNjb3JkaW9uOylcIlN1aUFjY29yZGlvblwiPT09ZS4kb3B0aW9ucy5uYW1lJiYodGhpcy5hY2NvcmRpb249ZSksZT1lLiRwYXJlbnQ7aWYoIXRoaXMuYWNjb3JkaW9uKXRocm93IG5ldyBFcnJvcihcIlwiLmNvbmNhdCh0aGlzLiRvcHRpb25zLm5hbWUsXCIgbXVzdCBiZSBwbGFjZSBhcyBhIGNoaWxkIG9mIGEgU3VpQWNjb3JkaW9uXCIpKTt0aGlzLmFjY29yZGlvbi5yZWdpc3Rlcih0aGlzKX0sd2F0Y2g6e2FjdGl2ZTpmdW5jdGlvbihlKXt0aGlzLmRhdGFBY3RpdmU9ZX19LG1ldGE6e3BhcmVudDpcIlN1aUFjY29yZGlvblwifX07ZnVuY3Rpb24gbXQoZSx0KXt2YXIgaT1PYmplY3Qua2V5cyhlKTtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgbj1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO3QmJihuPW4uZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLHQpLmVudW1lcmFibGV9KSkpLGkucHVzaC5hcHBseShpLG4pfXJldHVybiBpfWZ1bmN0aW9uIGd0KGUsdCxpKXtyZXR1cm4gdCBpbiBlP09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQse3ZhbHVlOmksZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTplW3RdPWksZX12YXIgYnQ9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PTE7dDxhcmd1bWVudHMubGVuZ3RoO3QrKyl7dmFyIGk9bnVsbCE9YXJndW1lbnRzW3RdP2FyZ3VtZW50c1t0XTp7fTt0JTI/bXQoT2JqZWN0KGkpLCEwKS5mb3JFYWNoKChmdW5jdGlvbih0KXtndChlLHQsaVt0XSl9KSk6T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM/T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhpKSk6bXQoT2JqZWN0KGkpKS5mb3JFYWNoKChmdW5jdGlvbih0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaSx0KSl9KSl9cmV0dXJuIGV9KHtuYW1lOlwiU3VpQWNjb3JkaW9uQ29udGVudFwiLG1peGluczpbTF19LGZ0LHtyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHNbMF0sdD10aGlzLmdldEVsZW1lbnRUeXBlKCk7cmV0dXJuIGUodCxsKCkoW3t9LHRoaXMuZ2V0Q2hpbGRQcm9wc0FuZExpc3RlbmVycygpLHtjbGFzczp0aGlzLmNsYXNzZXMoXCJjb250ZW50XCIsdGhpcy5kYXRhQWN0aXZlJiZcImFjdGl2ZVwiKX1dKSxbdGhpcy4kc2xvdHMuZGVmYXVsdF0pfX0pO2Z1bmN0aW9uIHl0KGUsdCl7dmFyIGk9T2JqZWN0LmtleXMoZSk7aWYoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyl7dmFyIG49T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTt0JiYobj1uLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSx0KS5lbnVtZXJhYmxlfSkpKSxpLnB1c2guYXBwbHkoaSxuKX1yZXR1cm4gaX1mdW5jdGlvbiB2dChlLHQsaSl7cmV0dXJuIHQgaW4gZT9PYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHt2YWx1ZTppLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6ZVt0XT1pLGV9dmFyIFN0PWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD0xO3Q8YXJndW1lbnRzLmxlbmd0aDt0Kyspe3ZhciBpPW51bGwhPWFyZ3VtZW50c1t0XT9hcmd1bWVudHNbdF06e307dCUyP3l0KE9iamVjdChpKSwhMCkuZm9yRWFjaCgoZnVuY3Rpb24odCl7dnQoZSx0LGlbdF0pfSkpOk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzP09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoaSkpOnl0KE9iamVjdChpKSkuZm9yRWFjaCgoZnVuY3Rpb24odCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGksdCkpfSkpfXJldHVybiBlfSh7bmFtZTpcIlN1aUFjY29yZGlvblRpdGxlXCIsbWl4aW5zOltMXX0sZnQse3JlbmRlcjpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50c1swXSx0PXRoaXMuZ2V0RWxlbWVudFR5cGUoKTtyZXR1cm4gZSh0LGwoKShbe30sdGhpcy5nZXRDaGlsZFByb3BzQW5kTGlzdGVuZXJzKCkse2NsYXNzOnRoaXMuY2xhc3NlcyhcInRpdGxlXCIsdGhpcy5kYXRhQWN0aXZlJiZcImFjdGl2ZVwiKSxvbjp7Y2xpY2s6dGhpcy50b2dnbGV9fV0pLFt0aGlzLiRzbG90cy5kZWZhdWx0XSl9fSksd3Q9e25hbWU6XCJTdWlDaGVja2JveFwiLG1vZGVsOntwcm9wOlwiaW5wdXRWYWx1ZVwiLGV2ZW50OlwiY2hhbmdlXCJ9LG1peGluczpbTF0scHJvcHM6e2Rpc2FibGVkOnt0eXBlOkJvb2xlYW4sZGVzY3JpcHRpb246XCJEaXNhYmxlcyBjaGVja2JveCBpbnRlcmFjdGlvbnNcIn0saW5wdXRWYWx1ZTpbQXJyYXksQm9vbGVhbixOdW1iZXIsU3RyaW5nLE9iamVjdF0sbGFiZWw6e3R5cGU6U3RyaW5nLGRlc2NyaXB0aW9uOlwiQWRkcyBsYWJlbCBuZXh0IHRvIHRoZSBjaGVja2JveFwifSxyYWRpbzp7dHlwZTpCb29sZWFuLGRlc2NyaXB0aW9uOlwiQ2hhbmdlcyBjaGVja2JveCB0byByYWRpbyBidXR0b25cIn0sdG9nZ2xlOnt0eXBlOkJvb2xlYW4sZGVzY3JpcHRpb246XCJNYWtlIGNoZWNrYm94IGxvb2tzIGxpa2UgYSBvbi9vZmYgdG9nZ2xlXCJ9LG5hbWU6e3R5cGU6U3RyaW5nLGRlc2NyaXB0aW9uOlwiTmFtaW5nIGlucHV0IGZpZWxkXCJ9LHZhbHVlOltTdHJpbmcsT2JqZWN0XSxyZXF1aXJlZDp7dHlwZTpCb29sZWFuLGRlc2NyaXB0aW9uOidBZGRzIFwicmVxdWlyZWRcIiB0byBjaGVja2JveCBpbnB1dCd9LHNsaWRlcjp7dHlwZTpCb29sZWFuLGRlc2NyaXB0aW9uOlwiTWFrZSBjaGVja2JveCBsb29rcyBsaWtlIGEgdHdvLXBvc2l0aW9uYWwgc2xpZGVyXCJ9fSxldmVudHM6e2NoYW5nZTp7Y3VzdG9tOiEwfX0sY29tcHV0ZWQ6e2lzQXJyYXk6ZnVuY3Rpb24oKXtyZXR1cm4gQXJyYXkuaXNBcnJheSh0aGlzLmlucHV0VmFsdWUpfSxpc0NoZWNrZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yYWRpbyYmdGhpcy52YWx1ZT90aGlzLmlucHV0VmFsdWU9PT10aGlzLnZhbHVlOnRoaXMuaXNBcnJheT90aGlzLmlucHV0VmFsdWUuaW5jbHVkZXModGhpcy52YWx1ZSk6ISF0aGlzLmlucHV0VmFsdWV9fSxtZXRob2RzOntzZXRWYWx1ZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzLGk9ZS50YXJnZXQuY2hlY2tlZDt0aGlzLnJhZGlvJiZ0aGlzLnZhbHVlP3RoaXMuJGVtaXQoXCJjaGFuZ2VcIix0aGlzLnZhbHVlKTp0aGlzLmlzQXJyYXk/aT90aGlzLiRlbWl0KFwiY2hhbmdlXCIsdGhpcy5pbnB1dFZhbHVlLmNvbmNhdChbdGhpcy52YWx1ZV0pKTp0aGlzLiRlbWl0KFwiY2hhbmdlXCIsdGhpcy5pbnB1dFZhbHVlLmZpbHRlcigoZnVuY3Rpb24oZSl7cmV0dXJuIGUhPT10LnZhbHVlfSkpKTp0aGlzLiRlbWl0KFwiY2hhbmdlXCIsaSl9fSxyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLHQ9YXJndW1lbnRzWzBdLGk9dGhpcy5nZXRFbGVtZW50VHlwZSgpO3JldHVybiB0KGksbCgpKFt7fSx0aGlzLmdldENoaWxkUHJvcHNBbmRMaXN0ZW5lcnMoKSx7Y2xhc3M6dGhpcy5jbGFzc2VzKFwidWlcIiwhKHRoaXMubGFiZWx8fHRoaXMuJHNsb3RzLmRlZmF1bHQpJiZcImZpdHRlZFwiLHRoaXMucmFkaW8mJlwicmFkaW9cIix0aGlzLnRvZ2dsZSYmXCJ0b2dnbGVcIix0aGlzLnNsaWRlciYmXCJzbGlkZXJcIix0aGlzLmRpc2FibGVkJiZcImRpc2FibGVkXCIsXCJjaGVja2JveFwiKX1dKSxbdChcImlucHV0XCIse3JlZjpcImlucHV0XCIsY2xhc3M6XCJoaWRkZW5cIixhdHRyczp7cmVhZG9ubHk6XCJcIix0YWJpbmRleDpcIjBcIixuYW1lOnRoaXMubmFtZSx0eXBlOnRoaXMucmFkaW8/XCJyYWRpb1wiOlwiY2hlY2tib3hcIixkaXNhYmxlZDp0aGlzLmRpc2FibGVkLHJlcXVpcmVkOnRoaXMucmVxdWlyZWR9LGRvbVByb3BzOntjaGVja2VkOnRoaXMuaXNDaGVja2VkfSxvbjp7Y2hhbmdlOnRoaXMuc2V0VmFsdWV9fSksdChcImxhYmVsXCIse29uOntjbGljazpmdW5jdGlvbigpe3JldHVybiBlLiRyZWZzLmlucHV0LmNsaWNrKCl9fSxhdHRyczp7Zm9yOnRoaXMubmFtZX19LFt0aGlzLmxhYmVsfHx0aGlzLiRzbG90cy5kZWZhdWx0XSldKX19LEF0PXtuYW1lOlwiU3VpRGltbWVyXCIsbWl4aW5zOltMXSxwcm9wczp7YWN0aXZlOkJvb2xlYW4saW52ZXJ0ZWQ6Qm9vbGVhbn0scmVuZGVyOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzWzBdLHQ9dGhpcy5nZXRFbGVtZW50VHlwZSgpO3JldHVybiBlKHQsbCgpKFt7fSx0aGlzLmdldENoaWxkUHJvcHNBbmRMaXN0ZW5lcnMoKSx7Y2xhc3M6dGhpcy5jbGFzc2VzKFwidWlcIix0aGlzLmFjdGl2ZSYmXCJhY3RpdmVcIix0aGlzLmludmVydGVkJiZcImludmVydGVkXCIsXCJkaW1tZXJcIil9XSksW2UoXCJkaXZcIix7Y2xhc3M6XCJjb250ZW50XCJ9LFtlKFwiZGl2XCIse2NsYXNzOlwiY2VudGVyXCJ9LFt0aGlzLiRzbG90cy5kZWZhdWx0XSldKV0pfX0sT3Q9e25hbWU6XCJTdWlEaW1tZXJEaW1tYWJsZVwiLG1peGluczpbTF0scHJvcHM6e30scmVuZGVyOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzWzBdLHQ9dGhpcy5nZXRFbGVtZW50VHlwZSgpO3JldHVybiBlKHQsbCgpKFt7fSx0aGlzLmdldENoaWxkUHJvcHNBbmRMaXN0ZW5lcnMoKSx7Y2xhc3M6dGhpcy5jbGFzc2VzKFwiZGltbWFibGVcIil9XSksW3RoaXMuJHNsb3RzLmRlZmF1bHRdKX0sbWV0YTp7cGFyZW50OlwiU3VpRGltbWVyXCJ9fTtmdW5jdGlvbiB4dChlLHQpe3ZhciBpPU9iamVjdC5rZXlzKGUpO2lmKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpe3ZhciBuPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7dCYmKG49bi5maWx0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsdCkuZW51bWVyYWJsZX0pKSksaS5wdXNoLmFwcGx5KGksbil9cmV0dXJuIGl9ZnVuY3Rpb24gUHQoZSl7Zm9yKHZhciB0PTE7dDxhcmd1bWVudHMubGVuZ3RoO3QrKyl7dmFyIGk9bnVsbCE9YXJndW1lbnRzW3RdP2FyZ3VtZW50c1t0XTp7fTt0JTI/eHQoT2JqZWN0KGkpLCEwKS5mb3JFYWNoKChmdW5jdGlvbih0KXtCdChlLHQsaVt0XSl9KSk6T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM/T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhpKSk6eHQoT2JqZWN0KGkpKS5mb3JFYWNoKChmdW5jdGlvbih0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaSx0KSl9KSl9cmV0dXJuIGV9ZnVuY3Rpb24gQnQoZSx0LGkpe3JldHVybiB0IGluIGU/T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCx7dmFsdWU6aSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOmVbdF09aSxlfXZhciBDdD17bmFtZTpcIlN1aURyb3Bkb3duSXRlbVwiLG1peGluczpbTF0scHJvcHM6e2ZsYWc6e3R5cGU6U3RyaW5nLGRlc2NyaXB0aW9uOlwiU2hvcnRoYW5kIGZvciBzdWktZmxhZy5cIn0saW1hZ2U6e3R5cGU6T2JqZWN0LGRlc2NyaXB0aW9uOlwiU2hvcnRoYW5kIGZvciBzdWktaW1hZ2UuXCJ9LGljb246e3R5cGU6U3RyaW5nLGRlc2NyaXB0aW9uOlwiU2hvcnRoYW5kIGZvciBzdWktaWNvbi5cIn0sbGFiZWw6e3R5cGU6T2JqZWN0LGRlc2NyaXB0aW9uOlwiU2hvcnRoYW5kIGZvciBzdWktbGFiZWxcIn0sdGV4dDp7dHlwZTpTdHJpbmcsZGVzY3JpcHRpb246XCJEaXNwbGF5IHRleHQuXCJ9LHZhbHVlOnt0eXBlOm51bGwsZGVzY3JpcHRpb246XCJTdG9yZWQgdmFsdWUuXCJ9LGFjdGl2ZTp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITEsZGVzY3JpcHRpb246XCJTdHlsZSBhcyB0aGUgY3VycmVudGx5IGNob3NlbiBpdGVtLlwifSxzZWxlY3RlZDp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITEsZGVzY3JpcHRpb246XCJJcyBpdGVtIHNlbGVjdGVkXCJ9LGRpc2FibGVkOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMSxkZXNjcmlwdGlvbjpcIkEgZHJvcGRvd24gaXRlbSBjYW4gYmUgZGlzYWJsZWQuXCJ9fSxldmVudHM6e3NlbGVjdDp7Y3VzdG9tOiEwfX0sbWV0aG9kczp7c2VsZWN0OmZ1bmN0aW9uKCl7dGhpcy4kZW1pdChcInNlbGVjdFwiLHRoaXMudmFsdWUpfX0scmVuZGVyOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzWzBdLHQ9dGhpcy5nZXRFbGVtZW50VHlwZSgpO3JldHVybiBlKHQsbCgpKFt7fSx0aGlzLmdldENoaWxkUHJvcHNBbmRMaXN0ZW5lcnMoKSx7YXR0cnM6e3JvbGU6XCJvcHRpb25cIn0sY2xhc3M6dGhpcy5jbGFzc2VzKHRoaXMuZGlzYWJsZWQmJlwiZGlzYWJsZWRcIix0aGlzLmFjdGl2ZSYmXCJhY3RpdmVcIix0aGlzLnNlbGVjdGVkJiZcInNlbGVjdGVkXCIsXCJpdGVtXCIpLG9uOntjbGljazp0aGlzLnNlbGVjdH19XSksW3RoaXMuaWNvbiYmZShRLHthdHRyczp7bmFtZTp0aGlzLmljb259fSksdGhpcy5pbWFnZSYmZShEZSx7cHJvcHM6UHQoe30sdGhpcy5pbWFnZSl9KSx0aGlzLmZsYWcmJmUoRWUse2F0dHJzOntuYW1lOnRoaXMuZmxhZ319KSx0aGlzLmxhYmVsJiZlKE5lLHtwcm9wczpQdCh7fSx0aGlzLmxhYmVsKX0pLHRoaXMudGV4dHx8dGhpcy4kc2xvdHMuZGVmYXVsdF0pfSxtZXRhOntwYXJlbnQ6XCJTdWlEcm9wZG93blwifX0sanQ9XCJjbG9zZWRcIixFdD1cIm9wZW5pbmdcIixUdD1cIm9wZW5cIiwkdD1cImNsb3NpbmdcIixMdD17bmFtZTpcIlN1aURyb3Bkb3duTWVudVwiLG1peGluczpbTF0sZGF0YTpmdW5jdGlvbigpe3JldHVybntvcGVuOiExLHZpc3VhbFN0YXRlOmp0fX0sY29tcHV0ZWQ6e2FuaW1hdGlvbjpmdW5jdGlvbigpe3ZhciBlPXRoaXMuJHBhcmVudC5hbmltYXRpb247c3dpdGNoKHRoaXMudmlzdWFsU3RhdGUpe2Nhc2UgRXQ6cmV0dXJuXCJhbmltYXRpbmcgXCIuY29uY2F0KGUsXCIgaW4gdmlzaWJsZVwiKTtjYXNlICR0OnJldHVyblwiYW5pbWF0aW5nIFwiLmNvbmNhdChlLFwiIG91dCB2aXNpYmxlXCIpO2RlZmF1bHQ6cmV0dXJuXCJcIn19fSx3YXRjaDp7b3BlbjpmdW5jdGlvbihlKXt0aGlzLnZpc3VhbFN0YXRlPWU/RXQ6JHR9fSxtb3VudGVkOmZ1bmN0aW9uKCl7Zm9yKHZhciBlPXRoaXMuJHBhcmVudDtlJiYhdGhpcy5hY2NvcmRpb247KS9eU3VpRHJvcGRvd24oV2l0aFJlcXVpcmVkKT8kLy50ZXN0KGUuJG9wdGlvbnMubmFtZSkmJih0aGlzLmRyb3Bkb3duPWUpLGU9ZS4kcGFyZW50O2lmKCF0aGlzLmRyb3Bkb3duKXRocm93IG5ldyBFcnJvcihcIlN1aURyb3Bkb3duTWVudSBtdXN0IGJlIHBsYWNlIGFzIGEgY2hpbGQgb2YgYSBTdWlEcm9wZG93blwiKTt0aGlzLmRyb3Bkb3duLnJlZ2lzdGVyKHRoaXMpLHRoaXMuJGVsLmFkZEV2ZW50TGlzdGVuZXIoRCgpLHRoaXMub25BbmltYXRpb25FbmRlZCwhMSl9LG1ldGhvZHM6e29uQW5pbWF0aW9uRW5kZWQ6ZnVuY3Rpb24oKXt0aGlzLnZpc3VhbFN0YXRlPXRoaXMub3Blbj9UdDpqdH0sc2V0T3BlbjpmdW5jdGlvbihlKXt0aGlzLm9wZW49ZX19LHJlbmRlcjpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50c1swXSx0PXRoaXMuZ2V0RWxlbWVudFR5cGUoKTtyZXR1cm4gZSh0LGwoKShbe2F0dHJzOnt0YWJpbmRleDpcIi0xXCJ9fSx0aGlzLmdldENoaWxkUHJvcHNBbmRMaXN0ZW5lcnMoKSx7Y2xhc3M6dGhpcy5jbGFzc2VzKFwibWVudVwiLHRoaXMub3BlbiYmXCJ2aXNpYmxlIGFjdGl2ZVwiLFwidHJhbnNpdGlvblwiLHRoaXMuYW5pbWF0aW9uKX1dKSxbdGhpcy4kc2xvdHMuZGVmYXVsdF0pfSxtZXRhOntwYXJlbnQ6XCJTdWlEcm9wZG93blwifX07ZnVuY3Rpb24ga3QoZSl7cmV0dXJuKGt0PVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbihlKXtyZXR1cm4gdHlwZW9mIGV9OmZ1bmN0aW9uKGUpe3JldHVybiBlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJmUuY29uc3RydWN0b3I9PT1TeW1ib2wmJmUhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIGV9KShlKX1mdW5jdGlvbiBEdChlLHQpe3ZhciBpPU9iamVjdC5rZXlzKGUpO2lmKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpe3ZhciBuPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7dCYmKG49bi5maWx0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsdCkuZW51bWVyYWJsZX0pKSksaS5wdXNoLmFwcGx5KGksbil9cmV0dXJuIGl9ZnVuY3Rpb24gSXQoZSl7Zm9yKHZhciB0PTE7dDxhcmd1bWVudHMubGVuZ3RoO3QrKyl7dmFyIGk9bnVsbCE9YXJndW1lbnRzW3RdP2FyZ3VtZW50c1t0XTp7fTt0JTI/RHQoT2JqZWN0KGkpLCEwKS5mb3JFYWNoKChmdW5jdGlvbih0KXtNdChlLHQsaVt0XSl9KSk6T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM/T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhpKSk6RHQoT2JqZWN0KGkpKS5mb3JFYWNoKChmdW5jdGlvbih0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaSx0KSl9KSl9cmV0dXJuIGV9ZnVuY3Rpb24gTXQoZSx0LGkpe3JldHVybiB0IGluIGU/T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCx7dmFsdWU6aSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOmVbdF09aSxlfXZhciBGdD17YXV0bzpcImF1dG9cIixhdXRvVXB3YXJkOlwiYXV0by11cHdhcmRcIix1cHdhcmQ6XCJ1cHdhcmRcIixkb3dud2FyZDpcImRvd253YXJkXCJ9LHp0PVwic2xpZGVcIixSdD1cImRvd25cIixOdD1cInVwXCI7dmFyIEh0LFZ0PXtuYW1lOlwiU3VpRHJvcGRvd25cIixtaXhpbnM6W0xdLHByb3BzOnthbGxvd0FkZGl0aW9uczp7dHlwZTpCb29sZWFuLGRlc2NyaXB0aW9uOlwiQSBkcm9wZG93biBjYW4gYWxsb3cgdXNlciBhZGRpdGlvbnMuXCJ9LGJ1dHRvbjp7dHlwZTpCb29sZWFuLGRlc2NyaXB0aW9uOlwiQSBkcm9wZG93biBidXR0b24gc3R5bGUuXCJ9LGljb246e3R5cGU6U3RyaW5nLGRlc2NyaXB0aW9uOlwiQ2hhbmdlIGRlZmF1bHQgYnV0dG9uIHRvIG90aGVyIGJ1dHRvbi5cIn0saXRlbTp7dHlwZTpCb29sZWFuLGRlc2NyaXB0aW9uOlwiQSBkcm9wZG93biBjYW4gYmUgZm9ybWF0dGVkIGFzIGEgTWVudSBpdGVtLlwifSxmbG9hdGluZzp7dHlwZTpCb29sZWFuLGRlc2NyaXB0aW9uOlwiQSBkcm9wZG93biBtZW51IGNhbiBhcHBlYXIgdG8gYmUgZmxvYXRpbmcgYmVsb3cgYW4gZWxlbWVudC5cIn0sZmx1aWQ6e3R5cGU6Qm9vbGVhbixkZXNjcmlwdGlvbjpcIkEgZHJvcGRvd24gY2FuIHRha2UgdGhlIGZ1bGwgd2lkdGggb2YgaXRzIHBhcmVudC5cIn0sbGFiZWxlZDp7dHlwZTpCb29sZWFuLGRlc2NyaXB0aW9uOlwiQSBkcm9wZG93biBjYW4gYmUgbGFiZWxlZC5cIn0sbXVsdGlwbGU6e3R5cGU6Qm9vbGVhbixkZXNjcmlwdGlvbjpcIkEgc2VsZWN0aW9uIGRyb3Bkb3duIGNhbiBhbGxvdyBtdWx0aXBsZSBzZWxlY3Rpb25zLlwifSxsb2FkaW5nOnt0eXBlOkJvb2xlYW4sZGVzY3JpcHRpb246XCJBIGRyb3Bkb3duIGNhbiBzaG93IHRoYXQgaXQgaXMgY3VycmVudGx5IGxvYWRpbmcgZGF0YS5cIn0sbWF4U2VsZWN0aW9uczp7dHlwZTpOdW1iZXIsZGVmYXVsdDoxLzAsZGVzY3JpcHRpb246XCJNYXhpbXVtIHBvc3NpYmxlIHNlbGVjdGlvbnMgd2hlbiB1c2luZyBtdWx0aXBsZSBzZWxlY3Rpb25cIn0sb3B0aW9uczp7dHlwZTpBcnJheSxkZWZhdWx0OmZ1bmN0aW9uKCl7cmV0dXJuW119LGRlc2NyaXB0aW9uOlwiQXJyYXkgb2YgU3VpRHJvcGRvd25JdGVtIHByb3BzIGUuZy4gYHsgdGV4dDogJycsIHZhbHVlOiAnJyB9YFwifSxwbGFjZWhvbGRlcjp7dHlwZTpTdHJpbmcsZGVzY3JpcHRpb246XCJQbGFjZWhvbGRlciB0ZXh0LlwifSxwb2ludGluZzp7dHlwZTpTdHJpbmcsZGVzY3JpcHRpb246XCJBIGRyb3Bkb3duIGNhbiBiZSBmb3JtYXR0ZWQgc28gdGhhdCBpdHMgbWVudSBpcyBwb2ludGluZy5cIn0sc2VhcmNoOnt0eXBlOkJvb2xlYW4sZGVzY3JpcHRpb246XCJBIGRyb3Bkb3duIGNhbiBoYXZlIGEgc2VhcmNoIGZpZWxkIHRvIGZpbHRlciBvcHRpb25zLlwifSxzZWFyY2hJbk1lbnU6e3R5cGU6T2JqZWN0LGRlc2NyaXB0aW9uOlwiQSBkcm9wZG93biBjYW4gaGF2ZSBhIHNlYXJjaCBpbnB1dCBpbiBkcm9wZG93biBtZW51LiBTaG91bGQgYmUgcGFzc2VkIGFuIE9iamVjdCB3aXRoIFN1aUlucHV0IHByb3BzLlwifSxzZWxlY3Rpb246e3R5cGU6Qm9vbGVhbixkZXNjcmlwdGlvbjpcIkEgZHJvcGRvd24gY2FuIGJlIHVzZWQgdG8gc2VsZWN0IGJldHdlZW4gY2hvaWNlcyBpbiBhIGZvcm0uXCJ9LHNpbXBsZTp7dHlwZTpCb29sZWFuLGRlc2NyaXB0aW9uOlwiQSBkcm9wZG93biB0aGF0IHdvcmtzIHdpdGhvdXQgSmF2YVNjcmlwdFwiLGRlZmF1bHQ6ITF9LHRleHQ6e3R5cGU6U3RyaW5nLGRlc2NyaXB0aW9uOlwiVGV4dCBvZiBkcm9wZG93blwifSx2YWx1ZTp7dHlwZTpbQXJyYXksU3RyaW5nLE51bWJlcl0sZGVzY3JpcHRpb246XCJWYWx1ZSBvZiB0aGUgZHJvcGRvd24uXCJ9LGRpcmVjdGlvbjpfKE9iamVjdC52YWx1ZXMoRnQpLHtkZWZhdWx0OkZ0LmF1dG8sZGVzY3JpcHRpb246XCJBIGRyb3Bkb3duIGNhbiBoYXZlIGEgZGlyZWN0aW9uIHRvIG9wZW5cIn0pLG9wZW5PbkZvY3VzOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMCxkZXNjcmlwdGlvbjpcIldoZXRoZXIgb3Igbm90IHRoZSBtZW51IHNob3VsZCBvcGVuIHdoZW4gdGhlIGRyb3Bkb3duIGlzIGZvY3VzZWQuXCJ9LGNsb3NlT25CbHVyOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMCxkZXNjcmlwdGlvbjpcIldoZXRoZXIgb3Igbm90IHRoZSBtZW51IHNob3VsZCBjbG9zZSB3aGVuIHRoZSBkcm9wZG93biBpcyBibHVycmVkLlwifSxub1Jlc3VsdHNNZXNzYWdlOnt0eXBlOlN0cmluZyxkZWZhdWx0OlwiTm8gcmVzdWx0cyBmb3VuZFwiLGRlc2NyaXB0aW9uOlwiTWVzc2FnZSB0byBkaXNwbGF5IHdoZW4gdGhlcmUgYXJlIG5vIHJlc3VsdHMuXCJ9LG1heFNlbGVjdGlvbnNNZXNzYWdlOnt0eXBlOlN0cmluZyxkZWZhdWx0OlwiTWF4IHtzZWxlY3Rpb25zfSBzZWxlY3Rpb25zXCIsZGVzY3JpcHRpb246XCJNZXNzYWdlIHRvIGRpc3BsYXkgd2hlbiB0aGUgbWF4aW11bSBhbW91bnQgb2Ygc2VsZWN0aW9ucyBpcyByZWFjaGVkLlwifSxkaXNhYmxlZDp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITEsZGVzY3JpcHRpb246XCJXaGV0aGVyIG9yIG5vdCB0aGUgZHJvcGRvd24gaXMgZGlzYWJsZWRcIn19LGV2ZW50czp7aW5wdXQ6e2N1c3RvbTohMH19LGRhdGE6ZnVuY3Rpb24oKXtyZXR1cm57ZmlsdGVyOlwiXCIsbWVudTpudWxsLG9wZW46ITEsbWVudURpcmVjdGlvbjpudWxsLGZvY3VzZWQ6ITEsaXNNb3VzZURvd246ITEsc2VsZWN0ZWRJbmRleDotMX19LGNvbXB1dGVkOnttYXhpbXVtVmFsdWVzU2VsZWN0ZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tdWx0aXBsZVZhbHVlLmxlbmd0aD49dGhpcy5tYXhTZWxlY3Rpb25zfSxkb3dud2FyZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRpcmVjdGlvbiE9PUZ0LmF1dG8mJnRoaXMuZGlyZWN0aW9uIT09RnQuYXV0b1Vwd2FyZD90aGlzLmRpcmVjdGlvbj09PUZ0LmRvd253YXJkOih0aGlzLmNhbGN1bGF0ZU1lbnVEaXJlY3Rpb24oKSxudWxsPT09dGhpcy5tZW51RGlyZWN0aW9ufHwodGhpcy5tZW51RGlyZWN0aW9uLmJlbG93JiZ0aGlzLm1lbnVEaXJlY3Rpb24uYWJvdmV8fCF0aGlzLm1lbnVEaXJlY3Rpb24uYmVsb3cmJiF0aGlzLm1lbnVEaXJlY3Rpb24uYWJvdmU/dGhpcy5kaXJlY3Rpb249PT1GdC5hdXRvOiEhdGhpcy5tZW51RGlyZWN0aW9uLmJlbG93KSl9LGFuaW1hdGlvbjpmdW5jdGlvbigpe3JldHVyblwiXCIuY29uY2F0KHp0LFwiIFwiKS5jb25jYXQodGhpcy5kb3dud2FyZD9SdDpOdCl9LGZpbHRlcmVkT3B0aW9uczpmdW5jdGlvbigpe3ZhciBlPXRoaXM7aWYoIXRoaXMuc2VhcmNoJiYhdGhpcy5tdWx0aXBsZSYmIXRoaXMuc2VhcmNoSW5NZW51KXJldHVybiB0aGlzLm9wdGlvbnM7dmFyIHQ9bmV3IFJlZ0V4cCh0aGlzLmZpbHRlci5yZXBsYWNlKC9bLS9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLFwiXFxcXCQmXCIpLFwiaVwiKTtyZXR1cm4gdGhpcy5vcHRpb25zLmZpbHRlcigoZnVuY3Rpb24oaSl7cmV0dXJuIShlLmZpbHRlciYmIXQudGVzdChpLnRleHQpKSYmKCFlLm11bHRpcGxlfHwhKGUubWF4aW11bVZhbHVlc1NlbGVjdGVkfHxlLm11bHRpcGxlVmFsdWUuaW5kZXhPZihpLnZhbHVlKT4tMSkpfSkpfSxtZXNzYWdlOmZ1bmN0aW9uKCl7aWYoMD09PXRoaXMuZmlsdGVyZWRPcHRpb25zLmxlbmd0aCl7aWYodGhpcy5tdWx0aXBsZSYmdGhpcy5tYXhpbXVtVmFsdWVzU2VsZWN0ZWQpcmV0dXJuIHRoaXMubWF4U2VsZWN0aW9uc01lc3NhZ2UucmVwbGFjZShcIntzZWxlY3Rpb25zfVwiLHRoaXMubWF4U2VsZWN0aW9ucyk7aWYodGhpcy5maWx0ZXImJiF0aGlzLmFsbG93QWRkaXRpb25zKXJldHVybiB0aGlzLm5vUmVzdWx0c01lc3NhZ2V9cmV0dXJuXCJcIn0sbWVudU5vZGU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLHQ9dGhpcy4kY3JlYXRlRWxlbWVudDtyZXR1cm4gdChMdCxbW3RoaXMuc2VhcmNoSW5NZW51JiZbdChSZSxsKCkoW3t9LHtwcm9wczp0aGlzLnNlYXJjaEluTWVudSxyZWY6XCJzZWFyY2hJbk1lbnVcIn0se29uOntpbnB1dDp0aGlzLnVwZGF0ZUZpbHRlcixrZXlkb3duOnRoaXMuaGFuZGxlU2VhcmNoS2V5RG93bn0sYXR0cnM6e3ZhbHVlOnRoaXMuZmlsdGVyfX1dKSksdChqZSldLHRoaXMubWVzc2FnZT90KFwiZGl2XCIse2NsYXNzOlwibWVzc2FnZVwifSxbdGhpcy5tZXNzYWdlXSk6dGhpcy5maWx0ZXJlZE9wdGlvbnMubWFwKChmdW5jdGlvbihpLG4pe3JldHVybiB0KEN0LHtwcm9wczpJdCh7fSxpKSxhdHRyczp7YWN0aXZlOmUubXVsdGlwbGU/LTEhPT1lLm11bHRpcGxlVmFsdWUuaW5kZXhPZihpLnZhbHVlKTplLnZhbHVlPT09aS52YWx1ZSxzZWxlY3RlZDplLnNlbGVjdGVkSW5kZXg9PT1ufSxjbGFzczppLmNsYXNzLG9uOntzZWxlY3Q6ZS5zZWxlY3RJdGVtfX0pfSkpXV0pfSxtdWx0aXBsZVZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIEFycmF5LmlzQXJyYXkodGhpcy52YWx1ZSk/dGhpcy52YWx1ZTpbXX0sc2VhcmNoTm9kZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMuJGNyZWF0ZUVsZW1lbnQ7cmV0dXJuIHRoaXMuc2VhcmNoJiZlKFwiaW5wdXRcIix7YXR0cnM6e3R5cGU6XCJ0ZXh0XCIsXCJhcmlhLWF1dG9jb21wbGV0ZVwiOlwibGlzdFwiLGF1dG9Db21wbGV0ZTpcIm9mZlwiLHRhYmluZGV4OlwiMFwifSxjbGFzczpcInNlYXJjaFwiLG9uOntpbnB1dDp0aGlzLnVwZGF0ZUZpbHRlcixrZXlkb3duOnRoaXMuaGFuZGxlU2VhcmNoS2V5RG93bn0scmVmOlwic2VhcmNoXCIsZG9tUHJvcHM6e3ZhbHVlOnRoaXMuZmlsdGVyfX0pfSxzZWxlY3RlZE5vZGVzOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcyx0PXRoaXMuJGNyZWF0ZUVsZW1lbnQ7cmV0dXJuIHRoaXMubXVsdGlwbGU/dGhpcy5tdWx0aXBsZVZhbHVlLm1hcCgoZnVuY3Rpb24oaSl7dmFyIG49ZS5maW5kT3B0aW9uKGkpLHI9ZS5hbGxvd0FkZGl0aW9ucyYmIW4/e3RleHQ6aX06bjtyZXR1cm4gcj90KE5lLHtuYXRpdmVPbjp7Y2xpY2s6ZS5oYW5kbGVDbGlja09uU2VsZWN0ZWROb2RlfX0sW3IuaWNvbiYmdChRLHthdHRyczp7bmFtZTpyLmljb259fSksci5pbWFnZSYmdChEZSx7cHJvcHM6SXQoe30sci5pbWFnZSl9KSxyLmZsYWcmJnQoRWUse2F0dHJzOntuYW1lOnIuZmxhZ319KSxyLnRleHQsdChRLHthdHRyczp7bmFtZTpcImRlbGV0ZVwifSxuYXRpdmVPbjp7Y2xpY2s6ZnVuY3Rpb24oKXtyZXR1cm4gZS5kZXNlbGVjdEl0ZW0oaSl9fX0pXSk6bnVsbH0pKS5maWx0ZXIoKGZ1bmN0aW9uKGUpe3JldHVybiBudWxsIT1lfSkpOm51bGx9LHRleHROb2RlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy4kY3JlYXRlRWxlbWVudCx0PXRoaXMudGV4dHx8dGhpcy5wbGFjZWhvbGRlcixpPXRoaXMubXVsdGlwbGUmJnRoaXMudmFsdWUmJnRoaXMudmFsdWUubGVuZ3RofHwhdGhpcy5tdWx0aXBsZSYmLTE9PT1bbnVsbCx2b2lkIDBdLmluZGV4T2YodGhpcy52YWx1ZSksbj0hdGhpcy5tdWx0aXBsZSYmdGhpcy5vcGVuJiZ2b2lkIDAhPT10aGlzLmZpbHRlcmVkT3B0aW9uc1t0aGlzLnNlbGVjdGVkSW5kZXhdJiZ0aGlzLmZpbHRlcmVkT3B0aW9uc1t0aGlzLnNlbGVjdGVkSW5kZXhdLnZhbHVlPT09dGhpcy52YWx1ZSxyPWk/dGhpcy5maW5kT3B0aW9uKHRoaXMudmFsdWUpOnQ7aWYoIXIpcmV0dXJuIG51bGw7dmFyIHM9dGhpcy5jbGFzc2VzKHRoaXMucGxhY2Vob2xkZXImJiFpJiZcImRlZmF1bHRcIiwhdGhpcy5zZWFyY2hJbk1lbnUmJnRoaXMuZmlsdGVyJiYhbiYmXCJmaWx0ZXJlZFwiLFwidGV4dFwiKSxvPVwib2JqZWN0XCI9PT1rdChyKT9yOnt0ZXh0OnJ9O3JldHVybiBlKFwiZGl2XCIse3JlZjpcInRleHRcIixjbGFzczpzLGF0dHJzOntyb2xlOlwiYWxlcnRcIixcImFyaWEtbGl2ZVwiOlwicG9saXRlXCJ9fSxbby5pY29uJiZlKFEse2F0dHJzOntuYW1lOm8uaWNvbn19KSxvLmltYWdlJiZlKERlLHtwcm9wczpJdCh7fSxvLmltYWdlKX0pLG8uZmxhZyYmZShFZSx7YXR0cnM6e25hbWU6by5mbGFnfX0pLG8ubGFiZWwmJmUoTmUse3Byb3BzOkl0KHt9LG8ubGFiZWwpfSksby50ZXh0XSl9fSx3YXRjaDp7ZmlsdGVyZWRPcHRpb25zOmZ1bmN0aW9uKCl7dGhpcy51cGRhdGVTZWxlY3RlZEluZGV4KCl9LGZpbHRlcjpmdW5jdGlvbihlKXt0aGlzLiRlbWl0KFwiZmlsdGVyZWRcIixlKSx0aGlzLnNlYXJjaCYmdGhpcy5yZXNpemVJbnB1dCgpfX0sbW91bnRlZDpmdW5jdGlvbigpe2RvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsdGhpcy5jbG9zZU1lbnUpfSxkZXN0cm95ZWQ6ZnVuY3Rpb24oKXtkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLHRoaXMuY2xvc2VNZW51KX0sbWV0aG9kczp7c2V0T3BlbjpmdW5jdGlvbigpe3ZhciBlPSEoYXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0pfHxhcmd1bWVudHNbMF07dGhpcy5vcGVuPWUsdGhpcy5zZWFyY2gmJnRoaXMuZmlsdGVyZWRPcHRpb25zLmxlbmd0aD49MCYmKHRoaXMuc2VsZWN0ZWRJbmRleD0wKSx0aGlzLm1lbnUmJnRoaXMubWVudS5zZXRPcGVuJiZ0aGlzLm1lbnUuc2V0T3BlbihlKX0sY2xvc2VNZW51OmZ1bmN0aW9uKCl7dGhpcy5jbG9zZU9uQmx1ciYmdGhpcy5zZXRPcGVuKCExKX0sZGVzZWxlY3RJdGVtOmZ1bmN0aW9uKGUpe3RoaXMuJGVtaXQoXCJpbnB1dFwiLHRoaXMubXVsdGlwbGVWYWx1ZS5maWx0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiB0IT09ZX0pKSl9LGZpbmRPcHRpb246ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMub3B0aW9ucy5maW5kKChmdW5jdGlvbih0KXtyZXR1cm4gdC52YWx1ZT09PWV9KSl9LGhhbmRsZU1vdXNlRG93bjpmdW5jdGlvbigpe3ZhciBlPXRoaXM7dGhpcy5pc01vdXNlRG93bj0hMCxkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsKGZ1bmN0aW9uKCl7ZS5pc01vdXNlRG93bj0hMX0pLHtjYXB0dXJlOiEwLG9uY2U6ITB9KX0saGFuZGxlQ2xpY2s6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztpZihlLnN0b3BQcm9wYWdhdGlvbigpLHRoaXMub3Blbil7aWYodGhpcy5zZWFyY2gmJmUudGFyZ2V0PT09dGhpcy4kcmVmcy5zZWFyY2gpcmV0dXJuO3ZhciBpPWUucGF0aHx8ZS5jb21wb3NlZFBhdGgmJmUuY29tcG9zZWRQYXRoKCk7aWYoaXx8dGhpcy5hZGRFdmVudFBhdGgoKSx0aGlzLnNlYXJjaEluTWVudSYmZS50YXJnZXQ9PT10aGlzLiRyZWZzLnNlYXJjaEluTWVudS4kcmVmcy5pbnB1dClyZXR1cm47aWYodGhpcy5tdWx0aXBsZSYmLTEhPT1pLmluZGV4T2YodGhpcy5tZW51LiRlbCkpcmV0dXJuIHZvaWQgdGhpcy4kbmV4dFRpY2soKGZ1bmN0aW9uKCl7cmV0dXJuIHQuZm9jdXNTZWFyY2goKX0pKX10aGlzLmZvY3VzU2VhcmNoKCksdGhpcy5zZXRPcGVuKCF0aGlzLm9wZW4pfSxhZGRFdmVudFBhdGg6ZnVuY3Rpb24oKXtcInBhdGhcImluIEV2ZW50LnByb3RvdHlwZXx8T2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50LnByb3RvdHlwZSxcInBhdGhcIix7Z2V0OmZ1bmN0aW9uKCl7Zm9yKHZhciBlPVtdLHQ9dGhpcy50YXJnZXQ7dDspZS5wdXNoKHQpLHQ9dC5wYXJlbnRFbGVtZW50O3JldHVybi0xPT09ZS5pbmRleE9mKHdpbmRvdykmJi0xPT09ZS5pbmRleE9mKGRvY3VtZW50KSYmZS5wdXNoKGRvY3VtZW50KSwtMT09PWUuaW5kZXhPZih3aW5kb3cpJiZlLnB1c2god2luZG93KSxlfX0pfSxoYW5kbGVGb2N1czpmdW5jdGlvbigpe3RoaXMuZm9jdXNlZHx8KHRoaXMuZm9jdXNlZD0hMCwhdGhpcy5pc01vdXNlRG93biYmdGhpcy5vcGVuT25Gb2N1cyYmdGhpcy5zZXRPcGVuKCEwKSl9LGhhbmRsZUJsdXI6ZnVuY3Rpb24oZSl7dGhpcy5pc01vdXNlRG93bnx8ZS5yZWxhdGVkVGFyZ2V0PT09dGhpcy4kcmVmcy5zZWFyY2h8fCh0aGlzLmZvY3VzZWQ9ITEsdGhpcy5vcGVuJiZ0aGlzLmNsb3NlT25CbHVyJiZ0aGlzLnNldE9wZW4oITEpKX0saGFuZGxlQ2xpY2tPblNlbGVjdGVkTm9kZTpmdW5jdGlvbihlKXtlLnN0b3BQcm9wYWdhdGlvbigpfSx0b2dnbGVGaWx0ZXJlZFRleHQ6ZnVuY3Rpb24oZSx0KXt0aGlzLnNlYXJjaEluTWVudXx8dGhpcy5tdWx0aXBsZXx8ZS5jbGFzc0xpc3QuY29udGFpbnMoXCJmaWx0ZXJlZFwiKXx8XCJcIj09PXQudHJpbSgpfHxlLmNsYXNzTGlzdC5hZGQoXCJmaWx0ZXJlZFwiKSx0aGlzLm11bHRpcGxlfHxcIlwiIT09dC50cmltKCl8fGUuY2xhc3NMaXN0LnJlbW92ZShcImZpbHRlcmVkXCIpfSxoYW5kbGVLZXlEb3duOmZ1bmN0aW9uKGUpe3RoaXMuJHJlZnMudGV4dCYmdGhpcy50b2dnbGVGaWx0ZXJlZFRleHQodGhpcy4kcmVmcy50ZXh0LHRoaXMuZmlsdGVyKTt2YXIgdD0xMyxpPTI3LG49Mzgscj00MDtpZih0aGlzLm9wZW4pe3ZhciBzPTE7c3dpdGNoKGUua2V5Q29kZSl7Y2FzZSB0OnZhciBvPXRoaXMuZmlsdGVyO2lmKHRoaXMubXVsdGlwbGV8fC0xPT09dGhpcy5zZWxlY3RlZEluZGV4fHwodGhpcy5maWx0ZXI9XCJcIiksdGhpcy5hbGxvd0FkZGl0aW9ucyYmLTE9PT10aGlzLnNlbGVjdGVkSW5kZXgmJlwiXCIhPT1vLnRyaW0oKSllLnByZXZlbnREZWZhdWx0KCksdGhpcy5zZWxlY3RJdGVtKG8pO2Vsc2UgaWYodGhpcy5zZWxlY3Rpb258fHRoaXMuc2VhcmNoSW5NZW51fHx0aGlzLnNlYXJjaCl7aWYoLTE9PT10aGlzLnNlbGVjdGVkSW5kZXgpcmV0dXJuO2UucHJldmVudERlZmF1bHQoKSx0aGlzLm11bHRpcGxlP3RoaXMuc2VsZWN0SXRlbSh0aGlzLmZpbHRlcmVkT3B0aW9uc1t0aGlzLnNlbGVjdGVkSW5kZXhdLnZhbHVlKToodGhpcy5zZXRPcGVuKCExKSx0aGlzLiRyZWZzLnRleHQuY2xhc3NMaXN0LnJlbW92ZShcImZpbHRlcmVkXCIpKX1yZXR1cm47Y2FzZSBpOnJldHVybiB2b2lkKHRoaXMub3BlbiYmdGhpcy5zZXRPcGVuKCExKSk7Y2FzZSBuOnM9LTE7YnJlYWs7Y2FzZSByOmJyZWFrO2RlZmF1bHQ6cmV0dXJufWlmKGUucHJldmVudERlZmF1bHQoKSwwIT09dGhpcy5maWx0ZXJlZE9wdGlvbnMubGVuZ3RoKXt2YXIgYT10aGlzLnNlbGVjdGVkSW5kZXgrczt0aGlzLmZpbHRlcmVkT3B0aW9ucy5sZW5ndGg8PWE/dGhpcy5zZWxlY3RlZEluZGV4PTA6dGhpcy5zZWxlY3RlZEluZGV4PWE8MD90aGlzLmZpbHRlcmVkT3B0aW9ucy5sZW5ndGgtMTphLCh0aGlzLnNlbGVjdGlvbnx8dGhpcy5zZWFyY2hJbk1lbnV8fHRoaXMuc2VhcmNoKSYmIXRoaXMubXVsdGlwbGUmJnRoaXMuJGVtaXQoXCJpbnB1dFwiLHRoaXMuZmlsdGVyZWRPcHRpb25zW3RoaXMuc2VsZWN0ZWRJbmRleF0udmFsdWUpfX1lbHNlIGUua2V5Q29kZSE9PXQmJih0aGlzLnNldE9wZW4oITApLGUucHJldmVudERlZmF1bHQoKSl9LHJlZ2lzdGVyOmZ1bmN0aW9uKGUpe3RoaXMubWVudT1lfSxzZWxlY3RJdGVtOmZ1bmN0aW9uKGUpe2lmKCF0aGlzLm11bHRpcGxlfHwhdGhpcy5tYXhpbXVtVmFsdWVzU2VsZWN0ZWQpe3ZhciB0PXRoaXMubXVsdGlwbGU/dGhpcy5tdWx0aXBsZVZhbHVlLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuIHQhPT1lfSkpLmNvbmNhdChlKTplO3RoaXMuJGVtaXQoXCJpbnB1dFwiLHQpLHRoaXMuZmlsdGVyPVwiXCIsdGhpcy5tdWx0aXBsZXx8dGhpcy4kbmV4dFRpY2sodGhpcy51cGRhdGVTZWxlY3RlZEluZGV4KX19LHVwZGF0ZVNlbGVjdGVkSW5kZXg6ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3RoaXMubXVsdGlwbGU/dGhpcy5zZWxlY3RlZEluZGV4PXRoaXMuZmlsdGVyZWRPcHRpb25zLmxlbmd0aD50aGlzLnNlbGVjdGVkSW5kZXg/dGhpcy5zZWxlY3RlZEluZGV4OnRoaXMuc2VsZWN0ZWRJbmRleC0xOnRoaXMuc2VsZWN0ZWRJbmRleD10aGlzLmZpbHRlcmVkT3B0aW9ucy5maW5kSW5kZXgoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnZhbHVlPT09ZS52YWx1ZX0pKX0scmVzaXplSW5wdXQ6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLiRyZWZzLnNpemVyO2UuaW5uZXJUZXh0PXRoaXMuZmlsdGVyO3ZhciB0PWUub2Zmc2V0V2lkdGg7ZS5zdHlsZS5kaXNwbGF5PVwiXCIsZS5zdHlsZS5wYWRkaW5nPVwiXCIsdGhpcy4kcmVmcy5zZWFyY2guc3R5bGUubWluV2lkdGg9XCJcIi5jb25jYXQoTWF0aC5jZWlsKHQrMSksXCJweFwiKX0sdXBkYXRlRmlsdGVyOmZ1bmN0aW9uKGUpe3RoaXMuZmlsdGVyPVwic3RyaW5nXCI9PXR5cGVvZiBlP2U6ZS50YXJnZXQudmFsdWV9LGZvY3VzU2VhcmNoOmZ1bmN0aW9uKCl7dGhpcy5zZWFyY2gmJnRoaXMuJHJlZnMuc2VhcmNoLmZvY3VzKCl9LGhhbmRsZVNlYXJjaEtleURvd246ZnVuY3Rpb24oZSl7dGhpcy5tdWx0aXBsZSYmOD09PWUua2V5Q29kZSYmXCJcIj09PXRoaXMuZmlsdGVyJiYodGhpcy5tdWx0aXBsZVZhbHVlLnBvcCgpLHRoaXMuJGVtaXQoXCJpbnB1dFwiLHRoaXMubXVsdGlwbGVWYWx1ZSkpfSxjYWxjdWxhdGVNZW51RGlyZWN0aW9uOmZ1bmN0aW9uKCl7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdyYmdGhpcy5tZW51JiZ0aGlzLm1lbnUuJGVsJiZ0aGlzLm9wZW4pe3RoaXMubWVudS4kZWwuY2xhc3NMaXN0LmFkZChcImxvYWRpbmdcIiksdGhpcy4kZWwuY2xhc3NMaXN0LnJlbW92ZShcInVwd2FyZFwiKTt2YXIgZSx0LGksbixyPXtvZmZzZXQ6e3RvcDowLGxlZnQ6MH0sc2Nyb2xsVG9wOmRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wLGhlaWdodDpkb2N1bWVudC5ib2R5Lm9mZnNldEhlaWdodH0scz17b2Zmc2V0OihlPXRoaXMubWVudS4kZWwsdD1lLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLGk9d2luZG93LnBhZ2VYT2Zmc2V0fHxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCxuPXdpbmRvdy5wYWdlWU9mZnNldHx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCx7dG9wOnQudG9wK24sbGVmdDp0LmxlZnQraX0pLGhlaWdodDp0aGlzLm1lbnUuJGVsLm9mZnNldEhlaWdodH07dGhpcy5tZW51LiRlbC5jbGFzc0xpc3QucmVtb3ZlKFwibG9hZGluZ1wiKSx0aGlzLm1lbnVEaXJlY3Rpb249e2Fib3ZlOnMub2Zmc2V0LnRvcC1zLmhlaWdodC10aGlzLiRlbC5jbGllbnRIZWlnaHQ+PTAsYmVsb3c6cy5vZmZzZXQudG9wK3MuaGVpZ2h0PHIuaGVpZ2h0fX19fSxyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHNbMF0sdD10aGlzLmdldEVsZW1lbnRUeXBlKFwiZGl2XCIpLGk9XCJzdHJpbmdcIj09dHlwZW9mIHQmJiF0LmluY2x1ZGVzKFwiLVwiKSxuPU10KHt9LGk/XCJvblwiOlwibmF0aXZlT25cIix7XCIhbW91c2Vkb3duXCI6dGhpcy5oYW5kbGVNb3VzZURvd24sY2xpY2s6dGhpcy5oYW5kbGVDbGljayxcIiFmb2N1c1wiOnRoaXMuaGFuZGxlRm9jdXMsXCIhYmx1clwiOnRoaXMuaGFuZGxlQmx1cixcIiFrZXlkb3duXCI6dGhpcy5oYW5kbGVLZXlEb3dufSk7cmV0dXJuIGUodCxsKCkoW3thdHRyczp7cm9sZTpcImxpc3Rib3hcIixcImFyaWEtZXhwYW5kZWRcIjp0aGlzLm9wZW4sdGFiaW5kZXg6XCIwXCJ9fSx0aGlzLmdldENoaWxkUHJvcHNBbmRMaXN0ZW5lcnMoKSx7Y2xhc3M6dGhpcy5jbGFzc2VzKFwidWlcIix0aGlzLmJ1dHRvbiYmXCJidXR0b25cIix0aGlzLml0ZW0mJlwiaXRlbVwiLHRoaXMuZmxvYXRpbmcmJlwiZmxvYXRpbmdcIix0aGlzLmZsdWlkJiZcImZsdWlkXCIsdGhpcy5wb2ludGluZyYmXCJwb2ludGluZyBcIi5jb25jYXQodGhpcy5wb2ludGluZyksdGhpcy5sb2FkaW5nJiZcImxvYWRpbmdcIix0aGlzLmxhYmVsZWQmJlwibGFiZWxlZFwiLHRoaXMubXVsdGlwbGUmJlwibXVsdGlwbGVcIix0aGlzLnNlbGVjdGlvbiYmXCJzZWxlY3Rpb25cIix0aGlzLnNlYXJjaCYmXCJzZWFyY2hcIix0aGlzLm9wZW4mJlwiYWN0aXZlIHZpc2libGVcIix0aGlzLmRpc2FibGVkJiZcImRpc2FibGVkXCIsdGhpcy5zaW1wbGUmJlwic2ltcGxlXCIsIXRoaXMuZG93bndhcmQmJkZ0LnVwd2FyZCxcImRyb3Bkb3duXCIpfSxuXSksW3RoaXMuc2VsZWN0ZWROb2Rlcyx0aGlzLnNlYXJjaE5vZGUsdGhpcy50ZXh0Tm9kZSxudWxsIT09dGhpcy5pY29uJiZlKFwiaVwiLHtyZWY6XCJpY29uXCIsYXR0cnM6e1wiYXJpYS1oaWRkZW5cIjpcInRydWVcIn0sY2xhc3M6XCJcIi5jb25jYXQodGhpcy5pY29ufHxcImRyb3Bkb3duXCIsXCIgaWNvblwiKX0pLGUoXCJzcGFuXCIse2NsYXNzOlwic2l6ZXJcIixyZWY6XCJzaXplclwifSksdGhpcy4kc2xvdHMuZGVmYXVsdHx8dGhpcy5tZW51Tm9kZV0pfX0scXQ9e25hbWU6XCJTdWlEcm9wZG93bkRpdmlkZXJcIixtaXhpbnM6W0xdLHJlbmRlcjpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50c1swXSx0PXRoaXMuZ2V0RWxlbWVudFR5cGUoKTtyZXR1cm4gZSh0LGwoKShbe30sdGhpcy5nZXRDaGlsZFByb3BzQW5kTGlzdGVuZXJzKCkse2F0dHJzOntyb2xlOlwib3B0aW9uXCJ9LGNsYXNzOnRoaXMuY2xhc3NlcyhcImRpdmlkZXJcIil9XSkpfSxtZXRhOntwYXJlbnQ6XCJTdWlEcm9wZG93blwifX0sR3Q9e25hbWU6XCJTdWlEcm9wZG93bkhlYWRlclwiLG1peGluczpbTF0scHJvcHM6e2NvbnRlbnQ6e3R5cGU6U3RyaW5nLGRlc2NyaXB0aW9uOlwiU2hvcnRoYW5kIGZvciBwcmltYXJ5IGNvbnRlbnQuXCJ9LGljb246e3R5cGU6U3RyaW5nLGRlc2NyaXB0aW9uOlwiU2hvcnRoYW5kIGZvciBgc3VpLWljb25gLlwifX0scmVuZGVyOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzWzBdLHQ9dGhpcy5nZXRFbGVtZW50VHlwZSgpO3JldHVybiBlKHQsbCgpKFt7fSx0aGlzLmdldENoaWxkUHJvcHNBbmRMaXN0ZW5lcnMoKSx7Y2xhc3M6dGhpcy5jbGFzc2VzKFwiaGVhZGVyXCIpfV0pLFt0aGlzLmljb24mJmUoUSx7YXR0cnM6e25hbWU6dGhpcy5pY29ufX0pLHRoaXMuY29udGVudHx8dGhpcy4kc2xvdHMuZGVmYXVsdF0pfSxtZXRhOntwYXJlbnQ6XCJTdWlEcm9wZG93blwifX0sX3Q9e25hbWU6XCJTdWlFbWJlZFwiLG1peGluczpbTF0scHJvcHM6e2FjdGl2ZTp7dHlwZTpCb29sZWFuLGRlc2NyaXB0aW9uOlwiQW4gZW1iZWQgY2FuIGJlIGFjdGl2ZVwifSxhc3BlY3RSYXRpbzpfKFtcIjQ6M1wiLFwiMTY6OVwiLFwiMjE6OVwiXSx7ZGVzY3JpcHRpb246XCJBbiBlbWJlZCBjYW4gc3BlY2lmeSBhbiBhbHRlcm5hdGl2ZSBhc3BlY3QgcmF0aW8gKDQ6MyB8IDE2OjkgfCAyMTo5KVwifSksaWNvbjp7dHlwZTpTdHJpbmcsZGVzY3JpcHRpb246XCJTcGVjaWZpZXMgYW4gaWNvbiB0byB1c2Ugd2l0aCBwbGFjZWhvbGRlciBjb250ZW50XCIsZGVmYXVsdDpcInZpZGVvIHBsYXlcIn0scGxhY2Vob2xkZXI6e3R5cGU6U3RyaW5nLGRlc2NyaXB0aW9uOlwiQSBwbGFjZWhvbGRlciBpbWFnZSBmb3IgZW1iZWRcIn0sc291cmNlOl8oW1wieW91dHViZVwiLFwidmltZW9cIl0se2Rlc2NyaXB0aW9uOlwiU3BlY2lmaWVzIGEgc291cmNlIHRvIHVzZS4gQ2Fubm90IGJlIHVzZWQgdG9nZXRoZXIgd2l0aCB1cmxcIn0pLHVybDp7dHlwZTpTdHJpbmcsZGVzY3JpcHRpb246XCJTcGVjaWZpZXMgYSB1cmwgdG8gdXNlIGZvciBlbWJlZC4gQ2Fubm90IGJlIHVzZWQgdG9nZXRoZXIgd2l0aCBzb3VyY2VcIn0sYXV0b3BsYXk6e3R5cGU6Qm9vbGVhbixkZXNjcmlwdGlvbjpcIlNldHRpbmcgdG8gdHJ1ZSBvciBmYWxzZSB3aWxsIGZvcmNlIGF1dG9wbGF5XCIsZGVmYXVsdDohMH0sYnJhbmRlZFVJOnt0eXBlOkJvb2xlYW4sZGVzY3JpcHRpb246XCJXaGV0aGVyIHRvIHNob3cgbmV0d29ya3MgYnJhbmRlZCBVSSBsaWtlIHRpdGxlIGNhcmRzLCBvciBhZnRlciB2aWRlbyBjYWxscyB0byBhY3Rpb25cIn0sY29sb3I6e3R5cGU6U3RyaW5nLGRlc2NyaXB0aW9uOlwiU3BlY2lmaWVzIHdoYXQgZGVmYXVsdCBjaHJvbWUgY29sb3Igd2l0aCBWaW1lbyBvciBZb3VUdWJlXCIsZGVmYXVsdDpcIiM0NDQ0NDRcIn0saGQ6e3R5cGU6Qm9vbGVhbixkZXNjcmlwdGlvbjpcIlNwZWNpZmllcyB3aGV0aGVyIHRvIGRpc3BsYXkgWW91VHViZXIvVmltZW8gdmlkZW8gaW4gaGlnaC1kZWZpbml0aW9uXCIsZGVmYXVsdDohMH0saWQ6e3R5cGU6U3RyaW5nLGRlc2NyaXB0aW9uOlwiU3BlY2lmaWVzIGFuIGlkIGZvciBzb3VyY2VcIn0saWZyYW1lOnt0eXBlOk9iamVjdCxkZXNjcmlwdGlvbjpcIlNob3J0aGFuZCBmb3IgSFRNTCBpZnJhbWVcIn19LGRhdGE6ZnVuY3Rpb24oKXtyZXR1cm57aXNBY3RpdmU6ITF9fSxjb21wdXRlZDp7aXNBY3RpdmVTdGF0ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmFjdGl2ZXx8dGhpcy5pc0FjdGl2ZX19LG1ldGhvZHM6e3NldEFjdGl2ZTpmdW5jdGlvbigpe3RoaXMuaXNBY3RpdmU9ITB9fSxyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHNbMF0sdD10aGlzO2Z1bmN0aW9uIGkoKXt2YXIgZT0hdC51cmwmJnQuc291cmNlLGk9IXQuc291cmNlJiZ0LnVybCxuPWUmJnQuYXV0b3BsYXkscj1lJiZ0LmJyYW5kZWRVSSxzPWUmJnQuY29sb3Isbz1lJiZ0LmhkLGE9ZSYmdC5pZDtyZXR1cm5cInlvdXR1YmVcIj09PWU/W1wiLy93d3cueW91dHViZS5jb20vZW1iZWQvXCIuY29uY2F0KGEpLFwiP2F1dG9oaWRlPXRydWVcIixcIiZhbXA7YXV0b3BsYXk9XCIuY29uY2F0KG4pLFwiJmFtcDtjb2xvcj1cIi5jb25jYXQoZW5jb2RlVVJJQ29tcG9uZW50KHMpKSxcIiZhbXA7aHE9XCIuY29uY2F0KG8pLFwiJmFtcDtqc2FwaT1mYWxzZVwiLFwiJmFtcDttb2Rlc3RicmFuZGluZz1cIi5jb25jYXQocildLmpvaW4oXCJcIik6XCJ2aW1lb1wiPT09ZT9bXCIvL3BsYXllci52aW1lby5jb20vdmlkZW8vXCIuY29uY2F0KGEpLFwiP2FwaT1mYWxzZVwiLFwiJmFtcDthdXRvcGxheT1cIi5jb25jYXQobiksXCImYW1wO2J5bGluZT1mYWxzZVwiLFwiJmFtcDtjb2xvcj1cIi5jb25jYXQoZW5jb2RlVVJJQ29tcG9uZW50KHMpKSxcIiZhbXA7cG9ydHJhaXQ9ZmFsc2VcIixcIiZhbXA7dGl0bGU9ZmFsc2VcIl0uam9pbihcIlwiKTppfWZ1bmN0aW9uIG4oZSl7cmV0dXJuIE9iamVjdC5lbnRyaWVzKGUpLnJlZHVjZSgoZnVuY3Rpb24oZSx0KXtyZXR1cm5cIlwiLmNvbmNhdChlKS5jb25jYXQodFswXSxcIjpcIikuY29uY2F0KHRbMV0sXCI7XCIpfSksXCJcIil9ZnVuY3Rpb24gcigpe2lmKCF0LmlzQWN0aXZlU3RhdGUpcmV0dXJuIG51bGw7aWYodC4kc2xvdHMuZGVmYXVsdClyZXR1cm4gdC4kc2xvdHMuZGVmYXVsdDt2YXIgcj10LmlmcmFtZXx8e30scz1pKCksbz1yLnN0eWxlP24oci5zdHlsZSk6XCJcIjtyZXR1cm4gZShcImRpdlwiLHtjbGFzczpcImVtYmVkXCJ9LFtlKFwiaWZyYW1lXCIse2F0dHJzOntzcmM6ci5zcmN8fHMsYWxsb3dGdWxsU2NyZWVuOnIuYWxsb3dGdWxsU2NyZWVufHwhMSxmcmFtZUJvcmRlcjpyLmZyYW1lQm9yZGVyfHwwLHdpZHRoOnIud2lkdGh8fFwiMTAwJVwiLGhlaWdodDpyLmhlaWdodHx8XCIxMDAlXCIsc2Nyb2xsaW5nOnIuc2Nyb2xsaW5nfHxcIm5vXCIsdGl0bGU6ci50aXRsZXx8XCJFbWJlZGRlZCBjb250ZW50IGZyb20gXCIuY29uY2F0KHQuc291cmNlfHxcImN1c3RvbSBob3N0XCIpfSxzdHlsZTpvfSldKX12YXIgcz10aGlzLmdldEVsZW1lbnRUeXBlKCk7cmV0dXJuIGUocyxsKCkoW3tvbjp7Y2xpY2s6dGhpcy5zZXRBY3RpdmV9fSx0aGlzLmdldENoaWxkUHJvcHNBbmRMaXN0ZW5lcnMoKSx7Y2xhc3M6dGhpcy5jbGFzc2VzKFwidWlcIix0aGlzLmFzcGVjdFJhdGlvLHRoaXMuaXNBY3RpdmVTdGF0ZSYmXCJhY3RpdmVcIixcImVtYmVkXCIpfV0pLFt0aGlzLmljb24mJmUoUSx7YXR0cnM6e25hbWU6dGhpcy5pY29ufX0pLHRoaXMucGxhY2Vob2xkZXImJmUoXCJpbWdcIix7Y2xhc3M6XCJwbGFjZWhvbGRlclwiLGF0dHJzOntzcmM6dGhpcy5wbGFjZWhvbGRlcn19KSxyKCldKX19O2Z1bmN0aW9uIFV0KGUsdCxpKXtyZXR1cm4gdCBpbiBlP09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQse3ZhbHVlOmksZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTplW3RdPWksZX1mdW5jdGlvbiBXdChlKXtyZXR1cm4gZnVuY3Rpb24oZSl7aWYoQXJyYXkuaXNBcnJheShlKSl7Zm9yKHZhciB0PTAsaT1uZXcgQXJyYXkoZS5sZW5ndGgpO3Q8ZS5sZW5ndGg7dCsrKWlbdF09ZVt0XTtyZXR1cm4gaX19KGUpfHxmdW5jdGlvbihlKXtpZihTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGUpfHxcIltvYmplY3QgQXJndW1lbnRzXVwiPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpKXJldHVybiBBcnJheS5mcm9tKGUpfShlKXx8ZnVuY3Rpb24oKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2VcIil9KCl9dmFyIFl0PXtjbG9zZWQ6XCJjbG9zZWRcIixvcGVuaW5nOlwib3BlbmluZ1wiLG9wZW46XCJvcGVuXCIsY2xvc2luZzpcImNsb3NpbmdcIn07ZnVuY3Rpb24gS3QoZSl7cmV0dXJuW1wiXCIuY29uY2F0KGUsXCIgdXBcIiksXCJcIi5jb25jYXQoZSxcIiBkb3duXCIpLFwiXCIuY29uY2F0KGUsXCIgbGVmdFwiKSxcIlwiLmNvbmNhdChlLFwiIHJpZ2h0XCIpXX12YXIgWHQ9W1wic2NhbGVcIixcImRyb3BcIixcImhvcml6b250YWwgZmxpcFwiLFwidmVydGljYWwgZmxpcFwiLFwiZmFkZVwiXS5jb25jYXQoV3QoS3QoXCJmYWRlXCIpKSxXdChLdChcImZseVwiKSksV3QoS3QoXCJzd2luZ1wiKSkpO2Z1bmN0aW9uIEp0KGUsdCl7cmV0dXJuXCJhbmltYXRpbmcgXCIuY29uY2F0KGUsXCIgXCIpLmNvbmNhdCh0P1wiaW5cIjpcIm91dFwiKX1mdW5jdGlvbiBadChlLHQpe3N3aXRjaChlKXtjYXNlIFl0Lm9wZW5pbmc6cmV0dXJuIEp0KHQsITApO2Nhc2UgWXQub3BlbjpyZXR1cm5cInZpc2libGUgYWN0aXZlXCI7Y2FzZSBZdC5jbG9zaW5nOnJldHVyblwidmlzaWJsZSBhY3RpdmUgXCIuY29uY2F0KEp0KHQsITEpKTtjYXNlIFl0LmNsb3NlOnJldHVyblwiaGlkZGVuXCI7ZGVmYXVsdDpyZXR1cm5cIlwifX12YXIgUXQ9e25hbWU6XCJTdWlNb2RhbFwiLG1vZGVsOntwcm9wOlwib3BlblwiLGV2ZW50OlwiY2hhbmdlZFwifSxtaXhpbnM6W0xdLHByb3BzOnthbmltYXRpb246XyhYdCx7ZGVmYXVsdDpYdFswXX0pLGFuaW1hdGlvbkR1cmF0aW9uOnt0eXBlOk51bWJlcixkZWZhdWx0OjUwMH0sYWxpZ25lZDpfKFtcInRvcFwiXSksY2xvc2VJY29uOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX0sZGltbWVyOl8oW1wiaW52ZXJ0ZWRcIl0pLGltYWdlOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX0sb3Blbjp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9LHNpemU6XyhbXCJzdGFuZGFyZFwiLFwiZnVsbHNjcmVlblwiLFwic21hbGxcIixcImxhcmdlXCIsXCJtaW5pXCIsXCJ0aW55XCJdLHtkZWZhdWx0Olwic3RhbmRhcmRcIn0pLGJhc2ljOnt0eXBlOkJvb2xlYW59LGNsb3NhYmxlOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMH19LGV2ZW50czooSHQ9e2Rpc3BsYXlDaGFuZ2VkOntjdXN0b206ITB9fSxVdChIdCxcImNoYW5nZWRcIix7Y3VzdG9tOiEwfSksVXQoSHQsXCJjbGlja0F3YXlNb2RhbFwiLHtjdXN0b206ITB9KSxIdCksZGF0YTpmdW5jdGlvbigpe3JldHVybnt2aXN1YWxTdGF0ZTp0aGlzLm9wZW4/WXQub3BlbjpZdC5jbG9zZWR9fSxjb21wdXRlZDp7ZGltbWVyQ2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gWnQodGhpcy52aXN1YWxTdGF0ZSxcImZhZGVcIil9LG1vZGFsQ2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gWnQodGhpcy52aXN1YWxTdGF0ZSx0aGlzLmFuaW1hdGlvbil9LHZpc2libGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52aXN1YWxTdGF0ZSE9PVl0LmNsb3NlZH0sZGltbWVyU3R5bGU6ZnVuY3Rpb24oKXtyZXR1cm57ZGlzcGxheTp0aGlzLnZpc2libGU/XCJmbGV4ICFpbXBvcnRhbnRcIjpcIm5vbmUgIWltcG9ydGFudFwiLGFuaW1hdGlvbkR1cmF0aW9uOlwiXCIuY29uY2F0KHRoaXMuYW5pbWF0aW9uRHVyYXRpb24sXCJtc1wiKX19LG1vZGFsU3R5bGU6ZnVuY3Rpb24oKXtyZXR1cm57ZGlzcGxheTp0aGlzLnZpc2libGU/XCJibG9jayAhaW1wb3J0YW50XCI6XCJub25lICFpbXBvcnRhbnRcIixhbmltYXRpb25EdXJhdGlvbjpcIlwiLmNvbmNhdCh0aGlzLmFuaW1hdGlvbkR1cmF0aW9uLFwibXNcIil9fX0sd2F0Y2g6e29wZW46ZnVuY3Rpb24oZSl7dGhpcy52aXN1YWxTdGF0ZT1lP1l0Lm9wZW5pbmc6WXQuY2xvc2luZ30sdmlzdWFsU3RhdGU6ZnVuY3Rpb24oZSl7dGhpcy4kZW1pdChcImRpc3BsYXlDaGFuZ2VkXCIsZSl9fSxtb3VudGVkOmZ1bmN0aW9uKCl7dGhpcy4kZWwuYWRkRXZlbnRMaXN0ZW5lcihEKCksdGhpcy5vbkFuaW1hdGlvbkVuZCwhMCl9LGJlZm9yZURlc3Ryb3k6ZnVuY3Rpb24oKXt0aGlzLiRlbC5yZW1vdmVFdmVudExpc3RlbmVyKEQoKSx0aGlzLm9uQW5pbWF0aW9uRW5kLCEwKX0sbWV0aG9kczp7Y2xvc2U6ZnVuY3Rpb24oKXt0aGlzLiRlbWl0KFwiY2hhbmdlZFwiLCExKX0sZGltbWVyQ2xpY2s6ZnVuY3Rpb24oZSl7dGhpcy5jbG9zYWJsZSYmZS50YXJnZXQ9PT1lLmN1cnJlbnRUYXJnZXQmJnRoaXMudmlzdWFsU3RhdGU9PT1ZdC5vcGVuJiYodGhpcy4kZW1pdChcImNsaWNrQXdheU1vZGFsXCIpLHRoaXMuY2xvc2UoKSl9LG9uQW5pbWF0aW9uRW5kOmZ1bmN0aW9uKCl7dGhpcy52aXN1YWxTdGF0ZT10aGlzLm9wZW4/WXQub3BlbjpZdC5jbG9zZWR9fSxyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLHQ9YXJndW1lbnRzWzBdO3JldHVybiB0KFwiZGl2XCIse3JlZjpcImRpbW1lclwiLGNsYXNzOnRoaXMuY2xhc3NlcyhcInVpXCIsdGhpcy5kaW1tZXIsXCJkaW1tZXIgbW9kYWxzIHBhZ2UgdHJhbnNpdGlvblwiLHRoaXMuZGltbWVyQ2xhc3MpLHN0eWxlOnRoaXMuZGltbWVyU3R5bGUsb246e2NsaWNrOnRoaXMuZGltbWVyQ2xpY2t9fSxbdChcImRpdlwiLHtyZWY6XCJtb2RhbFwiLHN0eWxlOnRoaXMubW9kYWxTdHlsZSxjbGFzczp0aGlzLmNsYXNzZXMoXCJ1aVwiLHRoaXMuc2l6ZSx0aGlzLmJhc2ljJiZcImJhc2ljXCIsdGhpcy5hbGlnbmVkJiZcIlwiLmNvbmNhdCh0aGlzLmFsaWduZWQsXCIgYWxpZ25lZFwiKSxcIm1vZGFsXCIsXCJ0cmFuc2l0aW9uXCIsdGhpcy5tb2RhbENsYXNzKX0sW3RoaXMuY2xvc2VJY29uJiZ0KFEse2F0dHJzOntuYW1lOlwiY2xvc2VcIn0sbmF0aXZlT246e2NsaWNrOmZ1bmN0aW9uKCl7cmV0dXJuIGUuY2xvc2UoKX19fSksdGhpcy4kc2xvdHMuZGVmYXVsdF0pXSl9fSxlaT17bmFtZTpcIlN1aU1vZGFsQWN0aW9uc1wiLG1peGluczpbTF0scmVuZGVyOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzWzBdLHQ9dGhpcy5nZXRFbGVtZW50VHlwZSgpO3JldHVybiBlKHQsbCgpKFt7fSx0aGlzLmdldENoaWxkUHJvcHNBbmRMaXN0ZW5lcnMoKSx7Y2xhc3M6dGhpcy5jbGFzc2VzKFwiYWN0aW9uc1wiKX1dKSxbdGhpcy4kc2xvdHMuZGVmYXVsdF0pfSxtZXRhOntwYXJlbnQ6XCJTdWlNb2RhbFwifX0sdGk9e25hbWU6XCJTdWlNb2RhbENvbnRlbnRcIixtaXhpbnM6W0xdLHByb3BzOntpbWFnZTpCb29sZWFuLHNjcm9sbGluZzp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITEsZGVzY3JpcHRpb246XCJBIG1vZGFsIGNhbiB1c2UgdGhlIGVudGlyZSBzaXplIG9mIHRoZSBzY3JlZW4uXCJ9fSxyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHNbMF0sdD10aGlzLmdldEVsZW1lbnRUeXBlKCk7cmV0dXJuIGUodCxsKCkoW3t9LHRoaXMuZ2V0Q2hpbGRQcm9wc0FuZExpc3RlbmVycygpLHtjbGFzczp0aGlzLmNsYXNzZXMoXCJjb250ZW50XCIsdGhpcy5pbWFnZSYmXCJpbWFnZVwiLHRoaXMuc2Nyb2xsaW5nJiZcInNjcm9sbGluZ1wiKX1dKSxbdGhpcy4kc2xvdHMuZGVmYXVsdF0pfSxtZXRhOntwYXJlbnQ6XCJTdWlNb2RhbFwifX0saWk9e25hbWU6XCJTdWlNb2RhbERlc2NyaXB0aW9uXCIsbWl4aW5zOltMXSxwcm9wczp7fSxyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHNbMF0sdD10aGlzLmdldEVsZW1lbnRUeXBlKCk7cmV0dXJuIGUodCxsKCkoW3t9LHRoaXMuZ2V0Q2hpbGRQcm9wc0FuZExpc3RlbmVycygpLHtjbGFzczp0aGlzLmNsYXNzZXMoXCJkZXNjcmlwdGlvblwiKX1dKSxbdGhpcy4kc2xvdHMuZGVmYXVsdF0pfSxtZXRhOntwYXJlbnQ6XCJTdWlNb2RhbFwifX0sbmk9e25hbWU6XCJTdWlNb2RhbEhlYWRlclwiLG1peGluczpbTF0scHJvcHM6e30scmVuZGVyOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzWzBdLHQ9dGhpcy5nZXRFbGVtZW50VHlwZSgpO3JldHVybiBlKHQsbCgpKFt7fSx0aGlzLmdldENoaWxkUHJvcHNBbmRMaXN0ZW5lcnMoKSx7Y2xhc3M6dGhpcy5jbGFzc2VzKFwiaGVhZGVyXCIpfV0pLFt0aGlzLiRzbG90cy5kZWZhdWx0XSl9LG1ldGE6e3BhcmVudDpcIlN1aU1vZGFsXCJ9fTtmdW5jdGlvbiByaShlKXtyZXR1cm4gZnVuY3Rpb24oZSl7aWYoQXJyYXkuaXNBcnJheShlKSl7Zm9yKHZhciB0PTAsaT1uZXcgQXJyYXkoZS5sZW5ndGgpO3Q8ZS5sZW5ndGg7dCsrKWlbdF09ZVt0XTtyZXR1cm4gaX19KGUpfHxmdW5jdGlvbihlKXtpZihTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGUpfHxcIltvYmplY3QgQXJndW1lbnRzXVwiPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpKXJldHVybiBBcnJheS5mcm9tKGUpfShlKXx8ZnVuY3Rpb24oKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2VcIil9KCl9ZnVuY3Rpb24gc2koZSx0KXt2YXIgaT1PYmplY3Qua2V5cyhlKTtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgbj1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO3QmJihuPW4uZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLHQpLmVudW1lcmFibGV9KSkpLGkucHVzaC5hcHBseShpLG4pfXJldHVybiBpfWZ1bmN0aW9uIG9pKGUsdCxpKXtyZXR1cm4gdCBpbiBlP09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQse3ZhbHVlOmksZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTplW3RdPWksZX12YXIgYWk9e25hbWU6XCJTdWlSYXRpbmdcIixtaXhpbnM6W0xdLGJpbmRpbmc6e3Byb3A6XCJyYXRpbmdcIixldmVudDpcImNoYW5nZWRcIn0scHJvcHM6e2ljb246U3RyaW5nLG1heFJhdGluZzpOdW1iZXIscmF0aW5nOk51bWJlcn0sZXZlbnRzOntyYXRlOntjdXN0b206ITB9fSxkYXRhOmZ1bmN0aW9uKCl7cmV0dXJue3NlbGVjdGVkOjB9fSxtZXRob2RzOntnZXRDdXJyZW50VmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIE51bWJlcihlLnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJhcmlhLXBvc2luc2V0XCIpKX0sb25SYXRlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMuZ2V0Q3VycmVudFZhbHVlKGUpO3RoaXMuJGVtaXQoXCJyYXRlXCIsZSxmdW5jdGlvbihlKXtmb3IodmFyIHQ9MTt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKXt2YXIgaT1udWxsIT1hcmd1bWVudHNbdF0/YXJndW1lbnRzW3RdOnt9O3QlMj9zaShPYmplY3QoaSksITApLmZvckVhY2goKGZ1bmN0aW9uKHQpe29pKGUsdCxpW3RdKX0pKTpPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycz9PYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKGkpKTpzaShPYmplY3QoaSkpLmZvckVhY2goKGZ1bmN0aW9uKHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihpLHQpKX0pKX1yZXR1cm4gZX0oe30sdGhpcy4kcHJvcHMse3JhdGluZzp0fSkpfSxvbk1vdXNlbGVhdmU6ZnVuY3Rpb24oKXt0aGlzLnNlbGVjdGVkPTB9LG9uTW91c2VvdmVyOmZ1bmN0aW9uKGUpe3RoaXMuc2VsZWN0ZWQ9dGhpcy5nZXRDdXJyZW50VmFsdWUoZSl9fSxyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLHQ9YXJndW1lbnRzWzBdLGk9dGhpcy5nZXRFbGVtZW50VHlwZSgpO3JldHVybiB0KGksbCgpKFt7fSx0aGlzLmdldENoaWxkUHJvcHNBbmRMaXN0ZW5lcnMoKSx7Y2xhc3M6dGhpcy5jbGFzc2VzKFwidWlcIix0aGlzLmljb24sXCJyYXRpbmdcIiksYXR0cnM6e3JvbGU6XCJyYWRpb2dyb3VwXCJ9fV0pLFtyaShuZXcgQXJyYXkodGhpcy5tYXhSYXRpbmcpKS5tYXAoKGZ1bmN0aW9uKGksbil7dmFyIHI9bisxLHM9ZS5yYXRpbmc+bixvPWUuc2VsZWN0ZWQ+bjtyZXR1cm4gdChcImlcIix7YXR0cnM6e1wiYXJpYS1jaGVja2VkXCI6cy50b1N0cmluZygpLFwiYXJpYS1wb3NpbnNldFwiOnIsXCJhcmlhLXNldHNpemVcIjplLm1heFJhdGluZyx0YWJpbmRleDpcIjBcIixyb2xlOlwicmFkaW9cIn0sY2xhc3M6ZS5jbGFzc2VzKHMmJlwiYWN0aXZlXCIsbyYmXCJzZWxlY3RlZFwiLFwiaWNvblwiKSxvbjp7Y2xpY2s6ZS5vblJhdGUsbW91c2VvdmVyOmUub25Nb3VzZW92ZXIsbW91c2VsZWF2ZTplLm9uTW91c2VsZWF2ZX19KX0pKV0pfX0sY2k9e25hbWU6XCJTdWlTZWFyY2hTaW1wbGVSZXN1bHRzXCIsZnVuY3Rpb25hbDohMCxwcm9wczp7cmVzdWx0czpBcnJheX0scmVuZGVyOmZ1bmN0aW9uKGUsdCl7dmFyIGk9dC5wcm9wcyxuPXQuc2NvcGVkU2xvdHM7cmV0dXJuIGkucmVzdWx0cy5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiBuLmRlZmF1bHQoe3Jlc3VsdDplfSl9KSl9fSxsaT17bmFtZTpcIlN1aVNlYXJjaENhdGVnb3J5UmVzdWx0c1wiLGZ1bmN0aW9uYWw6ITAscHJvcHM6e3Jlc3VsdHM6T2JqZWN0fSxyZW5kZXI6ZnVuY3Rpb24oZSx0KXt2YXIgaT10LnByb3BzLG49dC5zY29wZWRTbG90cyxyPWFyZ3VtZW50c1swXSxzPU9iamVjdC5rZXlzKGkucmVzdWx0cyk7cmV0dXJuIHMubWFwKChmdW5jdGlvbihlKXtyZXR1cm4gcihcImRpdlwiLHtjbGFzczpcImNhdGVnb3J5XCIsa2V5OmV9LFtyKFwiZGl2XCIse2NsYXNzOlwibmFtZVwifSxbaS5yZXN1bHRzW2VdLm5hbWVdKSxyKFwiZGl2XCIse2NsYXNzOlwicmVzdWx0c1wifSxbcihjaSxsKCkoW3thdHRyczp7cmVzdWx0czppLnJlc3VsdHNbZV0ucmVzdWx0c319LHtzY29wZWRTbG90czp7ZGVmYXVsdDpuLmRlZmF1bHR9fV0pKV0pXSl9KSl9fSxkaT17bmFtZTpcIlN1aVNlYXJjaFJlc3VsdFwiLGZ1bmN0aW9uYWw6ITAscHJvcHM6e3RpdGxlOnt0eXBlOlN0cmluZyxkZXNjcmlwdGlvbjpcIkRpc3BsYXkgdGl0bGUuXCJ9LGRlc2NyaXB0aW9uOnt0eXBlOlN0cmluZyxkZXNjcmlwdGlvbjpcIkFkZGl0aW9uYWwgdGV4dCB3aXRoIGxlc3MgZW1waGFzaXMuXCJ9LHVybDp7dHlwZTpTdHJpbmcsZGVzY3JpcHRpb246XCJMaW5rIHRvIG9wZW4gb24gY2xpY2suXCJ9fSxyZW5kZXI6ZnVuY3Rpb24oZSx0KXt2YXIgaT10LnByb3BzLG49dC5saXN0ZW5lcnMscj1hcmd1bWVudHNbMF0scz1pLnRpdGxlLG89aS5kZXNjcmlwdGlvbixhPWkudXJsLGM9YT97dXJsOmF9Ont9O3JldHVybiByKFwiZGl2XCIsbCgpKFt7fSxjLHtvbjp7Y2xpY2s6ZnVuY3Rpb24oKXtyZXR1cm4gbi5zZWxlY3QoaSl9fSxjbGFzczpcInJlc3VsdFwifV0pLFtyKFwiZGl2XCIse2NsYXNzOlwiY29udGVudFwifSxbcyYmcihcImRpdlwiLHtjbGFzczpcInRpdGxlXCJ9LFtzXSksbyYmcihcImRpdlwiLHtjbGFzczpcImRlc2NyaXB0aW9uXCJ9LFtvXSldKV0pfX07ZnVuY3Rpb24gdWkoZSx0KXt2YXIgaT1PYmplY3Qua2V5cyhlKTtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgbj1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO3QmJihuPW4uZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLHQpLmVudW1lcmFibGV9KSkpLGkucHVzaC5hcHBseShpLG4pfXJldHVybiBpfWZ1bmN0aW9uIGhpKGUpe2Zvcih2YXIgdD0xO3Q8YXJndW1lbnRzLmxlbmd0aDt0Kyspe3ZhciBpPW51bGwhPWFyZ3VtZW50c1t0XT9hcmd1bWVudHNbdF06e307dCUyP3VpKE9iamVjdChpKSwhMCkuZm9yRWFjaCgoZnVuY3Rpb24odCl7cGkoZSx0LGlbdF0pfSkpOk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzP09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoaSkpOnVpKE9iamVjdChpKSkuZm9yRWFjaCgoZnVuY3Rpb24odCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGksdCkpfSkpfXJldHVybiBlfWZ1bmN0aW9uIHBpKGUsdCxpKXtyZXR1cm4gdCBpbiBlP09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQse3ZhbHVlOmksZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTplW3RdPWksZX1mdW5jdGlvbiBmaShlKXtyZXR1cm4oZmk9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKGUpe3JldHVybiB0eXBlb2YgZX06ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmZS5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmZSE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgZX0pKGUpfXZhciBtaT17bmFtZTpcIlN1aVNlYXJjaFJlc3VsdHNcIixtaXhpbnM6W0xdLHByb3BzOntjYXRlZ29yeTpCb29sZWFuLGR1cmF0aW9uOk51bWJlcixzZWFyY2hGb2N1c2VkOkJvb2xlYW4sbG9hZGluZzpCb29sZWFuLHZhbHVlOlN0cmluZyxyZXN1bHRzOltBcnJheSxPYmplY3RdfSxkYXRhOmZ1bmN0aW9uKCl7cmV0dXJue2FuaW1hdGlvblRpbWVvdXQ6bnVsbH19LGNvbXB1dGVkOntvcGVuOmZ1bmN0aW9uKCl7cmV0dXJuISghdGhpcy52YWx1ZXx8IXRoaXMuc2VhcmNoRm9jdXNlZHx8dGhpcy5sb2FkaW5nfHwhdGhpcy5yZXN1bHRzKX0sZW1wdHk6ZnVuY3Rpb24oKXtyZXR1cm4hKHRoaXMucmVzdWx0cyYmXCJvYmplY3RcIj09PWZpKHRoaXMucmVzdWx0cykmJih0aGlzLnJlc3VsdHMubGVuZ3RofHxPYmplY3Qua2V5cyh0aGlzLnJlc3VsdHMpLmxlbmd0aCkpfX0sd2F0Y2g6e29wZW46ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3RoaXMuYW5pbWF0aW9uVGltZW91dD1zZXRUaW1lb3V0KChmdW5jdGlvbigpe2UuYW5pbWF0aW9uVGltZW91dD1udWxsfSksdGhpcy5kdXJhdGlvbil9fSxtZXRob2RzOntoYW5kbGVTZWxlY3Q6ZnVuY3Rpb24oZSl7dGhpcy4kZW1pdChcInNlbGVjdFwiLGUpfX0scmVuZGVyOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcyx0PWFyZ3VtZW50c1swXSxpPXRoaXMuY2F0ZWdvcnk/bGk6Y2k7cmV0dXJuIHRoaXMuZW1wdHk/bnVsbDp0KFwiZGl2XCIse2NsYXNzOnRoaXMuY2xhc3NlcyhcInJlc3VsdHNcIixcInRyYW5zaXRpb25cIix0aGlzLmNhdGVnb3J5JiZcImNhdGVnb3J5XCIsdGhpcy5hbmltYXRpb25UaW1lb3V0JiZcInZpc2libGUgYW5pbWF0aW5nIHNjYWxlIFwiLmNvbmNhdCh0aGlzLm9wZW4/XCJpblwiOlwib3V0XCIpLCF0aGlzLmFuaW1hdGlvblRpbWVvdXQmJih0aGlzLm9wZW4/XCJ2aXNpYmxlXCI6XCJoaWRkZW5cIikpfSxbdChpLGwoKShbe2F0dHJzOntyZXN1bHRzOnRoaXMucmVzdWx0c319LHtzY29wZWRTbG90czp7ZGVmYXVsdDpmdW5jdGlvbihpKXt2YXIgbj1pLnJlc3VsdDtyZXR1cm4gdChkaSx7cHJvcHM6aGkoe30sbiksb246e3NlbGVjdDplLmhhbmRsZVNlbGVjdH19KX19fV0pKV0pfX07ZnVuY3Rpb24gZ2koZSl7cmV0dXJuKGdpPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbihlKXtyZXR1cm4gdHlwZW9mIGV9OmZ1bmN0aW9uKGUpe3JldHVybiBlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJmUuY29uc3RydWN0b3I9PT1TeW1ib2wmJmUhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIGV9KShlKX12YXIgYmk9e25hbWU6XCJTdWlTZWFyY2hcIixtaXhpbnM6W0xdLHByb3BzOnthY3Rpb246e3R5cGU6U3RyaW5nLGRlc2NyaXB0aW9uOlwiQVBJIGFjdGlvbiB0byB1c2VcIixkZWZhdWx0OmZ1bmN0aW9uKCl7cmV0dXJuXCJzZWFyY2hcIn19LGFsaWduZWQ6Xy5GbG9hdGVkKHtkZXNjcmlwdGlvbjpcIkEgc2VhcmNoIGNhbiBoYXZlIGl0cyByZXN1bHRzIGFsaWduZWQgdG8gaXRzIGxlZnQgb3IgcmlnaHQgY29udGFpbmVyIGVkZ2UuXCJ9KSxkaXNhYmxlZDp7dHlwZTpCb29sZWFuLGRlc2NyaXB0aW9uOlwiQSBzZWFyY2ggY2FuIHNob3cgaXQgaXMgY3VycmVudGx5IHVuYWJsZSB0byBiZSBpbnRlcmFjdGVkIHdpdGguXCJ9LGR1cmF0aW9uOnt0eXBlOk51bWJlcixkZXNjcmlwdGlvbjpcIkR1cmF0aW9uIG9mIGFuaW1hdGlvbiBldmVudHMuXCIsZGVmYXVsdDpmdW5jdGlvbigpe3JldHVybiAzMDB9fSxmbHVpZDp7dHlwZTpCb29sZWFuLGRlc2NyaXB0aW9uOlwiQSBzZWFyY2ggY2FuIGhhdmUgaXRzIHJlc3VsdHMgdGFrZSB1cCB0aGUgd2lkdGggb2YgaXRzIGNvbnRhaW5lci5cIn0sZnVsbFRleHRTZWFyY2g6XyhbXCJleGFjdFwiXSx7dHlwZTpbQm9vbGVhbl0sZGVmYXVsdDpmdW5jdGlvbigpe3JldHVybiEwfX0pLGxvYWRpbmc6e3R5cGU6Qm9vbGVhbixkZXNjcmlwdGlvbjpcIkEgc2VhcmNoIGNhbiBzaG93IGEgbG9hZGluZyBpbmRpY2F0b3IuXCJ9LG1heFJlc3VsdHM6e3R5cGU6TnVtYmVyLGRlZmF1bHQ6ZnVuY3Rpb24oKXtyZXR1cm4gN319LHBsYWNlaG9sZGVyOnt0eXBlOlN0cmluZyxkZXNjcmlwdGlvbjpcIklucHV0J3MgcGxhY2Vob2xkZXIuXCJ9LHNlYXJjaERlbGF5Ont0eXBlOk51bWJlcixkZWZhdWx0OmZ1bmN0aW9uKCl7cmV0dXJuIDFlM30sZGVzY3JpcHRpb246XCJEZWxheSBiZWZvcmUgcXVlcnlpbmcgcmVzdWx0cyBvbiBpbnB1dGNoYW5nZVwifSxzZWFyY2hGaWVsZHM6e3R5cGU6QXJyYXksZGVmYXVsdDpmdW5jdGlvbigpe3JldHVybltcInRpdGxlXCIsXCJkZXNjcmlwdGlvblwiXX0sZGVzY3JpcHRpb246XCJTcGVjaWZ5IG9iamVjdCBwcm9wZXJ0aWVzIGluc2lkZSBsb2NhbCBzb3VyY2Ugb2JqZWN0IHdoaWNoIHdpbGwgYmUgc2VhcmNoZWQuXCJ9LHNvdXJjZTp7dHlwZTpBcnJheSxkZXNjcmlwdGlvbjpcIk9uZSBvZjpcXG4tIGFycmF5IG9mIHJlc3VsdHMgZS5nLiBgeyB0aXRsZTogJycsIGRlc2NyaXB0aW9uOiAnJyB9YCBvclxcbi0gb2JqZWN0IG9mIGNhdGVnb3JpZXMgZS5nLiBgeyBuYW1lOiAnJywgcmVzdWx0czogW3sgdGl0bGU6ICcnLCBkZXNjcmlwdGlvbjogJycgfV0gfWBcIn0sdmFsdWU6e3R5cGU6U3RyaW5nLGRlc2NyaXB0aW9uOlwiQ3VycmVudCB2YWx1ZSBvZiB0aGUgc2VhcmNoIGlucHV0LlwifX0sbWV0YTp7c2xvdHM6e2lucHV0OntkZXNjcmlwdGlvbjpcIkN1c3RvbSBpbnB1dC5cIixzY29wZTp7Y2xhc3M6e3R5cGU6U3RyaW5nLGRlc2NyaXB0aW9uOlwiQ1NTIGNsYXNzIHRvIGdpdmUgdG8gdGhlIGlucHV0LiBEbyBub3QgdXNlIHdpdGggc3VpLWlucHV0LCB1c2UgYHByb3BzYCBpbnN0ZWFkLlwifSxwcm9wczp7dHlwZTpPYmplY3QsZGVzY3JpcHRpb246XCJQcm9wcyB0byBwYXNzIHRvIHN1aS1pbnB1dC5cIn0saGFuZGxlcnM6e3R5cGU6T2JqZWN0LGRlc2NyaXB0aW9uOlwiSGFuZGxlcnMgdG8gcGFzcyB0byB0aGUgaW5wdXQuXCJ9fX0scmVzdWx0OntkZXNjcmlwdGlvbjpcIlJlbmRlciB0aGUgcmVzdWx0LlwiLHNjb3BlOntyZXN1bHQ6e3R5cGU6T2JqZWN0LGRlc2NyaXB0aW9uOlwiT2JqZWN0IGluIHRoZSByZXN1bHQgcHJvcCBtYXRjaGluZyB0aGUgc2VhcmNoIHRlcm0uXCJ9fX19fSxkYXRhOmZ1bmN0aW9uKCl7cmV0dXJue2FuaW1hdGlvblRpbWVvdXQ6bnVsbCxzZWFyY2hGb2N1c2VkOiExLHJlcXVlc3Q6bnVsbCxmaWx0ZXJlZFJlc3VsdHM6bnVsbCx2YWx1ZVN0YXRlOm51bGwsbG9hZGluZ1N0YXRlOiExfX0sY29tcHV0ZWQ6e2NhdGVnb3J5OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZmlsdGVyZWRSZXN1bHRzJiZcIm9iamVjdFwiPT09Z2kodGhpcy5maWx0ZXJlZFJlc3VsdHMpJiYhQXJyYXkuaXNBcnJheSh0aGlzLmZpbHRlcmVkUmVzdWx0cyl9LGludGVybmFsTG9hZGluZzpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxvYWRpbmd8fHRoaXMubG9hZGluZ1N0YXRlfSxpbnRlcm5hbFZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHZvaWQgMD09PXRoaXMudmFsdWU/dGhpcy52YWx1ZVN0YXRlOnRoaXMudmFsdWV9fSx3YXRjaDp7aW50ZXJuYWxWYWx1ZTpmdW5jdGlvbigpe3RoaXMuaW50ZXJuYWxWYWx1ZT8odGhpcy5sb2FkaW5nU3RhdGU9ITAsdGhpcy5zZWFyY2godGhpcy5pbnRlcm5hbFZhbHVlKSk6KHRoaXMubG9hZGluZ1N0YXRlPSExLHRoaXMuZmlsdGVyZWRSZXN1bHRzPW51bGwpfX0sY3JlYXRlZDpmdW5jdGlvbigpe3ZhciBlLHQsaSxuO3RoaXMuc291cmNlfHwodGhpcy5zZWFyY2g9KGU9dGhpcy5zZWFyY2gsdD10aGlzLnNlYXJjaERlbGF5LGZ1bmN0aW9uKCl7dmFyIHI9dGhpcyxzPWFyZ3VtZW50cyxvPWZ1bmN0aW9uKCl7bj1udWxsLGl8fGUuYXBwbHkocixzKX0sYT1pJiYhbjtjbGVhclRpbWVvdXQobiksbj1zZXRUaW1lb3V0KG8sdCksYSYmZS5hcHBseShyLHMpfSkpfSxtZXRob2RzOntoYW5kbGVJbnB1dDpmdW5jdGlvbihlKXt0aGlzLnZhbHVlU3RhdGU9XCJzdHJpbmdcIj09dHlwZW9mIGU/ZTplLnRhcmdldC52YWx1ZSx0aGlzLiRlbWl0KFwiaW5wdXRcIix0aGlzLnZhbHVlU3RhdGUpfSxoYW5kbGVTZWxlY3Q6ZnVuY3Rpb24oZSl7dGhpcy4kZW1pdChcInNlbGVjdFwiLGUpLHRoaXMuaGFuZGxlSW5wdXQoZS50aXRsZSl9LGhhbmRsZUZvY3VzOmZ1bmN0aW9uKCl7dGhpcy5zZWFyY2hGb2N1c2VkPSEwfSxoYW5kbGVCbHVyOmZ1bmN0aW9uKCl7dGhpcy5zZWFyY2hGb2N1c2VkPSExfSxzZWFyY2g6ZnVuY3Rpb24oZSl7dmFyIHQsaSxuLHIscyxvLGEsYyxsLGQsdT10aGlzO3RoaXMuc291cmNlPyh0aGlzLmZpbHRlcmVkUmVzdWx0cz0odD10aGlzLmludGVybmFsVmFsdWUsaT10aGlzLnNvdXJjZSxuPXRoaXMuc2VhcmNoRmllbGRzLHI9dGhpcy5mdWxsVGV4dFNlYXJjaCxzPVtdLG89W10sYT1bXSxjPXQudG9TdHJpbmcoKS5yZXBsYWNlKC9bLVtdXFwvXFx7XFx9XFwoXFwpXFwqXFwrXFw/XFwuXFxcXFxcXlxcJFxcfF0vZyxcIlxcXFwkJlwiKSxsPW5ldyBSZWdFeHAoXCIoPzpzfF4pXCIrYyxcImlcIiksZD1mdW5jdGlvbihlLHQpe3ZhciBpPSFzLmluY2x1ZGVzKHQpLG49IWEuaW5jbHVkZXModCkscj0hby5pbmNsdWRlcyh0KTtpJiZuJiZyJiZlLnB1c2godCl9LHZvaWQgMD09PWl8fCExPT09aT9bXToobi5mb3JFYWNoKChmdW5jdGlvbihlKXtpLmZvckVhY2goKGZ1bmN0aW9uKGkpe3ZhciBuLGM7XCJzdHJpbmdcIj09dHlwZW9mIGlbZV0mJigtMSE9PWlbZV0uc2VhcmNoKGwpP2QocyxpKTpcImV4YWN0XCI9PT1yJiYobj10LGM9aVtlXSxuPW4udG9Mb3dlckNhc2UoKSwoYz1jLnRvTG93ZXJDYXNlKCkpLmluZGV4T2Yobik+LTEpP2QobyxpKTpyJiZmdW5jdGlvbihlLHQpe3ZhciBpPXQubGVuZ3RoLG49ZS5sZW5ndGg7aWYoXCJzdHJpbmdcIiE9dHlwZW9mIGUpcmV0dXJuITE7aWYoZT1lLnRvTG93ZXJDYXNlKCksdD10LnRvTG93ZXJDYXNlKCksbj5pKXJldHVybiExO2lmKG49PT1pKXJldHVybiBlPT09dDtlOmZvcih2YXIgcj0wLHM9MDtyPG47cisrKXtmb3IodmFyIG89ZS5jaGFyQ29kZUF0KHIpO3M8aTspaWYodC5jaGFyQ29kZUF0KHMrKyk9PT1vKWNvbnRpbnVlIGU7cmV0dXJuITF9cmV0dXJuITB9KHQsaVtlXSkmJmQoYSxpKSl9KSl9KSksW10uY29uY2F0KHMsbyxhKSkpLnNsaWNlKDAsdGhpcy5tYXhSZXN1bHRzKSx0aGlzLmxvYWRpbmdTdGF0ZT0hMSk6dGhpcy5leGVjdXRlQWN0aW9uKHRoaXMuZ2V0RW5kcG9pbnQodGhpcy5hY3Rpb24se3ZhbHVlOmV9KSkudGhlbigoZnVuY3Rpb24odCl7dS5pbnRlcm5hbFZhbHVlPT09ZSYmKHUubG9hZGluZ1N0YXRlPSExLHUuZmlsdGVyZWRSZXN1bHRzPXQpfSkpfX0scmVuZGVyOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzWzBdLHQ9dGhpcy5nZXRFbGVtZW50VHlwZSgpLGk9XCJwcm9tcHRcIjtyZXR1cm4gZSh0LGwoKShbe30sdGhpcy5nZXRDaGlsZFByb3BzQW5kTGlzdGVuZXJzKCkse2NsYXNzOnRoaXMuY2xhc3NlcyhcInVpXCIsdGhpcy5jYXRlZ29yeSYmXCJjYXRlZ29yeVwiLHRoaXMuZGlzYWJsZWQmJlwiZGlzYWJsZWRcIix0aGlzLmZsdWlkJiZcImZsdWlkXCIsdGhpcy5hbGlnbmVkLHRoaXMuYWxpZ25lZCYmXCJhbGlnbmVkXCIsdGhpcy5pbnRlcm5hbExvYWRpbmcmJlwibG9hZGluZ1wiLFwic2VhcmNoXCIpfV0pLFt0aGlzLiRzY29wZWRTbG90cy5pbnB1dD90aGlzLiRzY29wZWRTbG90cy5pbnB1dCh7Y2xhc3M6aSxwcm9wczp7aW5wdXRDbGFzczppLHZhbHVlOnRoaXMuaW50ZXJuYWxWYWx1ZX0saGFuZGxlcnM6e2JsdXI6dGhpcy5oYW5kbGVCbHVyLGlucHV0OnRoaXMuaGFuZGxlSW5wdXQsZm9jdXM6dGhpcy5oYW5kbGVGb2N1c319KTplKFwiaW5wdXRcIix7Y2xhc3M6XCJwcm9tcHRcIixhdHRyczp7cGxhY2Vob2xkZXI6dGhpcy5wbGFjZWhvbGRlcix0eXBlOlwidGV4dFwifSxkb21Qcm9wczp7dmFsdWU6dGhpcy5pbnRlcm5hbFZhbHVlfSxvbjp7Ymx1cjp0aGlzLmhhbmRsZUJsdXIsZm9jdXM6dGhpcy5oYW5kbGVGb2N1cyxpbnB1dDp0aGlzLmhhbmRsZUlucHV0fX0pLGUobWkse2F0dHJzOnthbmltYXRpb25UaW1lb3V0OnRoaXMuYW5pbWF0aW9uVGltZW91dCxjYXRlZ29yeTp0aGlzLmNhdGVnb3J5LGR1cmF0aW9uOnRoaXMuZHVyYXRpb24sbG9hZGluZzp0aGlzLmludGVybmFsTG9hZGluZyxyZXN1bHRzOnRoaXMuZmlsdGVyZWRSZXN1bHRzLHNlYXJjaEZvY3VzZWQ6dGhpcy5zZWFyY2hGb2N1c2VkLHZhbHVlOnRoaXMuaW50ZXJuYWxWYWx1ZX0sb246e3NlbGVjdDp0aGlzLmhhbmRsZVNlbGVjdH19KV0pfX0seWk9e25hbWU6XCJTdWlTaWRlYmFyXCIsbWl4aW5zOltMXSxwcm9wczp7YW5pbWF0aW9uOl8oW1wib3ZlcmxheVwiLFwicHVzaFwiLFwic2NhbGUgZG93blwiLFwidW5jb3ZlclwiLFwic2xpZGUgb3V0XCIsXCJzbGlkZSBhbG9uZ1wiXSksZGlyZWN0aW9uOl8oW1widG9wXCIsXCJyaWdodFwiLFwiYm90dG9tXCIsXCJsZWZ0XCJdLHtkZWZhdWx0OlwibGVmdFwifSksdmlzaWJsZTpCb29sZWFuLHdpZHRoOl8oW1widmVyeSB0aGluXCIsXCJ0aGluXCIsXCJ3aWRlXCIsXCJ2ZXJ5IHdpZGVcIl0pfSxkYXRhOmZ1bmN0aW9uKCl7cmV0dXJue2FuaW1hdGluZzohMX19LHdhdGNoOnt2aXNpYmxlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpczt0aGlzLmFuaW1hdGluZz0hMCxzZXRUaW1lb3V0KChmdW5jdGlvbigpe2UuYW5pbWF0aW5nPSExfSksNTAwKX19LHJlbmRlcjpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50c1swXSx0PXRoaXMuZ2V0RWxlbWVudFR5cGUoKTtyZXR1cm4gZSh0LGwoKShbe30sdGhpcy5nZXRDaGlsZFByb3BzQW5kTGlzdGVuZXJzKCkse2NsYXNzOlwidWkgc2lkZWJhciBcIi5jb25jYXQodGhpcy5kaXJlY3Rpb24sXCIgXCIpLmNvbmNhdCh0aGlzLndpZHRoLFwiIFwiKS5jb25jYXQodGhpcy5hbmltYXRpb258fFwiXCIpLmNvbmNhdCh0aGlzLnZpc2libGU/XCIgdmlzaWJsZVwiOlwiXCIpLmNvbmNhdCh0aGlzLmFuaW1hdGluZz9cIiBhbmltYXRpbmdcIjpcIlwiKX1dKSxbdGhpcy4kc2xvdHMuZGVmYXVsdF0pfX0sdmk9e25hbWU6XCJTdWlTaWRlYmFyUHVzaGFibGVcIixtaXhpbnM6W0xdLHJlbmRlcjpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50c1swXSx0PXRoaXMuZ2V0RWxlbWVudFR5cGUoKTtyZXR1cm4gZSh0LGwoKShbe30sdGhpcy5nZXRDaGlsZFByb3BzQW5kTGlzdGVuZXJzKCkse2NsYXNzOlwicHVzaGFibGVcIn1dKSxbdGhpcy4kc2xvdHMuZGVmYXVsdF0pfSxtZXRhOntwYXJlbnQ6XCJTdWlTaWRlYmFyXCJ9fSxTaT17bmFtZTpcIlN1aVNpZGViYXJQdXNoZXJcIixtaXhpbnM6W0xdLHByb3BzOntkaW1tZWQ6Qm9vbGVhbn0scmVuZGVyOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzWzBdLHQ9dGhpcy5nZXRFbGVtZW50VHlwZSgpO3JldHVybiBlKHQsbCgpKFt7fSx0aGlzLmdldENoaWxkUHJvcHNBbmRMaXN0ZW5lcnMoKSx7Y2xhc3M6dGhpcy5jbGFzc2VzKFwicHVzaGVyXCIsdGhpcy5kaW1tZWQmJlwiZGltbWVkXCIpfV0pLFt0aGlzLiRzbG90cy5kZWZhdWx0XSl9LG1ldGE6e3BhcmVudDpcIlN1aVNpZGViYXJcIn19LHdpPXtpbnNlcnRlZDpmdW5jdGlvbihlKXt2YXIgdD1kb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksaT1BcnJheS5mcm9tKGUuY2hpbGROb2Rlcyksbj1lLnBhcmVudE5vZGUscj1kb2N1bWVudC5jcmVhdGVDb21tZW50KFwiZnJhZ21lbnQgdGFpbFwiKTt0LmFwcGVuZENoaWxkKHIpLGkuZm9yRWFjaCgoZnVuY3Rpb24oZSl7cmV0dXJuIHQuYXBwZW5kQ2hpbGQoZSl9KSksbi5pbnNlcnRCZWZvcmUodCxlKSxuLnJlbW92ZUNoaWxkKGUpLGkuZm9yRWFjaCgoZnVuY3Rpb24odCl7cmV0dXJuIEFpKHQsZSl9KSksZS5fX2hvb2tzX189e2FwcGVuZENoaWxkOmUuYXBwZW5kQ2hpbGQsaW5zZXJ0QmVmb3JlOmUuaW5zZXJ0QmVmb3JlLHJlbW92ZUNoaWxkOmUucmVtb3ZlQ2hpbGR9LGUuYXBwZW5kQ2hpbGQ9ZnVuY3Rpb24odCl7dmFyIGk9bi5pbnNlcnRCZWZvcmUodCxyKTtyZXR1cm4gdC5wYXJlbnROb2RlIT09ZSYmQWkodCxlKSxpfSxlLmluc2VydEJlZm9yZT1mdW5jdGlvbih0LGkpe3ZhciByPW4uaW5zZXJ0QmVmb3JlKHQsaSk7cmV0dXJuIHQucGFyZW50Tm9kZSE9PWUmJkFpKHQsZSkscn0sZS5yZW1vdmVDaGlsZD1mdW5jdGlvbihlKXtyZXR1cm4gT2koZSksbi5yZW1vdmVDaGlsZChlKX19LHVuYmluZDpmdW5jdGlvbihlKXtlLl9faG9va3NfXyYmKE9iamVjdC5rZXlzKGUuX19ob29rc19fKS5mb3JFYWNoKChmdW5jdGlvbih0KXtlW3RdPWUuX19ob29rc19fW3RdfSkpLGRlbGV0ZSBlLl9faG9va3NfXyl9fSxBaT1mdW5jdGlvbihlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwicGFyZW50Tm9kZVwiLHtjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITEsdmFsdWU6dH0pfSxPaT1mdW5jdGlvbihlKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcInBhcmVudE5vZGVcIix7Y29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOm51bGx9KX0seGk9e2Fic3RyYWN0OiEwLGRpcmVjdGl2ZXM6e2ZyYWdtZW50OndpfSxyZW5kZXI6ZnVuY3Rpb24oZSl7cmV0dXJuIGUoXCJkaXZcIix7YXR0cnM6e2NsYXNzOlwidi1mcmFnbWVudFwifSxkaXJlY3RpdmVzOlt7bmFtZTpcImZyYWdtZW50XCJ9XX0sW3RoaXMuJHNsb3RzLmRlZmF1bHRdKX19LFBpPVtcInRvcCBsZWZ0XCIsXCJ0b3AgcmlnaHRcIixcImJvdHRvbSByaWdodFwiLFwiYm90dG9tIGxlZnRcIixcInJpZ2h0IGNlbnRlclwiLFwibGVmdCBjZW50ZXJcIixcInRvcCBjZW50ZXJcIixcImJvdHRvbSBjZW50ZXJcIl0sQmk9e25hbWU6XCJTdWlQcml2YXRlUG9wdXBDb250YWluZXJcIixtaXhpbnM6W0xdLHByb3BzOntwb3B1cENsYXNzOlN0cmluZyx0cmlnZ2VyQ29vcmRzOnA/W3dpbmRvdy5ET01SZWN0LE9iamVjdF06T2JqZWN0LHBvc2l0aW9uOlN0cmluZ30sZGF0YTpmdW5jdGlvbigpe3JldHVybnttb3VudGVkUG9zaXRpb246dGhpcy5wb3NpdGlvbixtb3VudGVkU3R5bGU6bnVsbH19LG1vdW50ZWQ6ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3RoaXMuJG5leHRUaWNrKChmdW5jdGlvbigpe2UucG9wdXBDb29yZHM9ZS4kcmVmcy5jb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksZS5zZXRQb3B1cFN0eWxlKCl9KSl9LG1ldGhvZHM6e2NvbXB1dGVQb3B1cFN0eWxlOmZ1bmN0aW9uKGUpe3ZhciB0PXtwb3NpdGlvbjpcImFic29sdXRlXCJ9O2lmKCFwKXJldHVybiB0O3ZhciBpPXRoaXMub2Zmc2V0LG49d2luZG93LHI9bi5wYWdlWU9mZnNldCxzPW4ucGFnZVhPZmZzZXQsbz1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsYT1vLmNsaWVudFdpZHRoLGM9by5jbGllbnRIZWlnaHQ7aWYoZS5pbmNsdWRlcyhcInJpZ2h0XCIpKXQucmlnaHQ9TWF0aC5yb3VuZChhLSh0aGlzLnRyaWdnZXJDb29yZHMucmlnaHQrcykpLHQubGVmdD1cImF1dG9cIjtlbHNlIGlmKGUuaW5jbHVkZXMoXCJsZWZ0XCIpKXQubGVmdD1NYXRoLnJvdW5kKHRoaXMudHJpZ2dlckNvb3Jkcy5sZWZ0K3MpLHQucmlnaHQ9XCJhdXRvXCI7ZWxzZXt2YXIgbD0odGhpcy50cmlnZ2VyQ29vcmRzLndpZHRoLXRoaXMucG9wdXBDb29yZHMud2lkdGgpLzI7dC5sZWZ0PU1hdGgucm91bmQodGhpcy50cmlnZ2VyQ29vcmRzLmxlZnQrbCtzKSx0LnJpZ2h0PVwiYXV0b1wifWlmKGUuaW5jbHVkZXMoXCJ0b3BcIikpdC5ib3R0b209TWF0aC5yb3VuZChjLSh0aGlzLnRyaWdnZXJDb29yZHMudG9wK3IpKSx0LnRvcD1cImF1dG9cIjtlbHNlIGlmKGUuaW5jbHVkZXMoXCJib3R0b21cIikpdC50b3A9TWF0aC5yb3VuZCh0aGlzLnRyaWdnZXJDb29yZHMuYm90dG9tK3IpLHQuYm90dG9tPVwiYXV0b1wiO2Vsc2V7dmFyIGQ9KHRoaXMudHJpZ2dlckNvb3Jkcy5oZWlnaHQrdGhpcy5wb3B1cENvb3Jkcy5oZWlnaHQpLzI7dC50b3A9TWF0aC5yb3VuZCh0aGlzLnRyaWdnZXJDb29yZHMuYm90dG9tK3ItZCksdC5ib3R0b209XCJhdXRvXCI7dmFyIHU9dGhpcy5wb3B1cENvb3Jkcy53aWR0aCs4O2UuaW5jbHVkZXMoXCJyaWdodFwiKT90LnJpZ2h0LT11OnQubGVmdC09dX1yZXR1cm4gaSYmKFwibnVtYmVyXCI9PXR5cGVvZiB0LnJpZ2h0P3QucmlnaHQtPWk6dC5sZWZ0LT1pKSx0fSxpc1N0eWxlSW5WaWV3cG9ydDpmdW5jdGlvbihlKXt2YXIgdD13aW5kb3csaT10LnBhZ2VZT2Zmc2V0LG49dC5wYWdlWE9mZnNldCxyPWRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxzPXIuY2xpZW50V2lkdGgsbz1yLmNsaWVudEhlaWdodCxhPXt0b3A6ZS50b3AsbGVmdDplLmxlZnQsd2lkdGg6dGhpcy5wb3B1cENvb3Jkcy53aWR0aCxoZWlnaHQ6dGhpcy5wb3B1cENvb3Jkcy5oZWlnaHR9O3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiBlLnJpZ2h0JiYoYS5sZWZ0PXMtZS5yaWdodC1hLndpZHRoKSxcIm51bWJlclwiPT10eXBlb2YgZS5ib3R0b20mJihhLnRvcD1vLWUuYm90dG9tLWEuaGVpZ2h0KSwhKGEudG9wPGkpJiYoIShhLnRvcCthLmhlaWdodD5pK28pJiYoIShhLmxlZnQ8bikmJiEoYS5sZWZ0K2Eud2lkdGg+bitzKSkpfSxzZXRQb3B1cFN0eWxlOmZ1bmN0aW9uKCl7aWYodGhpcy50cmlnZ2VyQ29vcmRzJiZ0aGlzLnBvcHVwQ29vcmRzKXtmb3IodmFyIGUsdCxpLG4scj10aGlzLnBvc2l0aW9uLHM9dGhpcy5jb21wdXRlUG9wdXBTdHlsZShyKSxvPShlPVBpLHQ9cixlLmZpbHRlcigoZnVuY3Rpb24oZSl7cmV0dXJuIGUhPT10fSkpKS5jb25jYXQoW3JdKSxhPTA7IXRoaXMuaXNTdHlsZUluVmlld3BvcnQocykmJmE8by5sZW5ndGg7YSs9MSlzPXRoaXMuY29tcHV0ZVBvcHVwU3R5bGUob1thXSkscj1vW2FdO2k9cyxuPWZ1bmN0aW9uKGUpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiBlP1wiXCIuY29uY2F0KGUsXCJweFwiKTplfSxzPU9iamVjdC5rZXlzKGkpLnJlZHVjZSgoZnVuY3Rpb24oZSx0KXtyZXR1cm4gZVt0XT1uKGlbdF0pLGV9KSx7fSksdGhpcy5tb3VudGVkU3R5bGU9cyx0aGlzLm1vdW50ZWRQb3NpdGlvbj1yfX19LHJlbmRlcjpmdW5jdGlvbigpe3ZhciBlPXRoaXMsdD1hcmd1bWVudHNbMF0saT10aGlzLmNsYXNzZXMoXCJ1aVwiLHRoaXMubW91bnRlZFBvc2l0aW9uLHRoaXMucG9wdXBDbGFzcyxcInBvcHVwXCIsXCJ0cmFuc2l0aW9uIHZpc2libGVcIik7cmV0dXJuIHQoXCJwb3J0YWxcIix7YXR0cnM6e3RvOlwic2VtYW50aWMtdWktdnVlXCJ9fSxbdChcImRpdlwiLHtyZWY6XCJjb250YWluZXJcIixjbGFzczppLHN0eWxlOnRoaXMubW91bnRlZFN0eWxlLG9uOnttb3VzZW92ZXI6ZnVuY3Rpb24oKXtyZXR1cm4gZS4kZW1pdChcIm1vdXNlb3ZlclwiKX0sbW91c2VsZWF2ZTpmdW5jdGlvbigpe3JldHVybiBlLiRlbWl0KFwibW91c2VsZWF2ZVwiKX19fSxbdGhpcy4kc2xvdHMuZGVmYXVsdF0pXSl9fSxDaT17bmFtZTpcIlN1aVBvcHVwSGVhZGVyXCIsbWl4aW5zOltMXSxyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHNbMF0sdD10aGlzLmdldEVsZW1lbnRUeXBlKCk7cmV0dXJuIGUodCxsKCkoW3t9LHRoaXMuZ2V0Q2hpbGRQcm9wc0FuZExpc3RlbmVycygpLHtjbGFzczpcImhlYWRlclwifV0pLFt0aGlzLiRzbG90cy5kZWZhdWx0XSl9LG1ldGE6e3BhcmVudDpcIlN1aVBvcHVwXCJ9fSxqaT17bmFtZTpcIlN1aVBvcHVwQ29udGVudFwiLG1peGluczpbTF0scmVuZGVyOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzWzBdLHQ9dGhpcy5nZXRFbGVtZW50VHlwZSgpO3JldHVybiBlKHQsbCgpKFt7fSx0aGlzLmdldENoaWxkUHJvcHNBbmRMaXN0ZW5lcnMoKSx7Y2xhc3M6XCJjb250ZW50XCJ9XSksW3RoaXMuJHNsb3RzLmRlZmF1bHRdKX0sbWV0YTp7cGFyZW50OlwiU3VpUG9wdXBcIn19LEVpPXtuYW1lOlwiU3VpUG9wdXBcIixkZXNjcmlwdGlvbjpcIkEgcG9wdXAgZGlzcGxheXMgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBvbiB0b3Agb2YgYSBwYWdlLlwiLG1peGluczpbTF0scHJvcHM6e2Jhc2ljOnt0eXBlOkJvb2xlYW4sZGVzY3JpcHRpb246XCJEaXNwbGF5IHRoZSBwb3B1cCB3aXRob3V0IHRoZSBwb2ludGluZyBhcnJvdy5cIn0sY29udGVudDp7dHlwZTpTdHJpbmcsZGVzY3JpcHRpb246XCJTaW1wbGUgdGV4dCBjb250ZW50IGZvciB0aGUgcG9wb3Zlci5cIn0sZmxvd2luZzp7dHlwZTpCb29sZWFuLGRlc2NyaXB0aW9uOlwiQSBmbG93aW5nIFBvcHVwIGhhcyBubyBtYXhpbXVtIHdpZHRoIGFuZCBjb250aW51ZXMgdG8gZmxvdyB0byBmaXQgaXRzIGNvbnRlbnQuXCJ9LGhlYWRlcjp7dHlwZTpTdHJpbmcsZGVzY3JpcHRpb246XCJIZWFkZXIgZGlzcGxheWVkIGFib3ZlIHRoZSBjb250ZW50IGluIGJvbGQuXCJ9LGhvdmVyYWJsZTp7dHlwZTpCb29sZWFuLGRlc2NyaXB0aW9uOlwiV2hldGhlciB0aGUgcG9wdXAgc2hvdWxkIG5vdCBjbG9zZSBvbiBob3Zlci5cIn0saW52ZXJ0ZWQ6e3R5cGU6Qm9vbGVhbixkZXNjcmlwdGlvbjpcIkludmVydCB0aGUgY29sb3JzIG9mIHRoZSBQb3B1cC5cIn0scG9zaXRpb246XyhQaSx7ZGVzY3JpcHRpb246XCJQb3NpdGlvbiBmb3IgdGhlIHBvcG92ZXIuXCIsZGVmYXVsdDpcInRvcCBsZWZ0XCJ9KSxzaXplOl8oW1wibWluaVwiLFwidGlueVwiLFwic21hbGxcIixcImxhcmdlXCIsXCJodWdlXCJdLHtkZXNjcmlwdGlvbjpcIlBvcHVwIHNpemUuXCJ9KSx3aWRlOl8oW1widmVyeVwiXSx7dHlwZTpCb29sZWFuLGRlc2NyaXB0aW9uOlwiUG9wdXAgd2lkdGguXCJ9KX0sZGF0YTpmdW5jdGlvbigpe3JldHVybntjb29yZHM6bnVsbCxvcGVuOiExfX0sbW91bnRlZDpmdW5jdGlvbigpe3RoaXMuJHNsb3RzLnRyaWdnZXJbMF0uZWxtLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWVudGVyXCIsdGhpcy5oYW5kbGVPcGVuKSx0aGlzLiRzbG90cy50cmlnZ2VyWzBdLmVsbS5hZGRFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLHRoaXMuaGFuZGxlQmx1cil9LG1ldGhvZHM6e2hhbmRsZU9wZW46ZnVuY3Rpb24oKXt0aGlzLmNvb3Jkcz10aGlzLiRzbG90cy50cmlnZ2VyWzBdLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSx0aGlzLm9wZW49ITAsdGhpcy4kZW1pdChcIm9wZW5cIil9LGhhbmRsZUJsdXI6ZnVuY3Rpb24oKXt0aGlzLmhvdmVyYWJsZT90aGlzLmJsdXJUaW1lb3V0PXNldFRpbWVvdXQodGhpcy5jbG9zZSwzMDApOnRoaXMuY2xvc2UoKX0saGFuZGxlQ29udGFpbmVySG92ZXI6ZnVuY3Rpb24oKXt0aGlzLmhvdmVyYWJsZSYmdGhpcy5ibHVyVGltZW91dCYmY2xlYXJUaW1lb3V0KHRoaXMuYmx1clRpbWVvdXQpfSxjbG9zZTpmdW5jdGlvbigpe3RoaXMub3Blbj0hMSx0aGlzLiRlbWl0KFwiY2xvc2VcIil9fSxyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHNbMF07cmV0dXJuIGUoeGksW3RoaXMuJHNsb3RzLnRyaWdnZXIsdGhpcy5vcGVuJiZlKEJpLHtvbjp7bW91c2VvdmVyOnRoaXMuaGFuZGxlQ29udGFpbmVySG92ZXIsbW91c2VsZWF2ZTp0aGlzLmhhbmRsZUJsdXJ9LGF0dHJzOntwb3B1cENsYXNzOnRoaXMuY2xhc3Nlcyh0aGlzLmJhc2ljJiZcImJhc2ljXCIsdGhpcy5mbG93aW5nJiZcImZsb3dpbmdcIix0aGlzLmludmVydGVkJiZcImludmVydGVkXCIsdGhpcy5zaXplLHRoaXMud2lkZSx0aGlzLndpZGUmJlwid2lkZVwiKSx0cmlnZ2VyQ29vcmRzOnRoaXMuY29vcmRzLHBvc2l0aW9uOnRoaXMucG9zaXRpb24sY29udGVudDp0aGlzLmNvbnRlbnR9fSxbdGhpcy5oZWFkZXImJmUoQ2ksW3RoaXMuaGVhZGVyXSksdGhpcy5jb250ZW50JiZlKGppLFt0aGlzLmNvbnRlbnRdKSx0aGlzLiRzbG90cy5kZWZhdWx0XSldKX19LFRpPXtuYW1lOlwiU3VpUHJvZ3Jlc3NcIixtaXhpbnM6W0xdLHByb3BzOntsYWJlbDpTdHJpbmcsY29udGVudDpTdHJpbmcsdG9wOkJvb2xlYW4sYm90dG9tOkJvb2xlYW4sYXR0YWNoZWQ6Qm9vbGVhbixpbnZlcnRlZDpCb29sZWFuLHByb2dyZXNzOkJvb2xlYW4saW5kaWNhdGluZzpCb29sZWFuLGluZGV0ZXJtaW5hdGU6Qm9vbGVhbixzaXplOl8uU2l6ZSgpLGNvbG9yOl8uQ29sb3IoKSxzdGF0ZTpfLlN0YXRlKCkscGVyY2VudDp7dHlwZTpbTnVtYmVyLFN0cmluZ10sZGVmYXVsdDo1MCx2YWxpZGF0b3I6ZnVuY3Rpb24oZSl7cmV0dXJuIGU+PTAmJmU8PTEwMH19fSxjb21wdXRlZDp7cGVyY2VudFN0cmluZzpmdW5jdGlvbigpe3JldHVyblwiXCIuY29uY2F0KHRoaXMucGVyY2VudCxcIiVcIil9fSxyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHNbMF0sdD10aGlzLmdldEVsZW1lbnRUeXBlKCk7cmV0dXJuIGUodCxsKCkoW3t9LHRoaXMuZ2V0Q2hpbGRQcm9wc0FuZExpc3RlbmVycygpLHtjbGFzczp0aGlzLmNsYXNzZXMoXCJ1aVwiLFwicHJvZ3Jlc3NcIix0aGlzLnN0YXRlLHRoaXMuY29sb3IsdGhpcy5zaXplLHRoaXMudG9wJiZcInRvcFwiLHRoaXMuYm90dG9tJiZcImJvdHRvbVwiLHRoaXMuaW52ZXJ0ZWQmJlwiaW52ZXJ0ZWRcIix0aGlzLmF0dGFjaGVkJiZcImF0dGFjaGVkXCIsdGhpcy5pbmRpY2F0aW5nJiZcImluZGljYXRpbmdcIix0aGlzLmluZGV0ZXJtaW5hdGUmJlwiaW5kZXRlcm1pbmF0ZVwiKSxhdHRyczp7XCJkYXRhLXBlcmNlbnRcIjp0aGlzLnBlcmNlbnR9fV0pLFtlKFwiZGl2XCIse2NsYXNzOlwiYmFyXCIsc3R5bGU6e3dpZHRoOnRoaXMucGVyY2VudFN0cmluZyxcInRyYW5zaXRpb24tZHVyYXRpb25cIjpcIjMwMG1zXCJ9fSxbdGhpcy5wcm9ncmVzcyYmZShcImRpdlwiLHtjbGFzczpcInByb2dyZXNzXCJ9LFtcIiBcIix0aGlzLnBlcmNlbnRTdHJpbmcsXCIgXCJdKV0pLHRoaXMubGFiZWwmJmUoXCJkaXZcIix7Y2xhc3M6XCJsYWJlbFwifSxbdGhpcy5sYWJlbF0pXSl9fTtmdW5jdGlvbiAkaShlKXtyZXR1cm4gZnVuY3Rpb24oZSl7aWYoQXJyYXkuaXNBcnJheShlKSl7Zm9yKHZhciB0PTAsaT1uZXcgQXJyYXkoZS5sZW5ndGgpO3Q8ZS5sZW5ndGg7dCsrKWlbdF09ZVt0XTtyZXR1cm4gaX19KGUpfHxmdW5jdGlvbihlKXtpZihTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGUpfHxcIltvYmplY3QgQXJndW1lbnRzXVwiPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpKXJldHVybiBBcnJheS5mcm9tKGUpfShlKXx8ZnVuY3Rpb24oKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2VcIil9KCl9ZnVuY3Rpb24gTGkoZSx0KXt2YXIgaT1PYmplY3Qua2V5cyhlKTtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgbj1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO3QmJihuPW4uZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLHQpLmVudW1lcmFibGV9KSkpLGkucHVzaC5hcHBseShpLG4pfXJldHVybiBpfWZ1bmN0aW9uIGtpKGUpe2Zvcih2YXIgdD0xO3Q8YXJndW1lbnRzLmxlbmd0aDt0Kyspe3ZhciBpPW51bGwhPWFyZ3VtZW50c1t0XT9hcmd1bWVudHNbdF06e307dCUyP0xpKE9iamVjdChpKSwhMCkuZm9yRWFjaCgoZnVuY3Rpb24odCl7RGkoZSx0LGlbdF0pfSkpOk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzP09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoaSkpOkxpKE9iamVjdChpKSkuZm9yRWFjaCgoZnVuY3Rpb24odCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGksdCkpfSkpfXJldHVybiBlfWZ1bmN0aW9uIERpKGUsdCxpKXtyZXR1cm4gdCBpbiBlP09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQse3ZhbHVlOmksZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTplW3RdPWksZX12YXIgSWk9e25hbWU6XCJTdWlUYWJcIixwcm9wczp7bWVudTp7dHlwZTpPYmplY3QsZGVmYXVsdDpmdW5jdGlvbigpe3JldHVybnthdHRhY2hlZDohMCx0YWJ1bGFyOiEwfX19LG1lbnVQb3NpdGlvbjpfKFtcImxlZnRcIixcInJpZ2h0XCJdLHtkZXNjcmlwdGlvbjpcIk1lbnUgUG9zaXRpb25cIn0pLGFjdGl2ZUluZGV4Ont0eXBlOltTdHJpbmcsTnVtYmVyXSxkZWZhdWx0OjB9fSxkYXRhOmZ1bmN0aW9uKCl7cmV0dXJue3RhYnM6W10sYWN0aXZlVGFiOm51bGx9fSxjb21wdXRlZDp7dGFiTWVudTpmdW5jdGlvbigpe3ZhciBlPXRoaXMsdD10aGlzLiRjcmVhdGVFbGVtZW50O3JldHVybiB0KFwic3VpLW1lbnVcIix7cHJvcHM6a2koe30sdGhpcy5tZW51KX0sW3RoaXMudGFicy5tYXAoKGZ1bmN0aW9uKGkpe3JldHVybiB0KFwiYVwiLHtjbGFzczpbXCJpdGVtXCIse2FjdGl2ZTppLmFjdGl2ZSxkaXNhYmxlZDppLmRpc2FibGVkfV0sb246e2NsaWNrOmZ1bmN0aW9uKHQpe3JldHVybiBlLm9wZW5UYWIodCxpKX19fSxbaS5pY29uJiZ0KFwic3VpLWljb25cIix7YXR0cnM6e25hbWU6aS5pY29ufX0pLHQoXCJzcGFuXCIsW2kudGl0bGVdKSxpLmxhYmVsJiZ0KFwic3VpLWxhYmVsXCIsW2kubGFiZWxdKV0pfSkpXSl9fSx3YXRjaDp7YWN0aXZlSW5kZXg6ZnVuY3Rpb24oZSl7dGhpcy5vcGVuVGFiKG51bGwsdGhpcy50YWJzWytlXSl9fSxtb3VudGVkOmZ1bmN0aW9uKCl7aWYoIXRoaXMudGFicy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGFiIHVzZWQgd2l0aG91dCB0YWItcGFuZVwiKTt2YXIgZT10aGlzLnRhYnNbdGhpcy5hY3RpdmVJbmRleF18fHRoaXMudGFic1swXTtlLm9wZW4oKSx0aGlzLmFjdGl2ZVRhYj1lfSxtZXRob2RzOnthZGRUYWI6ZnVuY3Rpb24oZSl7dGhpcy50YWJzLnB1c2goZSl9LG9wZW5UYWI6ZnVuY3Rpb24oZSx0KXtpZighdC5kaXNhYmxlZCl7dGhpcy5hY3RpdmVUYWIuY2xvc2UoKSx0Lm9wZW4oKTt2YXIgaT10aGlzLnRhYnMuaW5kZXhPZih0KTt0aGlzLiRlbWl0KFwiY2hhbmdlXCIsZSx0LGkpLHRoaXMuJGVtaXQoXCJ1cGRhdGU6YWN0aXZlSW5kZXhcIixpKSx0aGlzLmFjdGl2ZVRhYj10fX19LHJlbmRlcjpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50c1swXSx0PXRoaXMuJHNsb3RzLmRlZmF1bHQsaT1bdGhpcy50YWJNZW51LHRdO3JldHVyblwiYm90dG9tXCI9PT10aGlzLm1lbnUuYXR0YWNoZWQmJmkucmV2ZXJzZSgpLHRoaXMubWVudS52ZXJ0aWNhbCYmKGk9W2UoXCJzdWktZ3JpZC1jb2x1bW5cIix7YXR0cnM6e3dpZHRoOjR9fSxbdGhpcy50YWJNZW51XSksZShcInN1aS1ncmlkLWNvbHVtblwiLHthdHRyczp7d2lkdGg6MTJ9LGNsYXNzOlwic3RyZXRjaGVkXCJ9LFt0XSldLFwicmlnaHRcIiE9PXRoaXMubWVudS50YWJ1bGFyJiZcInJpZ2h0XCIhPT10aGlzLm1lbnVQb3NpdGlvbnx8aS5yZXZlcnNlKCksaT1lKFwic3VpLWdyaWRcIixbZShcInN1aS1ncmlkLXJvd1wiLFtpXSldKSksZShcImRpdlwiLFtBcnJheS5pc0FycmF5KGkpPyRpKGkpOmldKX19LE1pPXtuYW1lOlwiU3VpVGFiUGFuZVwiLG1ldGE6e3BhcmVudDpcIlN1aVRhYlwifSxwcm9wczp7dGl0bGU6e3R5cGU6U3RyaW5nLHJlcXVpcmVkOiEwfSxpY29uOnt0eXBlOlN0cmluZ30sbGFiZWw6e3R5cGU6U3RyaW5nfSxhdHRhY2hlZDp7dHlwZTpbQm9vbGVhbixTdHJpbmddLGRlZmF1bHQ6ITB9LGxvYWRpbmc6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfSxkaXNhYmxlZDp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9fSxkYXRhOmZ1bmN0aW9uKCl7cmV0dXJue2FjdGl2ZTohMX19LGNvbXB1dGVkOntjbGFzc0xpc3Q6ZnVuY3Rpb24oKXt2YXIgZT1bXCJ1aVwiLFwidGFiXCIsXCJzZWdtZW50XCIse2xvYWRpbmc6dGhpcy5hY3RpdmUmJnRoaXMubG9hZGluZ30se2F0dGFjaGVkOnRoaXMuYXR0YWNoZWR9LHthY3RpdmU6dGhpcy5hY3RpdmV9XTtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgdGhpcy5hdHRhY2hlZCYmZS5wdXNoKHRoaXMuYXR0YWNoZWQpLGV9fSxtb3VudGVkOmZ1bmN0aW9uKCl7dHJ5e3RoaXMuZmluZFBhcmVudCgpLmFkZFRhYih0aGlzKX1jYXRjaChlKXt0aHJvdyBuZXcgRXJyb3IoXCJ0YWItcGFuZSB3YXMgcGxhY2VkIG91dHNpZGUgb2YgdGFiIGNvbXBvbmVudFwiKX19LG1ldGhvZHM6e2ZpbmRQYXJlbnQ6ZnVuY3Rpb24oKXtmb3IodmFyIGU9dGhpcy4kcGFyZW50LHQ9SWkubmFtZTtlLiRvcHRpb25zLm5hbWUhPT10OyllPWUuJHBhcmVudDtyZXR1cm4gZX0sb3BlbjpmdW5jdGlvbigpe3RoaXMuYWN0aXZlPSEwfSxjbG9zZTpmdW5jdGlvbigpe3RoaXMuYWN0aXZlPSExfX0scmVuZGVyOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmFjdGl2ZSYmZShcImRpdlwiLHtjbGFzczp0aGlzLmNsYXNzTGlzdH0sW3RoaXMuJHNsb3RzLmRlZmF1bHRdKX19LEZpPXtuYW1lOlwiU3VpQ2FyZFwiLG1peGluczpbTF0scHJvcHM6e30scmVuZGVyOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzWzBdLHQ9dGhpcy5nZXRFbGVtZW50VHlwZSgpO3JldHVybiBlKHQsbCgpKFt7fSx0aGlzLmdldENoaWxkUHJvcHNBbmRMaXN0ZW5lcnMoKSx7Y2xhc3M6dGhpcy5jbGFzc2VzKFwidWlcIixcImNhcmRcIil9XSksW3RoaXMuJHNsb3RzLmRlZmF1bHRdKX19LHppPXtuYW1lOlwiU3VpQ2FyZENvbnRlbnRcIixtaXhpbnM6W0xdLHByb3BzOntleHRyYTpCb29sZWFufSxyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHNbMF0sdD10aGlzLmdldEVsZW1lbnRUeXBlKCk7cmV0dXJuIGUodCxsKCkoW3t9LHRoaXMuZ2V0Q2hpbGRQcm9wc0FuZExpc3RlbmVycygpLHtjbGFzczp0aGlzLmNsYXNzZXModGhpcy5leHRyYSYmXCJleHRyYVwiLFwiY29udGVudFwiKX1dKSxbdGhpcy4kc2xvdHMuZGVmYXVsdCx0aGlzLiRzbG90cy5yaWdodCYmZShcImRpdlwiLHtjbGFzczpcInJpZ2h0IGZsb2F0ZWRcIn0sW3RoaXMuJHNsb3RzLnJpZ2h0XSldKX0sbWV0YTp7cGFyZW50OlwiU3VpQ2FyZFwifX0sUmk9e25hbWU6XCJTdWlDYXJkRGVzY3JpcHRpb25cIixtaXhpbnM6W0xdLHJlbmRlcjpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50c1swXSx0PXRoaXMuZ2V0RWxlbWVudFR5cGUoKTtyZXR1cm4gZSh0LGwoKShbe30sdGhpcy5nZXRDaGlsZFByb3BzQW5kTGlzdGVuZXJzKCkse2NsYXNzOnRoaXMuY2xhc3NlcyhcImRlc2NyaXB0aW9uXCIpfV0pLFt0aGlzLiRzbG90cy5kZWZhdWx0XSl9LG1ldGE6e3BhcmVudDpcIlN1aUNhcmRcIn19LE5pPXtuYW1lOlwiU3VpQ2FyZEdyb3VwXCIsbWl4aW5zOltMXSxwcm9wczp7aXRlbXNQZXJSb3c6Xy5OdW1iZXIoKSxzdGFja2FibGU6Qm9vbGVhbn0scmVuZGVyOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzWzBdLHQ9dGhpcy5nZXRFbGVtZW50VHlwZSgpO3JldHVybiBlKHQsbCgpKFt7fSx0aGlzLmdldENoaWxkUHJvcHNBbmRMaXN0ZW5lcnMoKSx7Y2xhc3M6dGhpcy5jbGFzc2VzKFwidWlcIix0aGlzLm51bSh0aGlzLml0ZW1zUGVyUm93KSx0aGlzLnN0YWNrYWJsZSYmXCJzdGFja2FibGVcIixcImNhcmRzXCIpfV0pLFt0aGlzLiRzbG90cy5kZWZhdWx0XSl9LG1ldGE6e3BhcmVudDpcIlN1aUNhcmRcIn19LEhpPXtuYW1lOlwiU3VpQ2FyZEhlYWRlclwiLG1peGluczpbTF0scmVuZGVyOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzWzBdLHQ9dGhpcy5nZXRFbGVtZW50VHlwZSgpO3JldHVybiBlKHQsbCgpKFt7fSx0aGlzLmdldENoaWxkUHJvcHNBbmRMaXN0ZW5lcnMoKSx7Y2xhc3M6dGhpcy5jbGFzc2VzKFwiaGVhZGVyXCIpfV0pLFt0aGlzLiRzbG90cy5kZWZhdWx0XSl9LG1ldGE6e3BhcmVudDpcIlN1aUNhcmRcIn19LFZpPXtuYW1lOlwiU3VpQ2FyZE1ldGFcIixtaXhpbnM6W0xdLHJlbmRlcjpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50c1swXSx0PXRoaXMuZ2V0RWxlbWVudFR5cGUoKTtyZXR1cm4gZSh0LGwoKShbe30sdGhpcy5nZXRDaGlsZFByb3BzQW5kTGlzdGVuZXJzKCkse2NsYXNzOnRoaXMuY2xhc3NlcyhcIm1ldGFcIil9XSksW3RoaXMuJHNsb3RzLmRlZmF1bHRdKX0sbWV0YTp7cGFyZW50OlwiU3VpQ2FyZFwifX0scWk9e25hbWU6XCJTdWlDb21tZW50XCIsbWl4aW5zOltMXSxyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHNbMF0sdD10aGlzLmdldEVsZW1lbnRUeXBlKCk7cmV0dXJuIGUodCxsKCkoW3t9LHRoaXMuZ2V0Q2hpbGRQcm9wc0FuZExpc3RlbmVycygpLHtjbGFzczp0aGlzLmNsYXNzZXMoXCJ1aVwiLFwiY29tbWVudFwiKX1dKSxbdGhpcy4kc2xvdHMuZGVmYXVsdF0pfX0sR2k9e25hbWU6XCJTdWlDb21tZW50QWN0aW9uXCIsbWl4aW5zOltMXSxyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHNbMF0sdD10aGlzLmdldEVsZW1lbnRUeXBlKFwiYVwiKTtyZXR1cm4gZSh0LGwoKShbe30sdGhpcy5nZXRDaGlsZFByb3BzQW5kTGlzdGVuZXJzKCldKSxbdGhpcy4kc2xvdHMuZGVmYXVsdF0pfSxtZXRhOntwYXJlbnQ6XCJTdWlDb21tZW50XCJ9fSxfaT17bmFtZTpcIlN1aUNvbW1lbnRBY3Rpb25zXCIsbWl4aW5zOltMXSxyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHNbMF0sdD10aGlzLmdldEVsZW1lbnRUeXBlKCk7cmV0dXJuIGUodCxsKCkoW3t9LHRoaXMuZ2V0Q2hpbGRQcm9wc0FuZExpc3RlbmVycygpLHtjbGFzczp0aGlzLmNsYXNzZXMoXCJhY3Rpb25zXCIpfV0pLFt0aGlzLiRzbG90cy5kZWZhdWx0XSl9LG1ldGE6e3BhcmVudDpcIlN1aUNvbW1lbnRcIn19LFVpPXtuYW1lOlwiU3VpQ29tbWVudEF1dGhvclwiLG1peGluczpbTF0scmVuZGVyOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzWzBdLHQ9dGhpcy5nZXRFbGVtZW50VHlwZSgpO3JldHVybiBlKHQsbCgpKFt7fSx0aGlzLmdldENoaWxkUHJvcHNBbmRMaXN0ZW5lcnMoKSx7Y2xhc3M6dGhpcy5jbGFzc2VzKFwiYXV0aG9yXCIpfV0pLFt0aGlzLiRzbG90cy5kZWZhdWx0XSl9LG1ldGE6e3BhcmVudDpcIlN1aUNvbW1lbnRcIn19LFdpPXtuYW1lOlwiU3VpQ29tbWVudEF2YXRhclwiLG1peGluczpbTF0scHJvcHM6e3NyYzpTdHJpbmd9LHJlbmRlcjpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50c1swXSx0PXRoaXMuZ2V0RWxlbWVudFR5cGUoKTtyZXR1cm4gZSh0LGwoKShbe30sdGhpcy5nZXRDaGlsZFByb3BzQW5kTGlzdGVuZXJzKCkse2NsYXNzOnRoaXMuY2xhc3NlcyhcImF2YXRhclwiKX1dKSxbZShcImltZ1wiLHthdHRyczp7c3JjOnRoaXMuc3JjfX0pXSl9LG1ldGE6e3BhcmVudDpcIlN1aUNvbW1lbnRcIn19LFlpPXtuYW1lOlwiU3VpQ29tbWVudENvbnRlbnRcIixtaXhpbnM6W0xdLHJlbmRlcjpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50c1swXSx0PXRoaXMuZ2V0RWxlbWVudFR5cGUoKTtyZXR1cm4gZSh0LGwoKShbe30sdGhpcy5nZXRDaGlsZFByb3BzQW5kTGlzdGVuZXJzKCkse2NsYXNzOnRoaXMuY2xhc3NlcyhcImNvbnRlbnRcIil9XSksW3RoaXMuJHNsb3RzLmRlZmF1bHRdKX0sbWV0YTp7cGFyZW50OlwiU3VpQ29tbWVudFwifX0sS2k9e25hbWU6XCJTdWlDb21tZW50R3JvdXBcIixtaXhpbnM6W0wsa10scHJvcHM6e3RocmVhZGVkOnt0eXBlOkJvb2xlYW4sZGVzY3JpcHRpb246XCJBIGNvbW1lbnQgbGlzdCBjYW4gYmUgdGhyZWFkZWQgdG8gc2hvd2luZyB0aGUgcmVsYXRpb25zaGlwIGJldHdlZW4gY29udmVyc2F0aW9uc1wiLGRlZmF1bHQ6ITF9LG1pbmltYWw6e3R5cGU6Qm9vbGVhbixkZXNjcmlwdGlvbjpcIkNvbW1lbnRzIGNhbiBoaWRlIGV4dHJhIGluZm9ybWF0aW9uIHVubGVzcyBhIHVzZXIgc2hvd3MgaW50ZW50IHRvIGludGVyYWN0IHdpdGggYSBjb21tZW50XCIsZGVmYXVsdDohMX0sY29sbGFwc2VkOnt0eXBlOkJvb2xlYW4sZGVzY3JpcHRpb246XCJDb21tZW50cyBjYW4gYmUgY29sbGFwc2VkLCBvciBoaWRkZW4gZnJvbSB2aWV3XCIsZGVmYXVsdDohMX0sc2l6ZTpfLlNpemUoKX0scmVuZGVyOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzWzBdLHQ9dGhpcy5nZXRFbGVtZW50VHlwZSgpLGk9W1wiY29tbWVudHNcIix0aGlzLnRocmVhZGVkJiZcInRocmVhZGVkXCIsdGhpcy5taW5pbWFsJiZcIm1pbmltYWxcIix0aGlzLmNvbGxhcHNlZCYmXCJjb2xsYXBzZWRcIix0aGlzLnNpemVdLG49dGhpcy5nZXRQYXJlbnROYW1lKCk7cmV0dXJuXCJTdWlDb21tZW50XCIhPT1uJiZpLnB1c2goXCJ1aVwiKSxlKHQsbCgpKFt7fSx0aGlzLmdldENoaWxkUHJvcHNBbmRMaXN0ZW5lcnMoKSx7Y2xhc3M6dGhpcy5jbGFzc2VzLmFwcGx5KHRoaXMsaSl9XSksW3RoaXMuJHNsb3RzLmRlZmF1bHRdKX0sbWV0YTp7cGFyZW50OlwiU3VpQ29tbWVudFwifX0sWGk9e25hbWU6XCJTdWlDb21tZW50TWV0YWRhdGFcIixtaXhpbnM6W0xdLHJlbmRlcjpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50c1swXSx0PXRoaXMuZ2V0RWxlbWVudFR5cGUoKTtyZXR1cm4gZSh0LGwoKShbe30sdGhpcy5nZXRDaGlsZFByb3BzQW5kTGlzdGVuZXJzKCkse2NsYXNzOnRoaXMuY2xhc3NlcyhcIm1ldGFkYXRhXCIpfV0pLFt0aGlzLiRzbG90cy5kZWZhdWx0XSl9LG1ldGE6e3BhcmVudDpcIlN1aUNvbW1lbnRcIn19LEppPXtuYW1lOlwiU3VpQ29tbWVudFRleHRcIixtaXhpbnM6W0xdLHJlbmRlcjpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50c1swXSx0PXRoaXMuZ2V0RWxlbWVudFR5cGUoKTtyZXR1cm4gZSh0LGwoKShbe30sdGhpcy5nZXRDaGlsZFByb3BzQW5kTGlzdGVuZXJzKCkse2NsYXNzOnRoaXMuY2xhc3NlcyhcInRleHRcIil9XSksW3RoaXMuJHNsb3RzLmRlZmF1bHRdKX0sbWV0YTp7cGFyZW50OlwiU3VpQ29tbWVudFwifX0sWmk9e25hbWU6XCJTdWlGZWVkRXZlbnRcIixtaXhpbnM6W0xdLGRlc2NyaXB0aW9uOlwiQSBmZWVkIGNvbnRhaW5zIGFuIGV2ZW50XCIscHJvcHM6e2NvbnRlbnQ6e3R5cGU6U3RyaW5nLGRlc2NyaXB0aW9uOlwiU2hvcnRoYW5kIGZvciBTdWlGZWVkQ29udGVudFwifSxpbWFnZTp7dHlwZTpTdHJpbmcsZGVzY3JpcHRpb246XCJBbiBldmVudCBjYW4gY29udGFpbiBpbWFnZSBsYWJlbFwifSxpY29uOnt0eXBlOlN0cmluZyxkZXNjcmlwdGlvbjpcIkFuIGV2ZW50IGNhbiBjb250YWluIGljb24gbGFiZWxcIn0sZGF0ZTp7dHlwZTpTdHJpbmcsZGVzY3JpcHRpb246XCJTaG9ydGhhbmQgZm9yIFN1aUZlZWREYXRlXCJ9LHN1bW1hcnk6e3R5cGU6U3RyaW5nLGRlc2NyaXB0aW9uOlwiU2hvcnRoYW5kIGZvciBTdWlGZWVkU3VtbWFyeVwifSxleHRyYUltYWdlczp7dHlwZTpBcnJheSxkZXNjcmlwdGlvbjpcIlNob3J0aGFuZCBmb3IgU3VpRmVlZEV4dHJhIHdpdGggaW1hZ2VzXCJ9LGV4dHJhVGV4dDp7dHlwZTpTdHJpbmcsZGVzY3JpcHRpb246XCJTaG9ydGhhbmQgZm9yIFN1aUZlZWRFeHRyYSB3aXRoIHRleHRcIn0sbWV0YTp7dHlwZTpTdHJpbmcsZGVzY3JpcHRpb246XCJTaG9ydGhhbmQgZm9yIFN1aUZlZWRNZXRhXCJ9fSxyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHNbMF0sdD10aGlzLmdldEVsZW1lbnRUeXBlKCksaT10aGlzLmNvbnRlbnR8fHRoaXMuZGF0ZXx8dGhpcy5zdW1tYXJ5fHx0aGlzLmV4dHJhSW1hZ2VzfHx0aGlzLmV4dHJhVGV4dHx8dGhpcy5tZXRhO3JldHVybiBlKHQsbCgpKFt7fSx0aGlzLmdldENoaWxkUHJvcHNBbmRMaXN0ZW5lcnMoKSx7Y2xhc3M6dGhpcy5jbGFzc2VzKFwiZXZlbnRcIil9XSksW3RoaXMuaW1hZ2UmJmUoYW4se2F0dHJzOntpbWFnZTp0aGlzLmltYWdlfX0pLHRoaXMuaWNvbiYmZShhbix7YXR0cnM6e2ljb246dGhpcy5pY29ufX0pLGkmJmUocm4se2F0dHJzOntjb250ZW50OnRoaXMuY29udGVudCxkYXRlOnRoaXMuZGF0ZSxzdW1tYXJ5OnRoaXMuc3VtbWFyeSxleHRyYUltYWdlczp0aGlzLmV4dHJhSW1hZ2VzLGV4dHJhVGV4dDp0aGlzLmV4dHJhVGV4dCxtZXRhOnRoaXMubWV0YX19KSx0aGlzLiRzbG90cy5kZWZhdWx0XSl9LG1ldGE6e3BhcmVudDpcIlN1aUZlZWRcIn19O2Z1bmN0aW9uIFFpKGUsdCl7dmFyIGk9T2JqZWN0LmtleXMoZSk7aWYoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyl7dmFyIG49T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTt0JiYobj1uLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSx0KS5lbnVtZXJhYmxlfSkpKSxpLnB1c2guYXBwbHkoaSxuKX1yZXR1cm4gaX1mdW5jdGlvbiBlbihlKXtmb3IodmFyIHQ9MTt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKXt2YXIgaT1udWxsIT1hcmd1bWVudHNbdF0/YXJndW1lbnRzW3RdOnt9O3QlMj9RaShPYmplY3QoaSksITApLmZvckVhY2goKGZ1bmN0aW9uKHQpe3RuKGUsdCxpW3RdKX0pKTpPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycz9PYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKGkpKTpRaShPYmplY3QoaSkpLmZvckVhY2goKGZ1bmN0aW9uKHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihpLHQpKX0pKX1yZXR1cm4gZX1mdW5jdGlvbiB0bihlLHQsaSl7cmV0dXJuIHQgaW4gZT9PYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHt2YWx1ZTppLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6ZVt0XT1pLGV9dmFyIG5uPXtuYW1lOlwiU3VpRmVlZFwiLG1peGluczpbTF0sZGVzY3JpcHRpb246XCJBIGZlZWQgcHJlc2VudHMgdXNlciBhY3Rpdml0eSBjaHJvbm9sb2dpY2FsbHlcIixwcm9wczp7c2l6ZTpfKFtcInNtYWxsXCIsXCJsYXJnZVwiXSx7ZGVzY3JpcHRpb246XCJBIGZlZWQgY2FuIGhhdmUgZGlmZmVyZW50IHNpemVzIChzbWFsbCB8IGxhcmdlKVwifSksZXZlbnRzOnt0eXBlOkFycmF5LGRlc2NyaXB0aW9uOlwiU2hvcnRoYW5kIGFycmF5IG9mIHByb3BzIGZvciBGZWVkRXZlbnRcIn19LHJlbmRlcjpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50c1swXSx0PXRoaXMuZ2V0RWxlbWVudFR5cGUoKTtyZXR1cm4gZSh0LGwoKShbe30sdGhpcy5nZXRDaGlsZFByb3BzQW5kTGlzdGVuZXJzKCkse2NsYXNzOnRoaXMuY2xhc3NlcyhcInVpXCIsdGhpcy5zaXplLFwiZmVlZFwiKX1dKSxbdGhpcy4kc2xvdHMuZGVmYXVsdHx8dGhpcy5ldmVudHMmJnRoaXMuZXZlbnRzLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIGUoWmkse3Byb3BzOmVuKHt9LHQpfSl9KSldKX19LHJuPXtuYW1lOlwiU3VpRmVlZENvbnRlbnRcIixtaXhpbnM6W0xdLHByb3BzOntjb250ZW50Ont0eXBlOlN0cmluZyxkZXNjcmlwdGlvbjpcIlNob3J0aGFuZCBmb3IgcHJpbWFyeSBjb250ZW50XCJ9LGRhdGU6e3R5cGU6U3RyaW5nLGRlc2NyaXB0aW9uOlwiU2hvcnRoYW5kIGZvciBTdWlGZWVkRGF0ZVwifSxzdW1tYXJ5Ont0eXBlOlN0cmluZyxkZXNjcmlwdGlvbjpcIlNob3J0aGFuZCBmb3IgU3VpRmVlZFN1bW1hcnlcIn0sZXh0cmFJbWFnZXM6e3R5cGU6QXJyYXksZGVzY3JpcHRpb246XCJTaG9ydGhhbmQgZm9yIFN1aUZlZWRFeHRyYSB3aXRoIGltYWdlc1wifSxleHRyYVRleHQ6e3R5cGU6U3RyaW5nLGRlc2NyaXB0aW9uOlwiU2hvcnRoYW5kIGZvciBTdWlGZWVkRXh0cmEgd2l0aCB0ZXh0XCJ9LG1ldGE6e3R5cGU6U3RyaW5nLGRlc2NyaXB0aW9uOlwiU2hvcnRoYW5kIGZvciBTdWlGZWVkTWV0YVwifX0scmVuZGVyOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzWzBdLHQ9dGhpcy5nZXRFbGVtZW50VHlwZSgpO3JldHVybiBlKHQsbCgpKFt7fSx0aGlzLmdldENoaWxkUHJvcHNBbmRMaXN0ZW5lcnMoKSx7Y2xhc3M6dGhpcy5jbGFzc2VzKFwiY29udGVudFwiKX1dKSxbdGhpcy4kc2xvdHMuZGVmYXVsdHx8W3RoaXMuZGF0ZSYmZShzbix7YXR0cnM6e2NvbnRlbnQ6dGhpcy5kYXRlfX0pLHRoaXMuY29udGVudCx0aGlzLnN1bW1hcnkmJmUoZG4se2F0dHJzOntjb250ZW50OnRoaXMuc3VtbWFyeX19KSx0aGlzLmV4dHJhVGV4dCYmZShvbix7YXR0cnM6e3RleHQ6ITAsY29udGVudDp0aGlzLmV4dHJhVGV4dH19KSx0aGlzLmV4dHJhSW1hZ2VzJiZlKG9uLHthdHRyczp7aW1hZ2VzOnRoaXMuZXh0cmFJbWFnZXN9fSksdGhpcy5tZXRhJiZlKGxuLHthdHRyczp7Y29udGVudDp0aGlzLm1ldGF9fSldXSl9LG1ldGE6e3BhcmVudDpcIlN1aUZlZWRcIn19LHNuPXtuYW1lOlwiU3VpRmVlZERhdGVcIixtaXhpbnM6W0xdLGRlc2NyaXB0aW9uOlwiQW4gZXZlbnQgb3IgYW4gZXZlbnQgc3VtbWFyeSBjYW4gY29udGFpbiBhIGRhdGVcIixwcm9wczp7Y29udGVudDp7dHlwZTpTdHJpbmcsZGVzY3JpcHRpb246XCJTaG9ydGhhbmQgZm9yIHByaW1hcnkgY29udGVudFwifX0scmVuZGVyOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzWzBdLHQ9dGhpcy5nZXRFbGVtZW50VHlwZSgpO3JldHVybiBlKHQsbCgpKFt7fSx0aGlzLmdldENoaWxkUHJvcHNBbmRMaXN0ZW5lcnMoKSx7Y2xhc3M6dGhpcy5jbGFzc2VzKFwiZGF0ZVwiKX1dKSxbdGhpcy4kc2xvdHMuZGVmYXVsdHx8dGhpcy5jb250ZW50XSl9LG1ldGE6e3BhcmVudDpcIlN1aUZlZWRcIn19LG9uPXtuYW1lOlwiU3VpRmVlZEV4dHJhXCIsbWl4aW5zOltMXSxkZXNjcmlwdGlvbjpcIkEgZmVlZCBjYW4gY29udGFpbiBhbiBleHRyYSBjb250ZW50XCIscHJvcHM6e2NvbnRlbnQ6e3R5cGU6U3RyaW5nLGRlc2NyaXB0aW9uOlwiU2hvcnRoYW5kIGZvciBwcmltYXJ5IGNvbnRlbnRcIn0saW1hZ2VzOnt0eXBlOltBcnJheSxCb29sZWFuXSxkZXNjcmlwdGlvbjpcIkFuIGV2ZW50IGNhbiBjb250YWluIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gbGlrZSBhIHNldCBvZiBpbWFnZXNcIn0sdGV4dDp7dHlwZTpCb29sZWFuLGRlc2NyaXB0aW9uOlwiQW4gZXZlbnQgY2FuIGNvbnRhaW4gYWRkaXRpb25hbCB0ZXh0IGluZm9ybWF0aW9uXCJ9fSxyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHNbMF0sdD10aGlzLmdldEVsZW1lbnRUeXBlKCksaT1BcnJheS5pc0FycmF5KHRoaXMuaW1hZ2VzKSYmdGhpcy5pbWFnZXMubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gZShEZSx7YXR0cnM6e3NyYzp0fX0pfSkpLG49W3RoaXMuY29udGVudCxpXTtyZXR1cm4gZSh0LGwoKShbe30sdGhpcy5nZXRDaGlsZFByb3BzQW5kTGlzdGVuZXJzKCkse2NsYXNzOnRoaXMuY2xhc3Nlcyh0aGlzLmltYWdlcyYmXCJpbWFnZXNcIiwodGhpcy50ZXh0fHx0aGlzLmNvbnRlbnQpJiZcInRleHRcIixcImV4dHJhXCIpfV0pLFt0aGlzLiRzbG90cy5kZWZhdWx0fHxuXSl9LG1ldGE6e3BhcmVudDpcIlN1aUZlZWRcIn19LGFuPXtuYW1lOlwiU3VpRmVlZExhYmVsXCIsbWl4aW5zOltMXSxkZXNjcmlwdGlvbjpcIkFuIGV2ZW50IGNhbiBjb250YWluIGFuIGltYWdlIG9yIGljb24gbGFiZWxcIixwcm9wczp7Y29udGVudDp7dHlwZTpTdHJpbmcsZGVzY3JpcHRpb246XCJTaG9ydGhhbmQgZm9yIHByaW1hcnkgY29udGVudFwifSxpbWFnZTp7dHlwZTpTdHJpbmcsZGVzY3JpcHRpb246XCJBbiBldmVudCBjYW4gY29udGFpbiBpbWFnZSBsYWJlbFwifSxpY29uOnt0eXBlOlN0cmluZyxkZXNjcmlwdGlvbjpcIkFuIGV2ZW50IGNhbiBjb250YWluIGljb24gbGFiZWxcIn19LHJlbmRlcjpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50c1swXSx0PXRoaXMuZ2V0RWxlbWVudFR5cGUoKTtyZXR1cm4gZSh0LGwoKShbe30sdGhpcy5nZXRDaGlsZFByb3BzQW5kTGlzdGVuZXJzKCkse2NsYXNzOnRoaXMuY2xhc3NlcyhcImxhYmVsXCIpfV0pLFt0aGlzLiRzbG90cy5kZWZhdWx0fHxbdGhpcy5jb250ZW50LHRoaXMuaWNvbiYmZShRLHthdHRyczp7bmFtZTp0aGlzLmljb259fSksdGhpcy5pbWFnZSYmZShEZSx7YXR0cnM6e3NyYzp0aGlzLmltYWdlfX0pXV0pfSxtZXRhOntwYXJlbnQ6XCJTdWlGZWVkXCJ9fSxjbj17bmFtZTpcIlN1aUZlZWRMaWtlXCIsbWl4aW5zOltMXSxkZXNjcmlwdGlvbjpcIkEgZmVlZCBjYW4gY29udGFpbiBhIGxpa2UgZWxlbWVudFwiLHByb3BzOntjb250ZW50Ont0eXBlOlN0cmluZyxkZXNjcmlwdGlvbjpcIlNob3J0aGFuZCBmb3IgcHJpbWFyeSBjb250ZW50XCJ9LGljb246e3R5cGU6U3RyaW5nLGRlc2NyaXB0aW9uOlwiU2hvcnRoYW5kIGZvciBpY29uLiBNdXR1YWxseSBleGNsdXNpdmUgd2l0aCBjaGlsZHJlblwifX0scmVuZGVyOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzWzBdLHQ9dGhpcy5nZXRFbGVtZW50VHlwZShcImFcIik7cmV0dXJuIGUodCxsKCkoW3t9LHRoaXMuZ2V0Q2hpbGRQcm9wc0FuZExpc3RlbmVycygpLHtjbGFzczp0aGlzLmNsYXNzZXMoXCJsaWtlXCIpfV0pLFt0aGlzLiRzbG90cy5kZWZhdWx0fHxbdGhpcy5pY29uJiZlKFEse2F0dHJzOntuYW1lOnRoaXMuaWNvbn19KSx0aGlzLmNvbnRlbnRdXSl9LG1ldGE6e3BhcmVudDpcIlN1aUZlZWRcIn19LGxuPXtuYW1lOlwiU3VpRmVlZE1ldGFcIixtaXhpbnM6W0xdLGRlc2NyaXB0aW9uOlwiQSBmZWVkIGNhbiBjb250YWluIGEgbWV0YVwiLHByb3BzOntjb250ZW50Ont0eXBlOlN0cmluZyxkZXNjcmlwdGlvbjpcIlNob3J0aGFuZCBmb3IgcHJpbWFyeSBjb250ZW50XCJ9LGxpa2U6e3R5cGU6U3RyaW5nLGRlc2NyaXB0aW9uOlwiU2hvcnRoYW5kIGZvciBTdWlGZWVkTGlrZVwifX0scmVuZGVyOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzWzBdLHQ9dGhpcy5nZXRFbGVtZW50VHlwZSgpO3JldHVybiBlKHQsbCgpKFt7fSx0aGlzLmdldENoaWxkUHJvcHNBbmRMaXN0ZW5lcnMoKSx7Y2xhc3M6dGhpcy5jbGFzc2VzKFwibWV0YVwiKX1dKSxbdGhpcy4kc2xvdHMuZGVmYXVsdHx8W3RoaXMubGlrZSYmZShjbix7YXR0cnM6e2NvbnRlbnQ6dGhpcy5saWtlfX0pLHRoaXMuY29udGVudF1dKX0sbWV0YTp7cGFyZW50OlwiU3VpRmVlZFwifX0sZG49e25hbWU6XCJTdWlGZWVkU3VtbWFyeVwiLG1peGluczpbTF0sZGVzY3JpcHRpb246XCJBIGZlZWQgY2FuIGNvbnRhaW4gYSBzdW1tYXJ5XCIscHJvcHM6e2NvbnRlbnQ6e3R5cGU6U3RyaW5nLGRlc2NyaXB0aW9uOlwiU2hvcnRoYW5kIGZvciBwcmltYXJ5IGNvbnRlbnRcIn0sZGF0ZTp7dHlwZTpTdHJpbmcsZGVzY3JpcHRpb246XCJTaG9ydGhhbmQgZm9yIFN1aUZlZWREYXRlXCJ9LHVzZXI6e3R5cGU6U3RyaW5nLGRlc2NyaXB0aW9uOlwiU2hvcnRoYW5kIGZvciBTdWlGZWVkVXNlclwifX0scmVuZGVyOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzWzBdLHQ9dGhpcy5nZXRFbGVtZW50VHlwZSgpO3JldHVybiBlKHQsbCgpKFt7fSx0aGlzLmdldENoaWxkUHJvcHNBbmRMaXN0ZW5lcnMoKSx7Y2xhc3M6dGhpcy5jbGFzc2VzKFwic3VtbWFyeVwiKX1dKSxbdGhpcy4kc2xvdHMuZGVmYXVsdHx8W3RoaXMudXNlciYmZSh1bix7YXR0cnM6e2NvbnRlbnQ6dGhpcy51c2VyfX0pLHRoaXMuY29udGVudCx0aGlzLmRhdGUmJmUoc24se2F0dHJzOntjb250ZW50OnRoaXMuZGF0ZX19KV1dKX0sbWV0YTp7cGFyZW50OlwiU3VpRmVlZFwifX0sdW49e25hbWU6XCJTdWlGZWVkVXNlclwiLG1peGluczpbTF0sZGVzY3JpcHRpb246XCJBIGZlZWQgY2FuIGNvbnRhaW4gYSB1c2VyIGVsZW1lbnRcIixwcm9wczp7Y29udGVudDp7dHlwZTpTdHJpbmcsZGVzY3JpcHRpb246XCJTaG9ydGhhbmQgZm9yIHByaW1hcnkgY29udGVudFwifX0scmVuZGVyOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzWzBdLHQ9dGhpcy5nZXRFbGVtZW50VHlwZShcImFcIik7cmV0dXJuIGUodCxsKCkoW3t9LHRoaXMuZ2V0Q2hpbGRQcm9wc0FuZExpc3RlbmVycygpLHtjbGFzczp0aGlzLmNsYXNzZXMoXCJ1c2VyXCIpfV0pLFt0aGlzLiRzbG90cy5kZWZhdWx0fHx0aGlzLmNvbnRlbnRdKX0sbWV0YTp7cGFyZW50OlwiU3VpRmVlZFwifX0saG49e25hbWU6XCJTdWlJdGVtXCIsbWl4aW5zOltMXSxkZXNjcmlwdGlvbjpcIkFuIGl0ZW0gdmlldyBwcmVzZW50cyBsYXJnZSBjb2xsZWN0aW9ucyBvZiBzaXRlIGNvbnRlbnQgZm9yIGRpc3BsYXlcIixwcm9wczp7aHJlZjp7dHlwZTpTdHJpbmcsZGVzY3JpcHRpb246J1NwZWNpZmllcyBhIGxpbmtlZCBkb2N1bWVudCwgcmVzb3VyY2UsIG9yIGxvY2F0aW9uLiBPbmx5IHVzZWZ1bCBpZiB0aGUgSXRlbUdyb3VwIGNvbnRhaW5zIHRoZSBcImxpbmtcIiBjbGFzcy4nfX0scmVuZGVyOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzWzBdLHQ9dGhpcy5ocmVmP1wiYVwiOnRoaXMuZ2V0RWxlbWVudFR5cGUoKTtyZXR1cm4gZSh0LHthdHRyczp7aHJlZjp0aGlzLmhyZWZ9LGNsYXNzOnRoaXMuY2xhc3NlcyhcIml0ZW1cIil9LFt0aGlzLiRzbG90cy5kZWZhdWx0XSl9fSxwbj17bmFtZTpcIlN1aUl0ZW1Hcm91cFwiLG1peGluczpbTF0sZGVzY3JpcHRpb246XCJBIGdyb3VwIG9mIGl0ZW1zXCIscHJvcHM6e3Vuc3RhY2thYmxlOnt0eXBlOkJvb2xlYW4sZGVzY3JpcHRpb246XCJBIHRhYmxlIGNhbiBzcGVjaWZ5IGhvdyBpdCBzdGFja3MgaXRlbXMgcmVzcG9uc2l2ZWx5XCJ9LGRpdmlkZWQ6e3R5cGU6Qm9vbGVhbixkZXNjcmlwdGlvbjpcIkl0ZW1zIGNhbiBiZSBkaXZpZGVkIHRvIGJldHRlciBkaXN0aW5ndWlzaCBiZXR3ZWVuIGdyb3VwZWQgY29udGVudFwifSxyZWxheGVkOl8oW1widmVyeVwiXSx7dHlwZTpCb29sZWFuLGRlc2NyaXB0aW9uOlwiQSBncm91cCBvZiBpdGVtcyBjYW4gcmVsYXggaXRzIHBhZGRpbmcgdG8gcHJvdmlkZSBtb3JlIG5lZ2F0aXZlIHNwYWNlXCJ9KSxsaW5rOnt0eXBlOkJvb2xlYW4sZGVzY3JpcHRpb246XCJBbiBpdGVtIGNhbiBiZSBmb3JtYXR0ZWQgc28gdGhhdCB0aGUgZW50aXJlIGNvbnRlbnRzIGxpbmsgdG8gYW5vdGhlciBwYWdlXCJ9fSxyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHNbMF0sdD10aGlzLmdldEVsZW1lbnRUeXBlKCk7cmV0dXJuIGUodCx7Y2xhc3M6dGhpcy5jbGFzc2VzKFwidWlcIix0aGlzLnVuc3RhY2thYmxlJiZcInVuc3RhY2thYmxlXCIsdGhpcy5kaXZpZGVkJiZcImRpdmlkZWRcIix0aGlzLnJlbGF4ZWQsdGhpcy5yZWxheGVkJiZcInJlbGF4ZWRcIix0aGlzLmxpbmsmJlwibGlua1wiLFwiaXRlbXNcIil9LFt0aGlzLiRzbG90cy5kZWZhdWx0XSl9LG1ldGE6e3BhcmVudDpcIlN1aUl0ZW1cIn19LGZuPXtuYW1lOlwiU3VpSXRlbUNvbnRlbnRcIixtaXhpbnM6W0xdLGRlc2NyaXB0aW9uOlwiQW4gaXRlbSBjYW4gY29udGFpbiBjb250ZW50XCIscHJvcHM6e3ZlcnRpY2FsQWxpZ246Xy5WZXJ0aWNhbEFsaWduKHtkZXNjcmlwdGlvbjpcIkNvbnRlbnQgY2FuIHNwZWNpZnkgaXRzIHZlcnRpY2FsIGFsaWdubWVudFwifSl9LHJlbmRlcjpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50c1swXSx0PXRoaXMuZ2V0RWxlbWVudFR5cGUoKTtyZXR1cm4gZSh0LHtjbGFzczp0aGlzLmNsYXNzZXModGhpcy52ZXJ0aWNhbEFsaWduJiZcIlwiLmNvbmNhdCh0aGlzLnZlcnRpY2FsQWxpZ24sXCIgYWxpZ25lZFwiKSxcImNvbnRlbnRcIil9LFt0aGlzLiRzbG90cy5kZWZhdWx0XSl9LG1ldGE6e3BhcmVudDpcIlN1aUl0ZW1cIn19LG1uPXtuYW1lOlwiU3VpSXRlbUltYWdlXCIsbWl4aW5zOltMXSxkZXNjcmlwdGlvbjpcIkFuIGl0ZW0gY2FuIGNvbnRhaW4gYW4gaW1hZ2VcIixwcm9wczp7c3JjOnt0eXBlOlN0cmluZyxyZXF1aXJlZDohMCxkZXNjcmlwdGlvbjpcIlNwZWNpZmllcyB0aGUgVVJMIG9mIHRoZSBpbWFnZVwifSxzaXplOl8oW1wibWluaVwiLFwidGlueVwiLFwic21hbGxcIixcIm1lZGl1bVwiLFwibGFyZ2VcIixcImJpZ1wiLFwiaHVnZVwiLFwibWFzc2l2ZVwiXSx7dHlwZTpTdHJpbmcsZGVzY3JpcHRpb246XCJBbiBpbWFnZSBtYXkgYXBwZWFyIGF0IGRpZmZlcmVudCBzaXplcyAobWluaSwgdGlueSwgc21hbGwsIG1lZGl1bSwgbGFyZ2UsIGJpZywgaHVnZSwgbWFzc2l2ZSlcIn0pLGhyZWY6e3R5cGU6U3RyaW5nLGRlc2NyaXB0aW9uOlwiU3BlY2lmaWVzIGEgbGlua2VkIGRvY3VtZW50LCByZXNvdXJjZSwgb3IgbG9jYXRpb25cIn19LHJlbmRlcjpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50c1swXSx0PXRoaXMuaHJlZj9cImFcIjp0aGlzLmdldEVsZW1lbnRUeXBlKCk7cmV0dXJuIGUodCx7YXR0cnM6e2hyZWY6dGhpcy5ocmVmfSxjbGFzczp0aGlzLmNsYXNzZXModGhpcy5zaXplJiZcInVpIFwiLmNvbmNhdCh0aGlzLnNpemUpLFwiaW1hZ2VcIil9LFtlKFwiaW1nXCIse2F0dHJzOntzcmM6dGhpcy5zcmN9fSldKX0sbWV0YTp7cGFyZW50OlwiU3VpSXRlbVwifX0sZ249e25hbWU6XCJTdWlJdGVtSGVhZGVyXCIsbWl4aW5zOltMXSxkZXNjcmlwdGlvbjpcIkFuIGl0ZW0gY2FuIGNvbnRhaW4gYSBoZWFkZXJcIixwcm9wczp7aHJlZjp7dHlwZTpTdHJpbmcsZGVzY3JpcHRpb246XCJTcGVjaWZpZXMgYSBsaW5rZWQgZG9jdW1lbnQsIHJlc291cmNlLCBvciBsb2NhdGlvblwifX0scmVuZGVyOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzWzBdLHQ9dGhpcy5ocmVmP1wiYVwiOnRoaXMuZ2V0RWxlbWVudFR5cGUoKTtyZXR1cm4gZSh0LHthdHRyczp7aHJlZjp0aGlzLmhyZWZ9LGNsYXNzOnRoaXMuY2xhc3NlcyhcImhlYWRlclwiKX0sW3RoaXMuJHNsb3RzLmRlZmF1bHRdKX0sbWV0YTp7cGFyZW50OlwiU3VpSXRlbVwifX0sYm49e25hbWU6XCJTdWlJdGVtTWV0YVwiLG1peGluczpbTF0sZGVzY3JpcHRpb246XCJBbiBpdGVtIGNhbiBjb250YWluIGNvbnRlbnQgbWV0YWRhdGFcIixwcm9wczp7fSxyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHNbMF0sdD10aGlzLmdldEVsZW1lbnRUeXBlKCk7cmV0dXJuIGUodCx7Y2xhc3M6dGhpcy5jbGFzc2VzKFwibWV0YVwiKX0sW3RoaXMuJHNsb3RzLmRlZmF1bHRdKX0sbWV0YTp7cGFyZW50OlwiU3VpSXRlbVwifX0seW49e25hbWU6XCJTdWlJdGVtRGVzY3JpcHRpb25cIixtaXhpbnM6W0xdLGRlc2NyaXB0aW9uOlwiQW4gaXRlbSBjYW4gY29udGFpbiBhIGRlc2NyaXB0aW9uIHdpdGggYSBzaW5nbGUgb3IgbXVsdGlwbGUgcGFyYWdyYXBoc1wiLHJlbmRlcjpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50c1swXSx0PXRoaXMuZ2V0RWxlbWVudFR5cGUoKTtyZXR1cm4gZSh0LHtjbGFzczp0aGlzLmNsYXNzZXMoXCJkZXNjcmlwdGlvblwiKX0sW3RoaXMuJHNsb3RzLmRlZmF1bHRdKX0sbWV0YTp7cGFyZW50OlwiU3VpSXRlbVwifX0sdm49e25hbWU6XCJTdWlJdGVtRXh0cmFcIixtaXhpbnM6W0xdLGRlc2NyaXB0aW9uOlwiQW4gaXRlbSBjYW4gY29udGFpbiBleHRyYSBjb250ZW50IG1lYW50IHRvIGJlIGZvcm1hdHRlZCBzZXBhcmF0ZWx5IGZyb20gdGhlIG1haW4gY29udGVudFwiLHByb3BzOnt9LHJlbmRlcjpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50c1swXSx0PXRoaXMuZ2V0RWxlbWVudFR5cGUoKTtyZXR1cm4gZSh0LHtjbGFzczp0aGlzLmNsYXNzZXMoXCJleHRyYVwiKX0sW3RoaXMuJHNsb3RzLmRlZmF1bHRdKX0sbWV0YTp7cGFyZW50OlwiU3VpSXRlbVwifX0sU249e25hbWU6XCJTdWlTdGF0aXN0aWNcIixtaXhpbnM6W2ssTF0scHJvcHM6e2hvcml6b250YWw6e3R5cGU6Qm9vbGVhbixkZXNjcmlwdGlvbjpcIlByZXNlbnQgbWVhc3VyZW1lbnQgaG9yaXpvbnRhbGx5XCJ9LGNvbG9yOl8uQ29sb3IoKSxzaXplOl8uU2l6ZSgpLGZsb2F0ZWQ6XyhbXCJsZWZ0XCIsXCJyaWdodFwiXSksaW52ZXJ0ZWQ6e3R5cGU6Qm9vbGVhbixkZXNjcmlwdGlvbjpcIlNob3VsZCB0aGUgY29sb3JzIGJlIGludmVydGVkXCJ9fSxyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHNbMF0sdD10aGlzLmdldEVsZW1lbnRUeXBlKCk7cmV0dXJuIGUodCxsKCkoW3t9LHRoaXMuZ2V0Q2hpbGRQcm9wc0FuZExpc3RlbmVycygpLHtjbGFzczp0aGlzLmNsYXNzZXModGhpcy5nZXRVSUNsYXNzKCksXCJzdGF0aXN0aWNcIix0aGlzLmNvbG9yLHRoaXMuc2l6ZSx0aGlzLmZsb2F0ZWQmJlwiXCIuY29uY2F0KHRoaXMuZmxvYXRlZCxcIiBmbG9hdGVkXCIpLHRoaXMuaW52ZXJ0ZWQmJlwiaW52ZXJ0ZWRcIix0aGlzLmhvcml6b250YWwmJlwiaG9yaXpvbnRhbFwiKX1dKSxbdGhpcy4kc2xvdHMuZGVmYXVsdF0pfX0sd249e25hbWU6XCJTdWlTdGF0aXN0aWNWYWx1ZVwiLG1peGluczpbTF0scHJvcHM6e3RleHQ6Qm9vbGVhbn0scmVuZGVyOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzWzBdLHQ9dGhpcy5nZXRFbGVtZW50VHlwZSgpO3JldHVybiBlKHQsbCgpKFt7fSx0aGlzLmdldENoaWxkUHJvcHNBbmRMaXN0ZW5lcnMoKSx7Y2xhc3M6dGhpcy5jbGFzc2VzKHRoaXMudGV4dCYmXCJ0ZXh0XCIsXCJ2YWx1ZVwiKX1dKSxbdGhpcy4kc2xvdHMuZGVmYXVsdF0pfSxtZXRhOntwYXJlbnQ6XCJTdWlTdGF0aXN0aWNcIn19LEFuPXtuYW1lOlwiU3VpU3RhdGlzdGljTGFiZWxcIixtaXhpbnM6W0xdLHJlbmRlcjpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50c1swXSx0PXRoaXMuZ2V0RWxlbWVudFR5cGUoKTtyZXR1cm4gZSh0LGwoKShbe30sdGhpcy5nZXRDaGlsZFByb3BzQW5kTGlzdGVuZXJzKCkse2NsYXNzOnRoaXMuY2xhc3NlcyhcImxhYmVsXCIpfV0pLFt0aGlzLiRzbG90cy5kZWZhdWx0XSl9LG1ldGE6e3BhcmVudDpcIlN1aVN0YXRpc3RpY1wifX0sT249e25hbWU6XCJTdWlTdGF0aXN0aWNzR3JvdXBcIixtaXhpbnM6W0xdLHByb3BzOntob3Jpem9udGFsOkJvb2xlYW4sY29sdW1uczpfLk51bWJlcigpfSxyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHNbMF0sdD10aGlzLmdldEVsZW1lbnRUeXBlKCk7cmV0dXJuIGUodCxsKCkoW3t9LHRoaXMuZ2V0Q2hpbGRQcm9wc0FuZExpc3RlbmVycygpLHtjbGFzczp0aGlzLmNsYXNzZXModGhpcy5udW0odGhpcy5jb2x1bW5zKSxcInVpXCIsXCJzdGF0aXN0aWNzXCIsdGhpcy5ob3Jpem9udGFsJiZcImhvcml6b250YWxcIil9XSksW3RoaXMuJHNsb3RzLmRlZmF1bHRdKX0sbWV0YTp7cGFyZW50OlwiU3VpU3RhdGlzdGljXCJ9fSx4bj17bmFtZTpcIlN1aUFkdmVydGlzZW1lbnRcIixkZXNjcmlwdGlvbjpcIkFuIGFkdmVydGlzZW1lbnQgdmlldyBwcmVzZW50cyB0aHJpZi1wYXJ0eSBwcm9tb3Rpb25hbCBjb250ZW50XCIsbWl4aW5zOltMXSxwcm9wczp7Y2VudGVyZWQ6e3R5cGU6Qm9vbGVhbixkZXNjcmlwdGlvbjpcIkNlbnRlciB0aGUgYWR2ZXJ0aXNlbWVudFwiLGRlZmF1bHQ6ITF9LHRlc3Q6e3R5cGU6W1N0cmluZyxOdW1iZXJdLGRlc2NyaXB0aW9uOlwiVGV4dCB0byBiZSBkaXNwbGF5ZWQgb24gdGhlIGFkdmVydGlzZW1lbnQuXCJ9LHVuaXQ6XyhbXCJtZWRpdW0gcmVjdGFuZ2xlXCIsXCJsYXJnZSByZWN0YW5nbGVcIixcInNtYWxsIHJlY3RhbmdsZVwiLFwidmVydGljYWwgcmVjdGFuZ2xlXCIsXCJsZWFkZXJib2FyZFwiLFwiaGFsZiBwYWdlXCIsXCJtb2JpbGUgbGVhZGVyYm9hcmRcIixcIm1vYmlsZSBiYW5uZXJcIixcImJ1dHRvblwiLFwic3F1YXJlIGJ1dHRvblwiLFwic21hbGwgYnV0dG9uXCIsXCJza3lzY3JhcGVyXCIsXCJ3aWRlIHNreXNjcmFwZXJcIixcImJhbm5lclwiLFwidmVydGljYWwgYmFubmVyXCIsXCJ0b3AgYmFubmVyXCIsXCJoYWxmIGJhbm5lclwiLFwibGVhZGVyYm9hcmRcIixcImxhcmdlIGxlYWRlcmJvYXJkXCIsXCJiaWxsYm9hcmRcIixcInBhbm9yYW1hXCIsXCJuZXRib2FyZFwiXSx7ZGVzY3JpcHRpb246XCJEZWZpbmUgdGhlIHNpemUgb2YgdGhlIGFkdmVydGlzZW1lbnRcIix0eXBlOlN0cmluZyxyZXF1aXJlZDohMH0pfSxyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHNbMF0sdD10aGlzLmdldEVsZW1lbnRUeXBlKCk7cmV0dXJuIGUodCxsKCkoW3t9LHRoaXMuZ2V0Q2hpbGRQcm9wc0FuZExpc3RlbmVycygpLHtjbGFzczp0aGlzLmNsYXNzZXMoXCJ1aVwiLHRoaXMuY2VudGVyZWQ/XCJjZW50ZXJlZFwiOm51bGwsdGhpcy51bml0LHRoaXMudGVzdD9cInRlc3RcIjpudWxsLFwiYWRcIiksYXR0cnM6e1wiZGF0YS10ZXh0XCI6dGhpcy50ZXN0fX1dKSxbdGhpcy4kc2xvdHMuZGVmYXVsdF0pfX07ZnVuY3Rpb24gUG4oZSx0KXt2YXIgaT1PYmplY3Qua2V5cyhlKTtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgbj1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO3QmJihuPW4uZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLHQpLmVudW1lcmFibGV9KSkpLGkucHVzaC5hcHBseShpLG4pfXJldHVybiBpfWZ1bmN0aW9uIEJuKGUsdCxpKXtyZXR1cm4gdCBpbiBlP09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQse3ZhbHVlOmksZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTplW3RdPWksZX1pLmQodCxcIkJyZWFkY3J1bWJcIiwoZnVuY3Rpb24oKXtyZXR1cm4gVX0pKSxpLmQodCxcIkJyZWFkY3J1bWJEaXZpZGVyXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIE59KSksaS5kKHQsXCJCcmVhZGNydW1iU2VjdGlvblwiLChmdW5jdGlvbigpe3JldHVybiBSfSkpLGkuZCh0LFwiRm9ybVwiLChmdW5jdGlvbigpe3JldHVybiBXfSkpLGkuZCh0LFwiRm9ybUZpZWxkXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIFl9KSksaS5kKHQsXCJGb3JtRmllbGRzXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIEt9KSksaS5kKHQsXCJHcmlkXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIFh9KSksaS5kKHQsXCJHcmlkQ29sdW1uXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIEp9KSksaS5kKHQsXCJHcmlkUm93XCIsKGZ1bmN0aW9uKCl7cmV0dXJuIFp9KSksaS5kKHQsXCJNZW51XCIsKGZ1bmN0aW9uKCl7cmV0dXJuIHJlfSkpLGkuZCh0LFwiTWVudUhlYWRlclwiLChmdW5jdGlvbigpe3JldHVybiBzZX0pKSxpLmQodCxcIk1lbnVJdGVtXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIGVlfSkpLGkuZCh0LFwiTWVudU1lbnVcIiwoZnVuY3Rpb24oKXtyZXR1cm4gb2V9KSksaS5kKHQsXCJNZXNzYWdlXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIHVlfSkpLGkuZCh0LFwiTWVzc2FnZUNvbnRlbnRcIiwoZnVuY3Rpb24oKXtyZXR1cm4gYWV9KSksaS5kKHQsXCJNZXNzYWdlSGVhZGVyXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIGNlfSkpLGkuZCh0LFwiTWVzc2FnZUl0ZW1cIiwoZnVuY3Rpb24oKXtyZXR1cm4gbGV9KSksaS5kKHQsXCJNZXNzYWdlTGlzdFwiLChmdW5jdGlvbigpe3JldHVybiBkZX0pKSxpLmQodCxcIlRhYmxlXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIGhlfSkpLGkuZCh0LFwiVGFibGVCb2R5XCIsKGZ1bmN0aW9uKCl7cmV0dXJuIHBlfSkpLGkuZCh0LFwiVGFibGVDZWxsXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIGZlfSkpLGkuZCh0LFwiVGFibGVGb290ZXJcIiwoZnVuY3Rpb24oKXtyZXR1cm4gbWV9KSksaS5kKHQsXCJUYWJsZUhlYWRlclwiLChmdW5jdGlvbigpe3JldHVybiBnZX0pKSxpLmQodCxcIlRhYmxlSGVhZGVyQ2VsbFwiLChmdW5jdGlvbigpe3JldHVybiBiZX0pKSxpLmQodCxcIlRhYmxlUm93XCIsKGZ1bmN0aW9uKCl7cmV0dXJuIHllfSkpLGkuZCh0LFwiZmxvYXRlZFwiLChmdW5jdGlvbigpe3JldHVybiB2ZX0pKSxpLmQodCxcIkJ1dHRvblwiLChmdW5jdGlvbigpe3JldHVybiBTZX0pKSxpLmQodCxcIkJ1dHRvbkNvbnRlbnRcIiwoZnVuY3Rpb24oKXtyZXR1cm4gd2V9KSksaS5kKHQsXCJCdXR0b25Hcm91cFwiLChmdW5jdGlvbigpe3JldHVybiBBZX0pKSxpLmQodCxcIkJ1dHRvbk9yXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIEJlfSkpLGkuZCh0LFwiQ29udGFpbmVyXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIENlfSkpLGkuZCh0LFwiRGl2aWRlclwiLChmdW5jdGlvbigpe3JldHVybiBqZX0pKSxpLmQodCxcIkZsYWdcIiwoZnVuY3Rpb24oKXtyZXR1cm4gRWV9KSksaS5kKHQsXCJIZWFkZXJcIiwoZnVuY3Rpb24oKXtyZXR1cm4gVGV9KSksaS5kKHQsXCJIZWFkZXJDb250ZW50XCIsKGZ1bmN0aW9uKCl7cmV0dXJuICRlfSkpLGkuZCh0LFwiSGVhZGVyU3ViaGVhZGVyXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIExlfSkpLGkuZCh0LFwiSWNvblwiLChmdW5jdGlvbigpe3JldHVybiBRfSkpLGkuZCh0LFwiSWNvbkdyb3VwXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIGtlfSkpLGkuZCh0LFwiSW1hZ2VcIiwoZnVuY3Rpb24oKXtyZXR1cm4gRGV9KSksaS5kKHQsXCJJbWFnZUdyb3VwXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIEllfSkpLGkuZCh0LFwiSW5wdXRcIiwoZnVuY3Rpb24oKXtyZXR1cm4gUmV9KSksaS5kKHQsXCJMYWJlbFwiLChmdW5jdGlvbigpe3JldHVybiBOZX0pKSxpLmQodCxcIkxhYmVsRGV0YWlsXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIEhlfSkpLGkuZCh0LFwiTGlzdFwiLChmdW5jdGlvbigpe3JldHVybiBXZX0pKSxpLmQodCxcIkxpc3RDb250ZW50XCIsKGZ1bmN0aW9uKCl7cmV0dXJuIF9lfSkpLGkuZCh0LFwiTGlzdERlc2NyaXB0aW9uXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIFllfSkpLGkuZCh0LFwiTGlzdEhlYWRlclwiLChmdW5jdGlvbigpe3JldHVybiBLZX0pKSxpLmQodCxcIkxpc3RJY29uXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIEdlfSkpLGkuZCh0LFwiTGlzdEl0ZW1cIiwoZnVuY3Rpb24oKXtyZXR1cm4gVWV9KSksaS5kKHQsXCJMaXN0TGlzdFwiLChmdW5jdGlvbigpe3JldHVybiBYZX0pKSxpLmQodCxcIkxvYWRlclwiLChmdW5jdGlvbigpe3JldHVybiBKZX0pKSxpLmQodCxcIlJhaWxcIiwoZnVuY3Rpb24oKXtyZXR1cm4gWmV9KSksaS5kKHQsXCJSZXZlYWxcIiwoZnVuY3Rpb24oKXtyZXR1cm4gUWV9KSksaS5kKHQsXCJSZXZlYWxDb250ZW50XCIsKGZ1bmN0aW9uKCl7cmV0dXJuIGV0fSkpLGkuZCh0LFwiU2VnbWVudFwiLChmdW5jdGlvbigpe3JldHVybiB0dH0pKSxpLmQodCxcIlNlZ21lbnRzXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIGl0fSkpLGkuZCh0LFwiU3RlcFwiLChmdW5jdGlvbigpe3JldHVybiBvdH0pKSxpLmQodCxcIlN0ZXBDb250ZW50XCIsKGZ1bmN0aW9uKCl7cmV0dXJuIHN0fSkpLGkuZCh0LFwiU3RlcERlc2NyaXB0aW9uXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIG50fSkpLGkuZCh0LFwiU3RlcEdyb3VwXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIGR0fSkpLGkuZCh0LFwiU3RlcFRpdGxlXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIHJ0fSkpLGkuZCh0LFwiQWNjb3JkaW9uXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIHB0fSkpLGkuZCh0LFwiQWNjb3JkaW9uQ29udGVudFwiLChmdW5jdGlvbigpe3JldHVybiBidH0pKSxpLmQodCxcIkFjY29yZGlvblRpdGxlXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIFN0fSkpLGkuZCh0LFwiQ2hlY2tib3hcIiwoZnVuY3Rpb24oKXtyZXR1cm4gd3R9KSksaS5kKHQsXCJEaW1tZXJcIiwoZnVuY3Rpb24oKXtyZXR1cm4gQXR9KSksaS5kKHQsXCJEaW1tZXJEaW1tYWJsZVwiLChmdW5jdGlvbigpe3JldHVybiBPdH0pKSxpLmQodCxcIkRyb3Bkb3duXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIFZ0fSkpLGkuZCh0LFwiRHJvcGRvd25EaXZpZGVyXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIHF0fSkpLGkuZCh0LFwiRHJvcGRvd25IZWFkZXJcIiwoZnVuY3Rpb24oKXtyZXR1cm4gR3R9KSksaS5kKHQsXCJEcm9wZG93bkl0ZW1cIiwoZnVuY3Rpb24oKXtyZXR1cm4gQ3R9KSksaS5kKHQsXCJEcm9wZG93bk1lbnVcIiwoZnVuY3Rpb24oKXtyZXR1cm4gTHR9KSksaS5kKHQsXCJFbWJlZFwiLChmdW5jdGlvbigpe3JldHVybiBfdH0pKSxpLmQodCxcIk1vZGFsXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIFF0fSkpLGkuZCh0LFwiTW9kYWxBY3Rpb25zXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIGVpfSkpLGkuZCh0LFwiTW9kYWxDb250ZW50XCIsKGZ1bmN0aW9uKCl7cmV0dXJuIHRpfSkpLGkuZCh0LFwiTW9kYWxEZXNjcmlwdGlvblwiLChmdW5jdGlvbigpe3JldHVybiBpaX0pKSxpLmQodCxcIk1vZGFsSGVhZGVyXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIG5pfSkpLGkuZCh0LFwiUmF0aW5nXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIGFpfSkpLGkuZCh0LFwiU2VhcmNoXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIGJpfSkpLGkuZCh0LFwiU2lkZWJhclwiLChmdW5jdGlvbigpe3JldHVybiB5aX0pKSxpLmQodCxcIlNpZGViYXJQdXNoYWJsZVwiLChmdW5jdGlvbigpe3JldHVybiB2aX0pKSxpLmQodCxcIlNpZGViYXJQdXNoZXJcIiwoZnVuY3Rpb24oKXtyZXR1cm4gU2l9KSksaS5kKHQsXCJQb3B1cFwiLChmdW5jdGlvbigpe3JldHVybiBFaX0pKSxpLmQodCxcIlBvcHVwQ29udGVudFwiLChmdW5jdGlvbigpe3JldHVybiBqaX0pKSxpLmQodCxcIlBvcHVwSGVhZGVyXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIENpfSkpLGkuZCh0LFwiUHJvZ3Jlc3NcIiwoZnVuY3Rpb24oKXtyZXR1cm4gVGl9KSksaS5kKHQsXCJUYWJQYW5lXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIE1pfSkpLGkuZCh0LFwiVGFiXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIElpfSkpLGkuZCh0LFwiQ2FyZFwiLChmdW5jdGlvbigpe3JldHVybiBGaX0pKSxpLmQodCxcIkNhcmRDb250ZW50XCIsKGZ1bmN0aW9uKCl7cmV0dXJuIHppfSkpLGkuZCh0LFwiQ2FyZERlc2NyaXB0aW9uXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIFJpfSkpLGkuZCh0LFwiQ2FyZEdyb3VwXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIE5pfSkpLGkuZCh0LFwiQ2FyZEhlYWRlclwiLChmdW5jdGlvbigpe3JldHVybiBIaX0pKSxpLmQodCxcIkNhcmRNZXRhXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIFZpfSkpLGkuZCh0LFwiQ29tbWVudFwiLChmdW5jdGlvbigpe3JldHVybiBxaX0pKSxpLmQodCxcIkNvbW1lbnRBY3Rpb25cIiwoZnVuY3Rpb24oKXtyZXR1cm4gR2l9KSksaS5kKHQsXCJDb21tZW50QWN0aW9uc1wiLChmdW5jdGlvbigpe3JldHVybiBfaX0pKSxpLmQodCxcIkNvbW1lbnRBdXRob3JcIiwoZnVuY3Rpb24oKXtyZXR1cm4gVWl9KSksaS5kKHQsXCJDb21tZW50QXZhdGFyXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIFdpfSkpLGkuZCh0LFwiQ29tbWVudENvbnRlbnRcIiwoZnVuY3Rpb24oKXtyZXR1cm4gWWl9KSksaS5kKHQsXCJDb21tZW50R3JvdXBcIiwoZnVuY3Rpb24oKXtyZXR1cm4gS2l9KSksaS5kKHQsXCJDb21tZW50TWV0YWRhdGFcIiwoZnVuY3Rpb24oKXtyZXR1cm4gWGl9KSksaS5kKHQsXCJDb21tZW50VGV4dFwiLChmdW5jdGlvbigpe3JldHVybiBKaX0pKSxpLmQodCxcIkZlZWRcIiwoZnVuY3Rpb24oKXtyZXR1cm4gbm59KSksaS5kKHQsXCJGZWVkQ29udGVudFwiLChmdW5jdGlvbigpe3JldHVybiBybn0pKSxpLmQodCxcIkZlZWREYXRlXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIHNufSkpLGkuZCh0LFwiRmVlZEV2ZW50XCIsKGZ1bmN0aW9uKCl7cmV0dXJuIFppfSkpLGkuZCh0LFwiRmVlZEV4dHJhXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIG9ufSkpLGkuZCh0LFwiRmVlZExhYmVsXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIGFufSkpLGkuZCh0LFwiRmVlZExpa2VcIiwoZnVuY3Rpb24oKXtyZXR1cm4gY259KSksaS5kKHQsXCJGZWVkTWV0YVwiLChmdW5jdGlvbigpe3JldHVybiBsbn0pKSxpLmQodCxcIkZlZWRTdW1tYXJ5XCIsKGZ1bmN0aW9uKCl7cmV0dXJuIGRufSkpLGkuZCh0LFwiRmVlZFVzZXJcIiwoZnVuY3Rpb24oKXtyZXR1cm4gdW59KSksaS5kKHQsXCJJdGVtXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIGhufSkpLGkuZCh0LFwiSXRlbUdyb3VwXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIHBufSkpLGkuZCh0LFwiSXRlbUNvbnRlbnRcIiwoZnVuY3Rpb24oKXtyZXR1cm4gZm59KSksaS5kKHQsXCJJdGVtSW1hZ2VcIiwoZnVuY3Rpb24oKXtyZXR1cm4gbW59KSksaS5kKHQsXCJJdGVtSGVhZGVyXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIGdufSkpLGkuZCh0LFwiSXRlbU1ldGFcIiwoZnVuY3Rpb24oKXtyZXR1cm4gYm59KSksaS5kKHQsXCJJdGVtRGVzY3JpcHRpb25cIiwoZnVuY3Rpb24oKXtyZXR1cm4geW59KSksaS5kKHQsXCJJdGVtRXh0cmFcIiwoZnVuY3Rpb24oKXtyZXR1cm4gdm59KSksaS5kKHQsXCJTdGF0aXN0aWNcIiwoZnVuY3Rpb24oKXtyZXR1cm4gU259KSksaS5kKHQsXCJTdGF0aXN0aWNWYWx1ZVwiLChmdW5jdGlvbigpe3JldHVybiB3bn0pKSxpLmQodCxcIlN0YXRpc3RpY0xhYmVsXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIEFufSkpLGkuZCh0LFwiU3RhdGlzdGljR3JvdXBcIiwoZnVuY3Rpb24oKXtyZXR1cm4gT259KSksaS5kKHQsXCJBZHZlcnRpc2VtZW50XCIsKGZ1bmN0aW9uKCl7cmV0dXJuIHhufSkpO3ZhciBDbj1mdW5jdGlvbihlKXtmb3IodmFyIHQ9MTt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKXt2YXIgaT1udWxsIT1hcmd1bWVudHNbdF0/YXJndW1lbnRzW3RdOnt9O3QlMj9QbihPYmplY3QoaSksITApLmZvckVhY2goKGZ1bmN0aW9uKHQpe0JuKGUsdCxpW3RdKX0pKTpPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycz9PYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKGkpKTpQbihPYmplY3QoaSkpLmZvckVhY2goKGZ1bmN0aW9uKHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihpLHQpKX0pKX1yZXR1cm4gZX0oe30sbix7fSxzLHt9LG8se30sYSk7dC5kZWZhdWx0PWZ1bmN0aW9uKGUpe09iamVjdC52YWx1ZXMoQ24pLmZvckVhY2goKGZ1bmN0aW9uKHQpe3JldHVybiBlLmNvbXBvbmVudCh0Lm5hbWUsdCl9KSksT2JqZWN0LnZhbHVlcyhyKS5mb3JFYWNoKChmdW5jdGlvbih0KXtyZXR1cm4gZS5kaXJlY3RpdmUodC5uYW1lLHQpfSkpfX1dKTsiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIHJ1bnRpbWUgaGVscGVyIGZvciBzZXR0aW5nIHByb3BlcnRpZXMgb24gY29tcG9uZW50c1xuLy8gaW4gYSB0cmVlLXNoYWthYmxlIHdheVxuZXhwb3J0cy5kZWZhdWx0ID0gKHNmYywgcHJvcHMpID0+IHtcbiAgICBjb25zdCB0YXJnZXQgPSBzZmMuX192Y2NPcHRzIHx8IHNmYztcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgcHJvcHMpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59O1xuIiwiaW1wb3J0IHsgcmVuZGVyIH0gZnJvbSBcIi4vQXBwLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD00MzMyNWMyYyZzY29wZWQ9dHJ1ZVwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL0FwcC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIlxuZXhwb3J0ICogZnJvbSBcIi4vQXBwLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiXG5cbmltcG9ydCBcIi4vQXBwLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTQzMzI1YzJjJnNjb3BlZD10cnVlJmxhbmc9Y3NzXCJcblxuaW1wb3J0IGV4cG9ydENvbXBvbmVudCBmcm9tIFwiL2hvbWUvYmRhY3J1ei9Eb2N1bWVudHMvcmV0YWlsZXIvU3lsaXVzU3RhbmRhcmQvdmVuZG9yL2FzZG9yaWEvc3lsaXVzLXJldGFpbGVyLXBsdWdpbi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2V4cG9ydEhlbHBlci5qc1wiXG5jb25zdCBfX2V4cG9ydHNfXyA9IC8qI19fUFVSRV9fKi9leHBvcnRDb21wb25lbnQoc2NyaXB0LCBbWydyZW5kZXInLHJlbmRlcl0sWydfX3Njb3BlSWQnLFwiZGF0YS12LTQzMzI1YzJjXCJdLFsnX19maWxlJyxcInNyYy9SZXNvdXJjZXMvcHJpdmF0ZS9qcy9BcHAudnVlXCJdXSlcbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7XG4gIF9fZXhwb3J0c19fLl9faG1ySWQgPSBcIjQzMzI1YzJjXCJcbiAgY29uc3QgYXBpID0gX19WVUVfSE1SX1JVTlRJTUVfX1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghYXBpLmNyZWF0ZVJlY29yZCgnNDMzMjVjMmMnLCBfX2V4cG9ydHNfXykpIHtcbiAgICBjb25zb2xlLmxvZygncmVsb2FkJylcbiAgICBhcGkucmVsb2FkKCc0MzMyNWMyYycsIF9fZXhwb3J0c19fKVxuICB9XG4gIFxuICBtb2R1bGUuaG90LmFjY2VwdChcIi4vQXBwLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD00MzMyNWMyYyZzY29wZWQ9dHJ1ZVwiLCAoKSA9PiB7XG4gICAgY29uc29sZS5sb2coJ3JlLXJlbmRlcicpXG4gICAgYXBpLnJlcmVuZGVyKCc0MzMyNWMyYycsIHJlbmRlcilcbiAgfSlcblxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IF9fZXhwb3J0c19fIiwiaW1wb3J0IHsgcmVuZGVyIH0gZnJvbSBcIi4vUmV0YWlsZXJNYXBJY29uLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD01ODI2MWY3MyZzY29wZWQ9dHJ1ZVwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL1JldGFpbGVyTWFwSWNvbi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIlxuZXhwb3J0ICogZnJvbSBcIi4vUmV0YWlsZXJNYXBJY29uLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiXG5cbmltcG9ydCBcIi4vUmV0YWlsZXJNYXBJY29uLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTU4MjYxZjczJnNjb3BlZD10cnVlJmxhbmc9Y3NzXCJcblxuaW1wb3J0IGV4cG9ydENvbXBvbmVudCBmcm9tIFwiL2hvbWUvYmRhY3J1ei9Eb2N1bWVudHMvcmV0YWlsZXIvU3lsaXVzU3RhbmRhcmQvdmVuZG9yL2FzZG9yaWEvc3lsaXVzLXJldGFpbGVyLXBsdWdpbi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2V4cG9ydEhlbHBlci5qc1wiXG5jb25zdCBfX2V4cG9ydHNfXyA9IC8qI19fUFVSRV9fKi9leHBvcnRDb21wb25lbnQoc2NyaXB0LCBbWydyZW5kZXInLHJlbmRlcl0sWydfX3Njb3BlSWQnLFwiZGF0YS12LTU4MjYxZjczXCJdLFsnX19maWxlJyxcInNyYy9SZXNvdXJjZXMvcHJpdmF0ZS9qcy9jb21wb25lbnRzL1JldGFpbGVyTWFwSWNvbi52dWVcIl1dKVxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHtcbiAgX19leHBvcnRzX18uX19obXJJZCA9IFwiNTgyNjFmNzNcIlxuICBjb25zdCBhcGkgPSBfX1ZVRV9ITVJfUlVOVElNRV9fXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFhcGkuY3JlYXRlUmVjb3JkKCc1ODI2MWY3MycsIF9fZXhwb3J0c19fKSkge1xuICAgIGNvbnNvbGUubG9nKCdyZWxvYWQnKVxuICAgIGFwaS5yZWxvYWQoJzU4MjYxZjczJywgX19leHBvcnRzX18pXG4gIH1cbiAgXG4gIG1vZHVsZS5ob3QuYWNjZXB0KFwiLi9SZXRhaWxlck1hcEljb24udnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTU4MjYxZjczJnNjb3BlZD10cnVlXCIsICgpID0+IHtcbiAgICBjb25zb2xlLmxvZygncmUtcmVuZGVyJylcbiAgICBhcGkucmVyZW5kZXIoJzU4MjYxZjczJywgcmVuZGVyKVxuICB9KVxuXG59XG5cblxuZXhwb3J0IGRlZmF1bHQgX19leHBvcnRzX18iLCJpbXBvcnQgeyByZW5kZXIgfSBmcm9tIFwiLi9UaGVNYXAudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPWZiZDExNWU2JnNjb3BlZD10cnVlXCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vVGhlTWFwLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiXG5leHBvcnQgKiBmcm9tIFwiLi9UaGVNYXAudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCJcblxuaW1wb3J0IFwiLi9UaGVNYXAudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9ZmJkMTE1ZTYmc2NvcGVkPXRydWUmbGFuZz1jc3NcIlxuXG5pbXBvcnQgZXhwb3J0Q29tcG9uZW50IGZyb20gXCIvaG9tZS9iZGFjcnV6L0RvY3VtZW50cy9yZXRhaWxlci9TeWxpdXNTdGFuZGFyZC92ZW5kb3IvYXNkb3JpYS9zeWxpdXMtcmV0YWlsZXItcGx1Z2luL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvZXhwb3J0SGVscGVyLmpzXCJcbmNvbnN0IF9fZXhwb3J0c19fID0gLyojX19QVVJFX18qL2V4cG9ydENvbXBvbmVudChzY3JpcHQsIFtbJ3JlbmRlcicscmVuZGVyXSxbJ19fc2NvcGVJZCcsXCJkYXRhLXYtZmJkMTE1ZTZcIl0sWydfX2ZpbGUnLFwic3JjL1Jlc291cmNlcy9wcml2YXRlL2pzL2NvbXBvbmVudHMvVGhlTWFwLnZ1ZVwiXV0pXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkge1xuICBfX2V4cG9ydHNfXy5fX2htcklkID0gXCJmYmQxMTVlNlwiXG4gIGNvbnN0IGFwaSA9IF9fVlVFX0hNUl9SVU5USU1FX19cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIWFwaS5jcmVhdGVSZWNvcmQoJ2ZiZDExNWU2JywgX19leHBvcnRzX18pKSB7XG4gICAgY29uc29sZS5sb2coJ3JlbG9hZCcpXG4gICAgYXBpLnJlbG9hZCgnZmJkMTE1ZTYnLCBfX2V4cG9ydHNfXylcbiAgfVxuICBcbiAgbW9kdWxlLmhvdC5hY2NlcHQoXCIuL1RoZU1hcC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9ZmJkMTE1ZTYmc2NvcGVkPXRydWVcIiwgKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdyZS1yZW5kZXInKVxuICAgIGFwaS5yZXJlbmRlcignZmJkMTE1ZTYnLCByZW5kZXIpXG4gIH0pXG5cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBfX2V4cG9ydHNfXyIsImltcG9ydCB7IHJlbmRlciB9IGZyb20gXCIuL1RoZVJldGFpbGVyLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD1hYmJkM2ZlMlwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL1RoZVJldGFpbGVyLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiXG5leHBvcnQgKiBmcm9tIFwiLi9UaGVSZXRhaWxlci52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIlxuXG5pbXBvcnQgZXhwb3J0Q29tcG9uZW50IGZyb20gXCIvaG9tZS9iZGFjcnV6L0RvY3VtZW50cy9yZXRhaWxlci9TeWxpdXNTdGFuZGFyZC92ZW5kb3IvYXNkb3JpYS9zeWxpdXMtcmV0YWlsZXItcGx1Z2luL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvZXhwb3J0SGVscGVyLmpzXCJcbmNvbnN0IF9fZXhwb3J0c19fID0gLyojX19QVVJFX18qL2V4cG9ydENvbXBvbmVudChzY3JpcHQsIFtbJ3JlbmRlcicscmVuZGVyXSxbJ19fZmlsZScsXCJzcmMvUmVzb3VyY2VzL3ByaXZhdGUvanMvY29tcG9uZW50cy9UaGVSZXRhaWxlci52dWVcIl1dKVxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHtcbiAgX19leHBvcnRzX18uX19obXJJZCA9IFwiYWJiZDNmZTJcIlxuICBjb25zdCBhcGkgPSBfX1ZVRV9ITVJfUlVOVElNRV9fXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFhcGkuY3JlYXRlUmVjb3JkKCdhYmJkM2ZlMicsIF9fZXhwb3J0c19fKSkge1xuICAgIGNvbnNvbGUubG9nKCdyZWxvYWQnKVxuICAgIGFwaS5yZWxvYWQoJ2FiYmQzZmUyJywgX19leHBvcnRzX18pXG4gIH1cbiAgXG4gIG1vZHVsZS5ob3QuYWNjZXB0KFwiLi9UaGVSZXRhaWxlci52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9YWJiZDNmZTJcIiwgKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdyZS1yZW5kZXInKVxuICAgIGFwaS5yZXJlbmRlcignYWJiZDNmZTInLCByZW5kZXIpXG4gIH0pXG5cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBfX2V4cG9ydHNfXyIsImltcG9ydCB7IHJlbmRlciB9IGZyb20gXCIuL1RoZVNlYXJjaC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NmY3NzUyZjJcIlxuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9UaGVTZWFyY2gudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCJcbmV4cG9ydCAqIGZyb20gXCIuL1RoZVNlYXJjaC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIlxuXG5pbXBvcnQgZXhwb3J0Q29tcG9uZW50IGZyb20gXCIvaG9tZS9iZGFjcnV6L0RvY3VtZW50cy9yZXRhaWxlci9TeWxpdXNTdGFuZGFyZC92ZW5kb3IvYXNkb3JpYS9zeWxpdXMtcmV0YWlsZXItcGx1Z2luL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvZXhwb3J0SGVscGVyLmpzXCJcbmNvbnN0IF9fZXhwb3J0c19fID0gLyojX19QVVJFX18qL2V4cG9ydENvbXBvbmVudChzY3JpcHQsIFtbJ3JlbmRlcicscmVuZGVyXSxbJ19fZmlsZScsXCJzcmMvUmVzb3VyY2VzL3ByaXZhdGUvanMvY29tcG9uZW50cy9UaGVTZWFyY2gudnVlXCJdXSlcbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7XG4gIF9fZXhwb3J0c19fLl9faG1ySWQgPSBcIjZmNzc1MmYyXCJcbiAgY29uc3QgYXBpID0gX19WVUVfSE1SX1JVTlRJTUVfX1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghYXBpLmNyZWF0ZVJlY29yZCgnNmY3NzUyZjInLCBfX2V4cG9ydHNfXykpIHtcbiAgICBjb25zb2xlLmxvZygncmVsb2FkJylcbiAgICBhcGkucmVsb2FkKCc2Zjc3NTJmMicsIF9fZXhwb3J0c19fKVxuICB9XG4gIFxuICBtb2R1bGUuaG90LmFjY2VwdChcIi4vVGhlU2VhcmNoLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD02Zjc3NTJmMlwiLCAoKSA9PiB7XG4gICAgY29uc29sZS5sb2coJ3JlLXJlbmRlcicpXG4gICAgYXBpLnJlcmVuZGVyKCc2Zjc3NTJmMicsIHJlbmRlcilcbiAgfSlcblxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IF9fZXhwb3J0c19fIiwiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gXCItIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTEudXNlWzBdIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMF0udXNlWzBdIS4vQXBwLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC0xLnVzZVswXSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzBdLnVzZVswXSEuL0FwcC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIiIsImV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tIFwiLSEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC0xLnVzZVswXSEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzBdLnVzZVswXSEuL1JldGFpbGVyTWFwSWNvbi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIjsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtMS51c2VbMF0hLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFswXS51c2VbMF0hLi9SZXRhaWxlck1hcEljb24udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCIiLCJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSBcIi0hLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtMS51c2VbMF0hLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFswXS51c2VbMF0hLi9UaGVNYXAudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCI7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTEudXNlWzBdIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMF0udXNlWzBdIS4vVGhlTWFwLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiIiwiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gXCItIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTEudXNlWzBdIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMF0udXNlWzBdIS4vVGhlUmV0YWlsZXIudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCI7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTEudXNlWzBdIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMF0udXNlWzBdIS4vVGhlUmV0YWlsZXIudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCIiLCJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSBcIi0hLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtMS51c2VbMF0hLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFswXS51c2VbMF0hLi9UaGVTZWFyY2gudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCI7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTEudXNlWzBdIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMF0udXNlWzBdIS4vVGhlU2VhcmNoLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiIiwiaW1wb3J0ICogYXMgcnVudGltZURvbSBmcm9tICdAdnVlL3J1bnRpbWUtZG9tJztcbmltcG9ydCB7IGluaXRDdXN0b21Gb3JtYXR0ZXIsIHdhcm4sIHJlZ2lzdGVyUnVudGltZUNvbXBpbGVyIH0gZnJvbSAnQHZ1ZS9ydW50aW1lLWRvbSc7XG5leHBvcnQgKiBmcm9tICdAdnVlL3J1bnRpbWUtZG9tJztcbmltcG9ydCB7IGNvbXBpbGUgfSBmcm9tICdAdnVlL2NvbXBpbGVyLWRvbSc7XG5pbXBvcnQgeyBpc1N0cmluZywgTk9PUCwgZXh0ZW5kLCBnZW5lcmF0ZUNvZGVGcmFtZSB9IGZyb20gJ0B2dWUvc2hhcmVkJztcblxuZnVuY3Rpb24gaW5pdERldigpIHtcclxuICAgIHtcclxuICAgICAgICBpbml0Q3VzdG9tRm9ybWF0dGVyKCk7XHJcbiAgICB9XHJcbn1cblxuLy8gVGhpcyBlbnRyeSBpcyB0aGUgXCJmdWxsLWJ1aWxkXCIgdGhhdCBpbmNsdWRlcyBib3RoIHRoZSBydW50aW1lXHJcbmlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgIGluaXREZXYoKTtcclxufVxyXG5jb25zdCBjb21waWxlQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG5mdW5jdGlvbiBjb21waWxlVG9GdW5jdGlvbih0ZW1wbGF0ZSwgb3B0aW9ucykge1xyXG4gICAgaWYgKCFpc1N0cmluZyh0ZW1wbGF0ZSkpIHtcclxuICAgICAgICBpZiAodGVtcGxhdGUubm9kZVR5cGUpIHtcclxuICAgICAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5pbm5lckhUTUw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgd2FybihgaW52YWxpZCB0ZW1wbGF0ZSBvcHRpb246IGAsIHRlbXBsYXRlKTtcclxuICAgICAgICAgICAgcmV0dXJuIE5PT1A7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3Qga2V5ID0gdGVtcGxhdGU7XHJcbiAgICBjb25zdCBjYWNoZWQgPSBjb21waWxlQ2FjaGVba2V5XTtcclxuICAgIGlmIChjYWNoZWQpIHtcclxuICAgICAgICByZXR1cm4gY2FjaGVkO1xyXG4gICAgfVxyXG4gICAgaWYgKHRlbXBsYXRlWzBdID09PSAnIycpIHtcclxuICAgICAgICBjb25zdCBlbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGVtcGxhdGUpO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWVsKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYFRlbXBsYXRlIGVsZW1lbnQgbm90IGZvdW5kIG9yIGlzIGVtcHR5OiAke3RlbXBsYXRlfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBfX1VOU0FGRV9fXHJcbiAgICAgICAgLy8gUmVhc29uOiBwb3RlbnRpYWwgZXhlY3V0aW9uIG9mIEpTIGV4cHJlc3Npb25zIGluIGluLURPTSB0ZW1wbGF0ZS5cclxuICAgICAgICAvLyBUaGUgdXNlciBtdXN0IG1ha2Ugc3VyZSB0aGUgaW4tRE9NIHRlbXBsYXRlIGlzIHRydXN0ZWQuIElmIGl0J3MgcmVuZGVyZWRcclxuICAgICAgICAvLyBieSB0aGUgc2VydmVyLCB0aGUgdGVtcGxhdGUgc2hvdWxkIG5vdCBjb250YWluIGFueSB1c2VyIGRhdGEuXHJcbiAgICAgICAgdGVtcGxhdGUgPSBlbCA/IGVsLmlubmVySFRNTCA6IGBgO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyBjb2RlIH0gPSBjb21waWxlKHRlbXBsYXRlLCBleHRlbmQoe1xyXG4gICAgICAgIGhvaXN0U3RhdGljOiB0cnVlLFxyXG4gICAgICAgIG9uRXJyb3I6IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IG9uRXJyb3IgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgb25XYXJuOiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBlID0+IG9uRXJyb3IoZSwgdHJ1ZSkgOiBOT09QXHJcbiAgICB9LCBvcHRpb25zKSk7XHJcbiAgICBmdW5jdGlvbiBvbkVycm9yKGVyciwgYXNXYXJuaW5nID0gZmFsc2UpIHtcclxuICAgICAgICBjb25zdCBtZXNzYWdlID0gYXNXYXJuaW5nXHJcbiAgICAgICAgICAgID8gZXJyLm1lc3NhZ2VcclxuICAgICAgICAgICAgOiBgVGVtcGxhdGUgY29tcGlsYXRpb24gZXJyb3I6ICR7ZXJyLm1lc3NhZ2V9YDtcclxuICAgICAgICBjb25zdCBjb2RlRnJhbWUgPSBlcnIubG9jICYmXHJcbiAgICAgICAgICAgIGdlbmVyYXRlQ29kZUZyYW1lKHRlbXBsYXRlLCBlcnIubG9jLnN0YXJ0Lm9mZnNldCwgZXJyLmxvYy5lbmQub2Zmc2V0KTtcclxuICAgICAgICB3YXJuKGNvZGVGcmFtZSA/IGAke21lc3NhZ2V9XFxuJHtjb2RlRnJhbWV9YCA6IG1lc3NhZ2UpO1xyXG4gICAgfVxyXG4gICAgLy8gVGhlIHdpbGRjYXJkIGltcG9ydCByZXN1bHRzIGluIGEgaHVnZSBvYmplY3Qgd2l0aCBldmVyeSBleHBvcnRcclxuICAgIC8vIHdpdGgga2V5cyB0aGF0IGNhbm5vdCBiZSBtYW5nbGVkLCBhbmQgY2FuIGJlIHF1aXRlIGhlYXZ5IHNpemUtd2lzZS5cclxuICAgIC8vIEluIHRoZSBnbG9iYWwgYnVpbGQgd2Uga25vdyBgVnVlYCBpcyBhdmFpbGFibGUgZ2xvYmFsbHkgc28gd2UgY2FuIGF2b2lkXHJcbiAgICAvLyB0aGUgd2lsZGNhcmQgb2JqZWN0LlxyXG4gICAgY29uc3QgcmVuZGVyID0gKG5ldyBGdW5jdGlvbignVnVlJywgY29kZSkocnVudGltZURvbSkpO1xyXG4gICAgcmVuZGVyLl9yYyA9IHRydWU7XHJcbiAgICByZXR1cm4gKGNvbXBpbGVDYWNoZVtrZXldID0gcmVuZGVyKTtcclxufVxyXG5yZWdpc3RlclJ1bnRpbWVDb21waWxlcihjb21waWxlVG9GdW5jdGlvbik7XG5cbmV4cG9ydCB7IGNvbXBpbGVUb0Z1bmN0aW9uIGFzIGNvbXBpbGUgfTtcbiIsIi8qIVxuICogdnVleCB2NC4wLjJcbiAqIChjKSAyMDIxIEV2YW4gWW91XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuaW1wb3J0IHsgaW5qZWN0LCByZWFjdGl2ZSwgd2F0Y2ggfSBmcm9tICd2dWUnO1xuaW1wb3J0IHsgc2V0dXBEZXZ0b29sc1BsdWdpbiB9IGZyb20gJ0B2dWUvZGV2dG9vbHMtYXBpJztcblxudmFyIHN0b3JlS2V5ID0gJ3N0b3JlJztcblxuZnVuY3Rpb24gdXNlU3RvcmUgKGtleSkge1xuICBpZiAoIGtleSA9PT0gdm9pZCAwICkga2V5ID0gbnVsbDtcblxuICByZXR1cm4gaW5qZWN0KGtleSAhPT0gbnVsbCA/IGtleSA6IHN0b3JlS2V5KVxufVxuXG4vKipcbiAqIEdldCB0aGUgZmlyc3QgaXRlbSB0aGF0IHBhc3MgdGhlIHRlc3RcbiAqIGJ5IHNlY29uZCBhcmd1bWVudCBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZcbiAqIEByZXR1cm4geyp9XG4gKi9cbmZ1bmN0aW9uIGZpbmQgKGxpc3QsIGYpIHtcbiAgcmV0dXJuIGxpc3QuZmlsdGVyKGYpWzBdXG59XG5cbi8qKlxuICogRGVlcCBjb3B5IHRoZSBnaXZlbiBvYmplY3QgY29uc2lkZXJpbmcgY2lyY3VsYXIgc3RydWN0dXJlLlxuICogVGhpcyBmdW5jdGlvbiBjYWNoZXMgYWxsIG5lc3RlZCBvYmplY3RzIGFuZCBpdHMgY29waWVzLlxuICogSWYgaXQgZGV0ZWN0cyBjaXJjdWxhciBzdHJ1Y3R1cmUsIHVzZSBjYWNoZWQgY29weSB0byBhdm9pZCBpbmZpbml0ZSBsb29wLlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IGNhY2hlXG4gKiBAcmV0dXJuIHsqfVxuICovXG5mdW5jdGlvbiBkZWVwQ29weSAob2JqLCBjYWNoZSkge1xuICBpZiAoIGNhY2hlID09PSB2b2lkIDAgKSBjYWNoZSA9IFtdO1xuXG4gIC8vIGp1c3QgcmV0dXJuIGlmIG9iaiBpcyBpbW11dGFibGUgdmFsdWVcbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBvYmpcbiAgfVxuXG4gIC8vIGlmIG9iaiBpcyBoaXQsIGl0IGlzIGluIGNpcmN1bGFyIHN0cnVjdHVyZVxuICB2YXIgaGl0ID0gZmluZChjYWNoZSwgZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMub3JpZ2luYWwgPT09IG9iajsgfSk7XG4gIGlmIChoaXQpIHtcbiAgICByZXR1cm4gaGl0LmNvcHlcbiAgfVxuXG4gIHZhciBjb3B5ID0gQXJyYXkuaXNBcnJheShvYmopID8gW10gOiB7fTtcbiAgLy8gcHV0IHRoZSBjb3B5IGludG8gY2FjaGUgYXQgZmlyc3RcbiAgLy8gYmVjYXVzZSB3ZSB3YW50IHRvIHJlZmVyIGl0IGluIHJlY3Vyc2l2ZSBkZWVwQ29weVxuICBjYWNoZS5wdXNoKHtcbiAgICBvcmlnaW5hbDogb2JqLFxuICAgIGNvcHk6IGNvcHlcbiAgfSk7XG5cbiAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBjb3B5W2tleV0gPSBkZWVwQ29weShvYmpba2V5XSwgY2FjaGUpO1xuICB9KTtcblxuICByZXR1cm4gY29weVxufVxuXG4vKipcbiAqIGZvckVhY2ggZm9yIG9iamVjdFxuICovXG5mdW5jdGlvbiBmb3JFYWNoVmFsdWUgKG9iaiwgZm4pIHtcbiAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGZuKG9ialtrZXldLCBrZXkpOyB9KTtcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QgKG9iaikge1xuICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnXG59XG5cbmZ1bmN0aW9uIGlzUHJvbWlzZSAodmFsKSB7XG4gIHJldHVybiB2YWwgJiYgdHlwZW9mIHZhbC50aGVuID09PSAnZnVuY3Rpb24nXG59XG5cbmZ1bmN0aW9uIGFzc2VydCAoY29uZGl0aW9uLCBtc2cpIHtcbiAgaWYgKCFjb25kaXRpb24pIHsgdGhyb3cgbmV3IEVycm9yKChcIlt2dWV4XSBcIiArIG1zZykpIH1cbn1cblxuZnVuY3Rpb24gcGFydGlhbCAoZm4sIGFyZykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmbihhcmcpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuZXJpY1N1YnNjcmliZSAoZm4sIHN1YnMsIG9wdGlvbnMpIHtcbiAgaWYgKHN1YnMuaW5kZXhPZihmbikgPCAwKSB7XG4gICAgb3B0aW9ucyAmJiBvcHRpb25zLnByZXBlbmRcbiAgICAgID8gc3Vicy51bnNoaWZ0KGZuKVxuICAgICAgOiBzdWJzLnB1c2goZm4pO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGkgPSBzdWJzLmluZGV4T2YoZm4pO1xuICAgIGlmIChpID4gLTEpIHtcbiAgICAgIHN1YnMuc3BsaWNlKGksIDEpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXNldFN0b3JlIChzdG9yZSwgaG90KSB7XG4gIHN0b3JlLl9hY3Rpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgc3RvcmUuX211dGF0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHN0b3JlLl93cmFwcGVkR2V0dGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHN0b3JlLl9tb2R1bGVzTmFtZXNwYWNlTWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdmFyIHN0YXRlID0gc3RvcmUuc3RhdGU7XG4gIC8vIGluaXQgYWxsIG1vZHVsZXNcbiAgaW5zdGFsbE1vZHVsZShzdG9yZSwgc3RhdGUsIFtdLCBzdG9yZS5fbW9kdWxlcy5yb290LCB0cnVlKTtcbiAgLy8gcmVzZXQgc3RhdGVcbiAgcmVzZXRTdG9yZVN0YXRlKHN0b3JlLCBzdGF0ZSwgaG90KTtcbn1cblxuZnVuY3Rpb24gcmVzZXRTdG9yZVN0YXRlIChzdG9yZSwgc3RhdGUsIGhvdCkge1xuICB2YXIgb2xkU3RhdGUgPSBzdG9yZS5fc3RhdGU7XG5cbiAgLy8gYmluZCBzdG9yZSBwdWJsaWMgZ2V0dGVyc1xuICBzdG9yZS5nZXR0ZXJzID0ge307XG4gIC8vIHJlc2V0IGxvY2FsIGdldHRlcnMgY2FjaGVcbiAgc3RvcmUuX21ha2VMb2NhbEdldHRlcnNDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciB3cmFwcGVkR2V0dGVycyA9IHN0b3JlLl93cmFwcGVkR2V0dGVycztcbiAgdmFyIGNvbXB1dGVkT2JqID0ge307XG4gIGZvckVhY2hWYWx1ZSh3cmFwcGVkR2V0dGVycywgZnVuY3Rpb24gKGZuLCBrZXkpIHtcbiAgICAvLyB1c2UgY29tcHV0ZWQgdG8gbGV2ZXJhZ2UgaXRzIGxhenktY2FjaGluZyBtZWNoYW5pc21cbiAgICAvLyBkaXJlY3QgaW5saW5lIGZ1bmN0aW9uIHVzZSB3aWxsIGxlYWQgdG8gY2xvc3VyZSBwcmVzZXJ2aW5nIG9sZFN0YXRlLlxuICAgIC8vIHVzaW5nIHBhcnRpYWwgdG8gcmV0dXJuIGZ1bmN0aW9uIHdpdGggb25seSBhcmd1bWVudHMgcHJlc2VydmVkIGluIGNsb3N1cmUgZW52aXJvbm1lbnQuXG4gICAgY29tcHV0ZWRPYmpba2V5XSA9IHBhcnRpYWwoZm4sIHN0b3JlKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3RvcmUuZ2V0dGVycywga2V5LCB7XG4gICAgICAvLyBUT0RPOiB1c2UgYGNvbXB1dGVkYCB3aGVuIGl0J3MgcG9zc2libGUuIGF0IHRoZSBtb21lbnQgd2UgY2FuJ3QgZHVlIHRvXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVleC9wdWxsLzE4ODNcbiAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29tcHV0ZWRPYmpba2V5XSgpOyB9LFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSAvLyBmb3IgbG9jYWwgZ2V0dGVyc1xuICAgIH0pO1xuICB9KTtcblxuICBzdG9yZS5fc3RhdGUgPSByZWFjdGl2ZSh7XG4gICAgZGF0YTogc3RhdGVcbiAgfSk7XG5cbiAgLy8gZW5hYmxlIHN0cmljdCBtb2RlIGZvciBuZXcgc3RhdGVcbiAgaWYgKHN0b3JlLnN0cmljdCkge1xuICAgIGVuYWJsZVN0cmljdE1vZGUoc3RvcmUpO1xuICB9XG5cbiAgaWYgKG9sZFN0YXRlKSB7XG4gICAgaWYgKGhvdCkge1xuICAgICAgLy8gZGlzcGF0Y2ggY2hhbmdlcyBpbiBhbGwgc3Vic2NyaWJlZCB3YXRjaGVyc1xuICAgICAgLy8gdG8gZm9yY2UgZ2V0dGVyIHJlLWV2YWx1YXRpb24gZm9yIGhvdCByZWxvYWRpbmcuXG4gICAgICBzdG9yZS5fd2l0aENvbW1pdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9sZFN0YXRlLmRhdGEgPSBudWxsO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGluc3RhbGxNb2R1bGUgKHN0b3JlLCByb290U3RhdGUsIHBhdGgsIG1vZHVsZSwgaG90KSB7XG4gIHZhciBpc1Jvb3QgPSAhcGF0aC5sZW5ndGg7XG4gIHZhciBuYW1lc3BhY2UgPSBzdG9yZS5fbW9kdWxlcy5nZXROYW1lc3BhY2UocGF0aCk7XG5cbiAgLy8gcmVnaXN0ZXIgaW4gbmFtZXNwYWNlIG1hcFxuICBpZiAobW9kdWxlLm5hbWVzcGFjZWQpIHtcbiAgICBpZiAoc3RvcmUuX21vZHVsZXNOYW1lc3BhY2VNYXBbbmFtZXNwYWNlXSAmJiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoKFwiW3Z1ZXhdIGR1cGxpY2F0ZSBuYW1lc3BhY2UgXCIgKyBuYW1lc3BhY2UgKyBcIiBmb3IgdGhlIG5hbWVzcGFjZWQgbW9kdWxlIFwiICsgKHBhdGguam9pbignLycpKSkpO1xuICAgIH1cbiAgICBzdG9yZS5fbW9kdWxlc05hbWVzcGFjZU1hcFtuYW1lc3BhY2VdID0gbW9kdWxlO1xuICB9XG5cbiAgLy8gc2V0IHN0YXRlXG4gIGlmICghaXNSb290ICYmICFob3QpIHtcbiAgICB2YXIgcGFyZW50U3RhdGUgPSBnZXROZXN0ZWRTdGF0ZShyb290U3RhdGUsIHBhdGguc2xpY2UoMCwgLTEpKTtcbiAgICB2YXIgbW9kdWxlTmFtZSA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICBzdG9yZS5fd2l0aENvbW1pdChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgIGlmIChtb2R1bGVOYW1lIGluIHBhcmVudFN0YXRlKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgKFwiW3Z1ZXhdIHN0YXRlIGZpZWxkIFxcXCJcIiArIG1vZHVsZU5hbWUgKyBcIlxcXCIgd2FzIG92ZXJyaWRkZW4gYnkgYSBtb2R1bGUgd2l0aCB0aGUgc2FtZSBuYW1lIGF0IFxcXCJcIiArIChwYXRoLmpvaW4oJy4nKSkgKyBcIlxcXCJcIilcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwYXJlbnRTdGF0ZVttb2R1bGVOYW1lXSA9IG1vZHVsZS5zdGF0ZTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBsb2NhbCA9IG1vZHVsZS5jb250ZXh0ID0gbWFrZUxvY2FsQ29udGV4dChzdG9yZSwgbmFtZXNwYWNlLCBwYXRoKTtcblxuICBtb2R1bGUuZm9yRWFjaE11dGF0aW9uKGZ1bmN0aW9uIChtdXRhdGlvbiwga2V5KSB7XG4gICAgdmFyIG5hbWVzcGFjZWRUeXBlID0gbmFtZXNwYWNlICsga2V5O1xuICAgIHJlZ2lzdGVyTXV0YXRpb24oc3RvcmUsIG5hbWVzcGFjZWRUeXBlLCBtdXRhdGlvbiwgbG9jYWwpO1xuICB9KTtcblxuICBtb2R1bGUuZm9yRWFjaEFjdGlvbihmdW5jdGlvbiAoYWN0aW9uLCBrZXkpIHtcbiAgICB2YXIgdHlwZSA9IGFjdGlvbi5yb290ID8ga2V5IDogbmFtZXNwYWNlICsga2V5O1xuICAgIHZhciBoYW5kbGVyID0gYWN0aW9uLmhhbmRsZXIgfHwgYWN0aW9uO1xuICAgIHJlZ2lzdGVyQWN0aW9uKHN0b3JlLCB0eXBlLCBoYW5kbGVyLCBsb2NhbCk7XG4gIH0pO1xuXG4gIG1vZHVsZS5mb3JFYWNoR2V0dGVyKGZ1bmN0aW9uIChnZXR0ZXIsIGtleSkge1xuICAgIHZhciBuYW1lc3BhY2VkVHlwZSA9IG5hbWVzcGFjZSArIGtleTtcbiAgICByZWdpc3RlckdldHRlcihzdG9yZSwgbmFtZXNwYWNlZFR5cGUsIGdldHRlciwgbG9jYWwpO1xuICB9KTtcblxuICBtb2R1bGUuZm9yRWFjaENoaWxkKGZ1bmN0aW9uIChjaGlsZCwga2V5KSB7XG4gICAgaW5zdGFsbE1vZHVsZShzdG9yZSwgcm9vdFN0YXRlLCBwYXRoLmNvbmNhdChrZXkpLCBjaGlsZCwgaG90KTtcbiAgfSk7XG59XG5cbi8qKlxuICogbWFrZSBsb2NhbGl6ZWQgZGlzcGF0Y2gsIGNvbW1pdCwgZ2V0dGVycyBhbmQgc3RhdGVcbiAqIGlmIHRoZXJlIGlzIG5vIG5hbWVzcGFjZSwganVzdCB1c2Ugcm9vdCBvbmVzXG4gKi9cbmZ1bmN0aW9uIG1ha2VMb2NhbENvbnRleHQgKHN0b3JlLCBuYW1lc3BhY2UsIHBhdGgpIHtcbiAgdmFyIG5vTmFtZXNwYWNlID0gbmFtZXNwYWNlID09PSAnJztcblxuICB2YXIgbG9jYWwgPSB7XG4gICAgZGlzcGF0Y2g6IG5vTmFtZXNwYWNlID8gc3RvcmUuZGlzcGF0Y2ggOiBmdW5jdGlvbiAoX3R5cGUsIF9wYXlsb2FkLCBfb3B0aW9ucykge1xuICAgICAgdmFyIGFyZ3MgPSB1bmlmeU9iamVjdFN0eWxlKF90eXBlLCBfcGF5bG9hZCwgX29wdGlvbnMpO1xuICAgICAgdmFyIHBheWxvYWQgPSBhcmdzLnBheWxvYWQ7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3Mub3B0aW9ucztcbiAgICAgIHZhciB0eXBlID0gYXJncy50eXBlO1xuXG4gICAgICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMucm9vdCkge1xuICAgICAgICB0eXBlID0gbmFtZXNwYWNlICsgdHlwZTtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhc3RvcmUuX2FjdGlvbnNbdHlwZV0pIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKChcIlt2dWV4XSB1bmtub3duIGxvY2FsIGFjdGlvbiB0eXBlOiBcIiArIChhcmdzLnR5cGUpICsgXCIsIGdsb2JhbCB0eXBlOiBcIiArIHR5cGUpKTtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RvcmUuZGlzcGF0Y2godHlwZSwgcGF5bG9hZClcbiAgICB9LFxuXG4gICAgY29tbWl0OiBub05hbWVzcGFjZSA/IHN0b3JlLmNvbW1pdCA6IGZ1bmN0aW9uIChfdHlwZSwgX3BheWxvYWQsIF9vcHRpb25zKSB7XG4gICAgICB2YXIgYXJncyA9IHVuaWZ5T2JqZWN0U3R5bGUoX3R5cGUsIF9wYXlsb2FkLCBfb3B0aW9ucyk7XG4gICAgICB2YXIgcGF5bG9hZCA9IGFyZ3MucGF5bG9hZDtcbiAgICAgIHZhciBvcHRpb25zID0gYXJncy5vcHRpb25zO1xuICAgICAgdmFyIHR5cGUgPSBhcmdzLnR5cGU7XG5cbiAgICAgIGlmICghb3B0aW9ucyB8fCAhb3B0aW9ucy5yb290KSB7XG4gICAgICAgIHR5cGUgPSBuYW1lc3BhY2UgKyB0eXBlO1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFzdG9yZS5fbXV0YXRpb25zW3R5cGVdKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gdW5rbm93biBsb2NhbCBtdXRhdGlvbiB0eXBlOiBcIiArIChhcmdzLnR5cGUpICsgXCIsIGdsb2JhbCB0eXBlOiBcIiArIHR5cGUpKTtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzdG9yZS5jb21taXQodHlwZSwgcGF5bG9hZCwgb3B0aW9ucyk7XG4gICAgfVxuICB9O1xuXG4gIC8vIGdldHRlcnMgYW5kIHN0YXRlIG9iamVjdCBtdXN0IGJlIGdvdHRlbiBsYXppbHlcbiAgLy8gYmVjYXVzZSB0aGV5IHdpbGwgYmUgY2hhbmdlZCBieSBzdGF0ZSB1cGRhdGVcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMobG9jYWwsIHtcbiAgICBnZXR0ZXJzOiB7XG4gICAgICBnZXQ6IG5vTmFtZXNwYWNlXG4gICAgICAgID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RvcmUuZ2V0dGVyczsgfVxuICAgICAgICA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1ha2VMb2NhbEdldHRlcnMoc3RvcmUsIG5hbWVzcGFjZSk7IH1cbiAgICB9LFxuICAgIHN0YXRlOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdldE5lc3RlZFN0YXRlKHN0b3JlLnN0YXRlLCBwYXRoKTsgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGxvY2FsXG59XG5cbmZ1bmN0aW9uIG1ha2VMb2NhbEdldHRlcnMgKHN0b3JlLCBuYW1lc3BhY2UpIHtcbiAgaWYgKCFzdG9yZS5fbWFrZUxvY2FsR2V0dGVyc0NhY2hlW25hbWVzcGFjZV0pIHtcbiAgICB2YXIgZ2V0dGVyc1Byb3h5ID0ge307XG4gICAgdmFyIHNwbGl0UG9zID0gbmFtZXNwYWNlLmxlbmd0aDtcbiAgICBPYmplY3Qua2V5cyhzdG9yZS5nZXR0ZXJzKS5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAvLyBza2lwIGlmIHRoZSB0YXJnZXQgZ2V0dGVyIGlzIG5vdCBtYXRjaCB0aGlzIG5hbWVzcGFjZVxuICAgICAgaWYgKHR5cGUuc2xpY2UoMCwgc3BsaXRQb3MpICE9PSBuYW1lc3BhY2UpIHsgcmV0dXJuIH1cblxuICAgICAgLy8gZXh0cmFjdCBsb2NhbCBnZXR0ZXIgdHlwZVxuICAgICAgdmFyIGxvY2FsVHlwZSA9IHR5cGUuc2xpY2Uoc3BsaXRQb3MpO1xuXG4gICAgICAvLyBBZGQgYSBwb3J0IHRvIHRoZSBnZXR0ZXJzIHByb3h5LlxuICAgICAgLy8gRGVmaW5lIGFzIGdldHRlciBwcm9wZXJ0eSBiZWNhdXNlXG4gICAgICAvLyB3ZSBkbyBub3Qgd2FudCB0byBldmFsdWF0ZSB0aGUgZ2V0dGVycyBpbiB0aGlzIHRpbWUuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZ2V0dGVyc1Byb3h5LCBsb2NhbFR5cGUsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdG9yZS5nZXR0ZXJzW3R5cGVdOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBzdG9yZS5fbWFrZUxvY2FsR2V0dGVyc0NhY2hlW25hbWVzcGFjZV0gPSBnZXR0ZXJzUHJveHk7XG4gIH1cblxuICByZXR1cm4gc3RvcmUuX21ha2VMb2NhbEdldHRlcnNDYWNoZVtuYW1lc3BhY2VdXG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyTXV0YXRpb24gKHN0b3JlLCB0eXBlLCBoYW5kbGVyLCBsb2NhbCkge1xuICB2YXIgZW50cnkgPSBzdG9yZS5fbXV0YXRpb25zW3R5cGVdIHx8IChzdG9yZS5fbXV0YXRpb25zW3R5cGVdID0gW10pO1xuICBlbnRyeS5wdXNoKGZ1bmN0aW9uIHdyYXBwZWRNdXRhdGlvbkhhbmRsZXIgKHBheWxvYWQpIHtcbiAgICBoYW5kbGVyLmNhbGwoc3RvcmUsIGxvY2FsLnN0YXRlLCBwYXlsb2FkKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyQWN0aW9uIChzdG9yZSwgdHlwZSwgaGFuZGxlciwgbG9jYWwpIHtcbiAgdmFyIGVudHJ5ID0gc3RvcmUuX2FjdGlvbnNbdHlwZV0gfHwgKHN0b3JlLl9hY3Rpb25zW3R5cGVdID0gW10pO1xuICBlbnRyeS5wdXNoKGZ1bmN0aW9uIHdyYXBwZWRBY3Rpb25IYW5kbGVyIChwYXlsb2FkKSB7XG4gICAgdmFyIHJlcyA9IGhhbmRsZXIuY2FsbChzdG9yZSwge1xuICAgICAgZGlzcGF0Y2g6IGxvY2FsLmRpc3BhdGNoLFxuICAgICAgY29tbWl0OiBsb2NhbC5jb21taXQsXG4gICAgICBnZXR0ZXJzOiBsb2NhbC5nZXR0ZXJzLFxuICAgICAgc3RhdGU6IGxvY2FsLnN0YXRlLFxuICAgICAgcm9vdEdldHRlcnM6IHN0b3JlLmdldHRlcnMsXG4gICAgICByb290U3RhdGU6IHN0b3JlLnN0YXRlXG4gICAgfSwgcGF5bG9hZCk7XG4gICAgaWYgKCFpc1Byb21pc2UocmVzKSkge1xuICAgICAgcmVzID0gUHJvbWlzZS5yZXNvbHZlKHJlcyk7XG4gICAgfVxuICAgIGlmIChzdG9yZS5fZGV2dG9vbEhvb2spIHtcbiAgICAgIHJldHVybiByZXMuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICBzdG9yZS5fZGV2dG9vbEhvb2suZW1pdCgndnVleDplcnJvcicsIGVycik7XG4gICAgICAgIHRocm93IGVyclxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJlc1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyR2V0dGVyIChzdG9yZSwgdHlwZSwgcmF3R2V0dGVyLCBsb2NhbCkge1xuICBpZiAoc3RvcmUuX3dyYXBwZWRHZXR0ZXJzW3R5cGVdKSB7XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gZHVwbGljYXRlIGdldHRlciBrZXk6IFwiICsgdHlwZSkpO1xuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuICBzdG9yZS5fd3JhcHBlZEdldHRlcnNbdHlwZV0gPSBmdW5jdGlvbiB3cmFwcGVkR2V0dGVyIChzdG9yZSkge1xuICAgIHJldHVybiByYXdHZXR0ZXIoXG4gICAgICBsb2NhbC5zdGF0ZSwgLy8gbG9jYWwgc3RhdGVcbiAgICAgIGxvY2FsLmdldHRlcnMsIC8vIGxvY2FsIGdldHRlcnNcbiAgICAgIHN0b3JlLnN0YXRlLCAvLyByb290IHN0YXRlXG4gICAgICBzdG9yZS5nZXR0ZXJzIC8vIHJvb3QgZ2V0dGVyc1xuICAgIClcbiAgfTtcbn1cblxuZnVuY3Rpb24gZW5hYmxlU3RyaWN0TW9kZSAoc3RvcmUpIHtcbiAgd2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RvcmUuX3N0YXRlLmRhdGE7IH0sIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICBhc3NlcnQoc3RvcmUuX2NvbW1pdHRpbmcsIFwiZG8gbm90IG11dGF0ZSB2dWV4IHN0b3JlIHN0YXRlIG91dHNpZGUgbXV0YXRpb24gaGFuZGxlcnMuXCIpO1xuICAgIH1cbiAgfSwgeyBkZWVwOiB0cnVlLCBmbHVzaDogJ3N5bmMnIH0pO1xufVxuXG5mdW5jdGlvbiBnZXROZXN0ZWRTdGF0ZSAoc3RhdGUsIHBhdGgpIHtcbiAgcmV0dXJuIHBhdGgucmVkdWNlKGZ1bmN0aW9uIChzdGF0ZSwga2V5KSB7IHJldHVybiBzdGF0ZVtrZXldOyB9LCBzdGF0ZSlcbn1cblxuZnVuY3Rpb24gdW5pZnlPYmplY3RTdHlsZSAodHlwZSwgcGF5bG9hZCwgb3B0aW9ucykge1xuICBpZiAoaXNPYmplY3QodHlwZSkgJiYgdHlwZS50eXBlKSB7XG4gICAgb3B0aW9ucyA9IHBheWxvYWQ7XG4gICAgcGF5bG9hZCA9IHR5cGU7XG4gICAgdHlwZSA9IHR5cGUudHlwZTtcbiAgfVxuXG4gIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICBhc3NlcnQodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnLCAoXCJleHBlY3RzIHN0cmluZyBhcyB0aGUgdHlwZSwgYnV0IGZvdW5kIFwiICsgKHR5cGVvZiB0eXBlKSArIFwiLlwiKSk7XG4gIH1cblxuICByZXR1cm4geyB0eXBlOiB0eXBlLCBwYXlsb2FkOiBwYXlsb2FkLCBvcHRpb25zOiBvcHRpb25zIH1cbn1cblxudmFyIExBQkVMX1ZVRVhfQklORElOR1MgPSAndnVleCBiaW5kaW5ncyc7XG52YXIgTVVUQVRJT05TX0xBWUVSX0lEID0gJ3Z1ZXg6bXV0YXRpb25zJztcbnZhciBBQ1RJT05TX0xBWUVSX0lEID0gJ3Z1ZXg6YWN0aW9ucyc7XG52YXIgSU5TUEVDVE9SX0lEID0gJ3Z1ZXgnO1xuXG52YXIgYWN0aW9uSWQgPSAwO1xuXG5mdW5jdGlvbiBhZGREZXZ0b29scyAoYXBwLCBzdG9yZSkge1xuICBzZXR1cERldnRvb2xzUGx1Z2luKFxuICAgIHtcbiAgICAgIGlkOiAnb3JnLnZ1ZWpzLnZ1ZXgnLFxuICAgICAgYXBwOiBhcHAsXG4gICAgICBsYWJlbDogJ1Z1ZXgnLFxuICAgICAgaG9tZXBhZ2U6ICdodHRwczovL25leHQudnVleC52dWVqcy5vcmcvJyxcbiAgICAgIGxvZ286ICdodHRwczovL3Z1ZWpzLm9yZy9pbWFnZXMvaWNvbnMvZmF2aWNvbi05Nng5Ni5wbmcnLFxuICAgICAgcGFja2FnZU5hbWU6ICd2dWV4JyxcbiAgICAgIGNvbXBvbmVudFN0YXRlVHlwZXM6IFtMQUJFTF9WVUVYX0JJTkRJTkdTXVxuICAgIH0sXG4gICAgZnVuY3Rpb24gKGFwaSkge1xuICAgICAgYXBpLmFkZFRpbWVsaW5lTGF5ZXIoe1xuICAgICAgICBpZDogTVVUQVRJT05TX0xBWUVSX0lELFxuICAgICAgICBsYWJlbDogJ1Z1ZXggTXV0YXRpb25zJyxcbiAgICAgICAgY29sb3I6IENPTE9SX0xJTUVfNTAwXG4gICAgICB9KTtcblxuICAgICAgYXBpLmFkZFRpbWVsaW5lTGF5ZXIoe1xuICAgICAgICBpZDogQUNUSU9OU19MQVlFUl9JRCxcbiAgICAgICAgbGFiZWw6ICdWdWV4IEFjdGlvbnMnLFxuICAgICAgICBjb2xvcjogQ09MT1JfTElNRV81MDBcbiAgICAgIH0pO1xuXG4gICAgICBhcGkuYWRkSW5zcGVjdG9yKHtcbiAgICAgICAgaWQ6IElOU1BFQ1RPUl9JRCxcbiAgICAgICAgbGFiZWw6ICdWdWV4JyxcbiAgICAgICAgaWNvbjogJ3N0b3JhZ2UnLFxuICAgICAgICB0cmVlRmlsdGVyUGxhY2Vob2xkZXI6ICdGaWx0ZXIgc3RvcmVzLi4uJ1xuICAgICAgfSk7XG5cbiAgICAgIGFwaS5vbi5nZXRJbnNwZWN0b3JUcmVlKGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgICAgIGlmIChwYXlsb2FkLmFwcCA9PT0gYXBwICYmIHBheWxvYWQuaW5zcGVjdG9ySWQgPT09IElOU1BFQ1RPUl9JRCkge1xuICAgICAgICAgIGlmIChwYXlsb2FkLmZpbHRlcikge1xuICAgICAgICAgICAgdmFyIG5vZGVzID0gW107XG4gICAgICAgICAgICBmbGF0dGVuU3RvcmVGb3JJbnNwZWN0b3JUcmVlKG5vZGVzLCBzdG9yZS5fbW9kdWxlcy5yb290LCBwYXlsb2FkLmZpbHRlciwgJycpO1xuICAgICAgICAgICAgcGF5bG9hZC5yb290Tm9kZXMgPSBub2RlcztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGF5bG9hZC5yb290Tm9kZXMgPSBbXG4gICAgICAgICAgICAgIGZvcm1hdFN0b3JlRm9ySW5zcGVjdG9yVHJlZShzdG9yZS5fbW9kdWxlcy5yb290LCAnJylcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgYXBpLm9uLmdldEluc3BlY3RvclN0YXRlKGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgICAgIGlmIChwYXlsb2FkLmFwcCA9PT0gYXBwICYmIHBheWxvYWQuaW5zcGVjdG9ySWQgPT09IElOU1BFQ1RPUl9JRCkge1xuICAgICAgICAgIHZhciBtb2R1bGVQYXRoID0gcGF5bG9hZC5ub2RlSWQ7XG4gICAgICAgICAgbWFrZUxvY2FsR2V0dGVycyhzdG9yZSwgbW9kdWxlUGF0aCk7XG4gICAgICAgICAgcGF5bG9hZC5zdGF0ZSA9IGZvcm1hdFN0b3JlRm9ySW5zcGVjdG9yU3RhdGUoXG4gICAgICAgICAgICBnZXRTdG9yZU1vZHVsZShzdG9yZS5fbW9kdWxlcywgbW9kdWxlUGF0aCksXG4gICAgICAgICAgICBtb2R1bGVQYXRoID09PSAncm9vdCcgPyBzdG9yZS5nZXR0ZXJzIDogc3RvcmUuX21ha2VMb2NhbEdldHRlcnNDYWNoZSxcbiAgICAgICAgICAgIG1vZHVsZVBhdGhcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgYXBpLm9uLmVkaXRJbnNwZWN0b3JTdGF0ZShmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgICAgICBpZiAocGF5bG9hZC5hcHAgPT09IGFwcCAmJiBwYXlsb2FkLmluc3BlY3RvcklkID09PSBJTlNQRUNUT1JfSUQpIHtcbiAgICAgICAgICB2YXIgbW9kdWxlUGF0aCA9IHBheWxvYWQubm9kZUlkO1xuICAgICAgICAgIHZhciBwYXRoID0gcGF5bG9hZC5wYXRoO1xuICAgICAgICAgIGlmIChtb2R1bGVQYXRoICE9PSAncm9vdCcpIHtcbiAgICAgICAgICAgIHBhdGggPSBtb2R1bGVQYXRoLnNwbGl0KCcvJykuZmlsdGVyKEJvb2xlYW4pLmNvbmNhdCggcGF0aCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0b3JlLl93aXRoQ29tbWl0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHBheWxvYWQuc2V0KHN0b3JlLl9zdGF0ZS5kYXRhLCBwYXRoLCBwYXlsb2FkLnN0YXRlLnZhbHVlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHN0b3JlLnN1YnNjcmliZShmdW5jdGlvbiAobXV0YXRpb24sIHN0YXRlKSB7XG4gICAgICAgIHZhciBkYXRhID0ge307XG5cbiAgICAgICAgaWYgKG11dGF0aW9uLnBheWxvYWQpIHtcbiAgICAgICAgICBkYXRhLnBheWxvYWQgPSBtdXRhdGlvbi5wYXlsb2FkO1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YS5zdGF0ZSA9IHN0YXRlO1xuXG4gICAgICAgIGFwaS5ub3RpZnlDb21wb25lbnRVcGRhdGUoKTtcbiAgICAgICAgYXBpLnNlbmRJbnNwZWN0b3JUcmVlKElOU1BFQ1RPUl9JRCk7XG4gICAgICAgIGFwaS5zZW5kSW5zcGVjdG9yU3RhdGUoSU5TUEVDVE9SX0lEKTtcblxuICAgICAgICBhcGkuYWRkVGltZWxpbmVFdmVudCh7XG4gICAgICAgICAgbGF5ZXJJZDogTVVUQVRJT05TX0xBWUVSX0lELFxuICAgICAgICAgIGV2ZW50OiB7XG4gICAgICAgICAgICB0aW1lOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgdGl0bGU6IG11dGF0aW9uLnR5cGUsXG4gICAgICAgICAgICBkYXRhOiBkYXRhXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBzdG9yZS5zdWJzY3JpYmVBY3Rpb24oe1xuICAgICAgICBiZWZvcmU6IGZ1bmN0aW9uIChhY3Rpb24sIHN0YXRlKSB7XG4gICAgICAgICAgdmFyIGRhdGEgPSB7fTtcbiAgICAgICAgICBpZiAoYWN0aW9uLnBheWxvYWQpIHtcbiAgICAgICAgICAgIGRhdGEucGF5bG9hZCA9IGFjdGlvbi5wYXlsb2FkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhY3Rpb24uX2lkID0gYWN0aW9uSWQrKztcbiAgICAgICAgICBhY3Rpb24uX3RpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgIGRhdGEuc3RhdGUgPSBzdGF0ZTtcblxuICAgICAgICAgIGFwaS5hZGRUaW1lbGluZUV2ZW50KHtcbiAgICAgICAgICAgIGxheWVySWQ6IEFDVElPTlNfTEFZRVJfSUQsXG4gICAgICAgICAgICBldmVudDoge1xuICAgICAgICAgICAgICB0aW1lOiBhY3Rpb24uX3RpbWUsXG4gICAgICAgICAgICAgIHRpdGxlOiBhY3Rpb24udHlwZSxcbiAgICAgICAgICAgICAgZ3JvdXBJZDogYWN0aW9uLl9pZCxcbiAgICAgICAgICAgICAgc3VidGl0bGU6ICdzdGFydCcsXG4gICAgICAgICAgICAgIGRhdGE6IGRhdGFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgYWZ0ZXI6IGZ1bmN0aW9uIChhY3Rpb24sIHN0YXRlKSB7XG4gICAgICAgICAgdmFyIGRhdGEgPSB7fTtcbiAgICAgICAgICB2YXIgZHVyYXRpb24gPSBEYXRlLm5vdygpIC0gYWN0aW9uLl90aW1lO1xuICAgICAgICAgIGRhdGEuZHVyYXRpb24gPSB7XG4gICAgICAgICAgICBfY3VzdG9tOiB7XG4gICAgICAgICAgICAgIHR5cGU6ICdkdXJhdGlvbicsXG4gICAgICAgICAgICAgIGRpc3BsYXk6IChkdXJhdGlvbiArIFwibXNcIiksXG4gICAgICAgICAgICAgIHRvb2x0aXA6ICdBY3Rpb24gZHVyYXRpb24nLFxuICAgICAgICAgICAgICB2YWx1ZTogZHVyYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChhY3Rpb24ucGF5bG9hZCkge1xuICAgICAgICAgICAgZGF0YS5wYXlsb2FkID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRhdGEuc3RhdGUgPSBzdGF0ZTtcblxuICAgICAgICAgIGFwaS5hZGRUaW1lbGluZUV2ZW50KHtcbiAgICAgICAgICAgIGxheWVySWQ6IEFDVElPTlNfTEFZRVJfSUQsXG4gICAgICAgICAgICBldmVudDoge1xuICAgICAgICAgICAgICB0aW1lOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgICB0aXRsZTogYWN0aW9uLnR5cGUsXG4gICAgICAgICAgICAgIGdyb3VwSWQ6IGFjdGlvbi5faWQsXG4gICAgICAgICAgICAgIHN1YnRpdGxlOiAnZW5kJyxcbiAgICAgICAgICAgICAgZGF0YTogZGF0YVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICk7XG59XG5cbi8vIGV4dHJhY3RlZCBmcm9tIHRhaWx3aW5kIHBhbGV0dGVcbnZhciBDT0xPUl9MSU1FXzUwMCA9IDB4ODRjYzE2O1xudmFyIENPTE9SX0RBUksgPSAweDY2NjY2NjtcbnZhciBDT0xPUl9XSElURSA9IDB4ZmZmZmZmO1xuXG52YXIgVEFHX05BTUVTUEFDRUQgPSB7XG4gIGxhYmVsOiAnbmFtZXNwYWNlZCcsXG4gIHRleHRDb2xvcjogQ09MT1JfV0hJVEUsXG4gIGJhY2tncm91bmRDb2xvcjogQ09MT1JfREFSS1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aFxuICovXG5mdW5jdGlvbiBleHRyYWN0TmFtZUZyb21QYXRoIChwYXRoKSB7XG4gIHJldHVybiBwYXRoICYmIHBhdGggIT09ICdyb290JyA/IHBhdGguc3BsaXQoJy8nKS5zbGljZSgtMiwgLTEpWzBdIDogJ1Jvb3QnXG59XG5cbi8qKlxuICogQHBhcmFtIHsqfSBtb2R1bGVcbiAqIEByZXR1cm4ge2ltcG9ydCgnQHZ1ZS9kZXZ0b29scy1hcGknKS5DdXN0b21JbnNwZWN0b3JOb2RlfVxuICovXG5mdW5jdGlvbiBmb3JtYXRTdG9yZUZvckluc3BlY3RvclRyZWUgKG1vZHVsZSwgcGF0aCkge1xuICByZXR1cm4ge1xuICAgIGlkOiBwYXRoIHx8ICdyb290JyxcbiAgICAvLyBhbGwgbW9kdWxlcyBlbmQgd2l0aCBhIGAvYCwgd2Ugd2FudCB0aGUgbGFzdCBzZWdtZW50IG9ubHlcbiAgICAvLyBjYXJ0LyAtPiBjYXJ0XG4gICAgLy8gbmVzdGVkL2NhcnQvIC0+IGNhcnRcbiAgICBsYWJlbDogZXh0cmFjdE5hbWVGcm9tUGF0aChwYXRoKSxcbiAgICB0YWdzOiBtb2R1bGUubmFtZXNwYWNlZCA/IFtUQUdfTkFNRVNQQUNFRF0gOiBbXSxcbiAgICBjaGlsZHJlbjogT2JqZWN0LmtleXMobW9kdWxlLl9jaGlsZHJlbikubWFwKGZ1bmN0aW9uIChtb2R1bGVOYW1lKSB7IHJldHVybiBmb3JtYXRTdG9yZUZvckluc3BlY3RvclRyZWUoXG4gICAgICAgIG1vZHVsZS5fY2hpbGRyZW5bbW9kdWxlTmFtZV0sXG4gICAgICAgIHBhdGggKyBtb2R1bGVOYW1lICsgJy8nXG4gICAgICApOyB9XG4gICAgKVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJ0B2dWUvZGV2dG9vbHMtYXBpJykuQ3VzdG9tSW5zcGVjdG9yTm9kZVtdfSByZXN1bHRcbiAqIEBwYXJhbSB7Kn0gbW9kdWxlXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsdGVyXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aFxuICovXG5mdW5jdGlvbiBmbGF0dGVuU3RvcmVGb3JJbnNwZWN0b3JUcmVlIChyZXN1bHQsIG1vZHVsZSwgZmlsdGVyLCBwYXRoKSB7XG4gIGlmIChwYXRoLmluY2x1ZGVzKGZpbHRlcikpIHtcbiAgICByZXN1bHQucHVzaCh7XG4gICAgICBpZDogcGF0aCB8fCAncm9vdCcsXG4gICAgICBsYWJlbDogcGF0aC5lbmRzV2l0aCgnLycpID8gcGF0aC5zbGljZSgwLCBwYXRoLmxlbmd0aCAtIDEpIDogcGF0aCB8fCAnUm9vdCcsXG4gICAgICB0YWdzOiBtb2R1bGUubmFtZXNwYWNlZCA/IFtUQUdfTkFNRVNQQUNFRF0gOiBbXVxuICAgIH0pO1xuICB9XG4gIE9iamVjdC5rZXlzKG1vZHVsZS5fY2hpbGRyZW4pLmZvckVhY2goZnVuY3Rpb24gKG1vZHVsZU5hbWUpIHtcbiAgICBmbGF0dGVuU3RvcmVGb3JJbnNwZWN0b3JUcmVlKHJlc3VsdCwgbW9kdWxlLl9jaGlsZHJlblttb2R1bGVOYW1lXSwgZmlsdGVyLCBwYXRoICsgbW9kdWxlTmFtZSArICcvJyk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Kn0gbW9kdWxlXG4gKiBAcmV0dXJuIHtpbXBvcnQoJ0B2dWUvZGV2dG9vbHMtYXBpJykuQ3VzdG9tSW5zcGVjdG9yU3RhdGV9XG4gKi9cbmZ1bmN0aW9uIGZvcm1hdFN0b3JlRm9ySW5zcGVjdG9yU3RhdGUgKG1vZHVsZSwgZ2V0dGVycywgcGF0aCkge1xuICBnZXR0ZXJzID0gcGF0aCA9PT0gJ3Jvb3QnID8gZ2V0dGVycyA6IGdldHRlcnNbcGF0aF07XG4gIHZhciBnZXR0ZXJzS2V5cyA9IE9iamVjdC5rZXlzKGdldHRlcnMpO1xuICB2YXIgc3RvcmVTdGF0ZSA9IHtcbiAgICBzdGF0ZTogT2JqZWN0LmtleXMobW9kdWxlLnN0YXRlKS5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gKHtcbiAgICAgIGtleToga2V5LFxuICAgICAgZWRpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogbW9kdWxlLnN0YXRlW2tleV1cbiAgICB9KTsgfSlcbiAgfTtcblxuICBpZiAoZ2V0dGVyc0tleXMubGVuZ3RoKSB7XG4gICAgdmFyIHRyZWUgPSB0cmFuc2Zvcm1QYXRoc1RvT2JqZWN0VHJlZShnZXR0ZXJzKTtcbiAgICBzdG9yZVN0YXRlLmdldHRlcnMgPSBPYmplY3Qua2V5cyh0cmVlKS5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gKHtcbiAgICAgIGtleToga2V5LmVuZHNXaXRoKCcvJykgPyBleHRyYWN0TmFtZUZyb21QYXRoKGtleSkgOiBrZXksXG4gICAgICBlZGl0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogY2FuVGhyb3coZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJlZVtrZXldOyB9KVxuICAgIH0pOyB9KTtcbiAgfVxuXG4gIHJldHVybiBzdG9yZVN0YXRlXG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVBhdGhzVG9PYmplY3RUcmVlIChnZXR0ZXJzKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgT2JqZWN0LmtleXMoZ2V0dGVycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHBhdGggPSBrZXkuc3BsaXQoJy8nKTtcbiAgICBpZiAocGF0aC5sZW5ndGggPiAxKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gcmVzdWx0O1xuICAgICAgdmFyIGxlYWZLZXkgPSBwYXRoLnBvcCgpO1xuICAgICAgcGF0aC5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIGlmICghdGFyZ2V0W3BdKSB7XG4gICAgICAgICAgdGFyZ2V0W3BdID0ge1xuICAgICAgICAgICAgX2N1c3RvbToge1xuICAgICAgICAgICAgICB2YWx1ZToge30sXG4gICAgICAgICAgICAgIGRpc3BsYXk6IHAsXG4gICAgICAgICAgICAgIHRvb2x0aXA6ICdNb2R1bGUnLFxuICAgICAgICAgICAgICBhYnN0cmFjdDogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0W3BdLl9jdXN0b20udmFsdWU7XG4gICAgICB9KTtcbiAgICAgIHRhcmdldFtsZWFmS2V5XSA9IGNhblRocm93KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdldHRlcnNba2V5XTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdFtrZXldID0gY2FuVGhyb3coZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2V0dGVyc1trZXldOyB9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIGdldFN0b3JlTW9kdWxlIChtb2R1bGVNYXAsIHBhdGgpIHtcbiAgdmFyIG5hbWVzID0gcGF0aC5zcGxpdCgnLycpLmZpbHRlcihmdW5jdGlvbiAobikgeyByZXR1cm4gbjsgfSk7XG4gIHJldHVybiBuYW1lcy5yZWR1Y2UoXG4gICAgZnVuY3Rpb24gKG1vZHVsZSwgbW9kdWxlTmFtZSwgaSkge1xuICAgICAgdmFyIGNoaWxkID0gbW9kdWxlW21vZHVsZU5hbWVdO1xuICAgICAgaWYgKCFjaGlsZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKFwiTWlzc2luZyBtb2R1bGUgXFxcIlwiICsgbW9kdWxlTmFtZSArIFwiXFxcIiBmb3IgcGF0aCBcXFwiXCIgKyBwYXRoICsgXCJcXFwiLlwiKSlcbiAgICAgIH1cbiAgICAgIHJldHVybiBpID09PSBuYW1lcy5sZW5ndGggLSAxID8gY2hpbGQgOiBjaGlsZC5fY2hpbGRyZW5cbiAgICB9LFxuICAgIHBhdGggPT09ICdyb290JyA/IG1vZHVsZU1hcCA6IG1vZHVsZU1hcC5yb290Ll9jaGlsZHJlblxuICApXG59XG5cbmZ1bmN0aW9uIGNhblRocm93IChjYikge1xuICB0cnkge1xuICAgIHJldHVybiBjYigpXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZVxuICB9XG59XG5cbi8vIEJhc2UgZGF0YSBzdHJ1Y3QgZm9yIHN0b3JlJ3MgbW9kdWxlLCBwYWNrYWdlIHdpdGggc29tZSBhdHRyaWJ1dGUgYW5kIG1ldGhvZFxudmFyIE1vZHVsZSA9IGZ1bmN0aW9uIE1vZHVsZSAocmF3TW9kdWxlLCBydW50aW1lKSB7XG4gIHRoaXMucnVudGltZSA9IHJ1bnRpbWU7XG4gIC8vIFN0b3JlIHNvbWUgY2hpbGRyZW4gaXRlbVxuICB0aGlzLl9jaGlsZHJlbiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIC8vIFN0b3JlIHRoZSBvcmlnaW4gbW9kdWxlIG9iamVjdCB3aGljaCBwYXNzZWQgYnkgcHJvZ3JhbW1lclxuICB0aGlzLl9yYXdNb2R1bGUgPSByYXdNb2R1bGU7XG4gIHZhciByYXdTdGF0ZSA9IHJhd01vZHVsZS5zdGF0ZTtcblxuICAvLyBTdG9yZSB0aGUgb3JpZ2luIG1vZHVsZSdzIHN0YXRlXG4gIHRoaXMuc3RhdGUgPSAodHlwZW9mIHJhd1N0YXRlID09PSAnZnVuY3Rpb24nID8gcmF3U3RhdGUoKSA6IHJhd1N0YXRlKSB8fCB7fTtcbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMkMSA9IHsgbmFtZXNwYWNlZDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG5wcm90b3R5cGVBY2Nlc3NvcnMkMS5uYW1lc3BhY2VkLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICEhdGhpcy5fcmF3TW9kdWxlLm5hbWVzcGFjZWRcbn07XG5cbk1vZHVsZS5wcm90b3R5cGUuYWRkQ2hpbGQgPSBmdW5jdGlvbiBhZGRDaGlsZCAoa2V5LCBtb2R1bGUpIHtcbiAgdGhpcy5fY2hpbGRyZW5ba2V5XSA9IG1vZHVsZTtcbn07XG5cbk1vZHVsZS5wcm90b3R5cGUucmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbiByZW1vdmVDaGlsZCAoa2V5KSB7XG4gIGRlbGV0ZSB0aGlzLl9jaGlsZHJlbltrZXldO1xufTtcblxuTW9kdWxlLnByb3RvdHlwZS5nZXRDaGlsZCA9IGZ1bmN0aW9uIGdldENoaWxkIChrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuW2tleV1cbn07XG5cbk1vZHVsZS5wcm90b3R5cGUuaGFzQ2hpbGQgPSBmdW5jdGlvbiBoYXNDaGlsZCAoa2V5KSB7XG4gIHJldHVybiBrZXkgaW4gdGhpcy5fY2hpbGRyZW5cbn07XG5cbk1vZHVsZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlIChyYXdNb2R1bGUpIHtcbiAgdGhpcy5fcmF3TW9kdWxlLm5hbWVzcGFjZWQgPSByYXdNb2R1bGUubmFtZXNwYWNlZDtcbiAgaWYgKHJhd01vZHVsZS5hY3Rpb25zKSB7XG4gICAgdGhpcy5fcmF3TW9kdWxlLmFjdGlvbnMgPSByYXdNb2R1bGUuYWN0aW9ucztcbiAgfVxuICBpZiAocmF3TW9kdWxlLm11dGF0aW9ucykge1xuICAgIHRoaXMuX3Jhd01vZHVsZS5tdXRhdGlvbnMgPSByYXdNb2R1bGUubXV0YXRpb25zO1xuICB9XG4gIGlmIChyYXdNb2R1bGUuZ2V0dGVycykge1xuICAgIHRoaXMuX3Jhd01vZHVsZS5nZXR0ZXJzID0gcmF3TW9kdWxlLmdldHRlcnM7XG4gIH1cbn07XG5cbk1vZHVsZS5wcm90b3R5cGUuZm9yRWFjaENoaWxkID0gZnVuY3Rpb24gZm9yRWFjaENoaWxkIChmbikge1xuICBmb3JFYWNoVmFsdWUodGhpcy5fY2hpbGRyZW4sIGZuKTtcbn07XG5cbk1vZHVsZS5wcm90b3R5cGUuZm9yRWFjaEdldHRlciA9IGZ1bmN0aW9uIGZvckVhY2hHZXR0ZXIgKGZuKSB7XG4gIGlmICh0aGlzLl9yYXdNb2R1bGUuZ2V0dGVycykge1xuICAgIGZvckVhY2hWYWx1ZSh0aGlzLl9yYXdNb2R1bGUuZ2V0dGVycywgZm4pO1xuICB9XG59O1xuXG5Nb2R1bGUucHJvdG90eXBlLmZvckVhY2hBY3Rpb24gPSBmdW5jdGlvbiBmb3JFYWNoQWN0aW9uIChmbikge1xuICBpZiAodGhpcy5fcmF3TW9kdWxlLmFjdGlvbnMpIHtcbiAgICBmb3JFYWNoVmFsdWUodGhpcy5fcmF3TW9kdWxlLmFjdGlvbnMsIGZuKTtcbiAgfVxufTtcblxuTW9kdWxlLnByb3RvdHlwZS5mb3JFYWNoTXV0YXRpb24gPSBmdW5jdGlvbiBmb3JFYWNoTXV0YXRpb24gKGZuKSB7XG4gIGlmICh0aGlzLl9yYXdNb2R1bGUubXV0YXRpb25zKSB7XG4gICAgZm9yRWFjaFZhbHVlKHRoaXMuX3Jhd01vZHVsZS5tdXRhdGlvbnMsIGZuKTtcbiAgfVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIE1vZHVsZS5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyQxICk7XG5cbnZhciBNb2R1bGVDb2xsZWN0aW9uID0gZnVuY3Rpb24gTW9kdWxlQ29sbGVjdGlvbiAocmF3Um9vdE1vZHVsZSkge1xuICAvLyByZWdpc3RlciByb290IG1vZHVsZSAoVnVleC5TdG9yZSBvcHRpb25zKVxuICB0aGlzLnJlZ2lzdGVyKFtdLCByYXdSb290TW9kdWxlLCBmYWxzZSk7XG59O1xuXG5Nb2R1bGVDb2xsZWN0aW9uLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGgucmVkdWNlKGZ1bmN0aW9uIChtb2R1bGUsIGtleSkge1xuICAgIHJldHVybiBtb2R1bGUuZ2V0Q2hpbGQoa2V5KVxuICB9LCB0aGlzLnJvb3QpXG59O1xuXG5Nb2R1bGVDb2xsZWN0aW9uLnByb3RvdHlwZS5nZXROYW1lc3BhY2UgPSBmdW5jdGlvbiBnZXROYW1lc3BhY2UgKHBhdGgpIHtcbiAgdmFyIG1vZHVsZSA9IHRoaXMucm9vdDtcbiAgcmV0dXJuIHBhdGgucmVkdWNlKGZ1bmN0aW9uIChuYW1lc3BhY2UsIGtleSkge1xuICAgIG1vZHVsZSA9IG1vZHVsZS5nZXRDaGlsZChrZXkpO1xuICAgIHJldHVybiBuYW1lc3BhY2UgKyAobW9kdWxlLm5hbWVzcGFjZWQgPyBrZXkgKyAnLycgOiAnJylcbiAgfSwgJycpXG59O1xuXG5Nb2R1bGVDb2xsZWN0aW9uLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUkMSAocmF3Um9vdE1vZHVsZSkge1xuICB1cGRhdGUoW10sIHRoaXMucm9vdCwgcmF3Um9vdE1vZHVsZSk7XG59O1xuXG5Nb2R1bGVDb2xsZWN0aW9uLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIHJlZ2lzdGVyIChwYXRoLCByYXdNb2R1bGUsIHJ1bnRpbWUpIHtcbiAgICB2YXIgdGhpcyQxJDEgPSB0aGlzO1xuICAgIGlmICggcnVudGltZSA9PT0gdm9pZCAwICkgcnVudGltZSA9IHRydWU7XG5cbiAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgIGFzc2VydFJhd01vZHVsZShwYXRoLCByYXdNb2R1bGUpO1xuICB9XG5cbiAgdmFyIG5ld01vZHVsZSA9IG5ldyBNb2R1bGUocmF3TW9kdWxlLCBydW50aW1lKTtcbiAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgdGhpcy5yb290ID0gbmV3TW9kdWxlO1xuICB9IGVsc2Uge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzLmdldChwYXRoLnNsaWNlKDAsIC0xKSk7XG4gICAgcGFyZW50LmFkZENoaWxkKHBhdGhbcGF0aC5sZW5ndGggLSAxXSwgbmV3TW9kdWxlKTtcbiAgfVxuXG4gIC8vIHJlZ2lzdGVyIG5lc3RlZCBtb2R1bGVzXG4gIGlmIChyYXdNb2R1bGUubW9kdWxlcykge1xuICAgIGZvckVhY2hWYWx1ZShyYXdNb2R1bGUubW9kdWxlcywgZnVuY3Rpb24gKHJhd0NoaWxkTW9kdWxlLCBrZXkpIHtcbiAgICAgIHRoaXMkMSQxLnJlZ2lzdGVyKHBhdGguY29uY2F0KGtleSksIHJhd0NoaWxkTW9kdWxlLCBydW50aW1lKTtcbiAgICB9KTtcbiAgfVxufTtcblxuTW9kdWxlQ29sbGVjdGlvbi5wcm90b3R5cGUudW5yZWdpc3RlciA9IGZ1bmN0aW9uIHVucmVnaXN0ZXIgKHBhdGgpIHtcbiAgdmFyIHBhcmVudCA9IHRoaXMuZ2V0KHBhdGguc2xpY2UoMCwgLTEpKTtcbiAgdmFyIGtleSA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgdmFyIGNoaWxkID0gcGFyZW50LmdldENoaWxkKGtleSk7XG5cbiAgaWYgKCFjaGlsZCkge1xuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgXCJbdnVleF0gdHJ5aW5nIHRvIHVucmVnaXN0ZXIgbW9kdWxlICdcIiArIGtleSArIFwiJywgd2hpY2ggaXMgXCIgK1xuICAgICAgICBcIm5vdCByZWdpc3RlcmVkXCJcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKCFjaGlsZC5ydW50aW1lKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBwYXJlbnQucmVtb3ZlQ2hpbGQoa2V5KTtcbn07XG5cbk1vZHVsZUNvbGxlY3Rpb24ucHJvdG90eXBlLmlzUmVnaXN0ZXJlZCA9IGZ1bmN0aW9uIGlzUmVnaXN0ZXJlZCAocGF0aCkge1xuICB2YXIgcGFyZW50ID0gdGhpcy5nZXQocGF0aC5zbGljZSgwLCAtMSkpO1xuICB2YXIga2V5ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuXG4gIGlmIChwYXJlbnQpIHtcbiAgICByZXR1cm4gcGFyZW50Lmhhc0NoaWxkKGtleSlcbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufTtcblxuZnVuY3Rpb24gdXBkYXRlIChwYXRoLCB0YXJnZXRNb2R1bGUsIG5ld01vZHVsZSkge1xuICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgYXNzZXJ0UmF3TW9kdWxlKHBhdGgsIG5ld01vZHVsZSk7XG4gIH1cblxuICAvLyB1cGRhdGUgdGFyZ2V0IG1vZHVsZVxuICB0YXJnZXRNb2R1bGUudXBkYXRlKG5ld01vZHVsZSk7XG5cbiAgLy8gdXBkYXRlIG5lc3RlZCBtb2R1bGVzXG4gIGlmIChuZXdNb2R1bGUubW9kdWxlcykge1xuICAgIGZvciAodmFyIGtleSBpbiBuZXdNb2R1bGUubW9kdWxlcykge1xuICAgICAgaWYgKCF0YXJnZXRNb2R1bGUuZ2V0Q2hpbGQoa2V5KSkge1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgXCJbdnVleF0gdHJ5aW5nIHRvIGFkZCBhIG5ldyBtb2R1bGUgJ1wiICsga2V5ICsgXCInIG9uIGhvdCByZWxvYWRpbmcsIFwiICtcbiAgICAgICAgICAgICdtYW51YWwgcmVsb2FkIGlzIG5lZWRlZCdcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdXBkYXRlKFxuICAgICAgICBwYXRoLmNvbmNhdChrZXkpLFxuICAgICAgICB0YXJnZXRNb2R1bGUuZ2V0Q2hpbGQoa2V5KSxcbiAgICAgICAgbmV3TW9kdWxlLm1vZHVsZXNba2V5XVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGZ1bmN0aW9uQXNzZXJ0ID0ge1xuICBhc3NlcnQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nOyB9LFxuICBleHBlY3RlZDogJ2Z1bmN0aW9uJ1xufTtcblxudmFyIG9iamVjdEFzc2VydCA9IHtcbiAgYXNzZXJ0OiBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHR5cGVvZiB2YWx1ZS5oYW5kbGVyID09PSAnZnVuY3Rpb24nKTsgfSxcbiAgZXhwZWN0ZWQ6ICdmdW5jdGlvbiBvciBvYmplY3Qgd2l0aCBcImhhbmRsZXJcIiBmdW5jdGlvbidcbn07XG5cbnZhciBhc3NlcnRUeXBlcyA9IHtcbiAgZ2V0dGVyczogZnVuY3Rpb25Bc3NlcnQsXG4gIG11dGF0aW9uczogZnVuY3Rpb25Bc3NlcnQsXG4gIGFjdGlvbnM6IG9iamVjdEFzc2VydFxufTtcblxuZnVuY3Rpb24gYXNzZXJ0UmF3TW9kdWxlIChwYXRoLCByYXdNb2R1bGUpIHtcbiAgT2JqZWN0LmtleXMoYXNzZXJ0VHlwZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGlmICghcmF3TW9kdWxlW2tleV0pIHsgcmV0dXJuIH1cblxuICAgIHZhciBhc3NlcnRPcHRpb25zID0gYXNzZXJ0VHlwZXNba2V5XTtcblxuICAgIGZvckVhY2hWYWx1ZShyYXdNb2R1bGVba2V5XSwgZnVuY3Rpb24gKHZhbHVlLCB0eXBlKSB7XG4gICAgICBhc3NlcnQoXG4gICAgICAgIGFzc2VydE9wdGlvbnMuYXNzZXJ0KHZhbHVlKSxcbiAgICAgICAgbWFrZUFzc2VydGlvbk1lc3NhZ2UocGF0aCwga2V5LCB0eXBlLCB2YWx1ZSwgYXNzZXJ0T3B0aW9ucy5leHBlY3RlZClcbiAgICAgICk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBtYWtlQXNzZXJ0aW9uTWVzc2FnZSAocGF0aCwga2V5LCB0eXBlLCB2YWx1ZSwgZXhwZWN0ZWQpIHtcbiAgdmFyIGJ1ZiA9IGtleSArIFwiIHNob3VsZCBiZSBcIiArIGV4cGVjdGVkICsgXCIgYnV0IFxcXCJcIiArIGtleSArIFwiLlwiICsgdHlwZSArIFwiXFxcIlwiO1xuICBpZiAocGF0aC5sZW5ndGggPiAwKSB7XG4gICAgYnVmICs9IFwiIGluIG1vZHVsZSBcXFwiXCIgKyAocGF0aC5qb2luKCcuJykpICsgXCJcXFwiXCI7XG4gIH1cbiAgYnVmICs9IFwiIGlzIFwiICsgKEpTT04uc3RyaW5naWZ5KHZhbHVlKSkgKyBcIi5cIjtcbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdG9yZSAob3B0aW9ucykge1xuICByZXR1cm4gbmV3IFN0b3JlKG9wdGlvbnMpXG59XG5cbnZhciBTdG9yZSA9IGZ1bmN0aW9uIFN0b3JlIChvcHRpb25zKSB7XG4gIHZhciB0aGlzJDEkMSA9IHRoaXM7XG4gIGlmICggb3B0aW9ucyA9PT0gdm9pZCAwICkgb3B0aW9ucyA9IHt9O1xuXG4gIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICBhc3NlcnQodHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnLCBcInZ1ZXggcmVxdWlyZXMgYSBQcm9taXNlIHBvbHlmaWxsIGluIHRoaXMgYnJvd3Nlci5cIik7XG4gICAgYXNzZXJ0KHRoaXMgaW5zdGFuY2VvZiBTdG9yZSwgXCJzdG9yZSBtdXN0IGJlIGNhbGxlZCB3aXRoIHRoZSBuZXcgb3BlcmF0b3IuXCIpO1xuICB9XG5cbiAgdmFyIHBsdWdpbnMgPSBvcHRpb25zLnBsdWdpbnM7IGlmICggcGx1Z2lucyA9PT0gdm9pZCAwICkgcGx1Z2lucyA9IFtdO1xuICB2YXIgc3RyaWN0ID0gb3B0aW9ucy5zdHJpY3Q7IGlmICggc3RyaWN0ID09PSB2b2lkIDAgKSBzdHJpY3QgPSBmYWxzZTtcbiAgdmFyIGRldnRvb2xzID0gb3B0aW9ucy5kZXZ0b29scztcblxuICAvLyBzdG9yZSBpbnRlcm5hbCBzdGF0ZVxuICB0aGlzLl9jb21taXR0aW5nID0gZmFsc2U7XG4gIHRoaXMuX2FjdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB0aGlzLl9hY3Rpb25TdWJzY3JpYmVycyA9IFtdO1xuICB0aGlzLl9tdXRhdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB0aGlzLl93cmFwcGVkR2V0dGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHRoaXMuX21vZHVsZXMgPSBuZXcgTW9kdWxlQ29sbGVjdGlvbihvcHRpb25zKTtcbiAgdGhpcy5fbW9kdWxlc05hbWVzcGFjZU1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHRoaXMuX3N1YnNjcmliZXJzID0gW107XG4gIHRoaXMuX21ha2VMb2NhbEdldHRlcnNDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHRoaXMuX2RldnRvb2xzID0gZGV2dG9vbHM7XG5cbiAgLy8gYmluZCBjb21taXQgYW5kIGRpc3BhdGNoIHRvIHNlbGZcbiAgdmFyIHN0b3JlID0gdGhpcztcbiAgdmFyIHJlZiA9IHRoaXM7XG4gIHZhciBkaXNwYXRjaCA9IHJlZi5kaXNwYXRjaDtcbiAgdmFyIGNvbW1pdCA9IHJlZi5jb21taXQ7XG4gIHRoaXMuZGlzcGF0Y2ggPSBmdW5jdGlvbiBib3VuZERpc3BhdGNoICh0eXBlLCBwYXlsb2FkKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoLmNhbGwoc3RvcmUsIHR5cGUsIHBheWxvYWQpXG4gIH07XG4gIHRoaXMuY29tbWl0ID0gZnVuY3Rpb24gYm91bmRDb21taXQgKHR5cGUsIHBheWxvYWQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gY29tbWl0LmNhbGwoc3RvcmUsIHR5cGUsIHBheWxvYWQsIG9wdGlvbnMpXG4gIH07XG5cbiAgLy8gc3RyaWN0IG1vZGVcbiAgdGhpcy5zdHJpY3QgPSBzdHJpY3Q7XG5cbiAgdmFyIHN0YXRlID0gdGhpcy5fbW9kdWxlcy5yb290LnN0YXRlO1xuXG4gIC8vIGluaXQgcm9vdCBtb2R1bGUuXG4gIC8vIHRoaXMgYWxzbyByZWN1cnNpdmVseSByZWdpc3RlcnMgYWxsIHN1Yi1tb2R1bGVzXG4gIC8vIGFuZCBjb2xsZWN0cyBhbGwgbW9kdWxlIGdldHRlcnMgaW5zaWRlIHRoaXMuX3dyYXBwZWRHZXR0ZXJzXG4gIGluc3RhbGxNb2R1bGUodGhpcywgc3RhdGUsIFtdLCB0aGlzLl9tb2R1bGVzLnJvb3QpO1xuXG4gIC8vIGluaXRpYWxpemUgdGhlIHN0b3JlIHN0YXRlLCB3aGljaCBpcyByZXNwb25zaWJsZSBmb3IgdGhlIHJlYWN0aXZpdHlcbiAgLy8gKGFsc28gcmVnaXN0ZXJzIF93cmFwcGVkR2V0dGVycyBhcyBjb21wdXRlZCBwcm9wZXJ0aWVzKVxuICByZXNldFN0b3JlU3RhdGUodGhpcywgc3RhdGUpO1xuXG4gIC8vIGFwcGx5IHBsdWdpbnNcbiAgcGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHsgcmV0dXJuIHBsdWdpbih0aGlzJDEkMSk7IH0pO1xufTtcblxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgc3RhdGU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxuU3RvcmUucHJvdG90eXBlLmluc3RhbGwgPSBmdW5jdGlvbiBpbnN0YWxsIChhcHAsIGluamVjdEtleSkge1xuICBhcHAucHJvdmlkZShpbmplY3RLZXkgfHwgc3RvcmVLZXksIHRoaXMpO1xuICBhcHAuY29uZmlnLmdsb2JhbFByb3BlcnRpZXMuJHN0b3JlID0gdGhpcztcblxuICB2YXIgdXNlRGV2dG9vbHMgPSB0aGlzLl9kZXZ0b29scyAhPT0gdW5kZWZpbmVkXG4gICAgPyB0aGlzLl9kZXZ0b29sc1xuICAgIDogKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXztcblxuICBpZiAodXNlRGV2dG9vbHMpIHtcbiAgICBhZGREZXZ0b29scyhhcHAsIHRoaXMpO1xuICB9XG59O1xuXG5wcm90b3R5cGVBY2Nlc3NvcnMuc3RhdGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fc3RhdGUuZGF0YVxufTtcblxucHJvdG90eXBlQWNjZXNzb3JzLnN0YXRlLnNldCA9IGZ1bmN0aW9uICh2KSB7XG4gIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICBhc3NlcnQoZmFsc2UsIFwidXNlIHN0b3JlLnJlcGxhY2VTdGF0ZSgpIHRvIGV4cGxpY2l0IHJlcGxhY2Ugc3RvcmUgc3RhdGUuXCIpO1xuICB9XG59O1xuXG5TdG9yZS5wcm90b3R5cGUuY29tbWl0ID0gZnVuY3Rpb24gY29tbWl0IChfdHlwZSwgX3BheWxvYWQsIF9vcHRpb25zKSB7XG4gICAgdmFyIHRoaXMkMSQxID0gdGhpcztcblxuICAvLyBjaGVjayBvYmplY3Qtc3R5bGUgY29tbWl0XG4gIHZhciByZWYgPSB1bmlmeU9iamVjdFN0eWxlKF90eXBlLCBfcGF5bG9hZCwgX29wdGlvbnMpO1xuICAgIHZhciB0eXBlID0gcmVmLnR5cGU7XG4gICAgdmFyIHBheWxvYWQgPSByZWYucGF5bG9hZDtcbiAgICB2YXIgb3B0aW9ucyA9IHJlZi5vcHRpb25zO1xuXG4gIHZhciBtdXRhdGlvbiA9IHsgdHlwZTogdHlwZSwgcGF5bG9hZDogcGF5bG9hZCB9O1xuICB2YXIgZW50cnkgPSB0aGlzLl9tdXRhdGlvbnNbdHlwZV07XG4gIGlmICghZW50cnkpIHtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKChcIlt2dWV4XSB1bmtub3duIG11dGF0aW9uIHR5cGU6IFwiICsgdHlwZSkpO1xuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuICB0aGlzLl93aXRoQ29tbWl0KGZ1bmN0aW9uICgpIHtcbiAgICBlbnRyeS5mb3JFYWNoKGZ1bmN0aW9uIGNvbW1pdEl0ZXJhdG9yIChoYW5kbGVyKSB7XG4gICAgICBoYW5kbGVyKHBheWxvYWQpO1xuICAgIH0pO1xuICB9KTtcblxuICB0aGlzLl9zdWJzY3JpYmVyc1xuICAgIC5zbGljZSgpIC8vIHNoYWxsb3cgY29weSB0byBwcmV2ZW50IGl0ZXJhdG9yIGludmFsaWRhdGlvbiBpZiBzdWJzY3JpYmVyIHN5bmNocm9ub3VzbHkgY2FsbHMgdW5zdWJzY3JpYmVcbiAgICAuZm9yRWFjaChmdW5jdGlvbiAoc3ViKSB7IHJldHVybiBzdWIobXV0YXRpb24sIHRoaXMkMSQxLnN0YXRlKTsgfSk7XG5cbiAgaWYgKFxuICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxuICAgIG9wdGlvbnMgJiYgb3B0aW9ucy5zaWxlbnRcbiAgKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgXCJbdnVleF0gbXV0YXRpb24gdHlwZTogXCIgKyB0eXBlICsgXCIuIFNpbGVudCBvcHRpb24gaGFzIGJlZW4gcmVtb3ZlZC4gXCIgK1xuICAgICAgJ1VzZSB0aGUgZmlsdGVyIGZ1bmN0aW9uYWxpdHkgaW4gdGhlIHZ1ZS1kZXZ0b29scydcbiAgICApO1xuICB9XG59O1xuXG5TdG9yZS5wcm90b3R5cGUuZGlzcGF0Y2ggPSBmdW5jdGlvbiBkaXNwYXRjaCAoX3R5cGUsIF9wYXlsb2FkKSB7XG4gICAgdmFyIHRoaXMkMSQxID0gdGhpcztcblxuICAvLyBjaGVjayBvYmplY3Qtc3R5bGUgZGlzcGF0Y2hcbiAgdmFyIHJlZiA9IHVuaWZ5T2JqZWN0U3R5bGUoX3R5cGUsIF9wYXlsb2FkKTtcbiAgICB2YXIgdHlwZSA9IHJlZi50eXBlO1xuICAgIHZhciBwYXlsb2FkID0gcmVmLnBheWxvYWQ7XG5cbiAgdmFyIGFjdGlvbiA9IHsgdHlwZTogdHlwZSwgcGF5bG9hZDogcGF5bG9hZCB9O1xuICB2YXIgZW50cnkgPSB0aGlzLl9hY3Rpb25zW3R5cGVdO1xuICBpZiAoIWVudHJ5KSB7XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gdW5rbm93biBhY3Rpb24gdHlwZTogXCIgKyB0eXBlKSk7XG4gICAgfVxuICAgIHJldHVyblxuICB9XG5cbiAgdHJ5IHtcbiAgICB0aGlzLl9hY3Rpb25TdWJzY3JpYmVyc1xuICAgICAgLnNsaWNlKCkgLy8gc2hhbGxvdyBjb3B5IHRvIHByZXZlbnQgaXRlcmF0b3IgaW52YWxpZGF0aW9uIGlmIHN1YnNjcmliZXIgc3luY2hyb25vdXNseSBjYWxscyB1bnN1YnNjcmliZVxuICAgICAgLmZpbHRlcihmdW5jdGlvbiAoc3ViKSB7IHJldHVybiBzdWIuYmVmb3JlOyB9KVxuICAgICAgLmZvckVhY2goZnVuY3Rpb24gKHN1YikgeyByZXR1cm4gc3ViLmJlZm9yZShhY3Rpb24sIHRoaXMkMSQxLnN0YXRlKTsgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJbdnVleF0gZXJyb3IgaW4gYmVmb3JlIGFjdGlvbiBzdWJzY3JpYmVyczogXCIpO1xuICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gZW50cnkubGVuZ3RoID4gMVxuICAgID8gUHJvbWlzZS5hbGwoZW50cnkubWFwKGZ1bmN0aW9uIChoYW5kbGVyKSB7IHJldHVybiBoYW5kbGVyKHBheWxvYWQpOyB9KSlcbiAgICA6IGVudHJ5WzBdKHBheWxvYWQpO1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgcmVzdWx0LnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcyQxJDEuX2FjdGlvblN1YnNjcmliZXJzXG4gICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoc3ViKSB7IHJldHVybiBzdWIuYWZ0ZXI7IH0pXG4gICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKHN1YikgeyByZXR1cm4gc3ViLmFmdGVyKGFjdGlvbiwgdGhpcyQxJDEuc3RhdGUpOyB9KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIlt2dWV4XSBlcnJvciBpbiBhZnRlciBhY3Rpb24gc3Vic2NyaWJlcnM6IFwiKTtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXNvbHZlKHJlcyk7XG4gICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzJDEkMS5fYWN0aW9uU3Vic2NyaWJlcnNcbiAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChzdWIpIHsgcmV0dXJuIHN1Yi5lcnJvcjsgfSlcbiAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAoc3ViKSB7IHJldHVybiBzdWIuZXJyb3IoYWN0aW9uLCB0aGlzJDEkMS5zdGF0ZSwgZXJyb3IpOyB9KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIlt2dWV4XSBlcnJvciBpbiBlcnJvciBhY3Rpb24gc3Vic2NyaWJlcnM6IFwiKTtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZWplY3QoZXJyb3IpO1xuICAgIH0pO1xuICB9KVxufTtcblxuU3RvcmUucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIHN1YnNjcmliZSAoZm4sIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGdlbmVyaWNTdWJzY3JpYmUoZm4sIHRoaXMuX3N1YnNjcmliZXJzLCBvcHRpb25zKVxufTtcblxuU3RvcmUucHJvdG90eXBlLnN1YnNjcmliZUFjdGlvbiA9IGZ1bmN0aW9uIHN1YnNjcmliZUFjdGlvbiAoZm4sIG9wdGlvbnMpIHtcbiAgdmFyIHN1YnMgPSB0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicgPyB7IGJlZm9yZTogZm4gfSA6IGZuO1xuICByZXR1cm4gZ2VuZXJpY1N1YnNjcmliZShzdWJzLCB0aGlzLl9hY3Rpb25TdWJzY3JpYmVycywgb3B0aW9ucylcbn07XG5cblN0b3JlLnByb3RvdHlwZS53YXRjaCA9IGZ1bmN0aW9uIHdhdGNoJDEgKGdldHRlciwgY2IsIG9wdGlvbnMpIHtcbiAgICB2YXIgdGhpcyQxJDEgPSB0aGlzO1xuXG4gIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICBhc3NlcnQodHlwZW9mIGdldHRlciA9PT0gJ2Z1bmN0aW9uJywgXCJzdG9yZS53YXRjaCBvbmx5IGFjY2VwdHMgYSBmdW5jdGlvbi5cIik7XG4gIH1cbiAgcmV0dXJuIHdhdGNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdldHRlcih0aGlzJDEkMS5zdGF0ZSwgdGhpcyQxJDEuZ2V0dGVycyk7IH0sIGNiLCBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSlcbn07XG5cblN0b3JlLnByb3RvdHlwZS5yZXBsYWNlU3RhdGUgPSBmdW5jdGlvbiByZXBsYWNlU3RhdGUgKHN0YXRlKSB7XG4gICAgdmFyIHRoaXMkMSQxID0gdGhpcztcblxuICB0aGlzLl93aXRoQ29tbWl0KGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzJDEkMS5fc3RhdGUuZGF0YSA9IHN0YXRlO1xuICB9KTtcbn07XG5cblN0b3JlLnByb3RvdHlwZS5yZWdpc3Rlck1vZHVsZSA9IGZ1bmN0aW9uIHJlZ2lzdGVyTW9kdWxlIChwYXRoLCByYXdNb2R1bGUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7IHBhdGggPSBbcGF0aF07IH1cblxuICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgYXNzZXJ0KEFycmF5LmlzQXJyYXkocGF0aCksIFwibW9kdWxlIHBhdGggbXVzdCBiZSBhIHN0cmluZyBvciBhbiBBcnJheS5cIik7XG4gICAgYXNzZXJ0KHBhdGgubGVuZ3RoID4gMCwgJ2Nhbm5vdCByZWdpc3RlciB0aGUgcm9vdCBtb2R1bGUgYnkgdXNpbmcgcmVnaXN0ZXJNb2R1bGUuJyk7XG4gIH1cblxuICB0aGlzLl9tb2R1bGVzLnJlZ2lzdGVyKHBhdGgsIHJhd01vZHVsZSk7XG4gIGluc3RhbGxNb2R1bGUodGhpcywgdGhpcy5zdGF0ZSwgcGF0aCwgdGhpcy5fbW9kdWxlcy5nZXQocGF0aCksIG9wdGlvbnMucHJlc2VydmVTdGF0ZSk7XG4gIC8vIHJlc2V0IHN0b3JlIHRvIHVwZGF0ZSBnZXR0ZXJzLi4uXG4gIHJlc2V0U3RvcmVTdGF0ZSh0aGlzLCB0aGlzLnN0YXRlKTtcbn07XG5cblN0b3JlLnByb3RvdHlwZS51bnJlZ2lzdGVyTW9kdWxlID0gZnVuY3Rpb24gdW5yZWdpc3Rlck1vZHVsZSAocGF0aCkge1xuICAgIHZhciB0aGlzJDEkMSA9IHRoaXM7XG5cbiAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykgeyBwYXRoID0gW3BhdGhdOyB9XG5cbiAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgIGFzc2VydChBcnJheS5pc0FycmF5KHBhdGgpLCBcIm1vZHVsZSBwYXRoIG11c3QgYmUgYSBzdHJpbmcgb3IgYW4gQXJyYXkuXCIpO1xuICB9XG5cbiAgdGhpcy5fbW9kdWxlcy51bnJlZ2lzdGVyKHBhdGgpO1xuICB0aGlzLl93aXRoQ29tbWl0KGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGFyZW50U3RhdGUgPSBnZXROZXN0ZWRTdGF0ZSh0aGlzJDEkMS5zdGF0ZSwgcGF0aC5zbGljZSgwLCAtMSkpO1xuICAgIGRlbGV0ZSBwYXJlbnRTdGF0ZVtwYXRoW3BhdGgubGVuZ3RoIC0gMV1dO1xuICB9KTtcbiAgcmVzZXRTdG9yZSh0aGlzKTtcbn07XG5cblN0b3JlLnByb3RvdHlwZS5oYXNNb2R1bGUgPSBmdW5jdGlvbiBoYXNNb2R1bGUgKHBhdGgpIHtcbiAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykgeyBwYXRoID0gW3BhdGhdOyB9XG5cbiAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgIGFzc2VydChBcnJheS5pc0FycmF5KHBhdGgpLCBcIm1vZHVsZSBwYXRoIG11c3QgYmUgYSBzdHJpbmcgb3IgYW4gQXJyYXkuXCIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuX21vZHVsZXMuaXNSZWdpc3RlcmVkKHBhdGgpXG59O1xuXG5TdG9yZS5wcm90b3R5cGUuaG90VXBkYXRlID0gZnVuY3Rpb24gaG90VXBkYXRlIChuZXdPcHRpb25zKSB7XG4gIHRoaXMuX21vZHVsZXMudXBkYXRlKG5ld09wdGlvbnMpO1xuICByZXNldFN0b3JlKHRoaXMsIHRydWUpO1xufTtcblxuU3RvcmUucHJvdG90eXBlLl93aXRoQ29tbWl0ID0gZnVuY3Rpb24gX3dpdGhDb21taXQgKGZuKSB7XG4gIHZhciBjb21taXR0aW5nID0gdGhpcy5fY29tbWl0dGluZztcbiAgdGhpcy5fY29tbWl0dGluZyA9IHRydWU7XG4gIGZuKCk7XG4gIHRoaXMuX2NvbW1pdHRpbmcgPSBjb21taXR0aW5nO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFN0b3JlLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XG5cbi8qKlxuICogUmVkdWNlIHRoZSBjb2RlIHdoaWNoIHdyaXR0ZW4gaW4gVnVlLmpzIGZvciBnZXR0aW5nIHRoZSBzdGF0ZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbbmFtZXNwYWNlXSAtIE1vZHVsZSdzIG5hbWVzcGFjZVxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IHN0YXRlcyAjIE9iamVjdCdzIGl0ZW0gY2FuIGJlIGEgZnVuY3Rpb24gd2hpY2ggYWNjZXB0IHN0YXRlIGFuZCBnZXR0ZXJzIGZvciBwYXJhbSwgeW91IGNhbiBkbyBzb21ldGhpbmcgZm9yIHN0YXRlIGFuZCBnZXR0ZXJzIGluIGl0LlxuICogQHBhcmFtIHtPYmplY3R9XG4gKi9cbnZhciBtYXBTdGF0ZSA9IG5vcm1hbGl6ZU5hbWVzcGFjZShmdW5jdGlvbiAobmFtZXNwYWNlLCBzdGF0ZXMpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFpc1ZhbGlkTWFwKHN0YXRlcykpIHtcbiAgICBjb25zb2xlLmVycm9yKCdbdnVleF0gbWFwU3RhdGU6IG1hcHBlciBwYXJhbWV0ZXIgbXVzdCBiZSBlaXRoZXIgYW4gQXJyYXkgb3IgYW4gT2JqZWN0Jyk7XG4gIH1cbiAgbm9ybWFsaXplTWFwKHN0YXRlcykuZm9yRWFjaChmdW5jdGlvbiAocmVmKSB7XG4gICAgdmFyIGtleSA9IHJlZi5rZXk7XG4gICAgdmFyIHZhbCA9IHJlZi52YWw7XG5cbiAgICByZXNba2V5XSA9IGZ1bmN0aW9uIG1hcHBlZFN0YXRlICgpIHtcbiAgICAgIHZhciBzdGF0ZSA9IHRoaXMuJHN0b3JlLnN0YXRlO1xuICAgICAgdmFyIGdldHRlcnMgPSB0aGlzLiRzdG9yZS5nZXR0ZXJzO1xuICAgICAgaWYgKG5hbWVzcGFjZSkge1xuICAgICAgICB2YXIgbW9kdWxlID0gZ2V0TW9kdWxlQnlOYW1lc3BhY2UodGhpcy4kc3RvcmUsICdtYXBTdGF0ZScsIG5hbWVzcGFjZSk7XG4gICAgICAgIGlmICghbW9kdWxlKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUgPSBtb2R1bGUuY29udGV4dC5zdGF0ZTtcbiAgICAgICAgZ2V0dGVycyA9IG1vZHVsZS5jb250ZXh0LmdldHRlcnM7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHZhbC5jYWxsKHRoaXMsIHN0YXRlLCBnZXR0ZXJzKVxuICAgICAgICA6IHN0YXRlW3ZhbF1cbiAgICB9O1xuICAgIC8vIG1hcmsgdnVleCBnZXR0ZXIgZm9yIGRldnRvb2xzXG4gICAgcmVzW2tleV0udnVleCA9IHRydWU7XG4gIH0pO1xuICByZXR1cm4gcmVzXG59KTtcblxuLyoqXG4gKiBSZWR1Y2UgdGhlIGNvZGUgd2hpY2ggd3JpdHRlbiBpbiBWdWUuanMgZm9yIGNvbW1pdHRpbmcgdGhlIG11dGF0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gW25hbWVzcGFjZV0gLSBNb2R1bGUncyBuYW1lc3BhY2VcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBtdXRhdGlvbnMgIyBPYmplY3QncyBpdGVtIGNhbiBiZSBhIGZ1bmN0aW9uIHdoaWNoIGFjY2VwdCBgY29tbWl0YCBmdW5jdGlvbiBhcyB0aGUgZmlyc3QgcGFyYW0sIGl0IGNhbiBhY2NlcHQgYW5vdGhlciBwYXJhbXMuIFlvdSBjYW4gY29tbWl0IG11dGF0aW9uIGFuZCBkbyBhbnkgb3RoZXIgdGhpbmdzIGluIHRoaXMgZnVuY3Rpb24uIHNwZWNpYWxseSwgWW91IG5lZWQgdG8gcGFzcyBhbnRob3IgcGFyYW1zIGZyb20gdGhlIG1hcHBlZCBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xudmFyIG1hcE11dGF0aW9ucyA9IG5vcm1hbGl6ZU5hbWVzcGFjZShmdW5jdGlvbiAobmFtZXNwYWNlLCBtdXRhdGlvbnMpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFpc1ZhbGlkTWFwKG11dGF0aW9ucykpIHtcbiAgICBjb25zb2xlLmVycm9yKCdbdnVleF0gbWFwTXV0YXRpb25zOiBtYXBwZXIgcGFyYW1ldGVyIG11c3QgYmUgZWl0aGVyIGFuIEFycmF5IG9yIGFuIE9iamVjdCcpO1xuICB9XG4gIG5vcm1hbGl6ZU1hcChtdXRhdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKHJlZikge1xuICAgIHZhciBrZXkgPSByZWYua2V5O1xuICAgIHZhciB2YWwgPSByZWYudmFsO1xuXG4gICAgcmVzW2tleV0gPSBmdW5jdGlvbiBtYXBwZWRNdXRhdGlvbiAoKSB7XG4gICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgLy8gR2V0IHRoZSBjb21taXQgbWV0aG9kIGZyb20gc3RvcmVcbiAgICAgIHZhciBjb21taXQgPSB0aGlzLiRzdG9yZS5jb21taXQ7XG4gICAgICBpZiAobmFtZXNwYWNlKSB7XG4gICAgICAgIHZhciBtb2R1bGUgPSBnZXRNb2R1bGVCeU5hbWVzcGFjZSh0aGlzLiRzdG9yZSwgJ21hcE11dGF0aW9ucycsIG5hbWVzcGFjZSk7XG4gICAgICAgIGlmICghbW9kdWxlKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgY29tbWl0ID0gbW9kdWxlLmNvbnRleHQuY29tbWl0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyB2YWwuYXBwbHkodGhpcywgW2NvbW1pdF0uY29uY2F0KGFyZ3MpKVxuICAgICAgICA6IGNvbW1pdC5hcHBseSh0aGlzLiRzdG9yZSwgW3ZhbF0uY29uY2F0KGFyZ3MpKVxuICAgIH07XG4gIH0pO1xuICByZXR1cm4gcmVzXG59KTtcblxuLyoqXG4gKiBSZWR1Y2UgdGhlIGNvZGUgd2hpY2ggd3JpdHRlbiBpbiBWdWUuanMgZm9yIGdldHRpbmcgdGhlIGdldHRlcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBbbmFtZXNwYWNlXSAtIE1vZHVsZSdzIG5hbWVzcGFjZVxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IGdldHRlcnNcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xudmFyIG1hcEdldHRlcnMgPSBub3JtYWxpemVOYW1lc3BhY2UoZnVuY3Rpb24gKG5hbWVzcGFjZSwgZ2V0dGVycykge1xuICB2YXIgcmVzID0ge307XG4gIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWlzVmFsaWRNYXAoZ2V0dGVycykpIHtcbiAgICBjb25zb2xlLmVycm9yKCdbdnVleF0gbWFwR2V0dGVyczogbWFwcGVyIHBhcmFtZXRlciBtdXN0IGJlIGVpdGhlciBhbiBBcnJheSBvciBhbiBPYmplY3QnKTtcbiAgfVxuICBub3JtYWxpemVNYXAoZ2V0dGVycykuZm9yRWFjaChmdW5jdGlvbiAocmVmKSB7XG4gICAgdmFyIGtleSA9IHJlZi5rZXk7XG4gICAgdmFyIHZhbCA9IHJlZi52YWw7XG5cbiAgICAvLyBUaGUgbmFtZXNwYWNlIGhhcyBiZWVuIG11dGF0ZWQgYnkgbm9ybWFsaXplTmFtZXNwYWNlXG4gICAgdmFsID0gbmFtZXNwYWNlICsgdmFsO1xuICAgIHJlc1trZXldID0gZnVuY3Rpb24gbWFwcGVkR2V0dGVyICgpIHtcbiAgICAgIGlmIChuYW1lc3BhY2UgJiYgIWdldE1vZHVsZUJ5TmFtZXNwYWNlKHRoaXMuJHN0b3JlLCAnbWFwR2V0dGVycycsIG5hbWVzcGFjZSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICEodmFsIGluIHRoaXMuJHN0b3JlLmdldHRlcnMpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoKFwiW3Z1ZXhdIHVua25vd24gZ2V0dGVyOiBcIiArIHZhbCkpO1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLiRzdG9yZS5nZXR0ZXJzW3ZhbF1cbiAgICB9O1xuICAgIC8vIG1hcmsgdnVleCBnZXR0ZXIgZm9yIGRldnRvb2xzXG4gICAgcmVzW2tleV0udnVleCA9IHRydWU7XG4gIH0pO1xuICByZXR1cm4gcmVzXG59KTtcblxuLyoqXG4gKiBSZWR1Y2UgdGhlIGNvZGUgd2hpY2ggd3JpdHRlbiBpbiBWdWUuanMgZm9yIGRpc3BhdGNoIHRoZSBhY3Rpb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBbbmFtZXNwYWNlXSAtIE1vZHVsZSdzIG5hbWVzcGFjZVxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IGFjdGlvbnMgIyBPYmplY3QncyBpdGVtIGNhbiBiZSBhIGZ1bmN0aW9uIHdoaWNoIGFjY2VwdCBgZGlzcGF0Y2hgIGZ1bmN0aW9uIGFzIHRoZSBmaXJzdCBwYXJhbSwgaXQgY2FuIGFjY2VwdCBhbnRob3IgcGFyYW1zLiBZb3UgY2FuIGRpc3BhdGNoIGFjdGlvbiBhbmQgZG8gYW55IG90aGVyIHRoaW5ncyBpbiB0aGlzIGZ1bmN0aW9uLiBzcGVjaWFsbHksIFlvdSBuZWVkIHRvIHBhc3MgYW50aG9yIHBhcmFtcyBmcm9tIHRoZSBtYXBwZWQgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbnZhciBtYXBBY3Rpb25zID0gbm9ybWFsaXplTmFtZXNwYWNlKGZ1bmN0aW9uIChuYW1lc3BhY2UsIGFjdGlvbnMpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFpc1ZhbGlkTWFwKGFjdGlvbnMpKSB7XG4gICAgY29uc29sZS5lcnJvcignW3Z1ZXhdIG1hcEFjdGlvbnM6IG1hcHBlciBwYXJhbWV0ZXIgbXVzdCBiZSBlaXRoZXIgYW4gQXJyYXkgb3IgYW4gT2JqZWN0Jyk7XG4gIH1cbiAgbm9ybWFsaXplTWFwKGFjdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKHJlZikge1xuICAgIHZhciBrZXkgPSByZWYua2V5O1xuICAgIHZhciB2YWwgPSByZWYudmFsO1xuXG4gICAgcmVzW2tleV0gPSBmdW5jdGlvbiBtYXBwZWRBY3Rpb24gKCkge1xuICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgIC8vIGdldCBkaXNwYXRjaCBmdW5jdGlvbiBmcm9tIHN0b3JlXG4gICAgICB2YXIgZGlzcGF0Y2ggPSB0aGlzLiRzdG9yZS5kaXNwYXRjaDtcbiAgICAgIGlmIChuYW1lc3BhY2UpIHtcbiAgICAgICAgdmFyIG1vZHVsZSA9IGdldE1vZHVsZUJ5TmFtZXNwYWNlKHRoaXMuJHN0b3JlLCAnbWFwQWN0aW9ucycsIG5hbWVzcGFjZSk7XG4gICAgICAgIGlmICghbW9kdWxlKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgZGlzcGF0Y2ggPSBtb2R1bGUuY29udGV4dC5kaXNwYXRjaDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gdmFsLmFwcGx5KHRoaXMsIFtkaXNwYXRjaF0uY29uY2F0KGFyZ3MpKVxuICAgICAgICA6IGRpc3BhdGNoLmFwcGx5KHRoaXMuJHN0b3JlLCBbdmFsXS5jb25jYXQoYXJncykpXG4gICAgfTtcbiAgfSk7XG4gIHJldHVybiByZXNcbn0pO1xuXG4vKipcbiAqIFJlYmluZGluZyBuYW1lc3BhY2UgcGFyYW0gZm9yIG1hcFhYWCBmdW5jdGlvbiBpbiBzcGVjaWFsIHNjb3BlZCwgYW5kIHJldHVybiB0aGVtIGJ5IHNpbXBsZSBvYmplY3RcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xudmFyIGNyZWF0ZU5hbWVzcGFjZWRIZWxwZXJzID0gZnVuY3Rpb24gKG5hbWVzcGFjZSkgeyByZXR1cm4gKHtcbiAgbWFwU3RhdGU6IG1hcFN0YXRlLmJpbmQobnVsbCwgbmFtZXNwYWNlKSxcbiAgbWFwR2V0dGVyczogbWFwR2V0dGVycy5iaW5kKG51bGwsIG5hbWVzcGFjZSksXG4gIG1hcE11dGF0aW9uczogbWFwTXV0YXRpb25zLmJpbmQobnVsbCwgbmFtZXNwYWNlKSxcbiAgbWFwQWN0aW9uczogbWFwQWN0aW9ucy5iaW5kKG51bGwsIG5hbWVzcGFjZSlcbn0pOyB9O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSB0aGUgbWFwXG4gKiBub3JtYWxpemVNYXAoWzEsIDIsIDNdKSA9PiBbIHsga2V5OiAxLCB2YWw6IDEgfSwgeyBrZXk6IDIsIHZhbDogMiB9LCB7IGtleTogMywgdmFsOiAzIH0gXVxuICogbm9ybWFsaXplTWFwKHthOiAxLCBiOiAyLCBjOiAzfSkgPT4gWyB7IGtleTogJ2EnLCB2YWw6IDEgfSwgeyBrZXk6ICdiJywgdmFsOiAyIH0sIHsga2V5OiAnYycsIHZhbDogMyB9IF1cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBtYXBcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplTWFwIChtYXApIHtcbiAgaWYgKCFpc1ZhbGlkTWFwKG1hcCkpIHtcbiAgICByZXR1cm4gW11cbiAgfVxuICByZXR1cm4gQXJyYXkuaXNBcnJheShtYXApXG4gICAgPyBtYXAubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuICh7IGtleToga2V5LCB2YWw6IGtleSB9KTsgfSlcbiAgICA6IE9iamVjdC5rZXlzKG1hcCkubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuICh7IGtleToga2V5LCB2YWw6IG1hcFtrZXldIH0pOyB9KVxufVxuXG4vKipcbiAqIFZhbGlkYXRlIHdoZXRoZXIgZ2l2ZW4gbWFwIGlzIHZhbGlkIG9yIG5vdFxuICogQHBhcmFtIHsqfSBtYXBcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRNYXAgKG1hcCkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShtYXApIHx8IGlzT2JqZWN0KG1hcClcbn1cblxuLyoqXG4gKiBSZXR1cm4gYSBmdW5jdGlvbiBleHBlY3QgdHdvIHBhcmFtIGNvbnRhaW5zIG5hbWVzcGFjZSBhbmQgbWFwLiBpdCB3aWxsIG5vcm1hbGl6ZSB0aGUgbmFtZXNwYWNlIGFuZCB0aGVuIHRoZSBwYXJhbSdzIGZ1bmN0aW9uIHdpbGwgaGFuZGxlIHRoZSBuZXcgbmFtZXNwYWNlIGFuZCB0aGUgbWFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBub3JtYWxpemVOYW1lc3BhY2UgKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAobmFtZXNwYWNlLCBtYXApIHtcbiAgICBpZiAodHlwZW9mIG5hbWVzcGFjZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIG1hcCA9IG5hbWVzcGFjZTtcbiAgICAgIG5hbWVzcGFjZSA9ICcnO1xuICAgIH0gZWxzZSBpZiAobmFtZXNwYWNlLmNoYXJBdChuYW1lc3BhY2UubGVuZ3RoIC0gMSkgIT09ICcvJykge1xuICAgICAgbmFtZXNwYWNlICs9ICcvJztcbiAgICB9XG4gICAgcmV0dXJuIGZuKG5hbWVzcGFjZSwgbWFwKVxuICB9XG59XG5cbi8qKlxuICogU2VhcmNoIGEgc3BlY2lhbCBtb2R1bGUgZnJvbSBzdG9yZSBieSBuYW1lc3BhY2UuIGlmIG1vZHVsZSBub3QgZXhpc3QsIHByaW50IGVycm9yIG1lc3NhZ2UuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RvcmVcbiAqIEBwYXJhbSB7U3RyaW5nfSBoZWxwZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0TW9kdWxlQnlOYW1lc3BhY2UgKHN0b3JlLCBoZWxwZXIsIG5hbWVzcGFjZSkge1xuICB2YXIgbW9kdWxlID0gc3RvcmUuX21vZHVsZXNOYW1lc3BhY2VNYXBbbmFtZXNwYWNlXTtcbiAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhbW9kdWxlKSB7XG4gICAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gbW9kdWxlIG5hbWVzcGFjZSBub3QgZm91bmQgaW4gXCIgKyBoZWxwZXIgKyBcIigpOiBcIiArIG5hbWVzcGFjZSkpO1xuICB9XG4gIHJldHVybiBtb2R1bGVcbn1cblxuLy8gQ3JlZGl0czogYm9ycm93ZWQgY29kZSBmcm9tIGZjb21iL3JlZHV4LWxvZ2dlclxuXG5mdW5jdGlvbiBjcmVhdGVMb2dnZXIgKHJlZikge1xuICBpZiAoIHJlZiA9PT0gdm9pZCAwICkgcmVmID0ge307XG4gIHZhciBjb2xsYXBzZWQgPSByZWYuY29sbGFwc2VkOyBpZiAoIGNvbGxhcHNlZCA9PT0gdm9pZCAwICkgY29sbGFwc2VkID0gdHJ1ZTtcbiAgdmFyIGZpbHRlciA9IHJlZi5maWx0ZXI7IGlmICggZmlsdGVyID09PSB2b2lkIDAgKSBmaWx0ZXIgPSBmdW5jdGlvbiAobXV0YXRpb24sIHN0YXRlQmVmb3JlLCBzdGF0ZUFmdGVyKSB7IHJldHVybiB0cnVlOyB9O1xuICB2YXIgdHJhbnNmb3JtZXIgPSByZWYudHJhbnNmb3JtZXI7IGlmICggdHJhbnNmb3JtZXIgPT09IHZvaWQgMCApIHRyYW5zZm9ybWVyID0gZnVuY3Rpb24gKHN0YXRlKSB7IHJldHVybiBzdGF0ZTsgfTtcbiAgdmFyIG11dGF0aW9uVHJhbnNmb3JtZXIgPSByZWYubXV0YXRpb25UcmFuc2Zvcm1lcjsgaWYgKCBtdXRhdGlvblRyYW5zZm9ybWVyID09PSB2b2lkIDAgKSBtdXRhdGlvblRyYW5zZm9ybWVyID0gZnVuY3Rpb24gKG11dCkgeyByZXR1cm4gbXV0OyB9O1xuICB2YXIgYWN0aW9uRmlsdGVyID0gcmVmLmFjdGlvbkZpbHRlcjsgaWYgKCBhY3Rpb25GaWx0ZXIgPT09IHZvaWQgMCApIGFjdGlvbkZpbHRlciA9IGZ1bmN0aW9uIChhY3Rpb24sIHN0YXRlKSB7IHJldHVybiB0cnVlOyB9O1xuICB2YXIgYWN0aW9uVHJhbnNmb3JtZXIgPSByZWYuYWN0aW9uVHJhbnNmb3JtZXI7IGlmICggYWN0aW9uVHJhbnNmb3JtZXIgPT09IHZvaWQgMCApIGFjdGlvblRyYW5zZm9ybWVyID0gZnVuY3Rpb24gKGFjdCkgeyByZXR1cm4gYWN0OyB9O1xuICB2YXIgbG9nTXV0YXRpb25zID0gcmVmLmxvZ011dGF0aW9uczsgaWYgKCBsb2dNdXRhdGlvbnMgPT09IHZvaWQgMCApIGxvZ011dGF0aW9ucyA9IHRydWU7XG4gIHZhciBsb2dBY3Rpb25zID0gcmVmLmxvZ0FjdGlvbnM7IGlmICggbG9nQWN0aW9ucyA9PT0gdm9pZCAwICkgbG9nQWN0aW9ucyA9IHRydWU7XG4gIHZhciBsb2dnZXIgPSByZWYubG9nZ2VyOyBpZiAoIGxvZ2dlciA9PT0gdm9pZCAwICkgbG9nZ2VyID0gY29uc29sZTtcblxuICByZXR1cm4gZnVuY3Rpb24gKHN0b3JlKSB7XG4gICAgdmFyIHByZXZTdGF0ZSA9IGRlZXBDb3B5KHN0b3JlLnN0YXRlKTtcblxuICAgIGlmICh0eXBlb2YgbG9nZ2VyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGxvZ011dGF0aW9ucykge1xuICAgICAgc3RvcmUuc3Vic2NyaWJlKGZ1bmN0aW9uIChtdXRhdGlvbiwgc3RhdGUpIHtcbiAgICAgICAgdmFyIG5leHRTdGF0ZSA9IGRlZXBDb3B5KHN0YXRlKTtcblxuICAgICAgICBpZiAoZmlsdGVyKG11dGF0aW9uLCBwcmV2U3RhdGUsIG5leHRTdGF0ZSkpIHtcbiAgICAgICAgICB2YXIgZm9ybWF0dGVkVGltZSA9IGdldEZvcm1hdHRlZFRpbWUoKTtcbiAgICAgICAgICB2YXIgZm9ybWF0dGVkTXV0YXRpb24gPSBtdXRhdGlvblRyYW5zZm9ybWVyKG11dGF0aW9uKTtcbiAgICAgICAgICB2YXIgbWVzc2FnZSA9IFwibXV0YXRpb24gXCIgKyAobXV0YXRpb24udHlwZSkgKyBmb3JtYXR0ZWRUaW1lO1xuXG4gICAgICAgICAgc3RhcnRNZXNzYWdlKGxvZ2dlciwgbWVzc2FnZSwgY29sbGFwc2VkKTtcbiAgICAgICAgICBsb2dnZXIubG9nKCclYyBwcmV2IHN0YXRlJywgJ2NvbG9yOiAjOUU5RTlFOyBmb250LXdlaWdodDogYm9sZCcsIHRyYW5zZm9ybWVyKHByZXZTdGF0ZSkpO1xuICAgICAgICAgIGxvZ2dlci5sb2coJyVjIG11dGF0aW9uJywgJ2NvbG9yOiAjMDNBOUY0OyBmb250LXdlaWdodDogYm9sZCcsIGZvcm1hdHRlZE11dGF0aW9uKTtcbiAgICAgICAgICBsb2dnZXIubG9nKCclYyBuZXh0IHN0YXRlJywgJ2NvbG9yOiAjNENBRjUwOyBmb250LXdlaWdodDogYm9sZCcsIHRyYW5zZm9ybWVyKG5leHRTdGF0ZSkpO1xuICAgICAgICAgIGVuZE1lc3NhZ2UobG9nZ2VyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZTdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChsb2dBY3Rpb25zKSB7XG4gICAgICBzdG9yZS5zdWJzY3JpYmVBY3Rpb24oZnVuY3Rpb24gKGFjdGlvbiwgc3RhdGUpIHtcbiAgICAgICAgaWYgKGFjdGlvbkZpbHRlcihhY3Rpb24sIHN0YXRlKSkge1xuICAgICAgICAgIHZhciBmb3JtYXR0ZWRUaW1lID0gZ2V0Rm9ybWF0dGVkVGltZSgpO1xuICAgICAgICAgIHZhciBmb3JtYXR0ZWRBY3Rpb24gPSBhY3Rpb25UcmFuc2Zvcm1lcihhY3Rpb24pO1xuICAgICAgICAgIHZhciBtZXNzYWdlID0gXCJhY3Rpb24gXCIgKyAoYWN0aW9uLnR5cGUpICsgZm9ybWF0dGVkVGltZTtcblxuICAgICAgICAgIHN0YXJ0TWVzc2FnZShsb2dnZXIsIG1lc3NhZ2UsIGNvbGxhcHNlZCk7XG4gICAgICAgICAgbG9nZ2VyLmxvZygnJWMgYWN0aW9uJywgJ2NvbG9yOiAjMDNBOUY0OyBmb250LXdlaWdodDogYm9sZCcsIGZvcm1hdHRlZEFjdGlvbik7XG4gICAgICAgICAgZW5kTWVzc2FnZShsb2dnZXIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRNZXNzYWdlIChsb2dnZXIsIG1lc3NhZ2UsIGNvbGxhcHNlZCkge1xuICB2YXIgc3RhcnRNZXNzYWdlID0gY29sbGFwc2VkXG4gICAgPyBsb2dnZXIuZ3JvdXBDb2xsYXBzZWRcbiAgICA6IGxvZ2dlci5ncm91cDtcblxuICAvLyByZW5kZXJcbiAgdHJ5IHtcbiAgICBzdGFydE1lc3NhZ2UuY2FsbChsb2dnZXIsIG1lc3NhZ2UpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nZ2VyLmxvZyhtZXNzYWdlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbmRNZXNzYWdlIChsb2dnZXIpIHtcbiAgdHJ5IHtcbiAgICBsb2dnZXIuZ3JvdXBFbmQoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGxvZ2dlci5sb2coJ+KAlOKAlCBsb2cgZW5kIOKAlOKAlCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEZvcm1hdHRlZFRpbWUgKCkge1xuICB2YXIgdGltZSA9IG5ldyBEYXRlKCk7XG4gIHJldHVybiAoXCIgQCBcIiArIChwYWQodGltZS5nZXRIb3VycygpLCAyKSkgKyBcIjpcIiArIChwYWQodGltZS5nZXRNaW51dGVzKCksIDIpKSArIFwiOlwiICsgKHBhZCh0aW1lLmdldFNlY29uZHMoKSwgMikpICsgXCIuXCIgKyAocGFkKHRpbWUuZ2V0TWlsbGlzZWNvbmRzKCksIDMpKSlcbn1cblxuZnVuY3Rpb24gcmVwZWF0IChzdHIsIHRpbWVzKSB7XG4gIHJldHVybiAobmV3IEFycmF5KHRpbWVzICsgMSkpLmpvaW4oc3RyKVxufVxuXG5mdW5jdGlvbiBwYWQgKG51bSwgbWF4TGVuZ3RoKSB7XG4gIHJldHVybiByZXBlYXQoJzAnLCBtYXhMZW5ndGggLSBudW0udG9TdHJpbmcoKS5sZW5ndGgpICsgbnVtXG59XG5cbnZhciBpbmRleCA9IHtcbiAgdmVyc2lvbjogJzQuMC4yJyxcbiAgU3RvcmU6IFN0b3JlLFxuICBzdG9yZUtleTogc3RvcmVLZXksXG4gIGNyZWF0ZVN0b3JlOiBjcmVhdGVTdG9yZSxcbiAgdXNlU3RvcmU6IHVzZVN0b3JlLFxuICBtYXBTdGF0ZTogbWFwU3RhdGUsXG4gIG1hcE11dGF0aW9uczogbWFwTXV0YXRpb25zLFxuICBtYXBHZXR0ZXJzOiBtYXBHZXR0ZXJzLFxuICBtYXBBY3Rpb25zOiBtYXBBY3Rpb25zLFxuICBjcmVhdGVOYW1lc3BhY2VkSGVscGVyczogY3JlYXRlTmFtZXNwYWNlZEhlbHBlcnMsXG4gIGNyZWF0ZUxvZ2dlcjogY3JlYXRlTG9nZ2VyXG59O1xuXG5leHBvcnQgZGVmYXVsdCBpbmRleDtcbmV4cG9ydCB7IFN0b3JlLCBjcmVhdGVMb2dnZXIsIGNyZWF0ZU5hbWVzcGFjZWRIZWxwZXJzLCBjcmVhdGVTdG9yZSwgbWFwQWN0aW9ucywgbWFwR2V0dGVycywgbWFwTXV0YXRpb25zLCBtYXBTdGF0ZSwgc3RvcmVLZXksIHVzZVN0b3JlIH07XG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuLy8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbl9fd2VicGFja19yZXF1aXJlX18ubSA9IF9fd2VicGFja19tb2R1bGVzX187XG5cbiIsIi8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcblx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG5cdFx0ZnVuY3Rpb24oKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG5cdFx0ZnVuY3Rpb24oKSB7IHJldHVybiBtb2R1bGU7IH07XG5cdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuXHRyZXR1cm4gZ2V0dGVyO1xufTsiLCJ2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgPyBmdW5jdGlvbihvYmopIHsgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopOyB9IDogZnVuY3Rpb24ob2JqKSB7IHJldHVybiBvYmouX19wcm90b19fOyB9O1xudmFyIGxlYWZQcm90b3R5cGVzO1xuLy8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4vLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbi8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuLy8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4vLyBtb2RlICYgMTY6IHJldHVybiB2YWx1ZSB3aGVuIGl0J3MgUHJvbWlzZS1saWtlXG4vLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuXHRpZihtb2RlICYgMSkgdmFsdWUgPSB0aGlzKHZhbHVlKTtcblx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcblx0aWYodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSkge1xuXHRcdGlmKChtb2RlICYgNCkgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuXHRcdGlmKChtb2RlICYgMTYpICYmIHR5cGVvZiB2YWx1ZS50aGVuID09PSAnZnVuY3Rpb24nKSByZXR1cm4gdmFsdWU7XG5cdH1cblx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcblx0dmFyIGRlZiA9IHt9O1xuXHRsZWFmUHJvdG90eXBlcyA9IGxlYWZQcm90b3R5cGVzIHx8IFtudWxsLCBnZXRQcm90byh7fSksIGdldFByb3RvKFtdKSwgZ2V0UHJvdG8oZ2V0UHJvdG8pXTtcblx0Zm9yKHZhciBjdXJyZW50ID0gbW9kZSAmIDIgJiYgdmFsdWU7IHR5cGVvZiBjdXJyZW50ID09ICdvYmplY3QnICYmICF+bGVhZlByb3RvdHlwZXMuaW5kZXhPZihjdXJyZW50KTsgY3VycmVudCA9IGdldFByb3RvKGN1cnJlbnQpKSB7XG5cdFx0T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoY3VycmVudCkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHsgZGVmW2tleV0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHZhbHVlW2tleV07IH07IH0pO1xuXHR9XG5cdGRlZlsnZGVmYXVsdCddID0gZnVuY3Rpb24oKSB7IHJldHVybiB2YWx1ZTsgfTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBkZWYpO1xuXHRyZXR1cm4gbnM7XG59OyIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIGRlZmluaXRpb24pIHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5mID0ge307XG4vLyBUaGlzIGZpbGUgY29udGFpbnMgb25seSB0aGUgZW50cnkgY2h1bmsuXG4vLyBUaGUgY2h1bmsgbG9hZGluZyBmdW5jdGlvbiBmb3IgYWRkaXRpb25hbCBjaHVua3Ncbl9fd2VicGFja19yZXF1aXJlX18uZSA9IGZ1bmN0aW9uKGNodW5rSWQpIHtcblx0cmV0dXJuIFByb21pc2UuYWxsKE9iamVjdC5rZXlzKF9fd2VicGFja19yZXF1aXJlX18uZikucmVkdWNlKGZ1bmN0aW9uKHByb21pc2VzLCBrZXkpIHtcblx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmZba2V5XShjaHVua0lkLCBwcm9taXNlcyk7XG5cdFx0cmV0dXJuIHByb21pc2VzO1xuXHR9LCBbXSkpO1xufTsiLCIvLyBUaGlzIGZ1bmN0aW9uIGFsbG93IHRvIHJlZmVyZW5jZSBhc3luYyBjaHVua3Ncbl9fd2VicGFja19yZXF1aXJlX18udSA9IGZ1bmN0aW9uKGNodW5rSWQpIHtcblx0Ly8gcmV0dXJuIHVybCBmb3IgZmlsZW5hbWVzIGJhc2VkIG9uIHRlbXBsYXRlXG5cdHJldHVybiBcIlwiICsgY2h1bmtJZCArIFwiLm1pbi5qc1wiO1xufTsiLCIvLyBUaGlzIGZ1bmN0aW9uIGFsbG93IHRvIHJlZmVyZW5jZSBhbGwgY2h1bmtzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm1pbmlDc3NGID0gZnVuY3Rpb24oY2h1bmtJZCkge1xuXHQvLyByZXR1cm4gdXJsIGZvciBmaWxlbmFtZXMgYmFzZWQgb24gdGVtcGxhdGVcblx0cmV0dXJuIFwiXCIgKyBjaHVua0lkICsgXCIubWluLmNzc1wiO1xufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmcgPSAoZnVuY3Rpb24oKSB7XG5cdGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHJldHVybiBnbG9iYWxUaGlzO1xuXHR0cnkge1xuXHRcdHJldHVybiB0aGlzIHx8IG5ldyBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSByZXR1cm4gd2luZG93O1xuXHR9XG59KSgpOyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iaiwgcHJvcCkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7IH0iLCJ2YXIgaW5Qcm9ncmVzcyA9IHt9O1xudmFyIGRhdGFXZWJwYWNrUHJlZml4ID0gXCJyZXRhaWxlci1idW5kbGU6XCI7XG4vLyBsb2FkU2NyaXB0IGZ1bmN0aW9uIHRvIGxvYWQgYSBzY3JpcHQgdmlhIHNjcmlwdCB0YWdcbl9fd2VicGFja19yZXF1aXJlX18ubCA9IGZ1bmN0aW9uKHVybCwgZG9uZSwga2V5LCBjaHVua0lkKSB7XG5cdGlmKGluUHJvZ3Jlc3NbdXJsXSkgeyBpblByb2dyZXNzW3VybF0ucHVzaChkb25lKTsgcmV0dXJuOyB9XG5cdHZhciBzY3JpcHQsIG5lZWRBdHRhY2g7XG5cdGlmKGtleSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0dmFyIHNjcmlwdHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNjcmlwdFwiKTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgc2NyaXB0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIHMgPSBzY3JpcHRzW2ldO1xuXHRcdFx0aWYocy5nZXRBdHRyaWJ1dGUoXCJzcmNcIikgPT0gdXJsIHx8IHMuZ2V0QXR0cmlidXRlKFwiZGF0YS13ZWJwYWNrXCIpID09IGRhdGFXZWJwYWNrUHJlZml4ICsga2V5KSB7IHNjcmlwdCA9IHM7IGJyZWFrOyB9XG5cdFx0fVxuXHR9XG5cdGlmKCFzY3JpcHQpIHtcblx0XHRuZWVkQXR0YWNoID0gdHJ1ZTtcblx0XHRzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcblxuXHRcdHNjcmlwdC5jaGFyc2V0ID0gJ3V0Zi04Jztcblx0XHRzY3JpcHQudGltZW91dCA9IDEyMDtcblx0XHRpZiAoX193ZWJwYWNrX3JlcXVpcmVfXy5uYykge1xuXHRcdFx0c2NyaXB0LnNldEF0dHJpYnV0ZShcIm5vbmNlXCIsIF9fd2VicGFja19yZXF1aXJlX18ubmMpO1xuXHRcdH1cblx0XHRzY3JpcHQuc2V0QXR0cmlidXRlKFwiZGF0YS13ZWJwYWNrXCIsIGRhdGFXZWJwYWNrUHJlZml4ICsga2V5KTtcblx0XHRzY3JpcHQuc3JjID0gdXJsO1xuXHR9XG5cdGluUHJvZ3Jlc3NbdXJsXSA9IFtkb25lXTtcblx0dmFyIG9uU2NyaXB0Q29tcGxldGUgPSBmdW5jdGlvbihwcmV2LCBldmVudCkge1xuXHRcdC8vIGF2b2lkIG1lbSBsZWFrcyBpbiBJRS5cblx0XHRzY3JpcHQub25lcnJvciA9IHNjcmlwdC5vbmxvYWQgPSBudWxsO1xuXHRcdGNsZWFyVGltZW91dCh0aW1lb3V0KTtcblx0XHR2YXIgZG9uZUZucyA9IGluUHJvZ3Jlc3NbdXJsXTtcblx0XHRkZWxldGUgaW5Qcm9ncmVzc1t1cmxdO1xuXHRcdHNjcmlwdC5wYXJlbnROb2RlICYmIHNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG5cdFx0ZG9uZUZucyAmJiBkb25lRm5zLmZvckVhY2goZnVuY3Rpb24oZm4pIHsgcmV0dXJuIGZuKGV2ZW50KTsgfSk7XG5cdFx0aWYocHJldikgcmV0dXJuIHByZXYoZXZlbnQpO1xuXHR9XG5cdDtcblx0dmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KG9uU2NyaXB0Q29tcGxldGUuYmluZChudWxsLCB1bmRlZmluZWQsIHsgdHlwZTogJ3RpbWVvdXQnLCB0YXJnZXQ6IHNjcmlwdCB9KSwgMTIwMDAwKTtcblx0c2NyaXB0Lm9uZXJyb3IgPSBvblNjcmlwdENvbXBsZXRlLmJpbmQobnVsbCwgc2NyaXB0Lm9uZXJyb3IpO1xuXHRzY3JpcHQub25sb2FkID0gb25TY3JpcHRDb21wbGV0ZS5iaW5kKG51bGwsIHNjcmlwdC5vbmxvYWQpO1xuXHRuZWVkQXR0YWNoICYmIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbn07IiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIi9idW5kbGVzL2FzZG9yaWFzeWxpdXNyZXRhaWxlcnBsdWdpbi9cIjsiLCIvLyBubyBiYXNlVVJJXG5cbi8vIG9iamVjdCB0byBzdG9yZSBsb2FkZWQgYW5kIGxvYWRpbmcgY2h1bmtzXG4vLyB1bmRlZmluZWQgPSBjaHVuayBub3QgbG9hZGVkLCBudWxsID0gY2h1bmsgcHJlbG9hZGVkL3ByZWZldGNoZWRcbi8vIFtyZXNvbHZlLCByZWplY3QsIFByb21pc2VdID0gY2h1bmsgbG9hZGluZywgMCA9IGNodW5rIGxvYWRlZFxudmFyIGluc3RhbGxlZENodW5rcyA9IHtcblx0XCJzaG9wLXJldGFpbGVyXCI6IDBcbn07XG5cbl9fd2VicGFja19yZXF1aXJlX18uZi5qID0gZnVuY3Rpb24oY2h1bmtJZCwgcHJvbWlzZXMpIHtcblx0XHQvLyBKU09OUCBjaHVuayBsb2FkaW5nIGZvciBqYXZhc2NyaXB0XG5cdFx0dmFyIGluc3RhbGxlZENodW5rRGF0YSA9IF9fd2VicGFja19yZXF1aXJlX18ubyhpbnN0YWxsZWRDaHVua3MsIGNodW5rSWQpID8gaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdIDogdW5kZWZpbmVkO1xuXHRcdGlmKGluc3RhbGxlZENodW5rRGF0YSAhPT0gMCkgeyAvLyAwIG1lYW5zIFwiYWxyZWFkeSBpbnN0YWxsZWRcIi5cblxuXHRcdFx0Ly8gYSBQcm9taXNlIG1lYW5zIFwiY3VycmVudGx5IGxvYWRpbmdcIi5cblx0XHRcdGlmKGluc3RhbGxlZENodW5rRGF0YSkge1xuXHRcdFx0XHRwcm9taXNlcy5wdXNoKGluc3RhbGxlZENodW5rRGF0YVsyXSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZih0cnVlKSB7IC8vIGFsbCBjaHVua3MgaGF2ZSBKU1xuXHRcdFx0XHRcdC8vIHNldHVwIFByb21pc2UgaW4gY2h1bmsgY2FjaGVcblx0XHRcdFx0XHR2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkgeyBpbnN0YWxsZWRDaHVua0RhdGEgPSBpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0gPSBbcmVzb2x2ZSwgcmVqZWN0XTsgfSk7XG5cdFx0XHRcdFx0cHJvbWlzZXMucHVzaChpbnN0YWxsZWRDaHVua0RhdGFbMl0gPSBwcm9taXNlKTtcblxuXHRcdFx0XHRcdC8vIHN0YXJ0IGNodW5rIGxvYWRpbmdcblx0XHRcdFx0XHR2YXIgdXJsID0gX193ZWJwYWNrX3JlcXVpcmVfXy5wICsgX193ZWJwYWNrX3JlcXVpcmVfXy51KGNodW5rSWQpO1xuXHRcdFx0XHRcdC8vIGNyZWF0ZSBlcnJvciBiZWZvcmUgc3RhY2sgdW53b3VuZCB0byBnZXQgdXNlZnVsIHN0YWNrdHJhY2UgbGF0ZXJcblx0XHRcdFx0XHR2YXIgZXJyb3IgPSBuZXcgRXJyb3IoKTtcblx0XHRcdFx0XHR2YXIgbG9hZGluZ0VuZGVkID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdFx0XHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhpbnN0YWxsZWRDaHVua3MsIGNodW5rSWQpKSB7XG5cdFx0XHRcdFx0XHRcdGluc3RhbGxlZENodW5rRGF0YSA9IGluc3RhbGxlZENodW5rc1tjaHVua0lkXTtcblx0XHRcdFx0XHRcdFx0aWYoaW5zdGFsbGVkQ2h1bmtEYXRhICE9PSAwKSBpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdGlmKGluc3RhbGxlZENodW5rRGF0YSkge1xuXHRcdFx0XHRcdFx0XHRcdHZhciBlcnJvclR5cGUgPSBldmVudCAmJiAoZXZlbnQudHlwZSA9PT0gJ2xvYWQnID8gJ21pc3NpbmcnIDogZXZlbnQudHlwZSk7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHJlYWxTcmMgPSBldmVudCAmJiBldmVudC50YXJnZXQgJiYgZXZlbnQudGFyZ2V0LnNyYztcblx0XHRcdFx0XHRcdFx0XHRlcnJvci5tZXNzYWdlID0gJ0xvYWRpbmcgY2h1bmsgJyArIGNodW5rSWQgKyAnIGZhaWxlZC5cXG4oJyArIGVycm9yVHlwZSArICc6ICcgKyByZWFsU3JjICsgJyknO1xuXHRcdFx0XHRcdFx0XHRcdGVycm9yLm5hbWUgPSAnQ2h1bmtMb2FkRXJyb3InO1xuXHRcdFx0XHRcdFx0XHRcdGVycm9yLnR5cGUgPSBlcnJvclR5cGU7XG5cdFx0XHRcdFx0XHRcdFx0ZXJyb3IucmVxdWVzdCA9IHJlYWxTcmM7XG5cdFx0XHRcdFx0XHRcdFx0aW5zdGFsbGVkQ2h1bmtEYXRhWzFdKGVycm9yKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5sKHVybCwgbG9hZGluZ0VuZGVkLCBcImNodW5rLVwiICsgY2h1bmtJZCwgY2h1bmtJZCk7XG5cdFx0XHRcdH0gZWxzZSBpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0gPSAwO1xuXHRcdFx0fVxuXHRcdH1cbn07XG5cbi8vIG5vIHByZWZldGNoaW5nXG5cbi8vIG5vIHByZWxvYWRlZFxuXG4vLyBubyBITVJcblxuLy8gbm8gSE1SIG1hbmlmZXN0XG5cbi8vIG5vIG9uIGNodW5rcyBsb2FkZWRcblxuLy8gaW5zdGFsbCBhIEpTT05QIGNhbGxiYWNrIGZvciBjaHVuayBsb2FkaW5nXG52YXIgd2VicGFja0pzb25wQ2FsbGJhY2sgPSBmdW5jdGlvbihwYXJlbnRDaHVua0xvYWRpbmdGdW5jdGlvbiwgZGF0YSkge1xuXHR2YXIgY2h1bmtJZHMgPSBkYXRhWzBdO1xuXHR2YXIgbW9yZU1vZHVsZXMgPSBkYXRhWzFdO1xuXHR2YXIgcnVudGltZSA9IGRhdGFbMl07XG5cdC8vIGFkZCBcIm1vcmVNb2R1bGVzXCIgdG8gdGhlIG1vZHVsZXMgb2JqZWN0LFxuXHQvLyB0aGVuIGZsYWcgYWxsIFwiY2h1bmtJZHNcIiBhcyBsb2FkZWQgYW5kIGZpcmUgY2FsbGJhY2tcblx0dmFyIG1vZHVsZUlkLCBjaHVua0lkLCBpID0gMDtcblx0aWYoY2h1bmtJZHMuc29tZShmdW5jdGlvbihpZCkgeyByZXR1cm4gaW5zdGFsbGVkQ2h1bmtzW2lkXSAhPT0gMDsgfSkpIHtcblx0XHRmb3IobW9kdWxlSWQgaW4gbW9yZU1vZHVsZXMpIHtcblx0XHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhtb3JlTW9kdWxlcywgbW9kdWxlSWQpKSB7XG5cdFx0XHRcdF9fd2VicGFja19yZXF1aXJlX18ubVttb2R1bGVJZF0gPSBtb3JlTW9kdWxlc1ttb2R1bGVJZF07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmKHJ1bnRpbWUpIHZhciByZXN1bHQgPSBydW50aW1lKF9fd2VicGFja19yZXF1aXJlX18pO1xuXHR9XG5cdGlmKHBhcmVudENodW5rTG9hZGluZ0Z1bmN0aW9uKSBwYXJlbnRDaHVua0xvYWRpbmdGdW5jdGlvbihkYXRhKTtcblx0Zm9yKDtpIDwgY2h1bmtJZHMubGVuZ3RoOyBpKyspIHtcblx0XHRjaHVua0lkID0gY2h1bmtJZHNbaV07XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGluc3RhbGxlZENodW5rcywgY2h1bmtJZCkgJiYgaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdKSB7XG5cdFx0XHRpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF1bMF0oKTtcblx0XHR9XG5cdFx0aW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdID0gMDtcblx0fVxuXG59XG5cbnZhciBjaHVua0xvYWRpbmdHbG9iYWwgPSBzZWxmW1wid2VicGFja0NodW5rcmV0YWlsZXJfYnVuZGxlXCJdID0gc2VsZltcIndlYnBhY2tDaHVua3JldGFpbGVyX2J1bmRsZVwiXSB8fCBbXTtcbmNodW5rTG9hZGluZ0dsb2JhbC5mb3JFYWNoKHdlYnBhY2tKc29ucENhbGxiYWNrLmJpbmQobnVsbCwgMCkpO1xuY2h1bmtMb2FkaW5nR2xvYmFsLnB1c2ggPSB3ZWJwYWNrSnNvbnBDYWxsYmFjay5iaW5kKG51bGwsIGNodW5rTG9hZGluZ0dsb2JhbC5wdXNoLmJpbmQoY2h1bmtMb2FkaW5nR2xvYmFsKSk7IiwiaW1wb3J0IHsgY3JlYXRlQXBwIH0gZnJvbSAndnVlJztcbmltcG9ydCB7IGNyZWF0ZVN0b3JlIH0gZnJvbSAndnVleCc7XG5cbmltcG9ydCBBcHAgZnJvbSAnLi9BcHAudnVlJztcbmltcG9ydCBTdWlWdWUgZnJvbSAnc2VtYW50aWMtdWktdnVlJztcblxuaW1wb3J0ICdzZW1hbnRpYy11aS1jc3Mvc2VtYW50aWMubWluLmNzcyc7XG5cbmNvbnN0IGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2FwcCcpO1xuXG5jb25zdCBzdG9yZSA9IGNyZWF0ZVN0b3JlKHtcbiAgc3RhdGUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJldGFpbGVyczogW10sXG4gICAgICBkZWZhdWx0VmFsdWVzOiBlbC5kYXRhc2V0LmRlZmF1bHQsXG4gICAgICBzZWFyY2hSZXN1bHRzTGVuZ3RoOiAwLFxuICAgICAgY2VudGVyQnlDbGljazogMCxcbiAgICB9XG4gIH0sXG4gIGdldHRlcnM6IHtcbiAgICBnZXRSZXRhaWxlcihzdGF0ZSkge1xuICAgICAgcmV0dXJuIHN0YXRlLnJldGFpbGVyO1xuICAgIH1cbiAgfVxufSk7XG5cblxuY29uc3QgYXBwID0gY3JlYXRlQXBwKEFwcCwge1xuICAuLi5lbC5kYXRhc2V0LFxufSk7XG5cbmFwcC51c2Uoc3RvcmUpO1xuYXBwLnVzZShTdWlWdWUpO1xuYXBwLm1vdW50KGVsKTtcblxuXG4iLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiXSwibmFtZXMiOlsiU2VhcmNoIiwiTWFwIiwiUmV0YWlsZXIiLCJwcm92aWRlIiwiaW5qZWN0IiwidXNlU3RvcmUiLCJuYW1lIiwiY29tcG9uZW50cyIsInByb3BzIiwiY29uZmlnIiwiU3RyaW5nIiwiYWpheFJvdXRlIiwiSlNPTiIsInBhcnNlIiwiaW1hZ2VSb3V0ZSIsImRlZmF1bHRWYWx1ZXMiLCJkZWZhdWx0IiwiZm9ybWF0UGhvbmVOdW1iZXIiLCJzZWFyY2hGaWVsZCIsImZpbmRCdXR0b24iLCJlbXB0eVJlc3VsdHNNZXNzYWdlIiwic2V0dXAiLCJzdG9yZSIsImltZ1JvdXRlIiwiaW1hZ2VVUkwiLCJkb2N1bWVudCIsImxvY2F0aW9uIiwib3JpZ2luIiwibnVtYmVyIiwiTUFTS1MiLCJ2Iiwic3RhcnRzV2l0aCIsImxlbmd0aCIsIm1hc2siLCJPYmplY3QiLCJlbnRyaWVzIiwiZmluZCIsIl8iLCJjb25kaXRpb24iLCJudW1iZXJBcnIiLCJudW1iZXJJbmRleCIsInJlZHVjZSIsImFjYyIsIkxJY29uIiwiTE1hcmtlciIsIkxQb3B1cCIsIm9uQmVmb3JlTW91bnQiLCJtYXJrZXIiLCJ0eXBlIiwicmVxdWlyZWQiLCJjb250ZW50Iiwic3RyZWV0IiwiY2l0eSIsInRvVXBwZXJDYXNlIiwicG9zdGNvZGUiLCJwaG9uZU51bWJlciIsIkxNYXAiLCJMVGlsZUxheWVyIiwiTWFya2VyIiwiYXhpb3MiLCJjb21wdXRlZCIsInJlZiIsIndhdGNoIiwiY29udGV4dCIsInJvdXRlQWpheCIsInVybCIsImNlbnRlciIsImxhdGl0dWRlIiwibG9uZ2l0dWRlIiwibWFya2VycyIsInpvb20iLCJyZXRhaWxlcnMiLCJzdGF0ZSIsImNlbnRlckJ5Q2xpY2siLCJuZXdWYWx1ZSIsIm9sZFZhbHVlIiwib2JqZWN0IiwidmFsdWUiLCJwYXJzZUZsb2F0IiwicmVwbGFjZSIsIm9iamVjdHMiLCJnZXQiLCJoZWFkZXJzIiwiZGF0YSIsIl9lbWJlZGRlZCIsIml0ZW1zIiwiaW1hZ2VVcmwiLCJmb3JFYWNoIiwiaXRlbSIsImltYWdlUGF0aCIsInBhdGgiLCJ1bmRlZmluZWQiLCJwdXNoIiwiaWQiLCJpbWFnZSIsImNvb3JkaW5hdGVzIiwiY2lyY2xlTWFya2VyIiwicmV0YWlsZXIiLCJ1cGRhdGVDZW50ZXIiLCJzZWFyY2hGaWVsZFRleHQiLCJmaW5kQnV0dG9uVGV4dCIsInVzZXJJbnB1dCIsInVybFJlcXVlc3QiLCJzZWFyY2giLCJpbnB1dCIsInNlYXJjaFJlc3VsdHNMZW5ndGgiLCJjbGFzcyIsIl9jcmVhdGVWTm9kZSIsIl9jb21wb25lbnRfU2VhcmNoIiwiX2NvbXBvbmVudF9NYXAiLCIkc2V0dXAiLCJfY3JlYXRlRWxlbWVudEJsb2NrIiwiX0ZyYWdtZW50IiwiX3JlbmRlckxpc3QiLCJfY3JlYXRlQmxvY2siLCJfY29tcG9uZW50X1JldGFpbGVyIiwiX3RvRGlzcGxheVN0cmluZyIsIiRwcm9wcyIsIl9jb21wb25lbnRfbF9tYXJrZXIiLCJrZXkiLCJfY29tcG9uZW50X2xfaWNvbiIsIl9jcmVhdGVFbGVtZW50Vk5vZGUiLCJzcmMiLCJfY29tcG9uZW50X2xfcG9wdXAiLCJfY29tcG9uZW50X2xfbWFwIiwiX2NvbXBvbmVudF9sX3RpbGVfbGF5ZXIiLCJfY29tcG9uZW50X01hcmtlciIsIm9uQ2xpY2siLCJfaG9pc3RlZF83IiwiX2hvaXN0ZWRfOSIsInBsYWNlaG9sZGVyIiwiJGV2ZW50IiwiY3JlYXRlQXBwIiwiY3JlYXRlU3RvcmUiLCJBcHAiLCJTdWlWdWUiLCJlbCIsInF1ZXJ5U2VsZWN0b3IiLCJkYXRhc2V0IiwiZ2V0dGVycyIsImdldFJldGFpbGVyIiwiYXBwIiwidXNlIiwibW91bnQiXSwic291cmNlUm9vdCI6IiJ9